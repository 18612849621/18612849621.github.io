

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="CodeTop做题总结🔥 按照微软题库的频率顺序进行练习  Day1  206、反转链表 递归法 时间复杂度O(n)O(n)O(n) 空间复杂度O(n)O(n)O(n) 123456789101112131415161718192021&#x2F;** * Definition for singly-linked list. * struct ListNode &amp;#123; *     int val;">
<meta property="og:type" content="article">
<meta property="og:title" content="CodeTop">
<meta property="og:url" content="http://example.com/2022/03/15/codeTop/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="CodeTop做题总结🔥 按照微软题库的频率顺序进行练习  Day1  206、反转链表 递归法 时间复杂度O(n)O(n)O(n) 空间复杂度O(n)O(n)O(n) 123456789101112131415161718192021&#x2F;** * Definition for singly-linked list. * struct ListNode &amp;#123; *     int val;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202204301401924.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205201118746.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221040826.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221409758.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205241113543.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205241211840.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205271444151.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205311238640.png">
<meta property="article:published_time" content="2022-03-15T01:53:26.674Z">
<meta property="article:modified_time" content="2022-06-17T03:58:12.578Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202204301401924.png">
  
  <title>CodeTop - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>PanPan</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/Title%20page/title.jpeg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="CodeTop">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-15 09:53" pubdate>
        2022年3月15日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      140k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      436 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">CodeTop</h1>
            
            <div class="markdown-body">
              <h1 id="codetop做题总结"><a class="markdownIt-Anchor" href="#codetop做题总结"></a> CodeTop做题总结🔥</h1>
<p>按照微软题库的频率顺序进行练习</p>
<h2 id="day1"><a class="markdownIt-Anchor" href="#day1"></a> Day1</h2>
<h3 id="206-反转链表"><a class="markdownIt-Anchor" href="#206-反转链表"></a> 206、反转链表</h3>
<p><strong>递归法</strong> 时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        ListNode* nextNode = head-&gt;next;<br>        ListNode* newHead = <span class="hljs-built_in">reverseList</span>(nextNode);<br>        nextNode-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>头插法</strong> 时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* newHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            ListNode* nextNode = head-&gt;next;<br>            head-&gt;next = newHead-&gt;next;<br>            newHead-&gt;next = head;<br>            head = nextNode;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="146-lru缓存机制"><a class="markdownIt-Anchor" href="#146-lru缓存机制"></a> 146、LRU缓存机制</h3>
<p>这道题让我们实现一个 LRU 缓存器，LRU 是 Least Recently Used 的简写，就是最近最少使用的意思。那么这个缓存器主要有两个成员函数，get 和 put，其中 get 函数是通过输入 key 来获得 value，如果成功获得后，这对 (key, value) 升至缓存器中最常用的位置（顶部），如果 key 不存在，则返回 -1。而 put 函数是插入一对新的 (key, value)，如果原缓存器中有该 key，则需要先删除掉原有的，将新的插入到缓存器的顶部。如果不存在，则直接插入到顶部。若加入新的值后缓存器超过了容量，则需要删掉一个最不常用的值，也就是底部的值。具体实现时我们需要三个私有变量，cap, l和m，其中 cap 是缓存器的容量大小，l是保存缓存器内容的列表，m是 HashMap，保存关键值 key 和缓存器各项的迭代器之间映射，方便我们以 O(1) 的时间内找到目标项。</p>
<p>然后我们再来看 get 和 put 如何实现，get 相对简单些，我们在 HashMap 中查找给定的 key，若不存在直接返回 -1。如果存在则将此项移到顶部，这里我们使用 C++ STL 中的函数 splice，专门移动链表中的一个或若干个结点到某个特定的位置，这里我们就只移动 key 对应的迭代器到列表的开头，然后返回 value。这里再解释一下为啥 HashMap 不用更新，因为 HashMap 的建立的是关键值 key 和缓存列表中的迭代器之间的映射，get 函数是查询函数，如果关键值 key 不在 HashMap，那么不需要更新。如果在，我们需要更新的是该 key-value 键值对儿对在缓存列表中的位置，而 HashMap 中还是这个 key 跟键值对儿的迭代器之间的映射，并不需要更新什么。</p>
<p>对于 put，我们也是现在 HashMap 中查找给定的 key，如果存在就删掉原有项，并在顶部插入新来项，然后判断是否溢出，若溢出则删掉底部项(最不常用项)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLinkedNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> key, value;<br>    DLinkedNode* next;<br>    DLinkedNode* prev;<br>    <span class="hljs-built_in">DLinkedNode</span>(): <span class="hljs-built_in">key</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    <span class="hljs-built_in">DLinkedNode</span>(<span class="hljs-keyword">int</span> _key, <span class="hljs-keyword">int</span> _value): <span class="hljs-built_in">key</span>(_key), <span class="hljs-built_in">value</span>(_value), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125; <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, DLinkedNode*&gt; cache;  <span class="hljs-comment">// 用哈希表作为一个索引工具，获取双向链表上的某个节点</span><br>    DLinkedNode* head;<br>    DLinkedNode* tail;<br>    <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-keyword">int</span> capacity;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-keyword">int</span> _capacity): <span class="hljs-built_in">capacity</span>(_capacity), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>)&#123;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>();<br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-comment">//如果没有找到该节点</span><br>        <span class="hljs-keyword">if</span> (!cache.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果该节点存在 需要将该节点移动到第一位</span><br>            DLinkedNode* node = cache[key];<br>            <span class="hljs-built_in">moveToHead</span>(node);<br>            <span class="hljs-keyword">return</span> node-&gt;value;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">//如果没有找到该节点</span><br>        <span class="hljs-keyword">if</span> (!cache.<span class="hljs-built_in">count</span>(key)) &#123;<br>            DLinkedNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>(key, value);<br>            <span class="hljs-built_in">addToHead</span>(node);<br>            cache[key] = node; <span class="hljs-comment">// 更新cache</span><br>            size++;<br>            <span class="hljs-keyword">if</span> (size &gt; capacity) &#123;   <br>                DLinkedNode* removed = <span class="hljs-built_in">removeTail</span>();<br>                cache.<span class="hljs-built_in">erase</span>(removed-&gt;key); <span class="hljs-comment">// 删除被挤出的key</span><br>                <span class="hljs-keyword">delete</span> removed;<br>                size--;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            DLinkedNode* node = cache[key];<br>            node-&gt;value = value;<br>            <span class="hljs-built_in">moveToHead</span>(node); <span class="hljs-comment">// 因为最新处理过所以放在第一个</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 链表函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addToHead</span><span class="hljs-params">(DLinkedNode* node)</span></span>&#123;<br>        node-&gt;next = head-&gt;next;<br>        head-&gt;next-&gt;prev = node;<br>        node-&gt;prev = head;<br>        head-&gt;next = node;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(DLinkedNode* node)</span></span>&#123;<br>        node-&gt;prev-&gt;next = node-&gt;next;<br>        node-&gt;next-&gt;prev = node-&gt;prev;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(DLinkedNode* node)</span></span>&#123;<br>        <span class="hljs-built_in">removeNode</span>(node);<br>        <span class="hljs-built_in">addToHead</span>(node);<br>    &#125;<br>    <br>    <span class="hljs-function">DLinkedNode* <span class="hljs-title">removeTail</span><span class="hljs-params">()</span></span>&#123;<br>        DLinkedNode* node = tail-&gt;prev;<br>        <span class="hljs-built_in">removeNode</span>(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h3 id="3-无重复字符的最长子串"><a class="markdownIt-Anchor" href="#3-无重复字符的最长子串"></a> 3、无重复字符的最长子串</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; map = vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">256</span>);<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (r &lt; s.<span class="hljs-built_in">size</span>()) &#123;<br>            map[s[r]]++;<br>            <span class="hljs-keyword">while</span> (map[s[r]] &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果发现当前这个字母出现过 那就缩小滑动窗口直到没有出现重复的</span><br>                map[s[l++]]--; <span class="hljs-comment">// 清除左边界的状态</span><br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, r - l + <span class="hljs-number">1</span>);<br>            r++; <span class="hljs-comment">// 一轮正常之后再进行下一轮</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="215-数组中的第k个最大元素"><a class="markdownIt-Anchor" href="#215-数组中的第k个最大元素"></a> 215、数组中的第K个最大元素</h3>
<p>用优先队列（小顶堆实现， 大顶堆反过来就行）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; minHeap;  <span class="hljs-comment">// 这道题的思路就是组合滑动窗口 为了让滑动窗口中小的数先出局</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            minHeap.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">if</span>(minHeap.<span class="hljs-built_in">size</span>() &gt; k)&#123;<br>                minHeap.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minHeap.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>可以用<strong>快速排序</strong>实现一下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>() - k];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>可以用<strong>快速选择</strong>+<strong>二分</strong>， 最差情况就和快速排序是一个样子了。</p>
<p>分开写</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 左闭右闭区间</span><br>        k = nums.<span class="hljs-built_in">size</span>() - k; <span class="hljs-comment">// 更新一下k</span><br>        <span class="hljs-keyword">int</span> cur = <span class="hljs-built_in">partition</span>(nums, l, h, k);<br>        <span class="hljs-keyword">while</span> (l &lt;= h)&#123;<br>            <span class="hljs-keyword">if</span> (k &gt; cur)<br>                cur = <span class="hljs-built_in">partition</span>(nums, cur + <span class="hljs-number">1</span>, h, k); <span class="hljs-comment">// 相当于在大的区域里接着找</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &lt; cur)<br>                cur = <span class="hljs-built_in">partition</span>(nums, l, cur - <span class="hljs-number">1</span>, k);<br>            <span class="hljs-keyword">else</span> <br>                <span class="hljs-keyword">return</span> nums[cur];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> l = low, h = high;<br>        <span class="hljs-keyword">int</span> pivot = nums[l];<br>        <span class="hljs-keyword">while</span> (l &lt; h) &#123;<br>            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; nums[h] &gt;= pivot) h--;<br>            <span class="hljs-keyword">if</span> (l &lt; h) nums[l] = nums[h];<br>            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; nums[l] &lt;= pivot) l++;<br>            <span class="hljs-keyword">if</span> (l &lt; h) nums[h] = nums[l];<br>        &#125;<br>        <span class="hljs-comment">//此刻一定l == h</span><br>        nums[l] = pivot;<br>        <span class="hljs-comment">//此刻l左边的数一定小于pivot l 右边的数一定大于pivot</span><br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>合在一起写</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">partition</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>() - k);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> l = low, h = high;<br>        <span class="hljs-keyword">int</span> pivot = nums[l];<br>        <span class="hljs-keyword">while</span> (l &lt; h)&#123;<br>            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; nums[h] &gt;= pivot) h--;<br>            <span class="hljs-keyword">if</span> (l &lt; h) nums[l] = nums[h];<br>            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; nums[l] &lt;= pivot) l++;<br>            <span class="hljs-keyword">if</span> (l &lt; h) nums[h] = nums[l];<br>        &#125;<br>        <span class="hljs-comment">//此刻一定l == h</span><br>        nums[l] = pivot;<br>        <span class="hljs-comment">//此刻l左边的数一定小于pivot l 右边的数一定大于pivot</span><br>        <span class="hljs-keyword">if</span> (k &gt; l)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">partition</span>(nums, l + <span class="hljs-number">1</span>, high, k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &lt; l)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">partition</span>(nums, low, h - <span class="hljs-number">1</span>, k);<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> pivot;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="236-二叉树的最近公共祖先"><a class="markdownIt-Anchor" href="#236-二叉树的最近公共祖先"></a> 236、二叉树的最近公共祖先</h3>
<p>递归 后序遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// </span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root || root == p || root == q) <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 这里存储了当前节点为p 或者 q 或者是空 三种情况都是返回自己</span><br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">return</span> !left ? right : !right ? left : root;  <span class="hljs-comment">// 左右都找到了那就是当前是最近祖先 左边没找到 那一定在右边 右边没找到就一定在左边</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day2"><a class="markdownIt-Anchor" href="#day2"></a> Day2</h2>
<h3 id="1-二叉树的最大路径和"><a class="markdownIt-Anchor" href="#1-二叉树的最大路径和"></a> 1、二叉树的最大路径和</h3>
<p>无需要打印路径</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> ans = INT_MIN;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">scan</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">scan</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-comment">//当遍历到空的位置的时候返回0</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//如果左叶子和右叶子只要是有一个是负数我们就抛弃</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">scan</span>(root-&gt;left), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">scan</span>(root-&gt;right), <span class="hljs-number">0</span>);<br>        ans = <span class="hljs-built_in">max</span>(ans, root-&gt;val + left + right); <span class="hljs-comment">// 每一个字结构就是左根右 做记录就好</span><br>        <span class="hljs-keyword">return</span> root-&gt;val + <span class="hljs-built_in">max</span>(left, right); <span class="hljs-comment">// 因为是路径 所以只能是走一边（下一层针对上一层）</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>增加难度打印路径</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span> <span class="hljs-comment">// 用一个结构体去存储一个节点的值和状态</span><br>        <span class="hljs-keyword">int</span> val;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; path;<br>        <span class="hljs-built_in">Node</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>        <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">int</span> _val) : <span class="hljs-built_in">val</span>(_val)&#123;&#125;<br>        <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">int</span> _val, vector&lt;<span class="hljs-keyword">int</span>&gt; _path) : <span class="hljs-built_in">val</span>(_val), <span class="hljs-built_in">path</span>(_path)&#123;&#125;<br>    &#125;;<br>    <span class="hljs-keyword">int</span> ans = INT_MIN;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; Path;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">scan</span>(root);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p : Path)&#123;<br>            cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function">Node* <span class="hljs-title">scan</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-comment">//当遍历到空的位置的时候返回一个空状态</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(); <br>        <br>        <span class="hljs-comment">//如果左叶子和右叶子只要是有一个是负数我们就抛弃</span><br>        Node* left = <span class="hljs-built_in">scan</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span> (left-&gt;val &lt;= <span class="hljs-number">0</span>)<br>            left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        Node* right = <span class="hljs-built_in">scan</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (right-&gt;val &lt;= <span class="hljs-number">0</span>)<br>            right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; cur; <span class="hljs-comment">// 建立一下当前状态</span><br>        <span class="hljs-keyword">if</span> (ans &lt; root-&gt;val + left-&gt;val + right-&gt;val) &#123; <span class="hljs-comment">// 先不处理等于的状态</span><br>            ans = root-&gt;val + left-&gt;val + right-&gt;val; <br>            <span class="hljs-comment">// 每一个字结构就是左根右 做记录就好</span><br>            cur.<span class="hljs-built_in">insert</span>(cur.<span class="hljs-built_in">end</span>(), left-&gt;path.<span class="hljs-built_in">begin</span>(), left-&gt;path.<span class="hljs-built_in">end</span>());<br>            cur.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            cur.<span class="hljs-built_in">insert</span>(cur.<span class="hljs-built_in">end</span>(), right-&gt;path.<span class="hljs-built_in">begin</span>(), right-&gt;path.<span class="hljs-built_in">end</span>());<br>            Path = cur;  <br>        &#125;<br>        Node* re = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        <span class="hljs-keyword">if</span> (left-&gt;val &gt; right-&gt;val) &#123; <span class="hljs-comment">//如果左边大于右边</span><br>            re-&gt;val = root-&gt;val + left-&gt;val; <span class="hljs-comment">// 当前状态的值为根 + 左</span><br>            re-&gt;path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            re-&gt;path.<span class="hljs-built_in">insert</span>(re-&gt;path.<span class="hljs-built_in">end</span>(), left-&gt;path.<span class="hljs-built_in">begin</span>(), left-&gt;path.<span class="hljs-built_in">end</span>());<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            re-&gt;val = root-&gt;val + right-&gt;val; <span class="hljs-comment">// 当前状态的值为右 + 根</span><br>            re-&gt;path.<span class="hljs-built_in">insert</span>(re-&gt;path.<span class="hljs-built_in">end</span>(), right-&gt;path.<span class="hljs-built_in">begin</span>(), right-&gt;path.<span class="hljs-built_in">end</span>());<br>            re-&gt;path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> re; <span class="hljs-comment">// 返回当前状态</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="2-删除二叉搜索树中的节点"><a class="markdownIt-Anchor" href="#2-删除二叉搜索树中的节点"></a> 2、删除二叉搜索树中的节点</h3>
<p>先序遍历处理节点，后序来将处理后的节点进行收集处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">// 找到该节点进行处理</span><br>        <span class="hljs-keyword">if</span> (root-&gt;val == key) &#123;<br>            <span class="hljs-keyword">if</span> (!root-&gt;left) <span class="hljs-comment">// 如果当前节点没有左节点，只能从他的右边找</span><br>                <span class="hljs-keyword">return</span> root-&gt;right;<br>            <span class="hljs-keyword">if</span> (!root-&gt;right) <span class="hljs-comment">// 如果当前节点没有右节点，只能从他的左边找</span><br>                <span class="hljs-keyword">return</span> root-&gt;left;<br>            TreeNode* r = root-&gt;right; <br>            <span class="hljs-keyword">while</span> (r-&gt;left) &#123; <span class="hljs-comment">// 我们要去找右子树的最左节点</span><br>                r = r-&gt;left;<br>            &#125;<br>            <span class="hljs-comment">//找到后需要接回去</span><br>            r-&gt;left = root-&gt;left;<br>            <span class="hljs-keyword">return</span> root-&gt;right; <span class="hljs-comment">// 返回处理的开始起点</span><br>        &#125;<br>        TreeNode* l = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key); <span class="hljs-comment">// 新构造的左子树</span><br>        TreeNode* r = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key); <span class="hljs-comment">// 新构造的右子树</span><br>        <span class="hljs-comment">// 后序遍历收集一下状态</span><br>        root-&gt;left = l;<br>        root-&gt;right = r;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="53-最大子序和"><a class="markdownIt-Anchor" href="#53-最大子序和"></a> 53、最大子序和</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = INT_MIN;<br>        <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            cur = cur &lt;= <span class="hljs-number">0</span> ? num: cur + num;<br>            ans = <span class="hljs-built_in">max</span>(ans, cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>记录一下最大的路径</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = INT_MIN;<br>        <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录起始结束位置</span><br>        <span class="hljs-keyword">int</span> dist = INT_MIN;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (cur &lt;= <span class="hljs-number">0</span>) &#123;<br>                cur = nums[i];<br>                start = i;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                cur += nums[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ans &lt; cur) &#123;<br>                end = i;<br>                ans = cur;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;[&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= end; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i != end)<br>                cout &lt;&lt; nums[i] &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>            <span class="hljs-keyword">else</span><br>                cout &lt;&lt; nums[i] &lt;&lt; <span class="hljs-string">&quot;]&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="207-课程表"><a class="markdownIt-Anchor" href="#207-课程表"></a> 207、课程表</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-comment">// 这道题就是检测环</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">2001</span>;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; graph[M];<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(M); <span class="hljs-comment">// 用于整体的剪枝</span><br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; dfsvis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(M); <span class="hljs-comment">// 用于每一回合检测是否出现环</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : prerequisites) &#123;<br>            graph[p[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 转换一下图的存储</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; ++i)&#123;<br>            <span class="hljs-keyword">if</span> (!vis[i]) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(i)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123; <span class="hljs-comment">// true代表有环</span><br>        vis[v] = <span class="hljs-literal">true</span>;<br>        dfsvis[v] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> g : graph[v]) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[g]) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(g)) &#123; <span class="hljs-comment">// 如果当前这一轮检测到环</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;  <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dfsvis[g]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        dfsvis[v] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="103-二叉树的锯齿形层次遍历"><a class="markdownIt-Anchor" href="#103-二叉树的锯齿形层次遍历"></a> 103、二叉树的锯齿形层次遍历</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; ans; <span class="hljs-comment">// 用于存储答案</span><br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 用来控制左右方向</span><br>        queue&lt;TreeNode* &gt; q; <span class="hljs-comment">// 用于层次遍历的队列</span><br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> n = q.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; curVec;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                TreeNode* cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span> (cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                curVec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (flag) &#123;<br>                <span class="hljs-built_in">reverse</span>(curVec.<span class="hljs-built_in">begin</span>(), curVec.<span class="hljs-built_in">end</span>());<br>            &#125;<br>            flag = !flag; <span class="hljs-comment">// 反转状态</span><br>            ans.<span class="hljs-built_in">push_back</span>(curVec);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day3"><a class="markdownIt-Anchor" href="#day3"></a> Day3</h2>
<h3 id="15-3sum"><a class="markdownIt-Anchor" href="#15-3sum"></a> 15、3Sum</h3>
<p>这道题就是2Sum的改进版，只需要添加一个外层的循环即可，相当于一个动态的target。注意两次去重：1）当我们获取到当前满足target的结果之后需要给left和right找到和当前的不同的，如果相同也不可能有答案 2）对于开头是相同的数列，不可能获得不同的结果我们也需要跳过。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123; <span class="hljs-comment">// 加了一个遍历的双指针</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; ans;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 排序一下</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; ++i) &#123;<br>            <span class="hljs-keyword">int</span> l = i + <span class="hljs-number">1</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">1</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-keyword">int</span> cur = nums[i] + nums[l] + nums[r];<br>                <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">0</span>) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[l], nums[r]&#125;);<br>                    <span class="hljs-keyword">int</span> left = nums[l++];<br>                    <span class="hljs-keyword">int</span> right = nums[r--];<br>                    <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; left == nums[l]) l++;<br>                    <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; right == nums[r]) r--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur &lt; <span class="hljs-number">0</span>) &#123;<br>                    l++;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    r--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="33-搜索旋转排序数组"><a class="markdownIt-Anchor" href="#33-搜索旋转排序数组"></a> 33、搜索旋转排序数组</h3>
<p>第一个二分法用于找到旋转排序数组的分界线就当作模版记住就好了：）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123; <span class="hljs-comment">// 使用两次二分法</span><br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] == target) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 左闭右闭 就当模版愣背吧</span><br>        <span class="hljs-comment">// 先确定转折的区域</span><br>        <span class="hljs-keyword">while</span> (l &lt; h) &#123; <span class="hljs-comment">// 正好就是l == h 退出</span><br>            <span class="hljs-keyword">int</span> m = l + ((h - l) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[m] &gt; nums[h]) &#123; <span class="hljs-comment">// 只要当前的数不是比他小 拿我们就得前进</span><br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 比我小了我原地踏步 这样最后停的位置一定在最小数的位置，不会越过去 如果加一个-1那就会变化</span><br>                h = m;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> pivot = l;<br>        <span class="hljs-comment">// 再用二分法确定 所有区间均为左闭右闭</span><br>        <span class="hljs-keyword">if</span> (pivot != <span class="hljs-number">0</span> &amp;&amp; nums[<span class="hljs-number">0</span>] &lt;= target &amp;&amp; target &lt;= nums[pivot - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">//如果在左区间 如果pivot等于0 就等于是没有发生旋转 正常做就行</span><br>            l = <span class="hljs-number">0</span>, h = pivot - <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 如果在右区间</span><br>            h = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (l &lt;= h) &#123;<br>            <span class="hljs-keyword">int</span> m = l + ((h - l) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[m] &gt; target) &#123;<br>                h = m - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[m] &lt; target) &#123;<br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> m;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="4-寻找两个正序数组的中位数"><a class="markdownIt-Anchor" href="#4-寻找两个正序数组的中位数"></a> 4、寻找两个正序数组的中位数</h3>
<p>合并两个数组，直接求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mo>+</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M+N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = nums1.<span class="hljs-built_in">size</span>(), n = nums2.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">double</span>&gt; arr = vector&lt;<span class="hljs-keyword">double</span>&gt;(m + n);<br>        <span class="hljs-built_in">mergeArr</span>(arr, nums1, nums2);<br>        <span class="hljs-keyword">if</span> ((m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> arr[(m + n) / <span class="hljs-number">2</span>];<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (arr[(m + n) / <span class="hljs-number">2</span>] + arr[(m + n) / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeArr</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">double</span>&gt;&amp; arr, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">0</span>, i2 = <span class="hljs-number">0</span>, idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i1 &lt; nums1.<span class="hljs-built_in">size</span>() &amp;&amp; i2 &lt; nums2.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (nums1[i1] &lt;= nums2[i2]) &#123;<br>                arr[idx++] = nums1[i1++];<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                arr[idx++] = nums2[i2++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i1 &lt; nums1.<span class="hljs-built_in">size</span>()) &#123;<br>            arr[idx++] = nums1[i1++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i2 &lt; nums2.<span class="hljs-built_in">size</span>()) &#123;<br>            arr[idx++] = nums2[i2++];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>利用二分法 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(n + m))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
<img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202204301401924.png" srcset="/img/loading.gif" lazyload alt="截屏2022-04-30 下午2.01.25"  />
<p>(m + n + 1) / 2 代表两个数组的中间位置，cut2根据cut1来变换位置。</p>
<p>这道题真的很妙，让两边的二分中轴进行联合移动cut1越大 cut2越小 cut1越小 cut2 越大</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = nums1.<span class="hljs-built_in">size</span>(), n = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (m &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-built_in">findMedianSortedArrays</span>(nums2, nums1); <span class="hljs-comment">// 为了让nums1永远是短的那个</span><br>        <span class="hljs-keyword">bool</span> isOdd = ((m + n) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>; <span class="hljs-comment">//判断是不是奇数</span><br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = m; <span class="hljs-comment">// 只在nums1中做二分法 取一半 要不是中间数 要不就是 中间偏右一位</span><br>        <span class="hljs-keyword">int</span> cut1, cut2; <span class="hljs-comment">// cut2 随着 cut1 进行联动 代表切开两部分的两个索引 cut位于中间偏右一位</span><br>        <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>            cut1 = (start + end) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// num1的中间位置</span><br>            cut2 = (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - cut1; <span class="hljs-comment">// 这里+1为了解决m + n 合在一起时 cut == m的情况下不会让cut2跑到第一个数组的位置 如 nums1: 1 2 nums2: 3 4 5 的情况自己推算</span><br>            <span class="hljs-keyword">int</span> nums1LeftMax = cut1 == <span class="hljs-number">0</span> ? INT_MIN : nums1[cut1 - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> nums1RightMin = cut1 == m ? INT_MAX : nums1[cut1];<br>            <span class="hljs-keyword">int</span> nums2LeftMax = cut2 == <span class="hljs-number">0</span> ? INT_MIN : nums2[cut2 - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> nums2RightMin = cut2 == n ? INT_MAX : nums2[cut2];<br>            <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">max</span>(nums1LeftMax, nums2LeftMax);<br>            <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">min</span>(nums1RightMin, nums2RightMin);<br>            <span class="hljs-keyword">if</span> (left &lt;= right) &#123;<br>                <span class="hljs-keyword">if</span> (isOdd) &#123;<br>                    <span class="hljs-keyword">return</span> left * <span class="hljs-number">1.0</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (left + right) / <span class="hljs-number">2.0</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (nums1LeftMax &gt; nums2RightMin) &#123; <span class="hljs-comment">// 需要找她左边区域</span><br>                    end = cut1 - <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums2LeftMax &gt; nums1RightMin) &#123; <span class="hljs-comment">// 需要找他右边区域</span><br>                    start = cut1 + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day4"><a class="markdownIt-Anchor" href="#day4"></a> Day4</h2>
<h3 id="22-括号生成"><a class="markdownIt-Anchor" href="#22-括号生成"></a> 22、括号生成</h3>
<p>dfs来解决</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; ans;<br>    <span class="hljs-keyword">int</span> N;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        N = n;<br>        string temp = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-built_in">dfs</span>(temp, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string temp, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123; <span class="hljs-comment">// input为左括号和右括号的个数 temp作为中间值进行记录</span><br>        <span class="hljs-keyword">if</span> (left == N &amp;&amp; right == N) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left &lt; N) <span class="hljs-comment">// 只要不大于总个数就行</span><br>            <span class="hljs-built_in">dfs</span>(temp + <span class="hljs-string">&quot;(&quot;</span>, left + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-comment">// 只有左边比右边多才可以放</span><br>            <span class="hljs-built_in">dfs</span>(temp + <span class="hljs-string">&quot;)&quot;</span>, left, right + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="151-反转字符串里的单词需要消除特别空格"><a class="markdownIt-Anchor" href="#151-反转字符串里的单词需要消除特别空格"></a> 151、反转字符串里的单词（需要消除特别空格）</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 整个字符串的长度</span><br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sIdx = <span class="hljs-number">0</span>, eIdx = n - <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录一下开始第一个不是空格和最后一个不是空格的索引</span><br>        <span class="hljs-keyword">while</span>(s[sIdx] == <span class="hljs-string">&#x27; &#x27;</span>) sIdx++;<br>        <span class="hljs-keyword">while</span>(s[eIdx] == <span class="hljs-string">&#x27; &#x27;</span>) eIdx--;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = sIdx; i &lt;= eIdx; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123; <span class="hljs-comment">// 如果检测到空格</span><br>                <span class="hljs-built_in">reverse</span>(s, start, i - <span class="hljs-number">1</span>); <span class="hljs-comment">// 相当于i是空格我选择了跳过 直接处理每一个单词就好</span><br>                start = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(s, start, n - <span class="hljs-number">1</span>); <span class="hljs-comment">// 反转最后一组</span><br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<span class="hljs-comment">// 反转整体</span><br>        <span class="hljs-comment">//使用erase删除多余空格</span><br>        <span class="hljs-built_in">cleanSpace</span>(s);<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanSpace</span><span class="hljs-params">(string&amp; s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; s[i - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27; &#x27;</span>) &#123; <span class="hljs-comment">// 当i - 1 和 i - 2都是空格这个时候删除 也就是 “空空字母” 的模式</span><br>                s.<span class="hljs-built_in">erase</span>(i - <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>                i--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> temp;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            temp = s[l];<br>            s[l] = s[r];<br>            s[r] = temp;<br>            l++, r--;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="297-二叉树的序列化和反序列化"><a class="markdownIt-Anchor" href="#297-二叉树的序列化和反序列化"></a> 297、二叉树的序列化和反序列化</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> idx; <span class="hljs-comment">//用于构造时遍历使用</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">preOrder</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (idx &gt; s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        string cur = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (s[idx] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>            idx += <span class="hljs-number">2</span>;  <span class="hljs-comment">//跳过 “*,”</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (s[idx] != <span class="hljs-string">&#x27;,&#x27;</span>) &#123; <span class="hljs-comment">// 凑齐每一个数</span><br>            cur += s[idx++];<br>        &#125;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">atoi</span>(cur.<span class="hljs-built_in">c_str</span>()));<br>        idx++; <span class="hljs-comment">// 此时停在&#x27;,&#x27; 我们跳下一个就行</span><br>        root-&gt;left = <span class="hljs-built_in">preOrder</span>(s);<br>        root-&gt;right = <span class="hljs-built_in">preOrder</span>(s);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;*&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(root-&gt;val) + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-built_in">serialize</span>(root-&gt;left) + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-built_in">serialize</span>(root-&gt;right); <span class="hljs-comment">//使用,隔开用于解决不是个位数组成的节点值</span><br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">preOrder</span>(data);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment">// Codec ser, deser;</span><br><span class="hljs-comment">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span><br></code></pre></td></tr></table></figure>
<h2 id="day5"><a class="markdownIt-Anchor" href="#day5"></a> Day5</h2>
<h3 id="1-旋转图像"><a class="markdownIt-Anchor" href="#1-旋转图像"></a> 1、旋转图像</h3>
<p>借助了辅助空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; temp = vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(n));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                temp[i][j] = matrix[n - j - <span class="hljs-number">1</span>][i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                matrix[i][j] = temp[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        n = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//先转置 再上下翻转</span><br>        <span class="hljs-built_in">transpose</span>(matrix);<br>        <span class="hljs-built_in">reverseCol</span>(matrix);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transpose</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;  <span class="hljs-comment">// 转置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; n; ++r) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = r + <span class="hljs-number">1</span>; c &lt; n; ++c) &#123;<br>                <span class="hljs-keyword">int</span> temp = matrix[r][c];<br>                matrix[r][c] = matrix[c][r];<br>                matrix[c][r] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseCol</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123; <span class="hljs-comment">// 左右翻转</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; n; ++r) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; n / <span class="hljs-number">2</span>; ++c) &#123;<br>                <span class="hljs-keyword">int</span> temp = matrix[r][c];<br>                matrix[r][c] = matrix[r][n - c - <span class="hljs-number">1</span>];<br>                matrix[r][n - c - <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="8-字符串转换整数atoi"><a class="markdownIt-Anchor" href="#8-字符串转换整数atoi"></a> 8、字符串转换整数（atoi）</h3>
<p>这道题别太在意，就是到面向用例的编程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">bool</span> neg = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 判断是否时负数</span><br>        <span class="hljs-keyword">while</span> (s[idx] == <span class="hljs-string">&#x27; &#x27;</span>) &#123; <span class="hljs-comment">// 跳过开头的空格</span><br>            idx++;<br>        &#125;<br>    <br>        <span class="hljs-keyword">if</span> (s[idx] == <span class="hljs-string">&#x27;-&#x27;</span> || s[idx] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (s[idx] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                neg = <span class="hljs-literal">true</span>;<br>            &#125;<br>            idx++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span> (s[idx] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[idx] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>            ans = ans * <span class="hljs-number">10</span> + (s[idx] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (ans &gt; INT_MAX) &#123;<br>                <span class="hljs-keyword">if</span> (neg) &#123; <span class="hljs-comment">// 溢出的话只显示最大值</span><br>                    <span class="hljs-keyword">return</span> INT_MIN;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> INT_MAX;<br>                &#125;<br>            &#125;<br>            idx++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (neg) &#123;<br>            ans *= <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="200-岛屿数量"><a class="markdownIt-Anchor" href="#200-岛屿数量"></a> 200、岛屿数量</h3>
<p>基本dfs的题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt; &gt; g;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        g = grid;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; g[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); ++j) &#123;<br>                <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    <span class="hljs-built_in">dfs</span>(i, j);<br>                    ans++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        g[x][y] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> d : dir) &#123;<br>            <span class="hljs-keyword">int</span> nx = x + d[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> ny = y + d[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt;= (g.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &amp;&amp; ny &lt;= (g[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &amp;&amp; g[nx][ny] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                <span class="hljs-built_in">dfs</span>(nx, ny);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="560-和为k的子数组"><a class="markdownIt-Anchor" href="#560-和为k的子数组"></a> 560、和为K的子数组</h3>
<p>这道题太妙了！！！sum是所有的前缀和，这道题的思想就是结合了动态规划，它记录了每一种和的情况下有几种能够达到该值的方式，0的时候为1次也就是正好是k；如果sum - k出现在map中，那也就是说当前这个num等于k，该循环sum没有变化。出现过该sum-k也说明，只要前缀和不带上它，当前状态+去掉sum-k组成的前缀和的差值就是咱们当前可以求到的结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        unordered_map &lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m; <span class="hljs-comment">// 记忆map 前一个int 是值</span><br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        m[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            sum += num;<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(sum - k)) &#123;<br>                ans += m[sum - k];<br>            &#125;<br>            m[sum]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day6"><a class="markdownIt-Anchor" href="#day6"></a> Day6</h2>
<h3 id="56-合并区间"><a class="markdownIt-Anchor" href="#56-合并区间"></a> 56、合并区间</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; ans;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; intervals) &#123;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>());<br>        ans.<span class="hljs-built_in">push_back</span>(intervals[<span class="hljs-number">0</span>]); <span class="hljs-comment">//先放第一个</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> val : intervals) &#123;<br>            <span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>] &gt;= val[<span class="hljs-number">0</span>]) &#123; <span class="hljs-comment">//若当前存储的结尾大于等于下一个的开始</span><br>                ans.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(ans.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>], val[<span class="hljs-number">1</span>]); <span class="hljs-comment">//更新一下结尾 若没有当前和这个大 那就不更新</span><br>            &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//不然就单独存放当前这个</span><br>                ans.<span class="hljs-built_in">push_back</span>(val); <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="1-两数之和"><a class="markdownIt-Anchor" href="#1-两数之和"></a> 1、两数之和</h3>
<p>利用map记录</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(target - nums[i])) &#123; <span class="hljs-comment">// 如果库里有那就输出</span><br>                <span class="hljs-keyword">return</span> &#123;m[target - nums[i]], i&#125;;<br>            &#125;<br>            m[nums[i]] = i; <span class="hljs-comment">//存储一下</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="5-最长回文子串"><a class="markdownIt-Anchor" href="#5-最长回文子串"></a> 5、最长回文子串</h3>
<p>暴力解（超时）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    string res;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">judge</span>(s, i, j) &amp;&amp; (j - i + <span class="hljs-number">1</span> &gt; res.<span class="hljs-built_in">size</span>())) &#123;<br>                    res = s.<span class="hljs-built_in">substr</span>(i, j - i + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (start == end) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (start == end - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s[start] == s[end];<br>        <span class="hljs-keyword">bool</span> ans = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (s[start] == s[end]) &#123;<br>            ans = <span class="hljs-built_in">judge</span>(s, start + <span class="hljs-number">1</span>, end - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>中心扩散法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    string res;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">int</span> len1 = <span class="hljs-built_in">spread</span>(s, i, i); <span class="hljs-comment">// 奇数</span><br>            <span class="hljs-keyword">int</span> len2 = <span class="hljs-built_in">spread</span>(s, i, i + <span class="hljs-number">1</span>); <span class="hljs-comment">//偶数</span><br>            <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">max</span>(len1, len2);<br>            <span class="hljs-keyword">if</span> (len &gt; (end - start)) &#123;<br>                start = i - (len - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>                end = i + len / <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(start, end - start + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">spread</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (start &gt;= <span class="hljs-number">0</span> &amp;&amp; end &lt; n &amp;&amp; s[start] == s[end]) &#123;<br>            start--;<br>            end++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> end - start - <span class="hljs-number">1</span>; <span class="hljs-comment">//求一下这个扩散区间的距离有多少</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day7"><a class="markdownIt-Anchor" href="#day7"></a> Day7</h2>
<h3 id="98-验证二叉搜索树"><a class="markdownIt-Anchor" href="#98-验证二叉搜索树"></a> 98、验证二叉搜索树</h3>
<p>递归版</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">bool</span> ans = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">inOrder</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span> (pre &amp;&amp; pre-&gt;val &gt;= root-&gt;val) &#123;<br>            ans = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        pre = root;<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>java版本但是没有用新的函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> TreeNode prev = <span class="hljs-keyword">null</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (!isValidBST(root.left)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (prev != <span class="hljs-keyword">null</span> &amp;&amp; prev.val &gt;= root.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    prev = root;<br>    <span class="hljs-keyword">if</span> (!isValidBST(root.right)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>非递归版本（偷偷练习一下非递归的中序遍历）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    stack&lt;TreeNode* &gt; s;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        TreeNode* cur = root, *pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur || !s.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (cur) &#123; <span class="hljs-comment">// 尽量往左走</span><br>                s.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;left;<br>            &#125;<br>            TreeNode* node = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (pre &amp;&amp; pre-&gt;val &gt;= node-&gt;val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            pre = node;<br>            cur = node-&gt;right; <span class="hljs-comment">//去右边看看</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="32-最长有效括号"><a class="markdownIt-Anchor" href="#32-最长有效括号"></a> 32、最长有效括号</h3>
<p>动态规划 + 栈 转换空间 方便统计个数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; S; <span class="hljs-comment">//用于记录下标</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; dp = vector&lt;<span class="hljs-keyword">int</span>&gt;(n);<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                S.<span class="hljs-built_in">push</span>(i); <span class="hljs-comment">// 存储一下为了待会儿记录dp的位置</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; !S.<span class="hljs-built_in">empty</span>())&#123; <span class="hljs-comment">//将可以配对的赋值1</span><br>                dp[S.<span class="hljs-built_in">top</span>()] = <span class="hljs-number">1</span>;<br>                dp[i] = <span class="hljs-number">1</span>;<br>                S.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 开始处理dp</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-number">0</span>) &#123;<br>                cur = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-number">1</span>) &#123;<br>                cur++;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>还有一种空间复杂度不增加的方法 左右遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//通过左右遍历 把没有办法匹配的括号全部去除</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                c++;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>                    s[i] = <span class="hljs-string">&#x27;*&#x27;</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    c--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        c = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                c++;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>                    s[i] = <span class="hljs-string">&#x27;*&#x27;</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    c--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最后再统计一遍</span><br>        c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                c++;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                ans = ans &gt; c ? ans : c;<br>                c = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        ans = ans &gt; c ? ans : c;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="94-二叉树的中序遍历"><a class="markdownIt-Anchor" href="#94-二叉树的中序遍历"></a> 94、二叉树的中序遍历</h3>
<p>递归版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">inOrder</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;left);<br>        ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>迭代版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; s;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span> (cur || !s.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (cur) &#123;<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;left;<br>            &#125;<br>            TreeNode* node = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            cur = node-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="141-环形链表"><a class="markdownIt-Anchor" href="#141-环形链表"></a> 141、环形链表</h3>
<p>使用快慢指针的经典案例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        ListNode* slow = head;<br>        ListNode* fast = head-&gt;next;<br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span> (slow == fast) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day8"><a class="markdownIt-Anchor" href="#day8"></a> Day8</h2>
<h3 id="25-k个一组反转链表好题"><a class="markdownIt-Anchor" href="#25-k个一组反转链表好题"></a> 25、K个一组反转链表✨好题！</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">// 构造dummy防止head翻转</span><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), * pre = dummy, * cur = head;<br>        dummy-&gt;next = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; cur; ++i) &#123;<br>            <span class="hljs-comment">// 当达到个数就反转</span><br>            <span class="hljs-keyword">if</span> (i % k == <span class="hljs-number">0</span>) &#123;<br>                pre = <span class="hljs-built_in">reverseOne</span>(pre, cur-&gt;next);<br>                cur = pre-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果不是该处理的时候 我们就直接正常下一个</span><br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//1 3 2 4 5</span><br>   <span class="hljs-comment">// p.  l c</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseOne</span><span class="hljs-params">(ListNode* pre, ListNode* next)</span> </span>&#123; <span class="hljs-comment">// pre代表上一组的最后一个节点， next代表下一组的第一个节点 也就是大循环中的cur下一个</span><br>        ListNode* last = pre-&gt;next, * cur = last-&gt;next;<br>        <span class="hljs-comment">// 这个过程就是尾巴出头接</span><br>        <span class="hljs-keyword">while</span> (cur != next) &#123;<br>            last-&gt;next = cur-&gt;next; <span class="hljs-comment">// 先把第一个放到该组下一个位置</span><br>            cur-&gt;next = pre-&gt;next;<br>            pre-&gt;next = cur;<br>            cur = last-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> last; <span class="hljs-comment">// 返回该组的最后一个</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="20-有效括号括号匹配"><a class="markdownIt-Anchor" href="#20-有效括号括号匹配"></a> 20、有效括号（括号匹配）</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-keyword">char</span>&gt; S;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>                S.<span class="hljs-built_in">push</span>(c);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (S.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">char</span> cur = S.<span class="hljs-built_in">top</span>();<br>                S.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">bool</span> b1 = (cur == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;)&#x27;</span>);<br>                <span class="hljs-keyword">bool</span> b2 = (cur == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>                <span class="hljs-keyword">bool</span> b3 = (cur == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;]&#x27;</span>);<br>                <span class="hljs-keyword">if</span> (!b1 &amp;&amp; !b2 &amp;&amp; !b3) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> S.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="121-买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#121-买卖股票的最佳时机"></a> 121、买卖股票的最佳时机</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = INT_MIN, minBuy = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            minBuy = <span class="hljs-built_in">min</span>(minBuy, prices[i]);<br>            ans = <span class="hljs-built_in">max</span>(ans, prices[i] - minBuy);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="210-课程表2"><a class="markdownIt-Anchor" href="#210-课程表2"></a> 210、课程表2</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; Graph[<span class="hljs-number">2001</span>];<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">2001</span>);<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; dfsvis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">2001</span>);<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; path; <span class="hljs-comment">// 最后的结果路径</span><br>    <span class="hljs-keyword">int</span> n; <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        n = numCourses;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : prerequisites) &#123;<br>            Graph[p[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(p[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>            <span class="hljs-keyword">if</span> (!vis[i]) &#123; <span class="hljs-comment">// 检测是否走过</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(i)) <span class="hljs-keyword">return</span> &#123;&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123; <span class="hljs-comment">// 有环返回true</span><br>        vis[s] = <span class="hljs-literal">true</span>;<br>        dfsvis[s] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> edge : Graph[s]) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[edge]) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(edge)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dfsvis[edge]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        dfsvis[s] = <span class="hljs-literal">false</span>;<br>        path.<span class="hljs-built_in">push_back</span>(s);<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == n) &#123;<br>            <span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day9"><a class="markdownIt-Anchor" href="#day9"></a> Day9</h2>
<h3 id="41-缺失的第一个正数"><a class="markdownIt-Anchor" href="#41-缺失的第一个正数"></a> 41、缺失的第一个正数</h3>
<p>利用hashset做，时间复杂度和空间复杂度都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(nums.begin(), nums.end())</span></span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (res &lt;= n) &#123;<br>            <span class="hljs-keyword">if</span> (!s.<span class="hljs-built_in">count</span>(res)) <span class="hljs-keyword">return</span> res;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，空间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i] - <span class="hljs-number">1</span>]) &#123;  <span class="hljs-comment">//将在0到n的正数放到属于自己的位置</span><br>                <span class="hljs-built_in">swap</span>(nums[i], nums[nums[i] - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>; <span class="hljs-comment">// 出去的话那就是最后一个的下一个</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="39-组合总和"><a class="markdownIt-Anchor" href="#39-组合总和"></a> 39、组合总和</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-comment">//dfs走一个</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; ans;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; temp; <span class="hljs-comment">// 中间存储</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; Can;  <span class="hljs-comment">//方便全局遍历</span><br>    <span class="hljs-keyword">int</span> tar; <span class="hljs-comment">//方便遍历记录target</span><br>    <span class="hljs-keyword">int</span> n; <span class="hljs-comment">// 记录一共有多少个数</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; candidates, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        Can = candidates, n = Can.<span class="hljs-built_in">size</span>(), tar = target;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">int</span> curVal)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (curVal == tar) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = idx; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (curVal + Can[i] &lt;= tar) &#123;<br>                temp.<span class="hljs-built_in">push_back</span>(Can[i]);<br>                <span class="hljs-built_in">dfs</span>(i, curVal + Can[i]);<br>                temp.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="168-excel表列名称"><a class="markdownIt-Anchor" href="#168-excel表列名称"></a> 168、Excel表列名称</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convertToTitle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> columnNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (columnNumber == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        columnNumber--; <span class="hljs-comment">// 因为A对应的是1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">convertToTitle</span>(columnNumber / <span class="hljs-number">26</span>) + (<span class="hljs-keyword">char</span>)(columnNumber % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;A&#x27;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="47-全排列2"><a class="markdownIt-Anchor" href="#47-全排列2"></a> 47、全排列2</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; Nums;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; res;<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">15</span>);<br>    <span class="hljs-keyword">int</span> N;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        N = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        Nums = nums;<br>        <span class="hljs-built_in">dfs</span>(&#123;&#125;);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; temp)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (temp.<span class="hljs-built_in">size</span>() == N) &#123;  <span class="hljs-comment">//完成一个就剪枝</span><br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">1</span> &amp;&amp; vis[i - <span class="hljs-number">1</span>] &amp;&amp; Nums[i - <span class="hljs-number">1</span>] == Nums[i]) &#123; <span class="hljs-comment">// 如果上一个使用过 且和我当前这个一样的话 那就跳过</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!vis[i]) &#123; <span class="hljs-comment">// 如果这个没有用过</span><br>                vis[i] = <span class="hljs-literal">true</span>;<br>                temp.<span class="hljs-built_in">push_back</span>(Nums[i]);<br>                <span class="hljs-built_in">dfs</span>(temp);<br>                temp.<span class="hljs-built_in">pop_back</span>();<br>                vis[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="543-二叉树的直径"><a class="markdownIt-Anchor" href="#543-二叉树的直径"></a> 543、二叉树的直径</h3>
<p>主要求的是路径</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">f</span>(root);<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">f</span>(root-&gt;left);<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">f</span>(root-&gt;right);<br>        sum = <span class="hljs-built_in">max</span>(sum, left + right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(left, right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day10"><a class="markdownIt-Anchor" href="#day10"></a> Day10</h2>
<h3 id="91-解码方法"><a class="markdownIt-Anchor" href="#91-解码方法"></a> 91、解码方法</h3>
<p>为什么第一个是= 第二个是+= 因为第i个状态先存储i - 1 个状态 然后在组合判断两位数的。其实第一个也可以改成+=。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; dp = vector&lt;<span class="hljs-keyword">int</span>&gt;(n);<br>        dp[<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">int</span> one = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">int</span> two = one + (s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (one != <span class="hljs-number">0</span>) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 继承上一个没有当前这个字符的状态</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">10</span> &lt;= two &amp;&amp; two &lt;= <span class="hljs-number">26</span>) &#123;<br>                dp[i] += i &gt;= <span class="hljs-number">2</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">1</span>;   <span class="hljs-comment">//这个判断用于第二位</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="142-环形链表2"><a class="markdownIt-Anchor" href="#142-环形链表2"></a> 142、环形链表2</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        ListNode* slow = head, * fast = head;<br>        <span class="hljs-keyword">do</span> &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<span class="hljs-keyword">while</span> (slow &amp;&amp; fast &amp;&amp; fast-&gt;next &amp;&amp; fast != slow);<br>        <span class="hljs-keyword">if</span> (!slow || !fast || !fast-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        slow = head;<br>        <span class="hljs-keyword">while</span> (fast != slow) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="46-全排列"><a class="markdownIt-Anchor" href="#46-全排列"></a> 46、全排列</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; ans;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; Nums;<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">15</span>);<br>    <span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        n = nums.<span class="hljs-built_in">size</span>();<br>        Nums = nums;<br>        <span class="hljs-built_in">dfs</span>(&#123;&#125;);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; temp)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (temp.<span class="hljs-built_in">size</span>() == n) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[i]) &#123;<br>                vis[i] = <span class="hljs-literal">true</span>;<br>                temp.<span class="hljs-built_in">push_back</span>(Nums[i]);<br>                <span class="hljs-built_in">dfs</span>(temp);<br>                temp.<span class="hljs-built_in">pop_back</span>();<br>                vis[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="415-字符串相加"><a class="markdownIt-Anchor" href="#415-字符串相加"></a> 415、字符串相加</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addStrings</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n1 = num1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> n2 = num2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n1 &gt;= <span class="hljs-number">0</span> || n2 &gt;= <span class="hljs-number">0</span> || carry) &#123;<br>            <span class="hljs-keyword">if</span> (n1 &gt;= <span class="hljs-number">0</span>) &#123;<br>                carry += num1[n1--] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (n2 &gt;= <span class="hljs-number">0</span>) &#123;<br>                carry += num2[n2--] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            ans += carry % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>            carry /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day11"><a class="markdownIt-Anchor" href="#day11"></a> Day11</h2>
<h3 id="240-搜索二维矩阵2"><a class="markdownIt-Anchor" href="#240-搜索二维矩阵2"></a> 240、搜索二维矩阵2</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>, c = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (r &lt; m &amp;&amp; c &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[r][c] == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[r][c] &gt; target) &#123;<br>                c--;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                r++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="93-复制ip地址"><a class="markdownIt-Anchor" href="#93-复制ip地址"></a> 93、复制IP地址</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;string&gt; ans;<br>    <span class="hljs-keyword">int</span> n;<br>    string S;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        n = s.<span class="hljs-built_in">size</span>();<br>        S = s;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">3</span> || s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 当长度超了不可以 如果没有了也不可以</span><br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">// 第一位不可以为&#x27;0&#x27;（如果是两位以上）</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &gt; <span class="hljs-built_in">stoi</span>(s) || <span class="hljs-built_in">stoi</span>(s) &gt; <span class="hljs-number">255</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 值的范围在0~255</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string temp, <span class="hljs-keyword">int</span> dot, <span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (dot == <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">isValid</span>(S.<span class="hljs-built_in">substr</span>(start))) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp + S.<span class="hljs-built_in">substr</span>(start));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; start + <span class="hljs-number">3</span> &amp;&amp; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(S.<span class="hljs-built_in">substr</span>(start, i - start + <span class="hljs-number">1</span>))) &#123;<br>                <span class="hljs-built_in">dfs</span>(temp + S.<span class="hljs-built_in">substr</span>(start, i - start + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;.&quot;</span> , dot + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="72-编辑距离"><a class="markdownIt-Anchor" href="#72-编辑距离"></a> 72、编辑距离</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n1 = word1.<span class="hljs-built_in">size</span>(), n2 = word2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">dp</span> (n1 + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n2 + <span class="hljs-number">1</span>));  <span class="hljs-comment">// dp这个状态数组表示两个字付串不同长度下的改变状态值</span><br>        <span class="hljs-comment">// 对于一个空一个没有那改变的数量就是当前另一个的长度值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n1; ++i) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= n2; ++j) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n2; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 如果字符串相等 那就是  ｜ 这里 -1 是数组索引的问题 0 是第一个</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// dp[i - 1][j - 1] 代表替换当前这个字符, min(dp[i - 1][j], dp[i][j - 1])代表删除一个字符串里的字符或者插入一个字符</span><br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>; <span class="hljs-comment">// +1代表一个操作处理</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n1][n2];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="752-打开转盘锁"><a class="markdownIt-Anchor" href="#752-打开转盘锁"></a> 752、打开转盘锁</h3>
<p>BFS遍历变种题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; dir&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">openLock</span><span class="hljs-params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;<br>        unordered_set&lt;string&gt; vis;  <span class="hljs-comment">// 计算过的状态</span><br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">dead</span><span class="hljs-params">(deadends.begin(), deadends.end())</span></span>; <span class="hljs-comment">// 不可以触碰的状态</span><br>        <span class="hljs-keyword">if</span> (dead.<span class="hljs-built_in">count</span>(<span class="hljs-string">&quot;0000&quot;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 防止一开始的开头出问题</span><br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-string">&quot;0000&quot;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        queue&lt;string&gt; q; <span class="hljs-comment">// 用于BFS中间存储状态</span><br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;0000&quot;</span>);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = q.<span class="hljs-built_in">size</span>();<br>            ans++;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                string cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cur.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> d : dir) &#123;<br>                        string t = cur;  <span class="hljs-comment">// 每次只要动一处 所以每次都得还原一次状态</span><br>                        t[i] = (((t[i] - <span class="hljs-string">&#x27;0&#x27;</span>) + <span class="hljs-number">10</span>) + d) % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-comment">// 为了让她在0 ～ 9 无限循环</span><br>                        <span class="hljs-keyword">if</span>(!vis.<span class="hljs-built_in">count</span>(t) &amp;&amp; !dead.<span class="hljs-built_in">count</span>(t)) &#123; <span class="hljs-comment">// 必须得都没有在违法区域的</span><br>                            <span class="hljs-keyword">if</span> (t == target) &#123;<br>                                <span class="hljs-keyword">return</span> ans;<br>                            &#125;<span class="hljs-keyword">else</span> &#123;<br>                                vis.<span class="hljs-built_in">insert</span>(t);<br>                                q.<span class="hljs-built_in">push</span>(t);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day12"><a class="markdownIt-Anchor" href="#day12"></a> Day12</h2>
<h3 id="138-复制带随机指针的链表"><a class="markdownIt-Anchor" href="#138-复制带随机指针的链表"></a> 138、复制带随机指针的链表</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>: <span class="hljs-comment">// 空间换时间就可以 用hashmap记录成成对的节点</span><br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> head; <span class="hljs-comment">// 不处理单个节点因为只要有节点就需要复制重新弄</span><br>        Node* res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(head-&gt;val); <br>        Node* cur = res, * node = head-&gt;next;<br>        unordered_map&lt;Node*, Node*&gt; m; <span class="hljs-comment">// 用于存储原链表与新链表的对应位置</span><br>        m[head] = res;  <span class="hljs-comment">// 第一个单独处理</span><br>        <span class="hljs-keyword">while</span>(node) &#123;<br>            Node* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(node-&gt;val);  <span class="hljs-comment">// 创建新的链表</span><br>            cur-&gt;next = newNode;<br>            m[node] = newNode;<br>            cur = cur-&gt;next;<br>            node = node-&gt;next;<br>        &#125;<br>        cur = res, node = head;<br>        <span class="hljs-keyword">while</span>(cur) &#123;<br>            cur-&gt;random = m[node-&gt;random];  <span class="hljs-comment">//m[node-&gt;random] 就等于是在cur上面找</span><br>            cur = cur-&gt;next;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="468-验证ip地址"><a class="markdownIt-Anchor" href="#468-验证ip地址"></a> 468、验证IP地址</h3>
<p>这道题太过于细致复杂，观看大神详解：</p>
<p>这道题让我们验证两种IP地址，LeetCode之前有一道关于IPv4的题<a target="_blank" rel="noopener" href="http://www.cnblogs.com/grandyang/p/4305572.html">Restore IP Addresses</a>，给我们了一个字符串，让我们通过在中间加点来找出所有正确的IP地址，这道题给了我们中间加点或者冒号的字符串，让我们验证其是否是正确的IPv4或者IPv6，感觉要稍稍复杂一些。那么我们只有分别来验证了，那么我们怎么样能快速的区别是IPv4或者IPv6呢，当然是通过中间的点或者冒号啦，所以我们首先在字符串中找冒号(当然你想找点也可以)，如果字符串中没有冒号，那么我们来验证其是否是IPv4，如果有冒号，我们就来验证其是否是IPv6.</p>
<p>首先对于IPv4，我们使用getline函数来截取两个点之间的字符串，我们还需要一个计数器cnt来记录我们已经截取了多少段，如果cnt大于4了，说明超过了4段，说明是不是正确的地址。如果取出的字符串为空，说明两个点连在一起了，也不对。再有就是如果字符串长度大于1，且第一个字符是0，也不对。由于IPv4的地址在0到255之间，所以如果字符串长度大于3，也不正确。下面我们检查每一个字符，如果有不是数字的字符，返回Neither。最后我们再把字符串转为数字，如果不在0到255之间就是非法的。最后的最后，我们要保证cnt正好为4，而且最后一个字符不能是点，统统满足以上条件才是正确的IPv4地址。</p>
<p>然后对于IPv6，我们也使用getline函数来截取两个冒号之间的字符串，我们同样需要计数器cnt来记录我们已经截取了多少段，如果cnt大于8了，说明超过了8段，说明是不是正确的地址。如果取出的字符串为空，说明两个冒号连在一起了，也不对。面我们检查每一个字符，正确的字符应该是0到9之间的数字，或者a到f，或A到F之间的字符，如果出现了其他字符，返回Neither。最后的最后，我们要保证cnt正好为8，而且最后一个字符不能是冒号，统统满足以上条件才是正确的IPv6地址。</p>
<p><strong>这题回头考试前多看看吧，也没办法去记忆这些规则</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">validIPAddress</span><span class="hljs-params">(string IP)</span> </span>&#123;<br>        <span class="hljs-function">istringstream <span class="hljs-title">is</span><span class="hljs-params">(IP)</span></span>; <span class="hljs-comment">// 转换字符流好处理</span><br>        string t = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (IP.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;:&quot;</span>) == string::npos) &#123; <span class="hljs-comment">// 如果是IPv4</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(is, t, <span class="hljs-string">&#x27;.&#x27;</span>)) &#123;<br>                cnt++; <span class="hljs-comment">// 记录有几段</span><br>                <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">4</span> || t.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">3</span> || (t.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; t[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) || t.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t) &#123;<br>                    <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>                &#125;<br>                <span class="hljs-keyword">int</span> val = <span class="hljs-built_in">stoi</span>(t);<br>                <span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">0</span> || val &gt; <span class="hljs-number">255</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> (cnt == <span class="hljs-number">4</span> &amp;&amp; IP.<span class="hljs-built_in">back</span>() != <span class="hljs-string">&#x27;.&#x27;</span>) ? <span class="hljs-string">&quot;IPv4&quot;</span> : <span class="hljs-string">&quot;Neither&quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 判断IPv6</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(is, t, <span class="hljs-string">&#x27;:&#x27;</span>)) &#123;<br>                cnt++;<br>                <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">8</span> || t.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">4</span> || t.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t) &#123;<br>                    <span class="hljs-keyword">if</span> (!(<span class="hljs-string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &amp;&amp; !(<span class="hljs-string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;f&#x27;</span>) &amp;&amp; !(<span class="hljs-string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;F&#x27;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> (cnt == <span class="hljs-number">8</span> &amp;&amp; IP.<span class="hljs-built_in">back</span>() != <span class="hljs-string">&#x27;:&#x27;</span>) ? <span class="hljs-string">&quot;IPv6&quot;</span> : <span class="hljs-string">&quot;Neither&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="64-最小路径和"><a class="markdownIt-Anchor" href="#64-最小路径和"></a> 64、最小路径和</h3>
<p>不记录路径</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> m = grid.<span class="hljs-built_in">size</span>(), n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; dp = vector&lt;<span class="hljs-keyword">int</span>&gt;(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 在第一列只能向下走</span><br>                    dp[j] += grid[i][j];<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">// 在第一行只能向右走</span><br>                    dp[j] = dp[j - <span class="hljs-number">1</span>] + grid[i][j];<br>                &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">// 可以往下也可以往右</span><br>                    dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - <span class="hljs-number">1</span>]) + grid[i][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>记录路径（延伸）【肯定超时】</p>
<p>但是思路就是用<strong>二维dp数组</strong>，然后根据<strong>dp的数据状态图</strong>进行<strong>dfs</strong>得到结果。</p>
<h3 id="224-基本计算器好题"><a class="markdownIt-Anchor" href="#224-基本计算器好题"></a> 224、基本计算器（好题）</h3>
<p>在于遇到括号需要存储当前的状态，并且我们对于数字的处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; st;  <span class="hljs-comment">//对于遇到括号 用于存储中间状态</span><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, sign = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;0&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123; <span class="hljs-comment">// 数字的话就把这个数解决了</span><br>                <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-string">&#x27;0&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                    num = num * <span class="hljs-number">10</span> + (s[i++] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                &#125;<br>                res += num * sign;<br>                i--; <span class="hljs-comment">// 因为退出的时候会多加一个</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                sign = <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                sign = <span class="hljs-number">-1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123; <span class="hljs-comment">// 存储状态并初始化</span><br>                st.<span class="hljs-built_in">push</span>(res);<br>                st.<span class="hljs-built_in">push</span>(sign);<br>                res = <span class="hljs-number">0</span>;<br>                sign = <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                res *= st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 解决左括号前的符号问题</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                res += st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day13"><a class="markdownIt-Anchor" href="#day13"></a> Day13</h2>
<h3 id="剑指-offer-51-数组中的逆序对"><a class="markdownIt-Anchor" href="#剑指-offer-51-数组中的逆序对"></a> 剑指 Offer 51. 数组中的逆序对</h3>
<p>就是归并排序上再外加一个统计逆序就行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InversePairs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; data)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">copy</span><span class="hljs-params">(data.begin(), data.end())</span></span>; <span class="hljs-comment">// copy数组用于给数组更新当中间变量</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">inverseCount</span>(data, copy, <span class="hljs-number">0</span>, data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inverseCount</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; data, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; copy, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (low &gt;= high) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> leftCnt = <span class="hljs-built_in">inverseCount</span>(copy, data, low, mid) % <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-keyword">int</span> rightCnt = <span class="hljs-built_in">inverseCount</span>(copy, data, mid + <span class="hljs-number">1</span>, high) % <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-keyword">int</span> i = mid, j = high;<br>        <span class="hljs-keyword">int</span> locCopy = high;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录当前多少逆续对</span><br>        <span class="hljs-keyword">while</span> (i &gt;= low &amp;&amp; j &gt; mid) &#123;<br>            <span class="hljs-keyword">if</span> (data[i] &gt; data[j]) &#123; <br>                count += j - mid; <span class="hljs-comment">// 因为j到mid一定小于i i到mid肯定大于j</span><br>                copy[locCopy--] = data[i--];<br>                <span class="hljs-keyword">if</span> (count &gt;= <span class="hljs-number">1000000007</span>) &#123;<br>                    count %= <span class="hljs-number">1000000007</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                copy[locCopy--] = data[j--];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//把剩余的更新了</span><br>        <span class="hljs-keyword">while</span> (i &gt;= low) &#123;<br>            copy[locCopy--] = data[i--];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (j &gt; mid) &#123;<br>            copy[locCopy--] = data[j--];<br>        &#125;<br>        <span class="hljs-keyword">return</span> (leftCnt + rightCnt + count) % <span class="hljs-number">1000000007</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="239-滑动窗口最大值"><a class="markdownIt-Anchor" href="#239-滑动窗口最大值"></a> 239、滑动窗口最大值</h3>
<p>使用k大小的堆来维护滑动窗口<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>时间复杂度 但是这部分只能用java实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">maxInWindows</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] num, <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">0</span> || size &gt; num.length)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        &#125;<br>        ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 初始化窗口</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)&#123;<br>            maxHeap.offer(num[i]);<br>        &#125;<br>        ans.add(maxHeap.peek());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = size; j &lt; num.length; ++i, ++j)&#123;<br>            maxHeap.remove(num[i]);<br>            maxHeap.offer(num[j]);<br>            ans.add(maxHeap.peek());<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>创建单调队列时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> &#123;</span> <span class="hljs-comment">// 创建单调队列</span><br>            <span class="hljs-keyword">private</span>:<br>                deque&lt;<span class="hljs-keyword">int</span>&gt; que;<br>            <span class="hljs-keyword">public</span>:<br>                <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>                    <span class="hljs-comment">//队头这个数就是当前最大值</span><br>                    <span class="hljs-keyword">if</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; val == que.<span class="hljs-built_in">front</span>()) &#123;  <span class="hljs-comment">//如果当前退出数是当前最大值，那么我们就踢出他 但是踢出当前这个不能踢出多的</span><br>                        que.<span class="hljs-built_in">pop_front</span>();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123; <span class="hljs-comment">// 插入操作</span><br>                    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>() &amp;&amp; val &gt; que.<span class="hljs-built_in">back</span>()) &#123;  <span class="hljs-comment">// 吧没有用的小值清干净 然后吧当前值放在能放的最大值的位置 如果有一样的也不破坏最大值的数量</span><br>                        que.<span class="hljs-built_in">pop_back</span>();<br>                    &#125;<br>                    que.<span class="hljs-built_in">push_back</span>(val);<br>                &#125;<br>                <span class="hljs-comment">// 通过pop 和 push保证这个单调队列里面包含的就是当前滑动窗口的最大值 以及候选人们</span><br>                <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span></span>&#123;<br>                    <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">front</span>();<br>                &#125;<br>        &#125;;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>            MyQueue Q;<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>                Q.<span class="hljs-built_in">push</span>(nums[i]);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(Q.<span class="hljs-built_in">front</span>());<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                Q.<span class="hljs-built_in">pop</span>(nums[i - k]);<br>                Q.<span class="hljs-built_in">push</span>(nums[i]);<br>                ans.<span class="hljs-built_in">push_back</span>(Q.<span class="hljs-built_in">front</span>());<br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="153-寻找旋转排序数组中的最小值"><a class="markdownIt-Anchor" href="#153-寻找旋转排序数组中的最小值"></a> 153、寻找旋转排序数组中的最小值</h3>
<p>按照时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的时间复杂度，所以是二分法的拓展应用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; h) &#123;<br>            <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[m] &gt; nums[h]) &#123; <span class="hljs-comment">// 比最右边的大 那一定不是</span><br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 比他小或着等于他 那都代表的是可能是或者说她是右边界</span><br>                h = m;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[l];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day14"><a class="markdownIt-Anchor" href="#day14"></a> Day14</h2>
<h3 id="8-二叉树的下一个节点"><a class="markdownIt-Anchor" href="#8-二叉树的下一个节点"></a> 8、二叉树的下一个节点</h3>
<p>题目链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=11210&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=11210&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github</a></p>
<p>中序遍历</p>
<p>1）如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点</p>
<p>2）否则，向上找第一个左链接指向的树包含该节点的祖先节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeLinkNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeLinkNode *left;</span><br><span class="hljs-comment">    struct TreeLinkNode *right;</span><br><span class="hljs-comment">    struct TreeLinkNode *next;</span><br><span class="hljs-comment">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeLinkNode* <span class="hljs-title">GetNext</span><span class="hljs-params">(TreeLinkNode* pNode)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pNode-&gt;right != <span class="hljs-literal">NULL</span>) &#123;<br>            TreeLinkNode* r = pNode-&gt;right;<br>            <span class="hljs-keyword">while</span> (r-&gt;left) &#123;<br>                r = r-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">return</span> r;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span>(pNode-&gt;next) &#123; <span class="hljs-comment">// 爹还一直在</span><br>                TreeLinkNode* parent = pNode-&gt;next;<br>                <span class="hljs-keyword">if</span> (parent-&gt;left == pNode) &#123;<br>                    <span class="hljs-keyword">return</span> parent;<br>                &#125;<br>                pNode = pNode-&gt;next; <span class="hljs-comment">// 往上走</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day15"><a class="markdownIt-Anchor" href="#day15"></a> Day15</h2>
<h3 id="76-最小覆盖子串"><a class="markdownIt-Anchor" href="#76-最小覆盖子串"></a> 76、最小覆盖子串</h3>
<p>收缩左边界，由于遍历的时候，对映射值减了1，所以此时去除字母的时候，就要把减去的1加回来，此时如果加1后的值大于0了，说明此时少了一个T中的字母，那么 cnt 值就要减1了，然后移动左边界 left。</p>
<p>- 先<strong>扫描一遍T</strong>，把对应的字符及其出现的次数存到 HashMap 中。</p>
<p>- 然后开始<strong>遍历S</strong>，就把遍历到的字母对应的 HashMap 中的 value 减一，如果减1后仍大于等于0，cnt 自增1。</p>
<p>- 如果 cnt 等于T串长度时，开始循环，纪录一个字串并更新最小字串值。然后将子窗口的左边界向右移，如果某个移除掉的字母是T串中不可缺少的字母，那么 cnt 自减1，表示此时T串并没有完全匹配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>, minDist = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : t) &#123;  <span class="hljs-comment">// 记录一下模版</span><br>            m[c]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (--m[s[i]] &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 遇到了t中对应的字母 记录一下个数</span><br>                cnt++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (cnt == t.<span class="hljs-built_in">size</span>()) &#123;<br>                <span class="hljs-keyword">if</span> (i - left + <span class="hljs-number">1</span> &lt; minDist) &#123;<br>                    minDist = i - left + <span class="hljs-number">1</span>;<br>                    res = s.<span class="hljs-built_in">substr</span>(left, minDist);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (++m[s[left]] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果某个移除掉的字母是T串中不可缺少的字母，那么 cnt 自减1</span><br>                    --cnt;<br>                &#125;<br>                ++left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a class="markdownIt-Anchor" href="#34-在排序数组中查找元素的第一个和最后一个位置"></a> 34、在排序数组中查找元素的第一个和最后一个位置</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-built_in">binarySearch</span>(nums, target, <span class="hljs-number">0</span>), <span class="hljs-built_in">binarySearch</span>(nums, target, <span class="hljs-number">1</span>)&#125;; <span class="hljs-comment">// 前左后右</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> mode)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= h) &#123;<br>            <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[m] &gt; target) &#123;<br>                h = m - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[m] &lt; target) &#123;<br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                ans = m;<br>                mode == <span class="hljs-number">0</span> ? h = m - <span class="hljs-number">1</span> : l = m + <span class="hljs-number">1</span>; <span class="hljs-comment">// 因为前面是+1 和 -1 所以这个h不可能超出这个值的范围</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="110-平衡二叉树"><a class="markdownIt-Anchor" href="#110-平衡二叉树"></a> 110、平衡二叉树</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">bool</span> ans = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">isB</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isB</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-built_in">isB</span>(root-&gt;left);<br>        <span class="hljs-keyword">int</span> r = <span class="hljs-built_in">isB</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(l - r) &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 不符合平衡二叉树的定义</span><br>            ans = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(r, l);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="21-合并两个有序链表"><a class="markdownIt-Anchor" href="#21-合并两个有序链表"></a> 21、合并两个有序链表</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        <span class="hljs-comment">//谁没了就接另一个</span><br>        <span class="hljs-keyword">if</span> (!list1) <span class="hljs-keyword">return</span> list2;<br>        <span class="hljs-keyword">if</span> (!list2) <span class="hljs-keyword">return</span> list1;<br>        <span class="hljs-keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;<br>            list1-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(list1-&gt;next, list2);<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            list2-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(list1, list2-&gt;next);<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>如果发现单个链表中有重复数字，直接跳到最后一个<br />
(1-&gt;1-&gt;1-&gt;2) 转换为 (1-&gt;2)<br />
有可能会出现list1与list2有相同元素，跳过其中的一个<br />
(1-&gt;3) and (1-&gt;2) 转换为 (1-&gt;3) and (2)</p>
<p>在上面解法中再加入以下代码在上面</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//单个链表中有重复数字，直接跳到最后一个</span><br><span class="hljs-keyword">while</span>(list1-&gt;next != null &amp;&amp; list1-&gt;val == list1-&gt;next-&gt;val)&#123;<br>		list1 = list1-&gt;next;<br>&#125;<br><span class="hljs-keyword">while</span>(list2-&gt;next!=null &amp;&amp; list2-&gt;val == list2-&gt;next-&gt;val)&#123;<br>		list2 = list2-&gt;next;<br>&#125;<br><span class="hljs-comment">//list1与list2有相同元素</span><br><span class="hljs-keyword">if</span>(list1-&gt;val == list2-&gt;val)&#123;<br>		<span class="hljs-keyword">if</span>(list2-&gt;next != null)&#123;<br>				list2 = list2-&gt;next;<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>				<span class="hljs-keyword">return</span> list1;<br>		&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>变形：合并多个有序链表 思路：以合并两个链表的思路为基础，使用<strong>归并自底向上合并</strong>。</p>
<h2 id="day16"><a class="markdownIt-Anchor" href="#day16"></a> Day16</h2>
<h3 id="14-排序链表"><a class="markdownIt-Anchor" href="#14-排序链表"></a> 14、排序链表</h3>
<p>用归并排序和合并有序链表组合实现</p>
<p>非递归实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head; <span class="hljs-comment">// 若为空 或者就自己 那就是返回自己</span><br>        ListNode* fast = head, * slow = head, * pre = head;<br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>            pre = slow; <span class="hljs-comment">// 为了截断两边用</span><br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//此时slow就是另一个新的链表的头</span><br>        pre-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 以上是自顶向下拆分</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">sortList</span>(head), <span class="hljs-built_in">sortList</span>(slow)); <span class="hljs-comment">//以下是自底向上合并</span><br>    &#125;<br>    <br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;  <span class="hljs-comment">// 合并两个有序链表</span><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* cur = dummy;<br>        <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) &#123;<br>            <span class="hljs-keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;<br>                cur-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                cur-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l1) &#123;<br>            cur-&gt;next = l1;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l2) &#123;<br>            cur-&gt;next = l2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>递归实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head; <span class="hljs-comment">// 若为空 或者就自己 那就是返回自己</span><br>        ListNode* fast = head, * slow = head, * pre = head;<br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>            pre = slow; <span class="hljs-comment">// 为了截断两边用</span><br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        pre-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">sortList</span>(head), <span class="hljs-built_in">sortList</span>(slow));<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123; <span class="hljs-comment">// 这部分就是合并两个有序链表</span><br>        <span class="hljs-keyword">if</span> (!l1) <span class="hljs-keyword">return</span> l2;<br>        <span class="hljs-keyword">if</span> (!l2) <span class="hljs-keyword">return</span> l1;<br>        <span class="hljs-keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;<br>            l1-&gt;next = <span class="hljs-built_in">merge</span>(l1-&gt;next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            l2-&gt;next = <span class="hljs-built_in">merge</span>(l1, l2-&gt;next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="69-x的平方根"><a class="markdownIt-Anchor" href="#69-x的平方根"></a> 69、x的平方根</h3>
<p>二分法结束条件就是除数和结果一致</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, h = x, sqrt;<br>        <span class="hljs-keyword">while</span> (l &lt;= h) &#123;<br>            <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;<br>            sqrt = x / m;<br>            <span class="hljs-keyword">if</span> (sqrt == m) <span class="hljs-keyword">return</span> m;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sqrt &lt; m) h = m - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> l = m + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> h; <span class="hljs-comment">// h = l - 1 说明取小数那端</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="173-二叉搜索树迭代器"><a class="markdownIt-Anchor" href="#173-二叉搜索树迭代器"></a> 173、二叉搜索树迭代器</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BSTIterator</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;TreeNode* &gt; temp; <span class="hljs-comment">// 用于存储层次序列</span><br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BSTIterator</span>(TreeNode* root) &#123;<br>        <span class="hljs-built_in">create</span>(root);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">create</span>(root-&gt;left);<br>        temp.<span class="hljs-built_in">push_back</span>(root);<br>        <span class="hljs-built_in">create</span>(root-&gt;right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> temp[idx++]-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> idx &lt; temp.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your BSTIterator object will be instantiated and called as such:</span><br><span class="hljs-comment"> * BSTIterator* obj = new BSTIterator(root);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;next();</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;hasNext();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p>非递归版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BSTIterator</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    stack&lt;TreeNode* &gt; st; <span class="hljs-comment">// 用于存储层次序列</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushAll</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (root) &#123;<br>            st.<span class="hljs-built_in">push</span>(root);<br>            root = root-&gt;left;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BSTIterator</span>(TreeNode* root) &#123;<br>        <span class="hljs-built_in">pushAll</span>(root);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 找到最新的左孩子</span><br>        TreeNode* cur = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-built_in">pushAll</span>(cur-&gt;right);<br>        <span class="hljs-keyword">return</span> cur-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> !st.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your BSTIterator object will be instantiated and called as such:</span><br><span class="hljs-comment"> * BSTIterator* obj = new BSTIterator(root);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;next();</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;hasNext();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h3 id="152-乘积最大子数组"><a class="markdownIt-Anchor" href="#152-乘积最大子数组"></a> 152、乘积最大子数组</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// dp1 代表 当前最小值用于处理负数 dp2 当前最大值</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; dp1 = vector&lt;<span class="hljs-keyword">int</span>&gt;(n);<br>        dp1[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; dp2 = vector&lt;<span class="hljs-keyword">int</span>&gt;(n);<br>        dp2[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> ans = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            dp1[i] = <span class="hljs-built_in">min</span>(nums[i] * dp1[i - <span class="hljs-number">1</span>], nums[i]);<br>            dp2[i] = <span class="hljs-built_in">max</span>(nums[i] * dp2[i - <span class="hljs-number">1</span>], nums[i]);<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果遇到负数</span><br>                dp1[i] = <span class="hljs-built_in">min</span>(nums[i] * dp2[i - <span class="hljs-number">1</span>], nums[i]);<br>                dp2[i] = <span class="hljs-built_in">max</span>(nums[i] * dp1[i - <span class="hljs-number">1</span>], nums[i]);<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, dp2[i]); <span class="hljs-comment">// 更新最优值</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day17"><a class="markdownIt-Anchor" href="#day17"></a> Day17</h2>
<h3 id="105-从前序与中序遍历序列构造二叉树"><a class="markdownIt-Anchor" href="#105-从前序与中序遍历序列构造二叉树"></a> 105、从前序与中序遍历序列构造二叉树</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; M; <span class="hljs-comment">// 用于从中序队列中找到前序队列中根的位置</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            M[inorder[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(preorder, <span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; pre, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> inL)</span> </span>&#123;  <span class="hljs-comment">//inL代表中序遍历的左边界</span><br>        <span class="hljs-keyword">if</span> (l &gt; r) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(pre[l]);  <span class="hljs-comment">// 建立好当前的根(前序遍历当前第一个为根)</span><br>        <span class="hljs-keyword">int</span> rootIdx = M[pre[l]];<br>        <span class="hljs-keyword">int</span> lenL = rootIdx - inL; <span class="hljs-comment">// 获取左边界的长度（从中序遍历中获得）</span><br>        root-&gt;left = <span class="hljs-built_in">build</span>(pre, l + <span class="hljs-number">1</span>, l + lenL, inL);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(pre, l + lenL + <span class="hljs-number">1</span>, r, rootIdx + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="剑指offer04二维数组中的查找"><a class="markdownIt-Anchor" href="#剑指offer04二维数组中的查找"></a> 剑指Offer04.二维数组中的查找</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; array)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> m = array.<span class="hljs-built_in">size</span>(), n = array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (target == array[i][j]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; array[i][j]) &#123;<br>                ++i;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                --j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="23-合并k个排序链表"><a class="markdownIt-Anchor" href="#23-合并k个排序链表"></a> 23、合并K个排序链表</h3>
<p>利用归并的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">int</span> n;<br>    vector&lt;ListNode*&gt; Ls;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        n = lists.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        Ls = lists;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">conquer</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">conquer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> Ls[l];<br>        <span class="hljs-keyword">int</span> m = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeTwo</span>(<span class="hljs-built_in">conquer</span>(l, m), <span class="hljs-built_in">conquer</span>(m + <span class="hljs-number">1</span>, r)); <span class="hljs-comment">// 这一步将分解问题和合并问题写在了一起</span><br>    &#125;<br>        <br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwo</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!l1) <span class="hljs-keyword">return</span> l2;<br>        <span class="hljs-keyword">if</span> (!l2) <span class="hljs-keyword">return</span> l1;<br>        <span class="hljs-keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;<br>            l1-&gt;next = <span class="hljs-built_in">mergeTwo</span>(l1-&gt;next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            l2-&gt;next = <span class="hljs-built_in">mergeTwo</span>(l1, l2-&gt;next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>用空间换时间，小顶堆 + 尾插法从小到大。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; minHeap; <span class="hljs-comment">// 小顶堆</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = lists.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            ListNode* cur = lists[i];<br>            <span class="hljs-keyword">while</span> (cur) &#123;<br>                minHeap.<span class="hljs-built_in">push</span>(cur-&gt;val);<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* node = dummy;<br>        <span class="hljs-comment">//小顶堆 + 尾插法 从小到大</span><br>        <span class="hljs-keyword">while</span>(!minHeap.<span class="hljs-built_in">empty</span>())&#123; <br>            node-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(minHeap.<span class="hljs-built_in">top</span>());<br>            minHeap.<span class="hljs-built_in">pop</span>();<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day18"><a class="markdownIt-Anchor" href="#day18"></a> Day18</h2>
<h3 id="剑指offer-33二叉搜索树的后序遍历序列"><a class="markdownIt-Anchor" href="#剑指offer-33二叉搜索树的后序遍历序列"></a> 剑指Offer 33.二叉搜索树的后序遍历序列</h3>
<p>找根然后确定左右子树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; sequence)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sequence.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Verify</span>(sequence, <span class="hljs-number">0</span>, sequence.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Verify</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; seq, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;  <span class="hljs-comment">// 每回合判断是否符合规矩</span><br>        <span class="hljs-keyword">if</span>(end - start &lt;= <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">//这个时候就是RD or D </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> rootVal = seq[end];  <span class="hljs-comment">// 获取跟节点的数值</span><br>        <span class="hljs-keyword">int</span> idx = start;<br>        <span class="hljs-keyword">while</span> (idx &lt; end &amp;&amp; seq[idx] &lt; rootVal) &#123;<br>            idx++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> center = idx - <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录一下左右子树的分界点</span><br>        <span class="hljs-comment">// 此时处理leftIdx指向右子树遍历的第一个节点</span><br>        <span class="hljs-keyword">while</span> (idx &lt; end) &#123;<br>            <span class="hljs-keyword">if</span> (seq[idx] &lt; rootVal) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            idx++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Verify</span>(seq, start, center) &amp;&amp; <span class="hljs-built_in">Verify</span>(seq, center + <span class="hljs-number">1</span>, end - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="208-实现trie前缀树"><a class="markdownIt-Anchor" href="#208-实现trie前缀树"></a> 208、实现Trie（前缀树）</h3>
<p>26分枝的树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span> &#123;</span> <span class="hljs-comment">// 拥有26个分支的字典树</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span>* <span class="hljs-title">dict</span>[26];</span> <span class="hljs-comment">// 这26个数组的索引就代表了他们的字符</span><br>        <span class="hljs-keyword">bool</span> isleaf; <span class="hljs-comment">// 是否是叶子</span><br>    &#125;;<br>    TrieNode* root;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Trie</span>() &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        TrieNode* cur = root; <span class="hljs-comment">// 开始从根开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : word) &#123;<br>            <span class="hljs-keyword">if</span> (!cur-&gt;dict[c - <span class="hljs-string">&#x27;a&#x27;</span>]) cur-&gt;dict[c -<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>(); <span class="hljs-comment">// 如果没有这个字母节点 就给他生成</span><br>            cur = cur-&gt;dict[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        cur-&gt;isleaf = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 到达最后的低端就做个标记</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        TrieNode* cur = root; <span class="hljs-comment">// 开始从根开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : word) &#123;<br>            <span class="hljs-keyword">if</span> (!cur-&gt;dict[c - <span class="hljs-string">&#x27;a&#x27;</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果没有这个字母节点 就是错的</span><br>            cur = cur-&gt;dict[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur-&gt;isleaf; <span class="hljs-comment">// 能到达叶子就说明是有的</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>        TrieNode* cur = root; <span class="hljs-comment">// 开始从根开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : prefix) &#123;<br>            <span class="hljs-keyword">if</span> (!cur-&gt;dict[c - <span class="hljs-string">&#x27;a&#x27;</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果没有这个字母节点 就是错的</span><br>            cur = cur-&gt;dict[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 不用到底 只要有就行</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Trie* obj = new Trie();</span><br><span class="hljs-comment"> * obj-&gt;insert(word);</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;search(word);</span><br><span class="hljs-comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h3 id="92-反转链表2"><a class="markdownIt-Anchor" href="#92-反转链表2"></a> 92、反转链表2</h3>
<p>经典好题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next = head;<br>        ListNode* pre = dummy, * cur = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; ++i) &#123;<br>            pre = pre-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; right; ++j) &#123;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-built_in">reverseOne</span>(pre, cur);<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseOne</span><span class="hljs-params">(ListNode* pre, ListNode* next)</span> </span>&#123; <span class="hljs-comment">// pre是上一组的最后一个， next是下一组的第一个</span><br>        <span class="hljs-comment">//尾巴出头接</span><br>        ListNode* last = pre-&gt;next, * cur = last-&gt;next;  <span class="hljs-comment">// last是该组第一个 cur是该组准备换链表头</span><br>        <span class="hljs-keyword">while</span> (cur != next) &#123;<br>            last-&gt;next = cur-&gt;next;<br>            cur-&gt;next = pre-&gt;next;<br>            pre-&gt;next = cur;<br>            cur = last-&gt;next;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>也可以转成数组处理完再放回去（太偷懒了……</p>
<h3 id="189-轮转数组"><a class="markdownIt-Anchor" href="#189-轮转数组"></a> 189、轮转数组</h3>
<p>注意题目中的要求是左旋转还是右旋转</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        k = k % nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 每当k循环数组长度的时候就等于没有动</span><br>        <span class="hljs-built_in">reverse</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 这放在最上面是左移动，放在最下面是右移动</span><br>        <span class="hljs-built_in">reverse</span>(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">reverse</span>(nums, k, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> temp = nums[l];<br>            nums[l++] = nums[r];<br>            nums[r--] = temp;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day19"><a class="markdownIt-Anchor" href="#day19"></a> Day19</h2>
<h3 id="428-序列化和反序列化n叉树"><a class="markdownIt-Anchor" href="#428-序列化和反序列化n叉树"></a> 428、序列化和反序列化N叉树</h3>
<p>这道题网上有问题，所以就直接参考别的大神的解题修改。</p>
<p>就是序列化和反序列化二叉树的部分进行循环处理n叉树就行。</p>
<p>大神是存了节点本身的值和孩子的数量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    vector&lt;Node*&gt; children;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        children = _children;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(Node* root)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ostringstream out;<br>        <span class="hljs-built_in">serialize</span>(root,out);<br>        <span class="hljs-keyword">return</span> out.<span class="hljs-built_in">str</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">Node* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">istringstream <span class="hljs-title">in</span><span class="hljs-params">(data)</span></span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">deserialize</span>(in);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(Node* root,ostringstream &amp;out)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root)<br>        &#123;<br>            out&lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            out&lt;&lt; root-&gt;children.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<span class="hljs-comment">//记录子节点个数</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p : root-&gt;children)<br>                <span class="hljs-built_in">serialize</span>(p, out);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            out &lt;&lt; <span class="hljs-string">&quot;N &quot;</span>;  <br>    &#125;<br>    <span class="hljs-function">Node* <span class="hljs-title">deserialize</span><span class="hljs-params">(istringstream &amp;in)</span></span><br><span class="hljs-function">    </span>&#123;<br>        string val;<br>        in &gt;&gt; val;<br>        <span class="hljs-keyword">if</span>(val == <span class="hljs-string">&quot;N&quot;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        Node* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-built_in">stoi</span>(val));<br>        in &gt;&gt; val;<br>        <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">stoi</span>(val);<br>        <span class="hljs-keyword">while</span>(n--)<span class="hljs-comment">//子节点个数</span><br>        &#123;<br>            Node* p = <span class="hljs-built_in">deserialize</span>(in);<br>            root-&gt;children.<span class="hljs-built_in">push_back</span>(p);<br>        &#125;    <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="24-两两交换链表中的节点"><a class="markdownIt-Anchor" href="#24-两两交换链表中的节点"></a> 24、两两交换链表中的节点</h3>
<p>可以理解：k个一组翻转链表的特殊情况</p>
<p>也可以转换成数组做完再回去</p>
<p>正常递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        ListNode* newHead = head-&gt;next;<br>        head-&gt;next = <span class="hljs-built_in">swapPairs</span>(head-&gt;next-&gt;next); <span class="hljs-comment">// 当前这个组的最后一个接到下一个状态的开头</span><br>        newHead-&gt;next = head; <span class="hljs-comment">// 用新头指向新换位置的那个</span><br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="386-字典序排数"><a class="markdownIt-Anchor" href="#386-字典序排数"></a> 386、字典序排数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>    <span class="hljs-keyword">int</span> N;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">lexicalOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        N = n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; ++i) &#123;<br>            <span class="hljs-built_in">dfs</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123; <span class="hljs-comment">//val为当前遍历的数的大小</span><br>        <span class="hljs-keyword">if</span> (val &gt; N) &#123;  <span class="hljs-comment">//结束条件</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(val);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; ++i) &#123;<br>            <span class="hljs-built_in">dfs</span>(val * <span class="hljs-number">10</span> + i);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="88-合并两个有序数组"><a class="markdownIt-Anchor" href="#88-合并两个有序数组"></a> 88、合并两个有序数组</h3>
<p>双指针空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-keyword">int</span> m, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l1 = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> l2 = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> len = m + n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (len &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1 &lt; <span class="hljs-number">0</span>) &#123;<br>                nums1[len--] = nums2[l2--];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2 &lt; <span class="hljs-number">0</span>) &#123;<br>                nums1[len--] = nums1[l1--];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[l1] &gt; nums2[l2]) &#123;<br>                nums1[len--] = nums1[l1--];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[l1] &gt; nums2[l2]) &#123;<br>                nums1[len--] = nums1[l1--];<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                nums1[len--] = nums2[l2--];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>其他的解法就简单了 只要是空间复杂度不是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>随便做</p>
<h3 id="273-整数转换英文表示"><a class="markdownIt-Anchor" href="#273-整数转换英文表示"></a> 273、整数转换英文表示</h3>
<p>分层判断，就是单纯麻烦</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">string <span class="hljs-title">onedigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        string word[] = &#123;<span class="hljs-string">&quot;One &quot;</span>,<span class="hljs-string">&quot;Two &quot;</span>,<span class="hljs-string">&quot;Three &quot;</span>,<span class="hljs-string">&quot;Four &quot;</span>,<span class="hljs-string">&quot;Five &quot;</span>,<span class="hljs-string">&quot;Six &quot;</span>,<span class="hljs-string">&quot;Seven &quot;</span>,<span class="hljs-string">&quot;Eight &quot;</span>,<span class="hljs-string">&quot;Nine &quot;</span>&#125;;<br>        <span class="hljs-keyword">return</span> word[n - <span class="hljs-number">1</span>];<br>    &#125;<br>    <br>    <span class="hljs-function">string <span class="hljs-title">twodigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">10</span>) &#123;<br>            ans += <span class="hljs-built_in">onedigit</span>(n);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">19</span>) &#123;<br>            string word[]=&#123;<span class="hljs-string">&quot;Twenty &quot;</span>,<span class="hljs-string">&quot;Thirty &quot;</span>,<span class="hljs-string">&quot;Forty &quot;</span>,<span class="hljs-string">&quot;Fifty &quot;</span>,<span class="hljs-string">&quot;Sixty &quot;</span>,<span class="hljs-string">&quot;Seventy &quot;</span>,<span class="hljs-string">&quot;Eighty &quot;</span>,<span class="hljs-string">&quot;Ninety &quot;</span>&#125;;<br>            ans += word[n / <span class="hljs-number">10</span> - <span class="hljs-number">2</span>] + <span class="hljs-built_in">onedigit</span>(n % <span class="hljs-number">10</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            string word[]=&#123;<span class="hljs-string">&quot;Ten &quot;</span>,<span class="hljs-string">&quot;Eleven &quot;</span>,<span class="hljs-string">&quot;Twelve &quot;</span>,<span class="hljs-string">&quot;Thirteen &quot;</span>,<span class="hljs-string">&quot;Fourteen &quot;</span>,<span class="hljs-string">&quot;Fifteen &quot;</span>,<span class="hljs-string">&quot;Sixteen &quot;</span>,<span class="hljs-string">&quot;Seventeen &quot;</span>,<span class="hljs-string">&quot;Eighteen &quot;</span>,<span class="hljs-string">&quot;Nineteen &quot;</span>&#125;;<br>            ans += word[n - <span class="hljs-number">10</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">threedigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">int</span> hundred = n / <span class="hljs-number">100</span>; <span class="hljs-comment">//确定百位数的值</span><br>        n %= <span class="hljs-number">100</span>; <span class="hljs-comment">// 获取个位和十位</span><br>        <span class="hljs-keyword">if</span> (hundred) &#123;<br>            ans += <span class="hljs-built_in">onedigit</span>(hundred) + <span class="hljs-string">&quot;Hundred &quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n) &#123;<br>            ans += <span class="hljs-built_in">twodigit</span>(n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">numberToWords</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Zero&quot;</span>;<br>        &#125;<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> billion = num / <span class="hljs-number">1e9</span>;<br>        num %= <span class="hljs-number">1000000000</span>;<br>        <span class="hljs-keyword">if</span> (billion) &#123;<br>            ans += <span class="hljs-built_in">threedigit</span>(billion) + <span class="hljs-string">&quot;Billion &quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> million = num / <span class="hljs-number">1e6</span>;<br>        num %= <span class="hljs-number">1000000</span>;<br>        <span class="hljs-keyword">if</span> (million) &#123;<br>            ans += <span class="hljs-built_in">threedigit</span>(million) + <span class="hljs-string">&quot;Million &quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> thousand = num / <span class="hljs-number">1e3</span>;<br>        num %= <span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">if</span> (thousand) &#123;<br>            ans += <span class="hljs-built_in">threedigit</span>(thousand) + <span class="hljs-string">&quot;Thousand &quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">//最后判断最后三位</span><br>        <span class="hljs-keyword">if</span> (num) &#123;<br>            ans += <span class="hljs-built_in">threedigit</span>(num);<br>        &#125;<br>        ans.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 去除最后的空格</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day20"><a class="markdownIt-Anchor" href="#day20"></a> Day20</h2>
<h3 id="89-格雷编码"><a class="markdownIt-Anchor" href="#89-格雷编码"></a> 89、格雷编码</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">find</span>(n - <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归处理</span><br>        <span class="hljs-keyword">int</span> last = ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 从当前状态下最后一个数开始逐个处理，</span><br>        <span class="hljs-comment">//例如n == 2 将 1 左移动（n - 1）位后与 00 相加-&gt; 01 </span><br>        <span class="hljs-comment">//1 左移动（n - 1）位后与 01 相加-&gt; 11</span><br>        <span class="hljs-comment">//两两对应</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = last; i &gt;= <span class="hljs-number">0</span>; --i) &#123; <br>            ans.<span class="hljs-built_in">push_back</span>(ans[i] + (<span class="hljs-number">1</span> &lt;&lt; (n - <span class="hljs-number">1</span>)));<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">grayCode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-built_in">find</span>(n);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="384-打乱数组"><a class="markdownIt-Anchor" href="#384-打乱数组"></a> 384、打乱数组</h3>
<p><strong>洗牌算法Knuth-Shuffle大神</strong></p>
<p>算法可简单表述为：将最后一个数和前面任意 n-1个数中的一个数进行交换（也可以不换），然后倒数第二个数和前面任意 n-2 个数中的一个数进行交换，如此往复直到最后一个元素，就完成了洗牌，该算法保证了每个元素在每个位置的概率都是相等的。</p>
<p>Prove:</p>
<p>为什么是相等的呢？可以举例说明！</p>
<p>比如12345是最初的排列，从最后一个数5开始。</p>
<p>**第一轮：**5跟12345换的概率都是相等的，比如随机出了2，因为下一轮要从倒数第二个开始了，所以2肯定就在最后一位了，现在就是15342，因为是五个数里面选一个，所以2在最后一位的概率就是1/5；</p>
<p>**第二轮：**不算最后一个数2，还剩1534，轮到4选一个，比如选了3，交换完就是1543，那么3出现在第4个位置的概率是多少呢？因为第一轮五个选一个没选中3的概率是4/5，这一轮是四个选一个，1/4，所以3在第四位的概率就是4/5 * 1/4 = 1/5；</p>
<p>**第三轮：**不算最后两个数32，还剩154，轮到4选一个，比如选了自己，交换完就还是154，那么4出现在第三个位置的概率就是，4/5（第一轮没选4）*3/4（第二轮没选4）*1/3（第三轮选了4） = 1/5；</p>
<p>以此类推，就会发现，每个元素在每个位置的概率都是1/5，真正的做到了乱！（当然这个东西可以用严谨的数学证明验证）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; arr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        arr = nums;<br>    &#125;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shuffle</span><span class="hljs-params">()</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; a = arr;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-built_in">swap</span>(a[i], a[<span class="hljs-built_in">rand</span>() % (i + <span class="hljs-number">1</span>)]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Solution object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Solution* obj = new Solution(nums);</span><br><span class="hljs-comment"> * vector&lt;int&gt; param_1 = obj-&gt;reset();</span><br><span class="hljs-comment"> * vector&lt;int&gt; param_2 = obj-&gt;shuffle();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h3 id="160-相交链表"><a class="markdownIt-Anchor" href="#160-相交链表"></a> 160、相交链表</h3>
<p>设公共部分的长度为c，两者不同部分的分别为a和b，那么结果为a+c和b+c。</p>
<p>则当双方都过a + b + c时只剩下c了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode* l1 = headA, * l2 = headB;<br>        <span class="hljs-keyword">while</span>(l1 != l2)&#123;<br>            l1 = !l1 ? headB: l1-&gt;next;<br>            l2 = !l2 ? headA: l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="62-独一无二的路径"><a class="markdownIt-Anchor" href="#62-独一无二的路径"></a> 62、独一无二的路径</h3>
<p>简单动态规划</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            dp[i] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 第一行的走法只有一种</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i) &#123; <span class="hljs-comment">// 第一行处理过了</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                dp[j] += dp[j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 将向下和向右的方法数量加在一起</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>也可以直接用数学公式求解，这是一个组合问题。机器人总共移动的次数 S=m+n-2，向下移动的次数 D=m-1，那么问题可以看成从 S 中取出 D 个位置的组合数量，这个问题的解为 C(S, D)。</p>
<p>S = m - 1 + n - 1</p>
<p>只会用java 不会c++数据结构出问题了:)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> S = m + n - <span class="hljs-number">2</span>;  <span class="hljs-comment">// 总共的移动次数</span><br>    <span class="hljs-keyword">int</span> D = m - <span class="hljs-number">1</span>;      <span class="hljs-comment">// 向下的移动次数</span><br>    <span class="hljs-keyword">long</span> ret = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= D; i++) &#123;<br>        ret = ret * (S - D + i) / i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="51-n皇后问题"><a class="markdownIt-Anchor" href="#51-n皇后问题"></a> 51、N皇后问题</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    <span class="hljs-keyword">int</span> N;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-keyword">int</span> n) &#123;<br>        vector&lt;string&gt; temp;<br>        string t = <span class="hljs-string">&quot;&quot;</span>;<br>        N = n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            t += <span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(t);<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(temp, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;string&gt;&amp; temp, <span class="hljs-keyword">int</span> row)</span> </span>&#123; <span class="hljs-comment">// row记录我们遍历到了第几行</span><br>        <span class="hljs-keyword">if</span> (row == N) &#123; <span class="hljs-comment">//完成目标</span><br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123; <span class="hljs-comment">// i是列</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">valid</span>(temp, row, i)) &#123;<br>                temp[row][i] = <span class="hljs-string">&#x27;Q&#x27;</span>; <span class="hljs-comment">// 放皇后</span><br>                <span class="hljs-built_in">dfs</span>(temp, row + <span class="hljs-number">1</span>); <span class="hljs-comment">// 去下一行弄</span><br>                temp[row][i] = <span class="hljs-string">&#x27;.&#x27;</span>; <span class="hljs-comment">// 拿走皇后</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">valid</span><span class="hljs-params">(vector&lt;string&gt;&amp; temp, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>        <span class="hljs-comment">// 检测改行上方是否有</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (temp[i][c] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//检测左上方是否有</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = r, j = c; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; --i, --j) &#123;<br>            <span class="hljs-keyword">if</span> (temp[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//检测右上方是否有</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = r, j = c; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt;= N; --i, ++j) &#123;<br>            <span class="hljs-keyword">if</span> (temp[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day21"><a class="markdownIt-Anchor" href="#day21"></a> Day21</h2>
<h3 id="912-手撕排序数组"><a class="markdownIt-Anchor" href="#912-手撕排序数组"></a> 912、手撕排序数组</h3>
<p>从此以后所有的排序任务都手撕</p>
<h4 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// quickSort</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span> <span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pivot = nums[low]; <span class="hljs-comment">// 将第一个数作为我们的标准轴</span><br>        <span class="hljs-keyword">int</span> l = low, h = high;<br>        <span class="hljs-keyword">while</span> (l &lt; h) &#123; <span class="hljs-comment">// 当左边界小于右边界我们再继续</span><br>            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; pivot &lt;= nums[h]) --h;<span class="hljs-comment">// 包含等于</span><br>            <span class="hljs-keyword">if</span> (l &lt; h) nums[l] = nums[h];<br>            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; pivot &gt;= nums[l]) ++l;<span class="hljs-comment">// 包含等于</span><br>            <span class="hljs-keyword">if</span> (l &lt; h) nums[h] = nums[l];<br>        &#125;<br>        nums[l] = pivot; <span class="hljs-comment">// 出来的时候一定是l == h 的情况</span><br>        <span class="hljs-keyword">return</span> l; <span class="hljs-comment">// 返回轴的位置</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (low &gt;= high) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> pivot = <span class="hljs-built_in">partition</span>(nums, low, high);<br>        <span class="hljs-built_in">quicksort</span>(nums, low, pivot);<br>        <span class="hljs-built_in">quicksort</span>(nums, pivot + <span class="hljs-number">1</span>, high);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">quicksort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; copy, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (low &gt;= high) &#123;  <span class="hljs-comment">//先设立推出条件</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 找到中心位置</span><br>        <span class="hljs-comment">// divide 关注一下copy和nums交换位置，因为这样可以将正确顺序的数组传入上一个状态</span><br>        <span class="hljs-built_in">mergesort</span>(copy, nums, low, mid);<br>        <span class="hljs-built_in">mergesort</span>(copy, nums, mid + <span class="hljs-number">1</span>, high);<br>        <span class="hljs-comment">// merge</span><br>        <span class="hljs-keyword">int</span> l = mid, h = high;<br>        <span class="hljs-keyword">int</span> len = high;<br>        <span class="hljs-keyword">while</span> (l &gt;= low &amp;&amp; h &gt; mid) &#123;<br>            <span class="hljs-keyword">if</span> (nums[l] &lt; nums[h]) &#123;<br>                copy[len--] = nums[h--];<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                copy[len--] = nums[l--];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (l &gt;= low) &#123;<br>            copy[len--] = nums[l--];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (h &gt; mid) &#123;<br>            copy[len--] = nums[h--];<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">copy</span><span class="hljs-params">(nums.begin(), nums.end())</span></span>;<br>        <span class="hljs-built_in">mergesort</span>(nums, copy, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 为什么copy是正确答案因为 最顶层就是把正确答案放入了copy</span><br>        <span class="hljs-keyword">return</span> copy;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">minHeap</span>&#123;</span><br>        <span class="hljs-keyword">private</span>:<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; H;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-built_in">minHeap</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>                H.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);  <span class="hljs-comment">// 把第一位空出来</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>                    H.<span class="hljs-built_in">push_back</span>(num);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 注意这里的堆排序我们用的是索引 1 ～ n 这样好计算</span><br>            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapadjust</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>                <span class="hljs-keyword">int</span> rc = H[s];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * s; j &lt;= m; j *= <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// *=2 往下找孩子</span><br>                    <span class="hljs-keyword">if</span> (j &lt; m &amp;&amp; H[j] &gt; H[j + <span class="hljs-number">1</span>]) j++; <span class="hljs-comment">// 选择大的分支走下去，因为我们是小顶堆 （因为小顶堆先输出小的数 我们只需要push_back插入就行） j &lt; m 防止 j = m 再 + 1 超界限</span><br>                    <span class="hljs-keyword">if</span> (rc &lt;= H[j]) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//（rc只要小于等于当前节点的 儿子j，我们就停下来放好那个值) 等于也算上</span><br>                    <span class="hljs-comment">//这两步为了将符合要求的小节点往上移动</span><br>                    H[s] = H[j];<br>                    s = j; <span class="hljs-comment">//s永远代表父亲节点</span><br>                &#125;<br>                H[s] = rc; <span class="hljs-comment">//再把当前处理的节点放到对应的位置</span><br>            &#125;<br>        <br>            <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">heapsort</span><span class="hljs-params">()</span> </span>&#123;<br>                vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>                <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = H.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 因为有一个第0位 所以排除掉</span><br>                <span class="hljs-comment">// 先构建出堆</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123; <span class="hljs-comment">// 1 ～ n为有效数据</span><br>                    <span class="hljs-built_in">heapadjust</span>(i, n);<br>                &#125;<br>                cout &lt;&lt; endl;<br>                <span class="hljs-comment">// 然后输出结果</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt; <span class="hljs-number">1</span>; --i) &#123;  <span class="hljs-comment">// 不需要处理第一个 因为还剩两个的时候也就是一个有效一个无效，我们已经放好了那个有效的</span><br>                    ans.<span class="hljs-built_in">push_back</span>(H[<span class="hljs-number">1</span>]);<br>                    <span class="hljs-built_in">swap</span>(H[<span class="hljs-number">1</span>], H[i]); <span class="hljs-comment">// 将大顶放到最后，这样只需要调整 i - 1 位置的就可以得到最终的结果了 这样循环就可以找到第二个大的以此类推</span><br>                    <span class="hljs-built_in">heapadjust</span>(<span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>); <span class="hljs-comment">// 新上位的在1的位置，然后只需要调整1 ～ i - 1 这样就相当于吧刚才存入的那个扔出去了</span><br>                &#125;<br>                ans.<span class="hljs-built_in">push_back</span>(H[<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br>    &#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        minHeap* H = <span class="hljs-keyword">new</span> <span class="hljs-built_in">minHeap</span>(nums);<br>        <span class="hljs-keyword">return</span> H-&gt;<span class="hljs-built_in">heapsort</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="179-最大数"><a class="markdownIt-Anchor" href="#179-最大数"></a> 179、最大数</h3>
<p>可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，应该比较的是S1+S2 和S2+S1的大小，如果S1+S2 &lt; S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。</p>
<p>注意⚠️：cmp返回值的实际意义是传入a、b两个参数，a在前b在后的排序是否是正确的，若是正确的返回1（true），否则返回0（false）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; dicts;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-keyword">static</span> <span class="hljs-title">cmp</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b &gt; b + a;  <span class="hljs-comment">// 如果ab 比 ba大的话 就说明这个排序是true的 不需要改变 当 ab 比 ba小的时候为false 那么这个排序就是不正确的 需要改变排列</span><br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">largestNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            dicts.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">to_string</span>(num));<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(dicts.<span class="hljs-built_in">begin</span>(), dicts.<span class="hljs-built_in">end</span>(), cmp);<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> dict : dicts) &#123;<br>            ans += dict;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dicts[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;0&quot;</span> ? dicts[<span class="hljs-number">0</span>] : ans; <span class="hljs-comment">// 这个判断为了防止出现00的情况</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day22"><a class="markdownIt-Anchor" href="#day22"></a> Day22</h2>
<h3 id="123-买卖股票的最佳时机三"><a class="markdownIt-Anchor" href="#123-买卖股票的最佳时机三"></a> 123、买卖股票的最佳时机三</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-comment">// 用两个数组保存两个状态 </span><br>        <span class="hljs-comment">// buy数组 ： 如果当前是买的情况下这个最好结果是什么（注意买的时候需要将之前的所有股票清空）</span><br>        <span class="hljs-comment">// sell数组 ： 如果当前是卖的情况下这个最好结果是什么</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">buy</span><span class="hljs-params">(<span class="hljs-number">3</span>, INT_MIN)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sell</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> price : prices) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span>; ++i) &#123; <span class="hljs-comment">// 遍历不大于两次的买卖的情况</span><br>                buy[i] = <span class="hljs-built_in">max</span>(buy[i], sell[i - <span class="hljs-number">1</span>] - price);  <span class="hljs-comment">// 因为是负数 所以我们让他价格绝对值最小 也就是去最大值</span><br>                sell[i] = <span class="hljs-built_in">max</span>(sell[i], buy[i] + price);  <span class="hljs-comment">// 这个也就是我们当前最好的利润</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sell[<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="40-组合总和2"><a class="markdownIt-Anchor" href="#40-组合总和2"></a> 40、组合总和2</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; ans;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; can;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">101</span>, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">int</span> tar; <span class="hljs-comment">// 记录目标值</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; candidates, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        can = candidates;<br>        tar = target;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (t &gt; tar) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 加出界了就不算了</span><br>        <span class="hljs-keyword">if</span> (t == tar) &#123;  <span class="hljs-comment">// 当数值够了 就存一波</span><br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = s; i &lt; can.<span class="hljs-built_in">size</span>(); ++i) &#123; <span class="hljs-comment">// 设置s因为我们没必要往回去找，往回找那是全排列</span><br>            <span class="hljs-keyword">if</span> (!vis[i]) &#123;<br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; !vis[i - <span class="hljs-number">1</span>] &amp;&amp; can[i] == can[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 当前这个的前一个我们未处理，但是却相等。等于是开始的东西是相同的，所以我们就没必要计算了</span><br>                vis[i] = <span class="hljs-literal">true</span>;<br>                temp.<span class="hljs-built_in">push_back</span>(can[i]);<br>                <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, t + can[i]);<br>                temp.<span class="hljs-built_in">pop_back</span>();<br>                vis[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="392-字符串解码"><a class="markdownIt-Anchor" href="#392-字符串解码"></a> 392、字符串解码</h3>
<p>双栈解法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; sn; <span class="hljs-comment">// 记录重复次数的</span><br>    stack&lt;string&gt; sc; <span class="hljs-comment">// 记录内容的 PS：栈底一直是最初的状态</span><br>    string tn = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 记录所需要的值</span><br>    string ans = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 记录内容</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;  <span class="hljs-comment">//只要是数字就统计一波</span><br>                tn += c;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                sn.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(tn));  <span class="hljs-comment">// 存储一波次数状态</span><br>                sc.<span class="hljs-built_in">push</span>(ans); <span class="hljs-comment">// 存储一波数字状态</span><br>                <span class="hljs-comment">// 状态清空</span><br>                tn = <span class="hljs-string">&quot;&quot;</span>;<br>                ans = <span class="hljs-string">&quot;&quot;</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>                string con = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 用来更新现在的结果</span><br>                <span class="hljs-comment">// 获取状态字需要输出的次数</span><br>                <span class="hljs-keyword">int</span> num = sn.<span class="hljs-built_in">top</span>();<br>                sn.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">// 按照括号内容以及次数制作结果</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i) &#123;<br>                    con += ans;<br>                &#125;<br>                <span class="hljs-comment">// 这里这么处理的话，只要是最后一个]遇到之后一定会吧栈底的那个答案提取出来并拼接</span><br>                ans = sc.<span class="hljs-built_in">top</span>() + con;  <span class="hljs-comment">// 与上一个状态进行拼接，更新答案【如果是嵌套ing，那就是更新当前嵌套的内容，如果里面是空的，那就是单纯的更新答案】</span><br>                sc.<span class="hljs-built_in">pop</span>();<br>            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 如果是内容</span><br>                ans += c;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>DFS递归解法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    string S;<br>    <span class="hljs-function">string <span class="hljs-title">decode</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; i)</span> </span>&#123; <span class="hljs-comment">// 这里必须是引用需要把整个值传递下去</span><br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; S.<span class="hljs-built_in">size</span>() &amp;&amp; S[i] != <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;a&#x27;</span> &lt;= S[i] &amp;&amp; S[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) &#123;<br>                res += S[i++];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;0&#x27;</span> &lt;= S[i] &amp;&amp; S[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                <span class="hljs-keyword">int</span> freq = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录需要循环的次数</span><br>                <span class="hljs-keyword">while</span> (<span class="hljs-string">&#x27;0&#x27;</span> &lt;= S[i] &amp;&amp; S[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                    freq = freq * <span class="hljs-number">10</span> + S[i++] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                &#125;<br>                <span class="hljs-comment">// 数字后面必定是 &#x27;[&#x27;</span><br>                i++; <span class="hljs-comment">// 所以这里需要往下走一个</span><br>                string t = <span class="hljs-built_in">decode</span>(i);<br>                i++; <span class="hljs-comment">//出来的时候一定是不满足（i &lt; S.size() &amp;&amp; S[i] != &#x27;]&#x27;）所以这里再往下一个</span><br>                <span class="hljs-keyword">while</span> (freq--) &#123; <span class="hljs-comment">// 给当前状态的结果处理好</span><br>                    res += t;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        S = s;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">decode</span>(i);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day23"><a class="markdownIt-Anchor" href="#day23"></a> Day23</h2>
<h3 id="907-子数组最小值之和"><a class="markdownIt-Anchor" href="#907-子数组最小值之和"></a> 907、子数组最小值之和</h3>
<p>dp解法</p>
<p>我们其实关心的是以某个数字结尾时的子数组最小值之和，可以用一个一维数组 dp，其中 dp[i] 表示以数字 arr[i] 结尾的所有子数组最小值之和，将 dp[0] 初始化为 arr[0]，结果 res 也初始化为 arr[0]。然后从第二个数字开始遍历，若大于等于前一个数字，则当前 dp[i] 赋值为 dp[i-1]+arr[i]，前面的分析已经解释了，当前数字 arr[i] 组成了新的子数组，同时由于 arr[i] 不会影响最小值，所以要把之前的最小值之和再加一遍。假如小于前一个数字，就需要向前遍历，去找到第一个小于 arr[i] 的位置j，假如j小于0，表示前面所有的数字都是小于 arr[i] 的，那么 arr[i] 是前面 i+1 个以 arr[i] 结尾的子数组的最小值，累加和为 (i+1) x arr[i]，若j大于等于0，则需要分成两部分累加，dp[j] + (i-j)xA[i]，这个也不难理解，前面有 i-j 个以 arr[i] 为结尾的子数组的最小值是 arr[i]，而再前面的子数组的最小值就不是 arr[i] 了，但是还是需要加上一遍其本身的最小值之和，因为每个子数组末尾都加上 arr[i] 均可以组成一个新的子数组，最终的结果 res 就是将 dp 数组累加起来即可，别忘了对超大数取余，参见代码如下（现在这种方法已经超时 TLE 了）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumSubarrayMins</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> res = arr[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 先得把第一个算上</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">dp</span>(n);<br>        dp[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &gt;= arr[i - <span class="hljs-number">1</span>]) dp[i] = dp[i - <span class="hljs-number">1</span>] + arr[i];<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[i] &lt; arr[j]) &#123;  <span class="hljs-comment">//向左扫描找到第一个a[j] &lt;= a[i]</span><br>                    j--;<br>                &#125;<br>                <span class="hljs-comment">// 如果j小于0 说明所有的都比i大 所有的最小值都是arr[i] 包括一个 arr[i]自身的子集</span><br>                dp[i] = (j &lt; <span class="hljs-number">0</span>) ? (i + <span class="hljs-number">1</span>) * arr[i] : (dp[j] + (i - j) * arr[i]);<br>            &#125;<br>            res = (res + dp[i]) % M; <span class="hljs-comment">// 每次算出当前结果记录一波</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>上面的方法虽然 work，但不是很高效，原因是在向前找第一个小于当前的数字，每次都要线性遍历一遍，造成了平方级的时间复杂度。而<strong>找每个数字的前小数字或是后小数字，正是单调栈擅长</strong>的，可以参考博主之前的总结贴 <a target="_blank" rel="noopener" href="http://www.cnblogs.com/grandyang/p/8887985.html">LeetCode Monotonous Stack Summary 单调栈小结</a>。这里我们用一个单调栈来保存之前一个小的数字的位置，栈里先提前放一个 -1，作用会在之后讲解。还是需要一个 dp 数组，跟上面的定义基本一样，但是为了避免数组越界，将长度初始化为 n+1，其中 dp[i] 表示以数字 arr[i-1] 结尾的所有子数组最小值之和。对数组进行遍历，当栈顶元素不是 -1 且 arr[i] 小于等于栈顶元素，则将栈顶元素移除。这样栈顶元素就是前面第一个比 arr[i] 小的数字，此时 dp[i+1] 更新还是跟之前一样，分为两个部分，由于知道了前面第一个小于 arr[i] 的数字位置，用当前位置减去栈顶元素位置再乘以 arr[i]，就是以 arr[i] 为结尾且最小值为 arr[i] 的子数组的最小值之和，而栈顶元素之前的子数组就不受 arr[i] 影响了，直接将其 dp 值加上即可。将当前位置压入栈，并将 dp[i+1] 累加到结果 res，同时对超大值取余，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumSubarrayMins</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; st&#123;&#123;<span class="hljs-number">-1</span>&#125;&#125;;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;  <span class="hljs-comment">// dp[0] 就是单独的一个</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (st.<span class="hljs-built_in">top</span>() != <span class="hljs-number">-1</span> &amp;&amp; arr[i] &lt;= arr[st.<span class="hljs-built_in">top</span>()]) &#123;  <span class="hljs-comment">// 为栈保留一个-1 用于找dp[0] 如果还有别的那就是当前最小值的下标 或者是</span><br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-comment">// st.top() + 1 就是存的当前比你小的 【这个太妙了 这里如果是i - 1 那么变成了 dp[i] + arr[i]】</span><br>            dp[i + <span class="hljs-number">1</span>] = (dp[st.<span class="hljs-built_in">top</span>() + <span class="hljs-number">1</span>] + (i - st.<span class="hljs-built_in">top</span>()) * arr[i]) % M;<br>            st.<span class="hljs-built_in">push</span>(i);<br>            res = (res + dp[i + <span class="hljs-number">1</span>]) % M;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="322-零钱兑换"><a class="markdownIt-Anchor" href="#322-零钱兑换"></a> 322、零钱兑换</h3>
<p>完全背包</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 防止出现amount == 0的边界条件</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> coin : coins) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = coin; j &lt;= amount; ++j) &#123; <span class="hljs-comment">// 因为是完全背包，所以这里是正序的</span><br>                <span class="hljs-keyword">if</span> (j == coin) &#123; <span class="hljs-comment">// 这个时候只能装下这个同样大小的硬币是最小值</span><br>                    dp[j] = <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[j] == <span class="hljs-number">0</span> &amp;&amp; dp[j - coin] != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 说明当前这个大小的包没有被正好放下（包括不是正好可以放下一枚硬币）此时放下这颗硬币正好放下</span><br>                    <span class="hljs-comment">//dp[j - coin] != 0 代表我之前已经装过硬币了，不会出现硬币放入后不能满足最终结果的情况比如[2] 3 是非法的</span><br>                    <span class="hljs-comment">// 这句话是为了确保我们是按照装满进行的操作 但是因为dp[j] == 0 所以没处理过 用min的话那结果一致是0了 就错了</span><br>                    dp[j] = dp[j - coin] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[j - coin] != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 说明至少放了一种硬币</span><br>                    dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - coin] + <span class="hljs-number">1</span>);  <br>                &#125; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="96-不同的二叉搜索树"><a class="markdownIt-Anchor" href="#96-不同的二叉搜索树"></a> 96、不同的二叉搜索树</h3>
<p>直接卡特兰数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup><mo>−</mo><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mfrac><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">C^n_{2n} - C^{n + 1}_{2n} = \frac{C^n_{2n}}{n + 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.931438em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.120547em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.430511em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.02718em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5102em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7385428571428572em;"><span style="top:-2.214em;margin-left:-0.07153em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n + <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; ++i) &#123;<br>            res = res * i / (i - n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res / (n + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205201118746.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-20 上午11.18.32" /></p>
<p>至于这里为什么是左子树乘以右子树是因为这是全排列问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                dp[i] += dp[j] * dp[i - j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day24"><a class="markdownIt-Anchor" href="#day24"></a> Day24</h2>
<h3 id="198-打家劫舍"><a class="markdownIt-Anchor" href="#198-打家劫舍"></a> 198、打家劫舍</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;  <span class="hljs-comment">// 存储到第n个的最大值</span><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]); <span class="hljs-comment">// 其实就是选和不选当前的两个状态</span><br>            <span class="hljs-comment">// 只不过当我们选的时候一定是上上个状态的最大值 + 当前这个</span><br>            <span class="hljs-comment">// 如果不选的话 那我们可以选择上一个状态的最大值，因为我不选所以我可以贴着</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day25"><a class="markdownIt-Anchor" href="#day25"></a> Day25</h2>
<h3 id="143-重排链表"><a class="markdownIt-Anchor" href="#143-重排链表"></a> 143、重排链表</h3>
<p>利用多余空间完成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; temp; <span class="hljs-comment">// 用数组转换一下</span><br>        ListNode* node = head-&gt;next;<br>        <span class="hljs-keyword">while</span> (node) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            node = node-&gt;next;<br>        &#125;<br>        ListNode* newLink = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = temp.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res; <span class="hljs-comment">// 这里存储最后的结果</span><br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp[r--]);<br>            res.<span class="hljs-built_in">push_back</span>(temp[l++]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l == r) res.<span class="hljs-built_in">push_back</span>(temp[l]);<br>        ListNode* tail = newLink;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> r : res) &#123;<br>            ListNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(r);<br>            tail-&gt;next = newNode;<br>            tail = newNode;<br>        &#125;<br>        head-&gt;next = newLink-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221040826.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 上午10.40.38" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 非递归版本</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseNo</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span> (head) &#123;<br>            ListNode* next = head-&gt;next;<br>            head-&gt;next = dummy;<br>            dummy = head;<br>            head = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy;<br>    &#125;<br>    <span class="hljs-comment">// 递归版本</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        ListNode* nextNode = head-&gt;next;<br>        ListNode* newHead = <span class="hljs-built_in">reverse</span>(head-&gt;next); <span class="hljs-comment">// 去获取新头</span><br>        nextNode-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// head 就是当前节点</span><br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>    <span class="hljs-comment">// 1 2</span><br>    <span class="hljs-comment">// 1 2 4 5 6</span><br>    <span class="hljs-comment">// 6 5 4</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123; <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 存一下状态</span><br>            ListNode* l1next = l1-&gt;next;<br>            ListNode* l2next = l2-&gt;next;<br>            l1-&gt;next = l2;<br>            <span class="hljs-keyword">if</span> (!l1next) &#123;  <span class="hljs-comment">// 如果空了就结束 后面也不用操作了</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            l2-&gt;next = l1next;<br>            l1 = l1next;<br>            l2 = l2next;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span>;<br>        ListNode* slow = head, * fast = head, * pre;<br>        <span class="hljs-comment">// 找中点分裂两者</span><br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>            pre = slow;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        pre-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//此时 slow是下一组节点的头 如果是奇数个的话后面更多 前面少</span><br>        <span class="hljs-comment">// l1 为head l2 为slow 反转l2</span><br>        ListNode* l2 = <span class="hljs-built_in">reverse</span>(slow);<br>        <span class="hljs-comment">// 合并</span><br>        <span class="hljs-built_in">merge</span>(head, l2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="109-有序链表转换二叉搜索树"><a class="markdownIt-Anchor" href="#109-有序链表转换二叉搜索树"></a> 109、有序链表转换二叉搜索树</h3>
<p>这道题的关键在于找到根节点的位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (!head-&gt;next)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(head-&gt;val);<br>        ListNode* pre = <span class="hljs-built_in">getRoot</span>(head), * cur = pre-&gt;next; <span class="hljs-comment">// 获得中间节点就是根</span><br>        pre-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 分开左边和右边 // 左头为head 右头为cur-&gt;next</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(cur-&gt;val);<br>        root-&gt;left = <span class="hljs-built_in">sortedListToBST</span>(head);<br>        root-&gt;right = <span class="hljs-built_in">sortedListToBST</span>(cur-&gt;next);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-comment">// 获得中间节点的</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">getRoot</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* slow = head, * fast = head, * pre;<br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>            pre = slow;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="1233-删除子文件夹"><a class="markdownIt-Anchor" href="#1233-删除子文件夹"></a> 1233、删除子文件夹</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span>&#123;</span><br>        <span class="hljs-keyword">private</span>:<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span> &#123;</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span>* <span class="hljs-title">branch</span>[26];</span> <span class="hljs-comment">// 每一个节点有26个分支</span><br>                <span class="hljs-keyword">bool</span> isleaf; <span class="hljs-comment">//是否是叶子</span><br>            &#125;* root;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-built_in">Trie</span>() &#123;<br>                root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>(); <span class="hljs-comment">// 作为每次处理的起点</span><br>            &#125;<br>            <span class="hljs-comment">// [&quot;/a/b/c&quot;,&quot;/a/b/ca&quot;,&quot;/a/b/d&quot;]</span><br>            <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">insert</span><span class="hljs-params">(string s)</span> </span>&#123;  <span class="hljs-comment">// 这里是将插入和判断是否是前缀联系在一起了</span><br>                TrieNode* node = root;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                    <span class="hljs-keyword">char</span> c = s[i];<br>                    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-keyword">if</span> (!node-&gt;branch[c - <span class="hljs-string">&#x27;a&#x27;</span>]) &#123; <span class="hljs-comment">// 如果这个路径上字符没有遇到过</span><br>                        node-&gt;branch[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>                    &#125;<br>                    node = node-&gt;branch[c - <span class="hljs-string">&#x27;a&#x27;</span>];  <span class="hljs-comment">// 走入到下一层</span><br>                    <span class="hljs-keyword">if</span> (s[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;/&#x27;</span> &amp;&amp; node-&gt;isleaf) &#123; <span class="hljs-comment">// 说明了还有 并且 已经到了之前的子串的结尾了 已经找到了当前情况的子串【只有下一个是‘/’且没有比完的时候才有意义】</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>                node-&gt;isleaf = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 成功插入了</span><br>            &#125;<br>    &#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">removeSubfolders</span><span class="hljs-params">(vector&lt;string&gt;&amp; folder)</span> </span>&#123;<br>        Trie* trie = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>        <span class="hljs-built_in">sort</span>(folder.<span class="hljs-built_in">begin</span>(), folder.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 排序为了让小的短的 在前</span><br>        vector&lt;string&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> f : folder) &#123;<br>            <span class="hljs-keyword">if</span> (trie-&gt;<span class="hljs-built_in">insert</span>(f)) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(f);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221409758.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午2.08.57" /></p>
<p>sort的意义</p>
<h2 id="day26"><a class="markdownIt-Anchor" href="#day26"></a> Day26</h2>
<h3 id="139-单词拆分"><a class="markdownIt-Anchor" href="#139-单词拆分"></a> 139、单词拆分</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// dp：前 n 个字符是否可以正确拆分</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 0 作为初始态为true</span><br>        <span class="hljs-comment">// 这里相当于不要求顺序的完全背包</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;  <span class="hljs-comment">// 这里能从1开始也是凑巧了索引</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> word : wordDict) &#123;<br>                <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> wn = word.<span class="hljs-built_in">size</span>();<br>                <span class="hljs-keyword">if</span> (i &gt;= wn &amp;&amp; word == s.<span class="hljs-built_in">substr</span>(i - wn, wn)) &#123; <span class="hljs-comment">// 这里本来是i - len + 1 但是从1 开始遍历就不需要了</span><br>                    dp[i] = dp[i] || dp[i - wn]; <span class="hljs-comment">// dp[i - wn] 代表看看他上一个状态行么 ，不行也拉倒， 能行就连续起来，所以用或来记录状态</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="402-移掉k位数字"><a class="markdownIt-Anchor" href="#402-移掉k位数字"></a> 402、移掉K位数字</h3>
<p>单调栈</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeKdigits</span><span class="hljs-params">(string num, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = num.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n &lt;= k) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>; <span class="hljs-comment">// 都消除没了也没法玩了</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> num; <span class="hljs-comment">// 不处理</span><br>        stack&lt;<span class="hljs-keyword">char</span>&gt; st;<br>        st.<span class="hljs-built_in">push</span>(num[<span class="hljs-number">0</span>]);<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; !st.<span class="hljs-built_in">empty</span>() &amp;&amp; num[i] &lt; st.<span class="hljs-built_in">top</span>()) &#123; <span class="hljs-comment">// 首先不空才能退栈 只要比我小 那我就推出前面的</span><br>                k--;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!(st.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> &amp;&amp; num[i] == <span class="hljs-string">&#x27;0&#x27;</span>)) <span class="hljs-comment">// 只要不是0开头咱们就放</span><br>                st.<span class="hljs-built_in">push</span>(num[i]);<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span> (k &amp;&amp; !st.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 没有完成k的指标, 但是还有东西可以退栈 因为栈越往下越是小的 所以从末尾退栈就对了</span><br>            k--;<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 开始处理结果</span><br>            ans += st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 因为是栈 所以我们要反转</span><br>        <span class="hljs-keyword">return</span> ans == <span class="hljs-string">&quot;&quot;</span> ? <span class="hljs-string">&quot;0&quot;</span> : ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="166-分数到小数好题"><a class="markdownIt-Anchor" href="#166-分数到小数好题"></a> 166、分数到小数【好题】</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">fractionToDecimal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numerator, <span class="hljs-keyword">int</span> denominator)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (numerator == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>; <span class="hljs-comment">// 被除数为0那么则结果为0</span><br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        ans += (numerator &gt; <span class="hljs-number">0</span>) ^ (denominator &gt; <span class="hljs-number">0</span>) ? <span class="hljs-string">&quot;-&quot;</span> : <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 判断是不是负数</span><br>        <span class="hljs-keyword">long</span> n1 = <span class="hljs-built_in">abs</span>((<span class="hljs-keyword">long</span>) numerator);<br>        <span class="hljs-keyword">long</span> n2 = <span class="hljs-built_in">abs</span>((<span class="hljs-keyword">long</span>) denominator);<br>        ans += <span class="hljs-built_in">to_string</span>(n1 / n2);<br>        n1 %= n2;<br>        <span class="hljs-keyword">if</span> (!n1) &#123; <span class="hljs-comment">// 说明没有小数</span><br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-comment">// 一下都是处理小数部分</span><br>        ans += <span class="hljs-string">&quot;.&quot;</span>; <span class="hljs-comment">// 先添加标点符号</span><br>        <span class="hljs-comment">// 用一个map就可以记录是否出现过 记录值和对应下标</span><br>        unordered_map&lt;<span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>&gt; m; <span class="hljs-comment">// 他一直记录和判断是的余数是否出现了一样的，如果出现了相同的余数那么一定会出现循环计算</span><br>        <span class="hljs-comment">// 目前n1存储的就是小数部分该处理的</span><br>        <span class="hljs-keyword">long</span> n = n1;<br>        <span class="hljs-keyword">while</span> (n) &#123; <span class="hljs-comment">// 只要没法除尽</span><br>            cout &lt;&lt; m[n] &lt;&lt; endl;<br>            <span class="hljs-keyword">if</span> (m[n]) &#123; <span class="hljs-comment">// 说明出现了重复</span><br>                ans.<span class="hljs-built_in">insert</span>(m[n], <span class="hljs-string">&quot;(&quot;</span>);<br>                ans += <span class="hljs-string">&#x27;)&#x27;</span>;<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//说明没有初始化过 也就是我们没动过 这个完全模拟了小数求解方法</span><br>                m[n] = ans.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 记录一下当前状态的位置</span><br>                n *= <span class="hljs-number">10</span>; <span class="hljs-comment">// 小数部分肯定是借位计算</span><br>                ans += <span class="hljs-built_in">to_string</span>(n / n2); <span class="hljs-comment">// 更新一下答案[如果当前这个数除不了需要补零然后接着计算]</span><br>                n %= n2; <span class="hljs-comment">// 取余数更新结果</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day27"><a class="markdownIt-Anchor" href="#day27"></a> Day27</h2>
<h3 id="31-下一个排列"><a class="markdownIt-Anchor" href="#31-下一个排列"></a> 31、下一个排列</h3>
<p>嘻嘻 这里我学到一种全排列的新思路</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; num) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        <span class="hljs-built_in">permuteDFS</span>(num, <span class="hljs-number">0</span>, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">permuteDFS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; num, <span class="hljs-keyword">int</span> start, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (start &gt;= num.<span class="hljs-built_in">size</span>()) res.<span class="hljs-built_in">push_back</span>(num);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; num.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-built_in">swap</span>(num[start], num[i]);<br>            <span class="hljs-built_in">permuteDFS</span>(num, start + <span class="hljs-number">1</span>, res);<br>            <span class="hljs-built_in">swap</span>(num[start], num[i]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>言归正传我们做这个道题</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205241113543.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-24 上午11.13.24" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &lt; nums[i]) &#123; <span class="hljs-comment">// 如果找到了第一个不是递增序列的断点(nums[i - 1])</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>; j &gt; i - <span class="hljs-number">1</span>; --j) &#123; <span class="hljs-comment">// 再次遍历找到第一个比断点大的数</span><br>                    <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &lt; nums[j]) &#123;  <span class="hljs-comment">// 找到了</span><br>                        <span class="hljs-built_in">swap</span>(nums[i - <span class="hljs-number">1</span>], nums[j]);<br>                        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + i, nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 把交换完断点之后的部分进行反转就对了</span><br>                        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 不要再处理了 退出</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果是 3 2 1 也就是最后一种情况 反转全部进行初始化就对了</span><br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>注意如果是要找上一个排序的话</p>
<p>只需要将两个 &lt; 变成 &gt; 就可以了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &gt; nums[i]) &#123; <span class="hljs-comment">// 如果找到了第一个不是递增序列的断点(nums[i - 1])</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>; j &gt; i - <span class="hljs-number">1</span>; --j) &#123; <span class="hljs-comment">// 再次遍历找到第一个比断点大的数</span><br>                    <span class="hljs-keyword">if</span> (nums[i - <span class="hljs-number">1</span>] &gt; nums[j]) &#123;  <span class="hljs-comment">// 找到了</span><br>                        <span class="hljs-built_in">swap</span>(nums[i - <span class="hljs-number">1</span>], nums[j]);<br>                        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + i, nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 把交换完断点之后的部分进行反转就对了</span><br>                        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 不要再处理了 退出</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果是 1 2 3 也就是最后一种情况 反转全部进行初始化就对了</span><br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="155-最小栈"><a class="markdownIt-Anchor" href="#155-最小栈"></a> 155、最小栈</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; st;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; mst;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        st.<span class="hljs-built_in">push</span>(val);<br>        <span class="hljs-keyword">int</span> mini = mst.<span class="hljs-built_in">empty</span>() ? INT_MAX : mst.<span class="hljs-built_in">top</span>();<br>        mst.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">min</span>(val, mini));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        st.<span class="hljs-built_in">pop</span>();<br>        mst.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mst.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack* obj = new MinStack();</span><br><span class="hljs-comment"> * obj-&gt;push(val);</span><br><span class="hljs-comment"> * obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * int param_4 = obj-&gt;getMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h3 id="974-和可被k整除的子数组"><a class="markdownIt-Anchor" href="#974-和可被k整除的子数组"></a> 974、和可被K整除的子数组</h3>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205241211840.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-24 下午12.11.46" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraysDivByK</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;; <br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            sum = (sum + (num % k) + k) % k; <span class="hljs-comment">// +k 不会影响到正余数</span><br>            ans += m[sum];<br>            m[sum]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>单独准备前缀和数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraysDivByK</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m&#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; S;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录结果</span><br>        <span class="hljs-keyword">int</span> stemp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            stemp += num;<br>            S.<span class="hljs-built_in">push_back</span>(stemp);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">int</span> mod = (S[i] % k + k) % k;  <span class="hljs-comment">// 这里加k不会影响余数的结果 但是负余数会变正</span><br>            <span class="hljs-comment">// -2 和 2 % 6是不一样的 但是 -2 和 4 % 6 结果是一样的可能定理是这样的吧</span><br>            ans += m[mod];<br>            m[mod]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="560-子数组和为k上一道题的原型题复习一下"><a class="markdownIt-Anchor" href="#560-子数组和为k上一道题的原型题复习一下"></a> 560、子数组和为K【上一道题的原型题，复习一下】</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m; <span class="hljs-comment">// 记录一下是否出现过该和</span><br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录前缀和</span><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        m[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">//这里也是为了让正好sum == k的时候有结果</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            sum += num;<br>            <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">count</span>(sum - k)) &#123; <span class="hljs-comment">// 当前的sum - k 的值 前缀和出现过说明可以构造出和为k的子序列</span><br>                ans += m[sum - k];<br>            &#125;<br>            m[sum]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day28"><a class="markdownIt-Anchor" href="#day28"></a> Day28</h2>
<h3 id="10-正则表达式匹配"><a class="markdownIt-Anchor" href="#10-正则表达式匹配"></a> 10、正则表达式匹配</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> m = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = p.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt; &gt; <span class="hljs-built_in">f</span>(m + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">bool</span>&gt;(n + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 非空的数列和空的正则一定不匹配</span><br>                    f[i][j] = (i == <span class="hljs-number">0</span>); <span class="hljs-comment">// 只有0 0空串才匹配</span><br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (s[i - <span class="hljs-number">1</span>] == p[j - <span class="hljs-number">1</span>] || p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>)) &#123; <span class="hljs-comment">// 当前如果一样 直接找上一个状态</span><br>                    f[i][j] = f[i][j] || f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p[j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>                    <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">1</span>)&#123;<br>                        <span class="hljs-comment">// 两种情况 </span><br>                        <span class="hljs-comment">// situation 1: * 代表消除当前这个字符</span><br>                        <span class="hljs-comment">// 只有这种情况可以让判断 s为空的情况</span><br>                        f[i][j] = f[i][j] || f[i][j - <span class="hljs-number">2</span>];<br>                        <span class="hljs-comment">// situation 2: * 代表复制 p[j - 2]</span><br>                        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; (s[i - <span class="hljs-number">1</span>] == p[j - <span class="hljs-number">2</span>] || p[j - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;.&#x27;</span>)) &#123; <span class="hljs-comment">// 如果那个字符为&#x27;.&#x27; 说明当前没问题 可以传递上一状态 或者是直接对比</span><br>                            f[i][j] = f[i][j] || f[i - <span class="hljs-number">1</span>][j]; <span class="hljs-comment">// 因为 f[i - 1][j] 相当于上一个字符的状态</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="252-会议室"><a class="markdownIt-Anchor" href="#252-会议室"></a> 252、会议室</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition of Interval:</span><br><span class="hljs-comment"> * class Interval &#123;</span><br><span class="hljs-comment"> * public:</span><br><span class="hljs-comment"> *     int start, end;</span><br><span class="hljs-comment"> *     Interval(int start, int end) &#123;</span><br><span class="hljs-comment"> *         this-&gt;start = start;</span><br><span class="hljs-comment"> *         this-&gt;end = end;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @param intervals: an array of meeting time intervals</span><br><span class="hljs-comment">     * @return: if a person could attend all meetings</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(Interval a, Interval b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a.start &lt; b.start;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canAttendMeetings</span><span class="hljs-params">(vector&lt;Interval&gt; &amp;intervals)</span> </span>&#123;<br>        <span class="hljs-comment">// Write your code here</span><br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (intervals[i - <span class="hljs-number">1</span>].end &gt; intervals[i].start) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="43-字符串相乘"><a class="markdownIt-Anchor" href="#43-字符串相乘"></a> 43、字符串相乘</h3>
<p>如果自己再写些例子出来，不难发现，两数相乘得到的乘积的长度其实其实不会超过两个数字的长度之和，若 num1 长度为m，num2 长度为n，则 num1 x num2 的长度不会超过 m+n，还有就是要明白乘的时候为什么要错位，比如6乘8得到的 48 为啥要跟6乘9得到的 54 错位相加，因为8是十位上的数字，其本身相当于80，所以错开的一位实际上末尾需要补的0。还有一点需要观察出来的就是，num1 和 num2 中任意位置的两个数字相乘，得到的两位数在最终结果中的位置是确定的，比如 num1 中位置为i的数字乘以 num2 中位置为j的数字，那么得到的两位数字的位置为 i+j 和 i+j+1，明白了这些后，就可以进行错位相加了，累加出最终的结果。</p>
<p>由于要从个位上开始相乘，所以从 num1 和 num2 字符串的尾部开始往前遍历，分别提取出对应位置上的字符，将其转为整型后相乘。然后确定相乘后的两位数所在的位置 p1 和 p2，由于 p2 相较于 p1 是低位，所以将得到的两位数 mul 先加到 p2 位置上去，这样可能会导致 p2 位上的数字大于9，所以将十位上的数字要加到高位 p1 上去，只将余数留在 p2 位置，这样每个位上的数字都变成一位。然后要做的是从高位开始，将数字存入结果 res 中，记住 leading zeros 要跳过，最后处理下 corner case，即若结果 res 为空，则返回 “0”，否则返回结果 res，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">multiply</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> m = num1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = num2.<span class="hljs-built_in">size</span>();<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(m + n)</span></span>; <span class="hljs-comment">// 用来存数字</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-keyword">int</span> p1 = i + j; <span class="hljs-comment">// 高位</span><br>                <span class="hljs-keyword">int</span> p2 = i + j + <span class="hljs-number">1</span>; <span class="hljs-comment">//低位</span><br>                <span class="hljs-keyword">int</span> val = (num1[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * (num2[j] - <span class="hljs-string">&#x27;0&#x27;</span>) + res[p2];<br>                res[p1] += val / <span class="hljs-number">10</span>; <span class="hljs-comment">// 因为可能出现过计算</span><br>                res[p2] = val % <span class="hljs-number">10</span>; <span class="hljs-comment">// 因为val是用res[p2]为底计算的所以没问题</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> r : res) &#123;<br>            <span class="hljs-keyword">if</span> (!ans.<span class="hljs-built_in">empty</span>() || r != <span class="hljs-number">0</span>) ans += (r + <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.<span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;0&quot;</span> : ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day29"><a class="markdownIt-Anchor" href="#day29"></a> Day29</h2>
<h3 id="295-数据流的中位数"><a class="markdownIt-Anchor" href="#295-数据流的中位数"></a> 295、数据流的中位数</h3>
<p>类似于烫手的山芋，左右倒。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> &#123;</span><br><span class="hljs-comment">// 使用两个堆，左边为最大堆，右边为最小堆</span><br><span class="hljs-keyword">private</span>:<br>    priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; right; <span class="hljs-comment">// 小顶堆</span><br>    priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, less&lt;<span class="hljs-keyword">int</span>&gt; &gt; left; <span class="hljs-comment">// 大顶堆</span><br>    <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MedianFinder</span>() &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 先放到右边在 吧右边最小的给放到左边</span><br>            right.<span class="hljs-built_in">push</span>(num);<br>            left.<span class="hljs-built_in">push</span>(right.<span class="hljs-built_in">top</span>());<br>            right.<span class="hljs-built_in">pop</span>();<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            left.<span class="hljs-built_in">push</span>(num);<br>            right.<span class="hljs-built_in">push</span>(left.<span class="hljs-built_in">top</span>());<br>            left.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        n++;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)((left.<span class="hljs-built_in">top</span>() + right.<span class="hljs-built_in">top</span>()) / <span class="hljs-number">2.0</span>);<br>        &#125;<span class="hljs-keyword">else</span> <br>            <span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword">double</span>)left.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MedianFinder* obj = new MedianFinder();</span><br><span class="hljs-comment"> * obj-&gt;addNum(num);</span><br><span class="hljs-comment"> * double param_2 = obj-&gt;findMedian();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h3 id="718-最长重复数组"><a class="markdownIt-Anchor" href="#718-最长重复数组"></a> 718、最长重复数组</h3>
<p>动态规划的解法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = nums1.<span class="hljs-built_in">size</span>(), m = nums2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(m + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">int</span> ans = INT_MIN;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums1[i - <span class="hljs-number">1</span>] == nums2[j - <span class="hljs-number">1</span>]) &#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                    ans = <span class="hljs-built_in">max</span>(dp[i][j], ans);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == INT_MIN ? <span class="hljs-number">0</span> : ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>滑动窗口的解法</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205271444151.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-27 下午2.44.09" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLength</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nums1.<span class="hljs-built_in">size</span>() &gt; nums2.<span class="hljs-built_in">size</span>() ? <span class="hljs-built_in">solve</span>(nums1, nums2) : <span class="hljs-built_in">solve</span>(nums2, nums1);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; A, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; B)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> an = A.<span class="hljs-built_in">size</span>(), bn = B.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> ans = INT_MIN;<br>        <span class="hljs-comment">// 短串还没有完全拼上长串</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>; len &lt;= bn; ++len) &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">cal</span>(A, <span class="hljs-number">0</span>, B, bn - len, len));<br>        &#125;<br>        <span class="hljs-comment">// 短串在长的串里</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ai = <span class="hljs-number">1</span>; ai &lt; an - bn; ++ai) &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">cal</span>(A, ai, B, <span class="hljs-number">0</span>, bn));<br>        &#125;<br>        <span class="hljs-comment">// 短串后面出去了</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> ai = an - bn; ai &lt; an; ++ai) &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">cal</span>(A, ai, B, <span class="hljs-number">0</span>, an - ai));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == INT_MIN ? <span class="hljs-number">0</span> : ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cal</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; A, <span class="hljs-keyword">int</span> aid, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; B, <span class="hljs-keyword">int</span> bid, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, ans = INT_MIN;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; len; ++k) &#123;<br>            <span class="hljs-keyword">if</span> (A[aid + k] == B[bid + k]) &#123;<br>                cnt++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">0</span>) &#123;<br>                    ans = <span class="hljs-built_in">max</span>(cnt, ans);<br>                    cnt = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果大于0了 那就是需要在判断最后一次</span><br>        <span class="hljs-keyword">return</span> cnt &gt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">max</span>(ans, cnt) : ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day30"><a class="markdownIt-Anchor" href="#day30"></a> Day30</h2>
<h3 id="2-两数相加"><a class="markdownIt-Anchor" href="#2-两数相加"></a> 2、两数相加</h3>
<blockquote>
<p>输入：(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295<br />
输出：2 -&gt; 1 -&gt; 9，即912</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), * c = dummy;<br>        <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l1 || l2 || carry) &#123;<br>            <span class="hljs-keyword">int</span> n1 = l1 ? l1-&gt;val : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> n2 = l2 ? l2-&gt;val : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> cur = n1 + n2 + carry;<br>            carry = cur / <span class="hljs-number">10</span>;<br>            ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(cur % <span class="hljs-number">10</span>);<br>            c-&gt;next = node;<br>            c = node;<br>            <span class="hljs-keyword">if</span> (l1) l1 = l1-&gt;next;<br>            <span class="hljs-keyword">if</span> (l2) l2 = l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>**进阶：**思考一下，假设这些数位是正向存放的，又该如何解决呢?</p>
<blockquote>
<p>输入：(6 -&gt; 1 -&gt; 7) + (2 -&gt; 9 -&gt; 5)，即617 + 295<br />
输出：9 -&gt; 1 -&gt; 2，即912</p>
</blockquote>
<p>method1 ：可以先各自反转，然后正常和上面一样求出结果，再反转一次。</p>
<p>Method2 :  可以计算长度补0，然后递归求解。</p>
<h3 id="剑指offer52-两个链表的第一个公共节点"><a class="markdownIt-Anchor" href="#剑指offer52-两个链表的第一个公共节点"></a> 剑指Offer52 两个链表的第一个公共节点</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode* l1 = headA, * l2 = headB;<br>        <span class="hljs-keyword">while</span> (l1 != l2) &#123;<br>            l1 = l1 ? l1-&gt;next : headB;<br>            l2 = l2 ? l2-&gt;next : headA;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="337-打家劫舍3"><a class="markdownIt-Anchor" href="#337-打家劫舍3"></a> 337、打家劫舍3</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    unordered_map&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt; dp; <span class="hljs-comment">// 记忆每一个节点的最好值</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (dp.<span class="hljs-built_in">count</span>(root)) <span class="hljs-keyword">return</span> dp[root]; <span class="hljs-comment">// 如果这个节点被处理过就不再处理了 [因为noskip 和 skip 遍历的时候会出现重复]</span><br>        <span class="hljs-keyword">int</span> skip = root-&gt;val; <span class="hljs-comment">// 如果有跳跃当前节点的情况</span><br>        <span class="hljs-keyword">int</span> noskip = <span class="hljs-number">0</span>; <span class="hljs-comment">// 也就是当前节点不可以被选择</span><br>        <span class="hljs-comment">// 将每一个节点的状态进行传递 因为0 &lt;= Node.val &lt;= 10^4 所以只要是跳过的都要</span><br>        <span class="hljs-keyword">if</span> (root-&gt;left) &#123;<br>            skip += <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;right);<br>            skip += <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;right) &#123;<br>            skip += <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;left);<br>            skip += <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;right);<br>        &#125;<br>        <span class="hljs-comment">// 对于不能选择当前节点的点 我们选择继承他下一层的状态</span><br>        noskip += <span class="hljs-built_in">rob</span>(root-&gt;right);<br>        noskip += <span class="hljs-built_in">rob</span>(root-&gt;left); <br>        <span class="hljs-comment">// 记忆结果 用来剪枝</span><br>        dp[root] = <span class="hljs-built_in">max</span>(skip, noskip);<br>        <span class="hljs-keyword">return</span> dp[root];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="300-最长上升子序列"><a class="markdownIt-Anchor" href="#300-最长上升子序列"></a> 300、最长上升子序列</h3>
<p>动态规划</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 因为光本身的话就是1</span><br>        <span class="hljs-keyword">int</span> ans = INT_MIN;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (nums[i] &gt; nums[j]) &#123;<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(dp[i], ans);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans == INT_MIN ? <span class="hljs-number">1</span> : ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>思路是先建立一个空的 dp 数组，然后开始遍历原数组，对于每一个遍历到的数字，用二分查找法在 dp 数组找第一个不小于它的数字，如果这个数字不存在，那么直接在 dp 数组后面加上遍历到的数字，如果存在，则将这个数字更新为当前遍历到的数字，最后返回 dp 数组的长度即可，注意的是，跟上面的方法一样，特别注意的是 dp 数组的值可能不是一个真实的 LIS。</p>
<p>说白了维护一个每一个位置尽可能小的数组二分法找的快</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; dp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = dp.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;  <span class="hljs-comment">// 因为是左闭右开</span><br>                <span class="hljs-keyword">int</span> m = l + (r - l) / <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span> (dp[m] &lt; nums[i]) l = m + <span class="hljs-number">1</span>; <span class="hljs-comment">// 这样可以保证剔除的是大数</span><br>                <span class="hljs-keyword">else</span> r = m;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (r &gt;= dp.<span class="hljs-built_in">size</span>()) dp.<span class="hljs-built_in">push_back</span>(nums[i]); <span class="hljs-comment">// 说明冲出去了太大</span><br>            <span class="hljs-keyword">else</span> dp[r] = nums[i];<br>        &#125;<br>        <span class="hljs-comment">// 因为dp数组是顺序的所以不是LIS，但是这一步之后我们可以直接一一对应找他在原数组中的位置</span><br>        <span class="hljs-keyword">return</span> dp.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day31"><a class="markdownIt-Anchor" href="#day31"></a> Day31</h2>
<h3 id="287-寻找重复数"><a class="markdownIt-Anchor" href="#287-寻找重复数"></a> 287、寻找重复数</h3>
<p>最垃圾解法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>循环求解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 主要他这个值不会越界</span><br>        <span class="hljs-keyword">while</span> (nums[<span class="hljs-number">0</span>] != nums[nums[<span class="hljs-number">0</span>]]) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>], nums[nums[<span class="hljs-number">0</span>]]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205311238640.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-31 下午12.37.56" /></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/monkeyduck/article/details/50439840">https://blog.csdn.net/monkeyduck/article/details/50439840</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> slow = nums[<span class="hljs-number">0</span>], fast = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 类似映射</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            slow = nums[slow];<br>            fast = nums[nums[fast]];<br>            <span class="hljs-keyword">if</span> (fast == slow) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        slow = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>            slow = nums[slow];<br>            fast = nums[fast];<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="354-俄罗斯套娃信封问题"><a class="markdownIt-Anchor" href="#354-俄罗斯套娃信封问题"></a> 354、俄罗斯套娃信封问题</h3>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cnoodle/p/14485551.html">https://www.cnblogs.com/cnoodle/p/14485551.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39144436/article/details/123693395?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-123693395-blog-111571531.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-123693395-blog-111571531.pc_relevant_default&amp;utm_relevant_index=2">https://blog.csdn.net/qq_39144436/article/details/123693395?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-123693395-blog-111571531.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1-123693395-blog-111571531.pc_relevant_default&amp;utm_relevant_index=2</a></p>
<p>类似于二分查找版本的插入排序,很奇怪c++就性能很差，但是java就很快。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; a, vector&lt;<span class="hljs-keyword">int</span>&gt; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>] ? a[<span class="hljs-number">1</span>] &gt; b[<span class="hljs-number">1</span>] : a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(envelopes.<span class="hljs-built_in">begin</span>(), envelopes.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = envelopes.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; A;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">int</span> ele = envelopes[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> idx = <span class="hljs-built_in">lower_bound</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>(), ele) - A.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-keyword">if</span> (idx &gt;= A.<span class="hljs-built_in">size</span>()) &#123; <span class="hljs-comment">// 说明他最大</span><br>                A.<span class="hljs-built_in">push_back</span>(ele);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                A[idx] = ele; <span class="hljs-comment">// 如果是新添加的那一定是最小的，保证每个段位都是最小的那就能找到LIS</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="79-字符搜索"><a class="markdownIt-Anchor" href="#79-字符搜索"></a> 79、字符搜索</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;;<br>    vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt; &gt; map;<br>    string sWord;<br>    <span class="hljs-keyword">bool</span> vis[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<br>    <span class="hljs-keyword">int</span> m, n;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>        map = board;<br>        sWord = word;<br>        m = board.<span class="hljs-built_in">size</span>();<br>        n = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(i, j, <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],</span><br><span class="hljs-comment">     [&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],</span><br><span class="hljs-comment">     [&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]]</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> idx)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (idx == sWord.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= m || y &gt;= n || map[x][y] != sWord[idx] || vis[x][y]) &#123; <span class="hljs-comment">// 为什么单独写出来为了防止只有一个的时候无法进入下一个状态</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        vis[x][y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> d : dir) &#123;<br>            <span class="hljs-keyword">int</span> nx = x + d[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> ny = y + d[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(nx, ny, idx + <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        vis[x][y] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 退回的时候要清空状态</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果能找到的话就不会到这里</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day32"><a class="markdownIt-Anchor" href="#day32"></a> Day32</h2>
<h3 id="449-序列化和反序列化bst"><a class="markdownIt-Anchor" href="#449-序列化和反序列化bst"></a> 449、序列化和反序列化BST</h3>
<p>跟二叉树一样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> idx;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">decode</span> <span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (idx &gt;= data.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">char</span> cur = data[idx];<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>            idx += <span class="hljs-number">2</span>; <span class="hljs-comment">// 因为#一定是与,共存的所以当前在# 需要跳过#,</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 如果是空字符 那就返回空</span><br>        &#125; <br>        <span class="hljs-keyword">int</span> val = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (data[idx] != <span class="hljs-string">&#x27;,&#x27;</span>) &#123; <span class="hljs-comment">// 把当前的数提取出来</span><br>            val *= <span class="hljs-number">10</span>;<br>            val += data[idx++] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        idx++; <span class="hljs-comment">// 因为当前是逗号</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>        root-&gt;left = <span class="hljs-built_in">decode</span>(data);<br>        root-&gt;right = <span class="hljs-built_in">decode</span>(data);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(root-&gt;val) + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-built_in">serialize</span>(root-&gt;left) + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-built_in">serialize</span>(root-&gt;right);<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">decode</span>(data);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment">// Codec* ser = new Codec();</span><br><span class="hljs-comment">// Codec* deser = new Codec();</span><br><span class="hljs-comment">// string tree = ser-&gt;serialize(root);</span><br><span class="hljs-comment">// TreeNode* ans = deser-&gt;deserialize(tree);</span><br><span class="hljs-comment">// return ans;</span><br></code></pre></td></tr></table></figure>
<h3 id="1095-山脉数组中查找目标值"><a class="markdownIt-Anchor" href="#1095-山脉数组中查找目标值"></a> 1095、山脉数组中查找目标值</h3>
<p>三次二分查找</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * // This is the MountainArray&#x27;s API interface.</span><br><span class="hljs-comment"> * // You should not implement it, or speculate about its implementation</span><br><span class="hljs-comment"> * class MountainArray &#123;</span><br><span class="hljs-comment"> *   public:</span><br><span class="hljs-comment"> *     int get(int index);</span><br><span class="hljs-comment"> *     int length();</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findInMountainArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, MountainArray &amp;M)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = M.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> mTop; <span class="hljs-comment">// 驼峰</span><br>        <span class="hljs-keyword">while</span> (l &lt;= h) &#123;<br>            <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">int</span> val = M.<span class="hljs-built_in">get</span>(m);<br>            <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//这个题需要处理边界条件，因为最边上是没有两个坡面的</span><br>                l = m + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (m == M.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>) &#123;<br>                h = m - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">continue</span>; <br>            &#125;<br>            <span class="hljs-comment">// 处理完以上两个就不要在继续了</span><br>            <span class="hljs-keyword">if</span> (val &gt; M.<span class="hljs-built_in">get</span>(m - <span class="hljs-number">1</span>) &amp;&amp; val &gt; M.<span class="hljs-built_in">get</span>(m + <span class="hljs-number">1</span>))&#123; <span class="hljs-comment">// 找峰顶</span><br>                mTop = m; <span class="hljs-comment">// 符合结束条件找到了</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &lt; M.<span class="hljs-built_in">get</span>(m - <span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">// 在右边</span><br>                h = m - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &lt; M.<span class="hljs-built_in">get</span>(m + <span class="hljs-number">1</span>))&#123; <span class="hljs-comment">// 在左边</span><br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        l = <span class="hljs-number">0</span>, h = mTop; <span class="hljs-comment">// 将mTop归于左边（右边也行）</span><br>        <span class="hljs-keyword">while</span> (l &lt;= h) &#123;<br>            <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">int</span> val = M.<span class="hljs-built_in">get</span>(m);<br>            <span class="hljs-keyword">if</span> (val == target)&#123; <span class="hljs-comment">// 找峰顶</span><br>                <span class="hljs-keyword">return</span> m; <span class="hljs-comment">// 符合结束条件找到了</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &gt; target) &#123; <br>                h = m - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果左边二分法没有找到</span><br>        l = mTop + <span class="hljs-number">1</span>, h = M.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 将mTop归于左边</span><br>        <span class="hljs-keyword">while</span> (l &lt;= h) &#123;<br>            <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">int</span> val = M.<span class="hljs-built_in">get</span>(m);<br>            <span class="hljs-keyword">if</span> (val == target)&#123; <span class="hljs-comment">// 找峰顶</span><br>                <span class="hljs-keyword">return</span> m; <span class="hljs-comment">// 符合结束条件找到了</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &lt; target) &#123; <span class="hljs-comment">// 因为是降序的</span><br>                h = m - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="222-完全二叉树的节点数"><a class="markdownIt-Anchor" href="#222-完全二叉树的节点数"></a> 222、完全二叉树的节点数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>不过这道题没那么简单，考点在别处。</p>
<p>最简单的思路就是采用后续遍历，暴力法，逐个数，但是这样的效率很低，而且题目改了test case，这样的代码容易TlE（Time Limit Exceeded），所以我们要充分利用题目给定的条件来解题，提高时间效率。</p>
<p>观察到题目给的的完全二叉树，即除了最后一层外，其余层都是每个节点有两个子节点，这样的树结构如果不考虑最后一层，假设有h层（不包含最后一层），则节点总数可以通过等比数列求出：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^h - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。所以我们对每层节点都判断左子树的深度和右子树的深度是否相同，如果相同那整棵树都是满二叉树，可以直接求总结点数。如果不相同则1（自己的节点数）+左子树递归调用节点总数+右子树递归调用节点总数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 只要我在中间加入一些剪枝就可以加速</span><br>        TreeNode* l = root-&gt;left, * r = root-&gt;right;<br>        <span class="hljs-keyword">int</span> lcnt = <span class="hljs-number">1</span>, rcnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l) &#123;<br>            l = l-&gt;left;<br>            lcnt++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(l) &#123;<br>            r = r-&gt;right;<br>            rcnt++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (lcnt == rcnt) &#123; <span class="hljs-comment">// 相等属于知道他是完全二叉树</span><br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span> &lt;&lt; lcnt) - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day33"><a class="markdownIt-Anchor" href="#day33"></a> Day33</h2>
<h3 id="706-设计哈希映射"><a class="markdownIt-Anchor" href="#706-设计哈希映射"></a> 706、设计哈希映射</h3>
<p>直接将空间拉满</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashMap</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; map = vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">1e6</span> + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyHashMap</span>() &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        map[key] = value;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> map[key];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        map[key] = <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyHashMap object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyHashMap* obj = new MyHashMap();</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;remove(key);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<p>用数组模拟一下链地址冲突</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHashMap</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; map;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyHashMap</span>() &#123;<br>        map.<span class="hljs-built_in">resize</span>(<span class="hljs-number">1001</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;());<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> hashkey = key % <span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">if</span> (map[hashkey].<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 如果空的就初始化一下</span><br>            map[hashkey].<span class="hljs-built_in">resize</span>(<span class="hljs-number">1001</span>, <span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">int</span> layer = key / <span class="hljs-number">1000</span>;<br>        map[hashkey][layer] = value;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> hashkey = key % <span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">if</span> (map[hashkey].<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 如果空的就初始化一下</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> layer = key / <span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">return</span> map[hashkey][layer];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> hashkey = key % <span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">if</span> (map[hashkey].<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 如果空的就初始化一下</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> layer = key / <span class="hljs-number">1000</span>;<br>        map[hashkey][layer] = <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyHashMap object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyHashMap* obj = new MyHashMap();</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;remove(key);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h3 id="36-有效数独"><a class="markdownIt-Anchor" href="#36-有效数独"></a> 36、有效数独</h3>
<p>数独有效的判断条件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt; &gt; sudo;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">valid</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sudo[row][col] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i) &#123; <span class="hljs-comment">// 这里注意别等于自己</span><br>            <span class="hljs-keyword">if</span> (i != col &amp;&amp; <br>                c == sudo[row][i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 检测该行是否有重复</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i != row &amp;&amp; <br>                     c == sudo[i][col]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 检测该列是否有重复的</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (row != (<span class="hljs-number">3</span> * (row / <span class="hljs-number">3</span>) + i / <span class="hljs-number">3</span>) &amp;&amp;<br>                     col != (<span class="hljs-number">3</span> * (col / <span class="hljs-number">3</span>) + i % <span class="hljs-number">3</span>) &amp;&amp;<br>                     c == sudo[<span class="hljs-number">3</span> * (row / <span class="hljs-number">3</span>) + i / <span class="hljs-number">3</span>][<span class="hljs-number">3</span> * (col / <span class="hljs-number">3</span>) + i % <span class="hljs-number">3</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        sudo = board;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">valid</span>(board[i][j], i, j))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="37-填数独"><a class="markdownIt-Anchor" href="#37-填数独"></a> 37、填数独</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">valid</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, <span class="hljs-keyword">char</span> c, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i) &#123; <span class="hljs-comment">// 这里注意别等于自己</span><br>            <span class="hljs-keyword">if</span> (c == board[row][i] || c == board[i][col]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 检测该行是否有重复</span><br>            <span class="hljs-keyword">if</span> (c == board[<span class="hljs-number">3</span> * (row / <span class="hljs-number">3</span>) + i / <span class="hljs-number">3</span>][<span class="hljs-number">3</span> * (col / <span class="hljs-number">3</span>) + i % <span class="hljs-number">3</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">fill</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;1&#x27;</span>; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; c++) &#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">valid</span>(board, c, i, j)) &#123; <span class="hljs-comment">// 如果可以放</span><br>                            board[i][j] = c;<br>                            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fill</span>(board)) &#123; <span class="hljs-comment">//dfs进入下一状态</span><br>                                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果在某一个刻完成了，那就会一直true到底</span><br>                            &#125;<br>                            <span class="hljs-keyword">else</span> board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//如果1到9试过了都不行 返回错误分支</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 所有地方都是数字的话 也就是结束了</span><br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-built_in">fill</span>(board);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day34"><a class="markdownIt-Anchor" href="#day34"></a> Day34</h2>
<h3 id="162-寻找峰值"><a class="markdownIt-Anchor" href="#162-寻找峰值"></a> 162、寻找峰值</h3>
<p>只要是峰值就行（太简单了O（n）直接遍历就行）</p>
<p>如果中间元素大于其相邻后续元素，则中间元素左侧(包含该中间元素）必包含一个局部最大值。如果中间元素小于其相邻后续元素，则中间元素右侧必包含一个局部最大值。（可通过反证法证明该方法的正确性）</p>
<p>这里用的是二分法<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 2 1</span><br>        <span class="hljs-comment">// 1 2</span><br>        <span class="hljs-comment">// 3 1 2</span><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; h) &#123;<br>            <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[m] &gt; nums[m + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 如果想不明白就直接用最简单的例子1 2 or 2 1去想</span><br>                h = m;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="437-路径总和"><a class="markdownIt-Anchor" href="#437-路径总和"></a> 437、路径总和</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pathSumRoot</span>(root, targetSum) + <span class="hljs-built_in">pathSum</span>(root-&gt;left, targetSum) + <span class="hljs-built_in">pathSum</span>(root-&gt;right, targetSum);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pathSumRoot</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 走到空就返回</span><br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>; <span class="hljs-comment">// 每次初始化一下需要记录的结果</span><br>        <span class="hljs-keyword">if</span> (targetSum == root-&gt;val) ret++; <span class="hljs-comment">// 说明到达了要求【最后一个】,但是不代表继续走没有结果</span><br>        <span class="hljs-comment">// 也就是当前的结果加上继续沿着左右往下走的结果</span><br>        <span class="hljs-keyword">return</span> ret + <span class="hljs-built_in">pathSumRoot</span>(root-&gt;left, targetSum - root-&gt;val) + <span class="hljs-built_in">pathSumRoot</span>(root-&gt;right, targetSum - root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="442-数组中重复的数据"><a class="markdownIt-Anchor" href="#442-数组中重复的数据"></a> 442、数组中重复的数据</h3>
<p>先排序再做</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>交换再处理答案</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">while</span>(nums[i] != nums[nums[i] - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[nums[i] - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// [4,3,2,7,8,2,3,1] -&gt; 1 2 3 4 3 2 7 8 </span><br>        <span class="hljs-comment">// 所以重复的话就不在位置上</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="day35"><a class="markdownIt-Anchor" href="#day35"></a> Day35</h3>
<h3 id="42-接雨水"><a class="markdownIt-Anchor" href="#42-接雨水"></a> 42、接雨水</h3>
<p>基于动态规划 Dynamic Programming 的，维护一个一维的 dp 数组，这个 DP 算法需要遍历两遍数组，第一遍在 dp[i] 中存入i位置左边的最大值，然后开始第二遍遍历数组，第二次遍历时找右边最大值，然后和左边最大值比较取其中的较小值，然后跟当前值 A[i] 相比，如果大于当前值，则将差值存入结果。【就是左右遍历完夹击出水面本身的高度(填平），然后按照位置求解】参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; h)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = h.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> mx = INT_MIN;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(mx, h[i]);<br>            mx = <span class="hljs-built_in">max</span>(mx, dp[i]); <span class="hljs-comment">// mx 存储当前左边最大值</span><br>        &#125;<br>        mx = INT_MIN; <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            mx = <span class="hljs-built_in">max</span>(mx, h[i]); <span class="hljs-comment">// mx 存储当前左边最大值</span><br>            dp[i] = <span class="hljs-built_in">min</span>(mx, dp[i]);<br>            <span class="hljs-keyword">if</span> (dp[i] &gt; h[i]) &#123;<br>                ans += dp[i] - h[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>再看一种只需要遍历一次即可的解法，这个算法需要 left 和 right 两个指针分别指向数组的首尾位置，从两边向中间扫描，在当前两指针确定的范围内，先比较两头找出较小值，如果较小值是 left 指向的值，则从左向右扫描，如果较小值是 right 指向的值，则从右向左扫描，若遇到的值比当较小值小，则将差值存入结果，如遇到的值大，则重新确定新的窗口范围，以此类推直至 left 和 right 指针重合，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; h)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = h.<span class="hljs-built_in">size</span>(), l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> mn = <span class="hljs-built_in">min</span>(h[l], h[r]); <br>            <span class="hljs-keyword">if</span> (mn == h[l]) &#123; <span class="hljs-comment">// 如果小的数是左边那就从左向右走</span><br>                l++;<br>                <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; mn &gt; h[l]) &#123;<br>                    ans += (mn - h[l]);<br>                    l++;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                r--;<br>                <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; mn &gt; h[r]) &#123;<br>                    ans += (mn - h[r]);<br>                    r--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>其实用 stack 的方法感觉更容易理解，思路是，遍历高度，如果此时栈为空，或者当前高度小于等于栈顶高度，则把当前高度的坐标压入栈，注意这里不直接把高度压入栈，而是把坐标压入栈，这样方便在后来算水平距离。当遇到比栈顶高度大的时候，就说明有可能会有坑存在，可以装雨水。此时栈里至少有一个高度，如果只有一个的话，那么不能形成坑，直接跳过，如果多余一个的话，那么此时把栈顶元素取出来当作坑，新的栈顶元素就是左边界，当前高度是右边界，只要取二者较小的，减去坑的高度，长度就是右边界坐标减去左边界坐标再减1，二者相乘就是盛水量啦，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; h)</span> </span>&#123;<br>        <span class="hljs-comment">// 构建单调栈</span><br>        stack&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = h.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;) &#123;<br>            <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>() || h[st.<span class="hljs-built_in">top</span>()] &gt;= h[i]) &#123;<br>                st.<span class="hljs-built_in">push</span>(i++);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">int</span> hole = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">continue</span>;<br>                ans += ((i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>) * (<span class="hljs-built_in">min</span>(h[st.<span class="hljs-built_in">top</span>()], h[i]) - h[hole]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="135-分发糖果"><a class="markdownIt-Anchor" href="#135-分发糖果"></a> 135、分发糖果</h3>
<p>这道题看起来很难，其实解法并没有那么复杂，当然我也是看了别人的解法才做出来的，先来看看两遍遍历的解法，首先初始化每个人一个糖果，然后这个算法需要遍历两遍，第一遍从左向右遍历，如果右边的小盆友的等级高，等加一个糖果，这样保证了一个方向上高等级的糖果多。然后再从右向左遍历一遍，如果相邻两个左边的等级高，而左边的糖果又少的话，则左边糖果数为右边糖果数加一。最后再把所有小盆友的糖果数都加起来返回即可。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = ratings.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 初始化每个小朋友的糖果都是1块</span><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 类似完全背包只有先更新后面的才能让状态延续</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i + <span class="hljs-number">1</span>] &gt; ratings[i]) &#123; <span class="hljs-comment">// 如果右边的人比我等级高，那右边的人多一块糖 </span><br>                nums[i + <span class="hljs-number">1</span>] = nums[i] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 这样写如果是递增序列可以逐渐增高</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i - <span class="hljs-number">1</span>] &gt; ratings[i]) &#123; <span class="hljs-comment">// 说明我比左侧的大</span><br>                nums[i - <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[i - <span class="hljs-number">1</span>], nums[i] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            ans += num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day36"><a class="markdownIt-Anchor" href="#day36"></a> Day36</h2>
<h3 id="968-监控二叉树"><a class="markdownIt-Anchor" href="#968-监控二叉树"></a> 968、监控二叉树</h3>
<p>这里先来考虑，到底把相机放在什么位置可以拍到最多的结点？是叶结点吗？不一定是，因为若放在叶结点，只能拍到该叶结点和其父结点两个而已。是根结点吗？也不一定，因为放在根结点，最多拍到根结点和其左右两个子结点，总共三个而已。最优解是放在叶结点的父结点上，这样最多可以拍到四个结点。所以策略应该是先找到叶结点，让后在其父结点放上相机，同时标记父结点的父结点为被拍到了。这样就有3种不同的状态，用0来表示当前结点是叶结点，1表示当前结点是叶结点的父结点，并被放置了相机，2表示当前结点的是叶结点的爷爷结点，并被相机拍到了。这里使用一个子函数，将全局变量 res 传进去，用来记录放置的相机的总个数。在递归函数中，若当前结点不存在，则返回2，空结点也可看作已经被相机拍到了。否则分别对左右子结点调用递归函数，若二者中有一个返回0了，当前结点至少有一个子结点是叶结点，需要在当前位置放一个相机，结果 res 自增1，并返回1。否则若左右子结点的返回值有一个为1，说明左右子结点中至少有一个已经被放上了相机，当前结点已经被拍到了，返回2。若都不是，则说明当前结点是叶结点，返回0。在主函数中，若对根结点调用递归的返回值是0，说明根结点是叶结点，此时没有办法，只能在叶结点上放个相机了，所以要加上1，否则不用加，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    There are 4 possibility:</span><br><span class="hljs-comment">        covered     hasCamera</span><br><span class="hljs-comment">         yes           yes  (possible)  returns 0</span><br><span class="hljs-comment">         yes           no   (possible)  returns 1</span><br><span class="hljs-comment">         no            yes  (im-possible)  invalid state</span><br><span class="hljs-comment">         no             no  (possible)  returns -1</span><br><span class="hljs-comment">   </span><br><span class="hljs-comment">   There can be 3 return values for a node:</span><br><span class="hljs-comment">   1. If a child(root) needs a camera,It will tell to parent that you place a camera on you return -1,(in need of camera)</span><br><span class="hljs-comment">   </span><br><span class="hljs-comment">   2.  If a child has a camera it will return 0,</span><br><span class="hljs-comment">   </span><br><span class="hljs-comment">   3. I dont need camera  and neither I have camera return 1.</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">int</span> cam = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addCamera</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 如果是孩子，标记covered 因为返回后他的父节点一定会成为-1状态</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">addCamera</span>(root-&gt;left);<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">addCamera</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">-1</span> || right == <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// 这里是后续遍历如果左右的孩子属于没有相机且需要摄像机，这个时候就添加一个</span><br>            cam++; <span class="hljs-comment">// 这里添加设备</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 左右只要有一个摄像机就可以映射到自己了 那这个节点不需要安装摄像机，covered</span><br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">// left == 1 &amp;&amp; right == 1 // 说明当前的节点很可能需要安装摄像机</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 说明该节点一定是被摄像机笼罩的【也就说明当前节点是普通节点，没有被覆盖也没有安装相机】</span><br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> x = <span class="hljs-built_in">addCamera</span>(root);<br>        <span class="hljs-keyword">return</span> x == <span class="hljs-number">-1</span> ? cam + <span class="hljs-number">1</span> : cam;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="2050-并行课程-iii"><a class="markdownIt-Anchor" href="#2050-并行课程-iii"></a> 2050、并行课程 III</h3>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43539599/article/details/106989905?utm_medium=distribute.pc_relevant.none-task-blog-2">https://blog.csdn.net/qq_43539599/article/details/106989905?utm_medium=distribute.pc_relevant.none-task-blog-2</a><sub>default</sub>baidujs_title~default-0-106989905-blog-107002071.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</p>
<p>有点类似dijskla算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumTime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; relations, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; time)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">indegree</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">// 用来记录每一个节点的入度</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">graph</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;()); <span class="hljs-comment">// 用来换成矩阵形式的临接表</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : relations) &#123;<br>            <span class="hljs-keyword">int</span> pre = e[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, next = e[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>; <span class="hljs-comment">// 索引 + 1 == 序号</span><br>            graph[pre].<span class="hljs-built_in">push_back</span>(next);<br>            indegree[next]++;<br>        &#125;<br>        <span class="hljs-comment">// 初始化拓扑排序</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">// Let dist[u] is the number of months required to finish u course</span><br>        queue&lt;<span class="hljs-keyword">int</span>&gt; q; <span class="hljs-comment">// 用于存储节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = <span class="hljs-number">0</span>; u &lt; n; ++u) &#123;<br>            <span class="hljs-keyword">if</span> (indegree[u] == <span class="hljs-number">0</span>) &#123; <br>                q.<span class="hljs-built_in">push</span>(u); <span class="hljs-comment">//  先把入度为0的节点放入</span><br>                dist[u] = time[u]; <span class="hljs-comment">// 更新一下按照这个节点开始的话他的时间消耗</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 说明还有节点没有走完，必须每一步都取得最大值这样可以囊括所有</span><br>            <span class="hljs-keyword">int</span> u = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : graph[u]) &#123;<br>                dist[v] = <span class="hljs-built_in">max</span>(dist[v], dist[u] + time[v]);<br>                <span class="hljs-keyword">if</span> (--indegree[v] == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 移除节点，入度减少, 且如果为0 则继续加入</span><br>                    q.<span class="hljs-built_in">push</span>(v);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(dist.<span class="hljs-built_in">begin</span>(), dist.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 找到最大值为结果</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day37"><a class="markdownIt-Anchor" href="#day37"></a> Day37</h2>
<h3 id="407-接雨水ii"><a class="markdownIt-Anchor" href="#407-接雨水ii"></a> 407、接雨水II</h3>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/grandyang/p/5928987.html">https://www.cnblogs.com/grandyang/p/5928987.html</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trapRainWater</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; heightMap)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; cell; <span class="hljs-comment">// 记录&#123;高度，坐标[这里简单编码一下后续好的到他的值]&#125;</span><br>        priority_queue&lt;cell, vector&lt;cell&gt;, greater&lt;cell&gt; &gt; q; <span class="hljs-comment">// 创建优先队列</span><br>        <span class="hljs-comment">// 将周围的一圈都放入优先队列</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> m = heightMap.<span class="hljs-built_in">size</span>(), n = heightMap[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt; &gt; <span class="hljs-built_in">vis</span>(m, vector&lt;<span class="hljs-keyword">bool</span>&gt;(n)); <span class="hljs-comment">// 设置vector数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || j == <span class="hljs-number">0</span> || i == m - <span class="hljs-number">1</span> || j == n - <span class="hljs-number">1</span>) &#123;<br>                    q.<span class="hljs-built_in">push</span>(&#123;heightMap[i][j], i * n + j&#125;);<br>                    vis[i][j] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> mh = INT_MIN;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> data = q.<span class="hljs-built_in">top</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">int</span> h = data.first, x = data.second / n, y = data.second % n;<br>            mh = <span class="hljs-built_in">max</span>(h, mh);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> d : dir) &#123;<br>                <span class="hljs-keyword">int</span> nx = x + d[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">int</span> ny = y + d[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; n &amp;&amp; !vis[nx][ny]) &#123;<br>                    <span class="hljs-keyword">if</span> (mh &gt; heightMap[nx][ny]) &#123; <span class="hljs-comment">// 按照最小高度来找可以装水的地方</span><br>                        ans += mh - heightMap[nx][ny];<br>                    &#125;<br>                    vis[nx][ny] = <span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(&#123;heightMap[nx][ny], nx * n + ny&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="234-回文链表"><a class="markdownIt-Anchor" href="#234-回文链表"></a> 234、回文链表</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        ListNode* slow = head, * fast = head, * pre;<br>        <span class="hljs-keyword">do</span> &#123;<br>            pre = slow;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next);<br>        <span class="hljs-keyword">if</span> (fast) slow = slow-&gt;next; <span class="hljs-comment">// 针对奇数需要特殊处理</span><br>        pre-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 分割成两段了</span><br>        <span class="hljs-comment">// 反转链表</span><br>        ListNode* partII = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span> (slow) &#123;<br>            ListNode* next = slow-&gt;next;<br>            slow-&gt;next = partII;<br>            partII = slow;<br>            slow = next;<br>        &#125;<br>        ListNode* partI = head;<br>        <span class="hljs-comment">// 对比字符串</span><br>        <span class="hljs-keyword">while</span> (partII) &#123;<br>            <span class="hljs-keyword">if</span> (partI-&gt;val != partII-&gt;val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            partI = partI-&gt;next;<br>            partII = partII-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="701-二叉搜索树中的插入操作"><a class="markdownIt-Anchor" href="#701-二叉搜索树中的插入操作"></a> 701、二叉搜索树中的插入操作</h3>
<p>直接插入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);  <br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) &#123;<br>            root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="102-二叉树的层序遍历"><a class="markdownIt-Anchor" href="#102-二叉树的层序遍历"></a> 102、二叉树的层序遍历</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; ans;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br>        queue&lt;TreeNode* &gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = q.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                TreeNode* cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                temp.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                <span class="hljs-keyword">if</span> (cur-&gt;left) &#123;<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (cur-&gt;right) &#123;<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                &#125;<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day38"><a class="markdownIt-Anchor" href="#day38"></a> Day38</h2>
<h3 id="264-丑数ii"><a class="markdownIt-Anchor" href="#264-丑数ii"></a> 264、丑数II</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 分别记录乘2 3 5 记录的是索引</span><br>        <span class="hljs-keyword">int</span> II = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> III = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> V = <span class="hljs-number">1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">int</span> nextII = dp[II] * <span class="hljs-number">2</span>, nextIII = dp[III] * <span class="hljs-number">3</span>, nextV = dp[V] * <span class="hljs-number">5</span>;<br>            dp[i] = <span class="hljs-built_in">min</span>(nextII, <span class="hljs-built_in">min</span>(nextIII, nextV));<br>            <span class="hljs-comment">// 这里是三个if 只要有相等都略过 这样才能保证不重复</span><br>            <span class="hljs-keyword">if</span> (nextII == dp[i]) &#123;<br>                II++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nextIII == dp[i]) &#123;<br>                III++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nextV == dp[i]) &#123;<br>                V++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="850-员工空闲时间"><a class="markdownIt-Anchor" href="#850-员工空闲时间"></a> 850、员工空闲时间</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition of Interval:</span><br><span class="hljs-comment"> * class Interval &#123;</span><br><span class="hljs-comment"> * public:</span><br><span class="hljs-comment"> *     int start, end;</span><br><span class="hljs-comment"> *     Interval(int start, int end) &#123;</span><br><span class="hljs-comment"> *         this-&gt;start = start;</span><br><span class="hljs-comment"> *         this-&gt;end = end;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; a, vector&lt;<span class="hljs-keyword">int</span>&gt; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @param schedule: a list schedule of employees</span><br><span class="hljs-comment">     * @return: Return a list of finite intervals </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;Interval&gt; <span class="hljs-title">employeeFreeTime</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;schedule)</span> </span>&#123;<br>        <span class="hljs-comment">// Write your code here</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; sch;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; cur;<br>        vector&lt;Interval&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; schedule.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; schedule[i].<span class="hljs-built_in">size</span>(); ++j) &#123;<br>                cur.<span class="hljs-built_in">push_back</span>(schedule[i][j]);<br>                <span class="hljs-keyword">if</span> (j != <span class="hljs-number">0</span> &amp;&amp; (j + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                    sch.<span class="hljs-built_in">push_back</span>(cur);<br>                    cur.<span class="hljs-built_in">resize</span>(<span class="hljs-number">0</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(sch.<span class="hljs-built_in">begin</span>(), sch.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-keyword">int</span> end = sch[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; sch.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (sch[i][<span class="hljs-number">0</span>] &gt; end) &#123; <span class="hljs-comment">// 没重叠就需要更新</span><br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Interval</span>(end, sch[i][<span class="hljs-number">0</span>]));<br>            &#125;<br>            end = <span class="hljs-built_in">max</span>(end, sch[i][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 更新边界</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="662-二叉树最大宽度"><a class="markdownIt-Anchor" href="#662-二叉树最大宽度"></a> 662、二叉树最大宽度</h3>
<p>记忆化层次遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">widthOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        queue&lt;pair&lt;TreeNode*, <span class="hljs-keyword">int</span>&gt; &gt; q; <span class="hljs-comment">// 存储树节点和芯片</span><br>        q.<span class="hljs-built_in">push</span>(&#123;root, <span class="hljs-number">1</span>&#125;);<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> n = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-comment">// 获得当前层左右边界</span><br>            <span class="hljs-keyword">int</span> left = q.<span class="hljs-built_in">front</span>().second; <br>            <span class="hljs-keyword">int</span> right = q.<span class="hljs-built_in">back</span>().second;<br>            res = <span class="hljs-built_in">max</span>(res, right - left + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-comment">// 其实不用记录真正的长度，按照规则就行</span><br>                <span class="hljs-keyword">auto</span> cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">int</span> idx = cur.second - left;<br>                <span class="hljs-keyword">if</span> (cur.first-&gt;left) &#123;<br>                    q.<span class="hljs-built_in">push</span>(&#123;cur.first-&gt;left, (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">2</span> * idx&#125;); <span class="hljs-comment">// 左子树节点的左手</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> (cur.first-&gt;right) &#123;<br>                    q.<span class="hljs-built_in">push</span>(&#123;cur.first-&gt;right, (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">2</span> * idx + <span class="hljs-number">1</span>&#125;); <span class="hljs-comment">// 左子树节点的左手</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day39"><a class="markdownIt-Anchor" href="#day39"></a> Day39</h2>
<h3 id="226-翻转二叉树"><a class="markdownIt-Anchor" href="#226-翻转二叉树"></a> 226、翻转二叉树</h3>
<p>递归法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        <span class="hljs-comment">// 后续遍历交换</span><br>        <span class="hljs-built_in">swap</span>(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        TreeNode* temp = root-&gt;left;<br>        root-&gt;left = root-&gt;right;<br>        root-&gt;right = temp;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>迭代法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> root;<br>        stack&lt;TreeNode*&gt; st;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* cur = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-built_in">swap</span>(cur);<br>            <span class="hljs-keyword">if</span> (cur-&gt;left) st.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            <span class="hljs-keyword">if</span> (cur-&gt;right) st.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        TreeNode* temp = root-&gt;left;<br>        root-&gt;left = root-&gt;right;<br>        root-&gt;right = temp;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="122-买卖股票的最佳时机ii"><a class="markdownIt-Anchor" href="#122-买卖股票的最佳时机ii"></a> 122、买卖股票的最佳时机II</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-comment">// 无限制最简单，只要第二天比前一天大就可以</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span> ; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (prices[i] &gt; prices[i - <span class="hljs-number">1</span>]) &#123;<br>                ans += prices[i] - prices[i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="223-矩形面积"><a class="markdownIt-Anchor" href="#223-矩形面积"></a> 223、矩形面积</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">computeArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ax1, <span class="hljs-keyword">int</span> ay1, <span class="hljs-keyword">int</span> ax2, <span class="hljs-keyword">int</span> ay2, <span class="hljs-keyword">int</span> bx1, <span class="hljs-keyword">int</span> by1, <span class="hljs-keyword">int</span> bx2, <span class="hljs-keyword">int</span> by2)</span> </span>&#123;<br>        <span class="hljs-comment">// A + B - AB</span><br>        <span class="hljs-keyword">int</span> A = (ax1 - ax2) * (ay1 - ay2);<br>        <span class="hljs-keyword">int</span> B = (bx1 - bx2) * (by1 - by2);<br>        <span class="hljs-keyword">int</span> AB = <span class="hljs-number">0</span>; <span class="hljs-comment">// 设交际为0；</span><br>        <br>        <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">max</span>(ax1, bx1);<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">min</span>(ax2, bx2);<br>        <span class="hljs-keyword">int</span> top = <span class="hljs-built_in">min</span>(ay2, by2);<br>        <span class="hljs-keyword">int</span> bottom = <span class="hljs-built_in">max</span>(ay1, by1);<br>        <br>        <span class="hljs-comment">// 判断是否有交集</span><br>        <span class="hljs-keyword">if</span> (top &gt; bottom &amp;&amp; left &lt; right) &#123;<br>            AB = (right - left) * (top - bottom);<br>        &#125;<br>        <span class="hljs-keyword">return</span> A + B - AB;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day40"><a class="markdownIt-Anchor" href="#day40"></a> Day40</h2>
<h3 id="694-不同岛屿的数量"><a class="markdownIt-Anchor" href="#694-不同岛屿的数量"></a> 694、不同岛屿的数量</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @param grid: a list of lists of integers</span><br><span class="hljs-comment">     * @return: return an integer, denote the number of distinct islands</span><br><span class="hljs-comment">     */</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; graph;<br>    unordered_set&lt;string&gt; ans; <span class="hljs-comment">// 用set的尺寸来记录结果</span><br>    <span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-keyword">int</span> m, n;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numberofDistinctIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;<br>        <span class="hljs-comment">// write your code here</span><br>        <span class="hljs-comment">// 用BFS做一遍 练练手</span><br>        graph = grid;<br>        m = grid.<span class="hljs-built_in">size</span>();<br>        n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (graph[i][j] == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-built_in">bfs</span>(i, j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans.<span class="hljs-built_in">size</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        queue&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt; q;<br>        q.<span class="hljs-built_in">push</span>(&#123;x, y&#125;);<br>        graph[x][y] = <span class="hljs-number">0</span>;<br>        string sb = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 建立模版</span><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> cur = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>            sb += <span class="hljs-built_in">to_string</span>(cur.first - x) + <span class="hljs-built_in">to_string</span>(cur.second - y);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> d : dir) &#123;<br>                <span class="hljs-keyword">int</span> nx = cur.first + d[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">int</span> ny = cur.second + d[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span> ( ( nx &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n ) &amp;&amp; graph[nx][ny] == <span class="hljs-number">1</span>) &#123;<br>                    q.<span class="hljs-built_in">push</span>(&#123;nx, ny&#125;);<br>                    graph[nx][ny] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        ans.<span class="hljs-built_in">insert</span>(sb);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="84-柱状图中最大的矩形"><a class="markdownIt-Anchor" href="#84-柱状图中最大的矩形"></a> 84、柱状图中最大的矩形</h3>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1727776/JavaC%2B%2B-Explanation-going-from-Brute-to-Optimal-Approach">https://leetcode.com/problems/largest-rectangle-in-histogram/discuss/1727776/JavaC%2B%2B-Explanation-going-from-Brute-to-Optimal-Approach</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; h)</span> </span>&#123;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        h.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 为了递增序列到最后一个也能处理掉</span><br>        <span class="hljs-keyword">int</span> maxArea = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; h.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; h[i] &lt; h[st.<span class="hljs-built_in">top</span>()]) &#123; <span class="hljs-comment">// 保证只要小我就处理</span><br>                <span class="hljs-keyword">int</span> top = st.<span class="hljs-built_in">top</span>(); st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">int</span> width = st.<span class="hljs-built_in">empty</span>() ? i : i - st.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 空的话 说明是全场最小 所以是i全部乘他就完事儿了</span><br>                maxArea = <span class="hljs-built_in">max</span>(maxArea, width * h[top]);<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i); <span class="hljs-comment">// 记录当前下标</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="253-会议室-ii"><a class="markdownIt-Anchor" href="#253-会议室-ii"></a> 253、会议室 II</h3>
<p><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/919/solution/57828">https://www.lintcode.com/problem/919/solution/57828</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition of Interval:</span><br><span class="hljs-comment"> * class Interval &#123;</span><br><span class="hljs-comment"> * public:</span><br><span class="hljs-comment"> *     int start, end;</span><br><span class="hljs-comment"> *     Interval(int start, int end) &#123;</span><br><span class="hljs-comment"> *         this-&gt;start = start;</span><br><span class="hljs-comment"> *         this-&gt;end = end;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @param intervals: an array of meeting time intervals</span><br><span class="hljs-comment">     * @return: the minimum number of conference rooms required</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(Interval a, Interval b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a.start == b.start ? a.end &lt; b.end : a.start &lt; b.start;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minMeetingRooms</span><span class="hljs-params">(vector&lt;Interval&gt; &amp;inter)</span> </span>&#123;<br>        <span class="hljs-comment">// Write your code here</span><br>        priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; q; <span class="hljs-comment">// 用于记录当前开的房间最早的结束时间</span><br>        <span class="hljs-built_in">sort</span>(inter.<span class="hljs-built_in">begin</span>(), inter.<span class="hljs-built_in">end</span>(), cmp);<br>        q.<span class="hljs-built_in">push</span>(inter[<span class="hljs-number">0</span>].end);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; inter.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">top</span>() &lt;= inter[i].start) &#123; <span class="hljs-comment">// 不冲突</span><br>                <span class="hljs-comment">// 那就新开房间</span><br>                q.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-comment">// 冲突了</span><br>            q.<span class="hljs-built_in">push</span>(inter[i].end);<br>        &#125;<br>        <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day41"><a class="markdownIt-Anchor" href="#day41"></a> Day41</h2>
<h3 id="232-用栈实现队列"><a class="markdownIt-Anchor" href="#232-用栈实现队列"></a> 232、用栈实现队列</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; in;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; out;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        in.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">transform</span>();<br>        <span class="hljs-keyword">int</span> val = out.<span class="hljs-built_in">top</span>();<br>        out.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">transform</span>();<br>        <span class="hljs-keyword">return</span> out.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> in.<span class="hljs-built_in">empty</span>() &amp;&amp; out.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transform</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(out.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">while</span>(!in.<span class="hljs-built_in">empty</span>()) &#123;<br>                out.<span class="hljs-built_in">push</span>(in.<span class="hljs-built_in">top</span>());<br>                in.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue* obj = new MyQueue();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;peek();</span><br><span class="hljs-comment"> * bool param_4 = obj-&gt;empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>
<h3 id="470-用-rand7-实现-rand10"><a class="markdownIt-Anchor" href="#470-用-rand7-实现-rand10"></a> 470、用 Rand7() 实现 Rand10()</h3>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/YY_Tina/article/details/124748454">https://blog.csdn.net/YY_Tina/article/details/124748454</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// The rand7() API is already defined for you.</span><br><span class="hljs-comment">// int rand7();</span><br><span class="hljs-comment">// @return a random integer in the range 1 to 7</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rand10</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> rand1, rand2, rand;<br>        <span class="hljs-keyword">do</span>&#123;<br>            rand1 = <span class="hljs-built_in">rand7</span>() - <span class="hljs-number">1</span>;<br>            rand2 = <span class="hljs-built_in">rand7</span>() - <span class="hljs-number">1</span>;<br>            rand = <span class="hljs-number">7</span> * rand1 + rand2;<br>        &#125;<span class="hljs-keyword">while</span> (rand &gt;= <span class="hljs-number">40</span>);<br>        <span class="hljs-keyword">return</span> rand % <span class="hljs-number">10</span> + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="946-验证栈序列"><a class="markdownIt-Anchor" href="#946-验证栈序列"></a> 946、验证栈序列</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; pushed, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; popped)</span> </span>&#123;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        <span class="hljs-keyword">int</span> inIdx = <span class="hljs-number">0</span>, outIdx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = pushed.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (inIdx &lt; n &amp;&amp; outIdx &lt; n) &#123;<br>            st.<span class="hljs-built_in">push</span>(pushed[inIdx++]);<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() == popped[outIdx]) &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                outIdx++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day42"><a class="markdownIt-Anchor" href="#day42"></a> Day42</h2>
<h3 id="227-基本计算器ii"><a class="markdownIt-Anchor" href="#227-基本计算器ii"></a> 227、基本计算器II</h3>
<p>很巧妙，强行转换为了后缀表达式的计算方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">issign</span><span class="hljs-params">(<span class="hljs-keyword">char</span> obj)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-string">&#x27;+&#x27;</span> || obj ==<span class="hljs-string">&#x27;-&#x27;</span> || obj == <span class="hljs-string">&#x27;*&#x27;</span> || obj == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        <span class="hljs-keyword">char</span> ps = <span class="hljs-string">&#x27;+&#x27;</span>;<br>        <span class="hljs-keyword">int</span> val = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(s[i])) &#123; <span class="hljs-comment">// 如果是数字</span><br>                val =  val * <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">issign</span>(s[i]) || i == n - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (ps == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                    st.<span class="hljs-built_in">push</span>(val);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ps == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                    st.<span class="hljs-built_in">push</span>(-val);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ps == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">int</span> no = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    st.<span class="hljs-built_in">push</span>(no * val);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ps == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">int</span> no = st.<span class="hljs-built_in">top</span>();<br>                    st.<span class="hljs-built_in">pop</span>();<br>                    st.<span class="hljs-built_in">push</span>(no / val);<br>                &#125;<br>                ps = s[i];<br>                val = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            val += st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="518-零钱兑换ii"><a class="markdownIt-Anchor" href="#518-零钱兑换ii"></a> 518、零钱兑换II</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 完全背包</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 按照价值进行动态</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 说明正好放下</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> coin : coins) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = coin; i &lt;= amount; ++i) &#123;<br>                dp[i] += dp[i - coin];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="115-不同的子序列"><a class="markdownIt-Anchor" href="#115-不同的子序列"></a> 115、不同的子序列</h3>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/l141210113/article/details/107134302">https://blog.csdn.net/l141210113/article/details/107134302</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numDistinct</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MOD = (<span class="hljs-keyword">int</span>)<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;            <span class="hljs-comment">// To avoid Integer Overflow on some cases</span><br>    <span class="hljs-keyword">int</span> m = s.<span class="hljs-built_in">size</span>(), n = t.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(s[i - <span class="hljs-number">1</span>] == t[j - <span class="hljs-number">1</span>])<br>                dp[i][j] = (dp[i - <span class="hljs-number">1</span>][j] + dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % MOD;<br>            <span class="hljs-keyword">else</span> <br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day43"><a class="markdownIt-Anchor" href="#day43"></a> Day43</h2>
<h3 id="848-字母移位"><a class="markdownIt-Anchor" href="#848-字母移位"></a> 848、字母移位</h3>
<p>复杂度降到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>就行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">shiftingLetters</span><span class="hljs-params">(string s, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; shifts)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span>&gt; new_sh;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">reverse</span>(shifts.<span class="hljs-built_in">begin</span>(), shifts.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将数组翻转才是应该位移的数量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : shifts) &#123; <span class="hljs-comment">// 记录前缀和</span><br>            sum += s;<br>            new_sh.<span class="hljs-built_in">push_back</span>(sum);<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(new_sh.<span class="hljs-built_in">begin</span>(), new_sh.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将数组翻转才是应该位移的数量</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            s[i] = (s[i] - <span class="hljs-string">&#x27;a&#x27;</span> + new_sh[i]) % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;a&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>空间复杂度降到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">shiftingLetters</span><span class="hljs-params">(string s, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; shifts)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            sum += shifts[i];<br>            s[i] = (s[i] - <span class="hljs-string">&#x27;a&#x27;</span> + sum) % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;a&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="1438-绝对差不超过限制的最长连续子数组"><a class="markdownIt-Anchor" href="#1438-绝对差不超过限制的最长连续子数组"></a> 1438、绝对差不超过限制的最长连续子数组</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestSubarray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> limit)</span> </span>&#123;<br>        priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt;, greater&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt; &gt; minHeap;<br>        priority_queue&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt;, less&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; &gt; maxHeap;<br>        <span class="hljs-comment">// 记录索引为了排除不在窗口里的最大最小堆的值</span><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (j &lt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-comment">// 记录对应的值和下标</span><br>            minHeap.<span class="hljs-built_in">push</span>(&#123;nums[j], j&#125;);<br>            maxHeap.<span class="hljs-built_in">push</span>(&#123;nums[j], j&#125;);<br>            <span class="hljs-keyword">while</span> (maxHeap.<span class="hljs-built_in">top</span>().second &lt; i) &#123; <span class="hljs-comment">// 清掉不属于滑动窗口里的东西</span><br>                maxHeap.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">while</span> (minHeap.<span class="hljs-built_in">top</span>().second &lt; i) &#123; <span class="hljs-comment">// 清掉不属于滑动窗口里的东西</span><br>                minHeap.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (maxHeap.<span class="hljs-built_in">top</span>().first - minHeap.<span class="hljs-built_in">top</span>().first &lt;= limit) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, j - i + <span class="hljs-number">1</span>);<br>                j++; <span class="hljs-comment">//因为满足 所以更加扩大看看能不能行</span><br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                i++; <span class="hljs-comment">// 不行就整个往前挪，比他小的也没有查看的意义</span><br>                j++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="剑指-offer-29-顺时针打印矩阵"><a class="markdownIt-Anchor" href="#剑指-offer-29-顺时针打印矩阵"></a> 剑指 Offer 29、顺时针打印矩阵</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">printMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> r1 = <span class="hljs-number">0</span>, r2 = matrix.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, c1 = <span class="hljs-number">0</span>, c2 = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">while</span> (r1 &lt;= r2 &amp;&amp; c1 &lt;= c2) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = c1; i &lt;= c2; ++i) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(matrix[r1][i]);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (r1 == r2) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = r1 + <span class="hljs-number">1</span>; i &lt;= r2; ++i) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(matrix[i][c2]);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (c1 == c2) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = c2 - <span class="hljs-number">1</span>; i &gt;= c1; --i) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(matrix[r2][i]);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = r2 - <span class="hljs-number">1</span>; i &gt; r1; --i) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(matrix[i][c1]);<br>            &#125;<br>            r1++, c1++, r2--, c2--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day44"><a class="markdownIt-Anchor" href="#day44"></a> Day44</h2>
<h3 id="1143-最长公共子序列"><a class="markdownIt-Anchor" href="#1143-最长公共子序列"></a> 1143、最长公共子序列</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span> <span class="hljs-comment">// 动态规划+打印路径</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> m = text1.<span class="hljs-built_in">size</span>(), n = text2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>));<br>        string str = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 如果相等的话</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (dp[i][j] == dp[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span> &amp;&amp; dp[i - <span class="hljs-number">1</span>][j] == dp[i][j - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 打印路径</span><br>                    str += text1[i - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; str &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="33-搜索旋转数组"><a class="markdownIt-Anchor" href="#33-搜索旋转数组"></a> 33、搜索旋转数组</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> &amp;&amp; nums[<span class="hljs-number">0</span>] == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">// 先找分界线</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> last = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; h) &#123;<br>            <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[m] &lt; nums[last]) &#123;<br>                h = m;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 左闭右开</span><br>        <span class="hljs-keyword">if</span> (target &lt;= nums[last] || l == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 说明在右侧 or 正常从小到大的数组</span><br>            h = last + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 说明在左侧</span><br>            h = l;<br>            l = <span class="hljs-number">0</span>;          <br>        &#125;<br>        <span class="hljs-keyword">while</span> (l &lt; h) &#123;<br>            <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[m] &gt; target) &#123;<br>                h = m;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[m] &lt; target)&#123;<br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> m; <span class="hljs-comment">// 找到了就返回</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="二叉树的下一个结点"><a class="markdownIt-Anchor" href="#二叉树的下一个结点"></a> 二叉树的下一个结点</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeLinkNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeLinkNode *left;</span><br><span class="hljs-comment">    struct TreeLinkNode *right;</span><br><span class="hljs-comment">    struct TreeLinkNode *next;</span><br><span class="hljs-comment">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeLinkNode* <span class="hljs-title">GetNext</span><span class="hljs-params">(TreeLinkNode* pNode)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!pNode) <span class="hljs-keyword">return</span> pNode;<br>        <span class="hljs-comment">// 唯一的区别就是有无右子树</span><br>        <span class="hljs-keyword">if</span> (pNode-&gt;right) &#123;<br>            pNode = pNode-&gt;right;<br>            <span class="hljs-keyword">while</span> (pNode-&gt;left) &#123;<br>                pNode = pNode-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">return</span> pNode;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 没有右子树的话需要往上走</span><br>            <span class="hljs-keyword">while</span> (pNode-&gt;next) &#123;<br>                TreeLinkNode* parent = pNode-&gt;next;<br>                <span class="hljs-keyword">if</span> (parent-&gt;left == pNode) &#123; <span class="hljs-comment">// 如果当前节点为父节点的左孩子</span><br>                    <span class="hljs-keyword">return</span> parent;<br>                &#125;<br>                pNode = pNode-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day45"><a class="markdownIt-Anchor" href="#day45"></a> Day45</h2>
<h3 id="136-只出现一次的数字"><a class="markdownIt-Anchor" href="#136-只出现一次的数字"></a> 136、只出现一次的数字</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            ans ^= num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="540-有序数组里的只出现一次的元素"><a class="markdownIt-Anchor" href="#540-有序数组里的只出现一次的元素"></a> 540、有序数组里的只出现一次的元素</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNonDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> m = l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (m % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                m--;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nums[m] == nums[m + <span class="hljs-number">1</span>]) &#123;<br>                l = m + <span class="hljs-number">2</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                r = m;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[l];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="1642-可以到达的最远建筑"><a class="markdownIt-Anchor" href="#1642-可以到达的最远建筑"></a> 1642、可以到达的最远建筑</h3>
<p>最高的留给梯子(万能解答)</p>
<p>用负数排列maxHeap即保留了最大的数最小，还保证了+=的时候是减法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">furthestBuilding</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; heights, <span class="hljs-keyword">int</span> bricks, <span class="hljs-keyword">int</span> ladders)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = heights.<span class="hljs-built_in">size</span>();<br>        priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, less&lt;<span class="hljs-keyword">int</span>&gt; &gt; maxHeap;<br>        <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            h = heights[i + <span class="hljs-number">1</span>] - heights[i]; <span class="hljs-comment">// 获取当前高度差</span><br>            <span class="hljs-keyword">if</span> (h &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 因为不需要处理</span><br>            <span class="hljs-comment">// 当前比下一个低</span><br>            maxHeap.<span class="hljs-built_in">push</span>(-h);<br>            <span class="hljs-keyword">if</span> (maxHeap.<span class="hljs-built_in">size</span>() &gt; ladders) &#123;<br>                bricks += maxHeap.<span class="hljs-built_in">top</span>(); <br>                maxHeap.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (bricks &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day46"><a class="markdownIt-Anchor" href="#day46"></a> Day46</h2>
<h3 id="99-恢复二叉搜索树"><a class="markdownIt-Anchor" href="#99-恢复二叉搜索树"></a> 99、恢复二叉搜索树</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    TreeNode* first, * second, * pre;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123; <span class="hljs-comment">// 这题简单在只有两处有问题</span><br>        pre = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(INT_MIN);<br>        <span class="hljs-built_in">inorder</span>(root);<br>        <span class="hljs-built_in">swap</span>(first-&gt;val, second-&gt;val);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123; <span class="hljs-comment">// 遍历找到两个不对的地方然后删除 321 举例子就行</span><br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;left);<br>        <br>        <span class="hljs-keyword">if</span> (!first &amp;&amp; root-&gt;val &lt; pre-&gt;val)<br>            first = pre;<br>        <span class="hljs-keyword">if</span> (first &amp;&amp; root-&gt;val &lt; pre-&gt;val)<br>            second = root;<br>        <br>        <span class="hljs-comment">// 更新上一个节点</span><br>        pre = root;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="剑指offer-31-栈的压入-弹出序列"><a class="markdownIt-Anchor" href="#剑指offer-31-栈的压入-弹出序列"></a> 剑指Offer 31 栈的压入、弹出序列</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; pushV,vector&lt;<span class="hljs-keyword">int</span>&gt; popV)</span> </span>&#123;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = pushV.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> pushid = <span class="hljs-number">0</span>, popid = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (pushid &lt; n &amp;&amp; popid &lt; n) &#123;<br>            st.<span class="hljs-built_in">push</span>(pushV[pushid++]);<br>            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; popV[popid] == st.<span class="hljs-built_in">top</span>()) &#123;<br>                popid++;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="day47"><a class="markdownIt-Anchor" href="#day47"></a> Day47</h2>
<h3 id="329-矩阵中的最长递增路径"><a class="markdownIt-Anchor" href="#329-矩阵中的最长递增路径"></a> 329、矩阵中的最长递增路径</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; dp;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; mat;<br>    <span class="hljs-keyword">int</span> m, n;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestIncreasingPath</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        mat = matrix;<br>        m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        dp.<span class="hljs-built_in">resize</span>(m, vector&lt;<span class="hljs-keyword">int</span>&gt;(n));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">dpsearch</span>(i, j));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dpsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (dp[x][y]) <span class="hljs-keyword">return</span> dp[x][y]; <span class="hljs-comment">// 即当了vis 又记忆了状态</span><br>        dp[x][y] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 每一个最少是1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> d : dir) &#123;<br>            <span class="hljs-keyword">int</span> nx = x + d[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> ny = y + d[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n &amp;&amp; mat[nx][ny] &gt; mat[x][y]) &#123;<br>                dp[x][y] = <span class="hljs-built_in">max</span>(dp[x][y], <span class="hljs-number">1</span> + <span class="hljs-built_in">dpsearch</span>(nx, ny)); <span class="hljs-comment">// 找出周围记忆最大的+1</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[x][y];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="679-24点游戏"><a class="markdownIt-Anchor" href="#679-24点游戏"></a> 679、24点游戏</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">compute</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> &#123;x + y, y - x, x - y, x * y, x / y, y / x&#125;;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">helper</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">double</span>&gt;&amp; cards)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cards.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">abs</span>(cards[<span class="hljs-number">0</span>] - <span class="hljs-number">24</span>) &lt; <span class="hljs-number">1e-6</span>) &#123; <span class="hljs-comment">// 能修复成一个并且符合要求</span><br>            <span class="hljs-comment">// abs(cards[0] - 24) &lt; 1e-6 因为是有除法，所以只要是接近就可以</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 双循环遍历 全排列遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cards.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; cards.<span class="hljs-built_in">size</span>(); ++j) &#123;<br>                <span class="hljs-keyword">double</span> n1 = cards[i];<br>                <span class="hljs-keyword">double</span> n2 = cards[j];<br>                vector&lt;<span class="hljs-keyword">double</span>&gt; next;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">double</span> &amp;num : <span class="hljs-built_in">compute</span>(n1, n2)) &#123;<br>                    next.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 对于每一种符号单独记录状态 dfs</span><br>                    next.<span class="hljs-built_in">push_back</span>(num);<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; cards.<span class="hljs-built_in">size</span>(); ++k) &#123;<br>                        <span class="hljs-keyword">if</span> (k != j &amp;&amp; k != i) next.<span class="hljs-built_in">push_back</span>(cards[k]); <span class="hljs-comment">// 更新了next的状态[不能用重复的]</span><br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">helper</span>(next)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 都不行那就是false</span><br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judgePoint24</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; cards)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">double</span>&gt;<span class="hljs-built_in">dcards</span>(cards.<span class="hljs-built_in">begin</span>(), cards.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(dcards);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="133-克隆图"><a class="markdownIt-Anchor" href="#133-克隆图"></a> 133、克隆图</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    vector&lt;Node*&gt; neighbors;</span><br><span class="hljs-comment">    Node() &#123;</span><br><span class="hljs-comment">        val = 0;</span><br><span class="hljs-comment">        neighbors = vector&lt;Node*&gt;();</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        neighbors = vector&lt;Node*&gt;();</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        neighbors = _neighbors;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;Node*, Node*&gt; mp; <span class="hljs-comment">// 这个就是 原本 和 生成的映射</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">cloneGraph</span><span class="hljs-params">(Node* node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> node;<br>        <span class="hljs-keyword">if</span> (!mp.<span class="hljs-built_in">count</span>(node)) &#123; <span class="hljs-comment">// 没有遍历过 再处理</span><br>            mp[node] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(node-&gt;val, &#123;&#125;);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> neighbor : node-&gt;neighbors) &#123;<br>                mp[node]-&gt;neighbors.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">cloneGraph</span>(neighbor)); <span class="hljs-comment">// 每次获得的是处理好的点</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> mp[node]; <span class="hljs-comment">// 获得原本节点克隆节点 返回</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/">算法练习</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/05/03/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Linux高性能服务器编程</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/09/leecode/">
                        <span class="hidden-mobile">Leecode Top200</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
