

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="第1章 TCP&#x2F;IP协议族  1.1 TCP&#x2F;IP协议族体系结构以及主要协议   1.1.1 数据链路层 ARP和RARP协议实现了IP地址和机器物理地址(通 常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址) 之间的相互转换  ARP协议（Address Resolve Protocol，地址解析协议） 网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻址一台机器，">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux高性能服务器编程">
<meta property="og:url" content="http://example.com/2022/05/03/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第1章 TCP&#x2F;IP协议族  1.1 TCP&#x2F;IP协议族体系结构以及主要协议   1.1.1 数据链路层 ARP和RARP协议实现了IP地址和机器物理地址(通 常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址) 之间的相互转换  ARP协议（Address Resolve Protocol，地址解析协议） 网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻址一台机器，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071505040.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071505484.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071504810.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052119363.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052118653.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052118513.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052119640.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052120702.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052117137.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052125476.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052126399.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052130947.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052133025.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071553191.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205072139077.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205072159863.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205081527791.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205081554166.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091446138.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091501261.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091506319.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091514830.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091554080.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091554401.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091600766.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091629187.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091633489.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091654334.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091740284.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091833324.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205092023605.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205121608151.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205131634108.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142122368.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142127783.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142147580.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142150680.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142153207.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142156591.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142201066.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205161643321.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205161712755.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205161827241.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205162120269.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205162146797.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205172044910.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205181750387.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205172102909.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205172105793.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205182136344.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205182140957.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205182200198.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205192105914.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205201338156.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205201347161.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205201348081.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205201626146.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205210748418.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205210756313.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205210800519.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205210803060.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205210959142.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205211008893.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205211014062.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205211145639.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205211150756.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221725664.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221726905.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221731291.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221752179.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221752817.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221754982.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221757761.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221759451.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221839581.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221901531.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221910960.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222157650.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222203553.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222213581.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222214153.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222218451.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222224608.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222230567.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222236451.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205230716467.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205230718544.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205231548114.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205231802604.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205231803566.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205241029029.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205241738695.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205241812903.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205252115522.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205252154043.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205271456734.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205271456772.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205271530985.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205271540984.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205272125344.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205281724469.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205281745151.png">
<meta property="article:published_time" content="2022-05-02T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-28T13:07:53.039Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071505040.png">
  
  <title>Linux高性能服务器编程 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>PanPan</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/Title%20page/title.jpeg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Linux高性能服务器编程">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-05-03 00:00" pubdate>
        2022年5月3日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      222k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      693 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Linux高性能服务器编程</h1>
            
            <div class="markdown-body">
              <h1 id="第1章-tcpip协议族"><a class="markdownIt-Anchor" href="#第1章-tcpip协议族"></a> 第1章 TCP/IP协议族</h1>
<h2 id="11-tcpip协议族体系结构以及主要协议"><a class="markdownIt-Anchor" href="#11-tcpip协议族体系结构以及主要协议"></a> 1.1 TCP/IP协议族体系结构以及主要协议</h2>
<img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071505040.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-07 下午3.05.28" style="zoom:200%;" />
<h3 id="111-数据链路层"><a class="markdownIt-Anchor" href="#111-数据链路层"></a> 1.1.1 数据链路层</h3>
<p><strong>ARP和RARP协议</strong>实现了IP地址和机器物理地址(通 常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址) 之间的相互转换</p>
<h4 id="arp协议address-resolve-protocol地址解析协议"><a class="markdownIt-Anchor" href="#arp协议address-resolve-protocol地址解析协议"></a> ARP协议（Address Resolve Protocol，地址解析协议）</h4>
<p>网络层使用<strong>IP地址</strong>寻址一台机器，而数据链路层使用<strong>物理地址</strong>寻址一台机器，因此网络层必须先将目标机器的<u>IP地址转化成其物理地址</u>，才能使用数据链路层提供的服务。</p>
<h4 id="rarp协议reverse-address-resolve-protocol逆地址解析协议"><a class="markdownIt-Anchor" href="#rarp协议reverse-address-resolve-protocol逆地址解析协议"></a> RARP协议(Reverse Address Resolve Protocol，逆地址解析协议)</h4>
<p>用于网络上的某些无盘工作站。因为缺乏存储设备，无盘工作站无法记住自己的IP地址，但它们可以利用网卡上的物理地址来向网络管理者(服务器或网络管理软件)查询自身的IP地址。</p>
<p>PS：运行RARP服 务的网络管理者通常存有该网络上所有机器的物理地址到IP地址的映射。</p>
<h3 id="112-网络层"><a class="markdownIt-Anchor" href="#112-网络层"></a> 1.1.2 网络层</h3>
<p>网络层实现数据包的选路和转发。</p>
<p>通信的两台主机一般<u>不是直接相连</u>的，而是通过多个中间节点(路由器)连接的就是选择这些中间节点，以确定两台主机之间的通信路径。同时，网络层对上层协议<u>隐藏了网络拓扑连接</u>的细节，使得在<u>传输层和网络应用程序</u><u>看来，通信的双方是直接相连</u>的。</p>
<h4 id="ip协议internet-protocol因特网协议"><a class="markdownIt-Anchor" href="#ip协议internet-protocol因特网协议"></a> IP协议（Internet Protocol，因特网协议）</h4>
<p>step 1: IP协议<strong>根据数据包的目的IP地址</strong>来决定如何投递它。</p>
<p>step 2: 如果数据包<u>不能直接发送</u>给目标主机，那么IP协议就为它<strong>寻找一个合适的下一跳(next hop)<strong>路由器，并将数据包</strong>交付给该路由器</strong>来转发。</p>
<p>重复step1、2直到最后发送到目的地，或者由于发送失败而丢弃。</p>
<p>PS：IP协议使用逐跳(hop by hop)的方式确定通信路径</p>
<h4 id="icmp协议internet-control-message-protocol-因特网控制报文协议"><a class="markdownIt-Anchor" href="#icmp协议internet-control-message-protocol-因特网控制报文协议"></a> ICMP协议（Internet Control Message Protocol， 因特网控制报文协议）</h4>
<p>它是IP协议的重要补充，主要用于<strong>检测网络连接</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071505484.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-07 下午3.04.44" /></p>
<p>主要分两种：1）用来回应网络错误 2）用来查询网络信息如ping程序</p>
<p>ICMP协议并非严格意义上的网络层协议，因为它使用处于同一层的IP协议提供的服务(一般来说，上层协议使用下层协议提供的服务)。</p>
<h3 id="113-传输层"><a class="markdownIt-Anchor" href="#113-传输层"></a> 1.1.3 传输层</h3>
<p>传输层为两台主机上的应用程序提供<strong>端到端(end to end)<strong>的通信。与网络层使用的逐跳通信方式不同，传输层</strong>只关心通信的起始端和目的端，而不在乎数据包的中转过程</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071504810.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-07 下午3.04.16" /></p>
<p>垂直的实线箭头表示TCP/IP协议族各层之间的<strong>实体通信</strong>，而水平的虚线箭头表示<strong>逻辑通信线路</strong>。该图中还附带描述了<strong>不同物理网络的连接方法</strong>。可见，数据链路层(驱动程序)<strong>封装了物理网络的电气细节</strong>;网络层<strong>封装了网络连接</strong>的细节;传输层则为应用程序<strong>封装了一条端到端的逻辑通信链路</strong>，它负责数据<u>的收发、链路的超时重连</u>等。</p>
<h4 id="tcp协议transmission-control-protocol传输控制协议"><a class="markdownIt-Anchor" href="#tcp协议transmission-control-protocol传输控制协议"></a> TCP协议(Transmission Control Protocol，传输控制协议)</h4>
<p>1、为应用层提供<u>可靠的、面向连接的和基于流(stream)</u>的服务。</p>
<p>2、TCP协议使用<u>超时重传、数据确认</u>等方式来<strong>确保数据包被正确地发送至目的端</strong>，因此TCP服务是<strong>可靠</strong>的。</p>
<p>3、使用TCP协议通信的双方必须<strong>先建立TCP连接</strong>， 并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等。</p>
<p>4、当通信结束时，双方必须关闭连接以释放这些内核数据。</p>
<p>5、TCP服务是基于流的。<strong>基于流的数据没有边界(长度)限制</strong>，它<u>源源不断地从通信的一端流入另一端</u>。</p>
<p>6、发送端可以逐个 字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出。</p>
<h4 id="udp协议user-datagram-protocol用户数据报协议"><a class="markdownIt-Anchor" href="#udp协议user-datagram-protocol用户数据报协议"></a> UDP协议(User Datagram Protocol，用户数据报协议)</h4>
<p>它为应用层提供<u>不可靠、无连接和基于数据报</u>的服务。（与TCP完全相反）</p>
<p>1、<strong>“不可靠”<strong>意味着UDP协议无法保证数据从发送端正确地传送到目的端。如果数据在</strong>中途丢失</strong>，或者目的端通过数据校验<strong>发现数据错误而将其丢弃</strong>，则UDP协议只是<strong>简单地通知应用程序发送失败</strong>。因此，使用UDP协议的应用程序通常要<u>自己处理数据确认、超时重传</u>等逻辑。</p>
<p>2、UDP协议是无连接的，即<strong>通信双方不保持一个长久的联系</strong>，因此应用程序<strong>每次发送数据都要明确指定接收端的地址</strong>(IP地址等信息)。</p>
<p>3、基于数据报的服务，<u>是相对基于流的服务而言的</u>。每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其<u>所有内容一次性读出</u>，否则数据将被截断。</p>
<h4 id="sctp协议stream-control-transmission-protocol流控制传输协议"><a class="markdownIt-Anchor" href="#sctp协议stream-control-transmission-protocol流控制传输协议"></a> SCTP协议(Stream Control Transmission Protocol，流控制传输协议)</h4>
<p>是一种相对较新的传输层协议，它是为了在因特网上传输电话信号而设计的。</p>
<h3 id="114-应用层"><a class="markdownIt-Anchor" href="#114-应用层"></a> 1.1.4 应用层</h3>
<p>应用层负责处理应用程序的逻辑。</p>
<p>内核态：<u>数据链路层、网络层和传输层</u>负责处理网络通信细节，这部分必须既稳定又高效，因此它们都在内核空间中实现</p>
<p>用户态：应用层则在用户空间实现，因为它负责处理众多逻辑，比如文件传输、名称查询和网络管理等。</p>
<h4 id="ping应用程序"><a class="markdownIt-Anchor" href="#ping应用程序"></a> ping应用程序</h4>
<p>它利用ICMP报文检测网络连接，是调试网络环境的必备工具。</p>
<h4 id="telnet协议"><a class="markdownIt-Anchor" href="#telnet协议"></a> telnet协议</h4>
<p>它使我们能在本地完成远程任务</p>
<h4 id="ospfopen-shortest-path-first开放最短路径优先协议"><a class="markdownIt-Anchor" href="#ospfopen-shortest-path-first开放最短路径优先协议"></a> OSPF(Open Shortest Path First，开放最短路径优先)协议</h4>
<p>是一种动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由信息。</p>
<h4 id="dnsdomain-name-service域名服务协议"><a class="markdownIt-Anchor" href="#dnsdomain-name-service域名服务协议"></a> DNS(Domain Name Service，域名服务)协议</h4>
<p>提供机器域名到IP地址的转换，我们将在后面简要介绍DNS协议。</p>
<p>应用层协议(或程序)可能跳过传输层直接使用网络层提供的服务，比如ping程序和OSPF协议。应用层协议(或程序)通常既可以使用TCP服务，又可以使用UDP服务，比如DNS协议。我们可以通过/etc/services文件查看所有知名的应用层协议，以及它们都能使用哪些传输层服务。</p>
<h2 id="12-封装"><a class="markdownIt-Anchor" href="#12-封装"></a> 1.2 封装</h2>
<p>上层协议是如何使用下层协议提供的服务的呢?其实这是通过封装(encapsulation)实现的。</p>
<p>应用程序数据在发送到物理网络上之前， 将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加上自己的头部信息(有时还包括尾部信息)，以实现该层的功能， 这个过程就称为封装，如图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052119363.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.19.17" /></p>
<h3 id="121-tcp封装"><a class="markdownIt-Anchor" href="#121-tcp封装"></a> 1.2.1 TCP封装</h3>
<p>经过TCP封装后的数据称为<strong>TCP报文段(TCP message segment)</strong>，或者简称TCP段。</p>
<p>前文提到，TCP协议为通信双方维持一个连接，并且在内核中存储相关数据。这部分数据中的<strong>TCP头部信息</strong>和<strong>TCP内核缓冲区</strong>(发送缓冲区或接收缓冲区)<strong>数据</strong>一起构成了TCP报文段。</p>
<p>封装过程如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052118653.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.18.56" /></p>
<p>当发送端应用程序使用send(或者write)函数向一个TCP连接写入数据过程</p>
<p>1、内核中的TCP模块首先<u>把这些数据复制到与该连接对应的TCP</u>内核发送缓冲区中</p>
<p>2、TCP模块调用IP模块提供的服务，传递的参数包括TCP头部信息和TCP发送缓冲区中的数据，即TCP报文段。</p>
<h3 id="122-udp封装"><a class="markdownIt-Anchor" href="#122-udp封装"></a> 1.2.2 UDP封装</h3>
<p>经过UDP封装后的数据称为<strong>UDP数据报(UDP datagram)</strong>。</p>
<p>UDP 对应用程序数据的封装与TCP类似。不同的是，UDP<strong>无须为应用层数据保存副本</strong>，因为它提供的服务是<strong>不可靠的</strong>。</p>
<p>1、当一个UDP数据报被成功发送之后，UDP内核缓冲区中的该数据报就被丢弃了。</p>
<p>2、如果应用程序检测到该数据报未能被接收端正确接收，并打算<strong>重发</strong>这个数据报，则应用程序需要<u>重新从用户空间将该数据报拷贝到UDP内核发送缓冲区</u>中。</p>
<h3 id="123-ip封装"><a class="markdownIt-Anchor" href="#123-ip封装"></a> 1.2.3 IP封装</h3>
<p>经过IP封装后的数据称为<strong>IP数据报(IP datagram)</strong>。IP数据报也包括<strong>头部信息</strong>和数据部分，其中<u>数据</u>部分就是<u>一个TCP报文段、UDP数据 报或者ICMP报文</u>。</p>
<h3 id="124-数据链路层封装"><a class="markdownIt-Anchor" href="#124-数据链路层封装"></a> 1.2.4 数据链路层封装</h3>
<p>经过数据链路层封装的数据称为<strong>帧(frame)</strong>。传输媒介不同，帧的类型也不同。</p>
<p>比如，<strong>以太网</strong>上传输的是<strong>以太网帧(ethernet frame)</strong>， 而令牌环网络上传输的则是<strong>令牌环帧(token ring frame)</strong>。以以太网帧为例，其封装格式如图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052118513.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午6.16.14" /></p>
<p>以太网帧使用<strong>6字节</strong>的目的物理地址和6字节的源物理地址来表示通信的双方。<strong>4字节</strong>CRC字段对帧的其他部分提供循环冗余校验。</p>
<p><strong>帧的最大传输单元(Max Transmit Unit，MTU)</strong>，即帧<u>最多能携带多少上层协议数据</u>(比如IP数据报)，通常受到网络类型的限制。 图1-6所示的以太网帧的MTU是1500字节。正因为如此，过长的IP数据 报可能需要被分片(fragment)传输。</p>
<p>帧才是最终在物理网络上传送的字节序列。至此，封装过程完成。</p>
<h3 id="13-分用"><a class="markdownIt-Anchor" href="#13-分用"></a> 1.3 分用</h3>
<h3 id="131-分用的流程"><a class="markdownIt-Anchor" href="#131-分用的流程"></a> 1.3.1 分用的流程</h3>
<p>1、当帧到达目的主机时，将沿着协议栈自底向上依次传递。</p>
<p>2、各层协议依次处理帧中本层负责的头部数据，以获取所需的信息。</p>
<p>3、最终将处理后的帧交给目标应用程序。</p>
<p>这个过程称为<strong>分用 (demultiplexing)</strong>，我个人理解就是对于数据报的解析。</p>
<p>分用是依靠头部信息中的类型字段实现的。<u>标准文档RFC 1700</u>定义了所有标识上层协议的类型字段以及每个上层协议对应的数值。如图显示了以太网帧的<strong>分用过程</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052119640.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.19.35" /></p>
<h3 id="132-分用时如何区分协议"><a class="markdownIt-Anchor" href="#132-分用时如何区分协议"></a> 1.3.2 分用时如何区分协议</h3>
<p>因为IP协议、ARP协议和RARP协议都使用帧传输数据，所以帧的 头部需要提供某个字段(具体情况取决于帧的类型)来区分它们。</p>
<p>以以太网帧为例，它使用2字节的类型字段来标识上层协议封装图。 如果主机接收到的以太网帧类型字段的值为0x800，则帧的数据部分 <strong>IP数据报</strong>，以太网驱动程序就将帧交付给IP模块;若类型字段的值为0x806，则帧的数据部分为<strong>ARP</strong>请求或应答报文，以太网驱动程序就将帧交付给<strong>ARP模块</strong>;若类型字段的值为0x835，则帧的数据部分为<strong>RARP</strong>请求或应答报文，以太网驱动程序就将帧交付给<strong>RARP模块</strong>。</p>
<p>简单来说就是根据字节来识别判断什么协议做什么操作。</p>
<p>同样，因为<strong>ICMP协议</strong>、<strong>TCP协议</strong>和<strong>UDP协议</strong>都使用<strong>IP协议</strong>，所以IP数据报的头部采用16位的协议(protocol)字段来区分它们。</p>
<p>TCP报文段和UDP数据报则通过其头部中的16位的端口号(port number)字段来区分上层应用程序。比如DNS协议对应的端口号是53，HTTP协议(Hyper-Text Transfer Protocol，超文本传送协议)对应的端口号是80。所有知名应用层协议使用的端口号都可在/etc/services文件中找到。</p>
<p>帧通过上述分用步骤后，最终将封装前的原始数据送至目标服务 (上图中的ARP服务、RARP服务、ICMP服务或者应用程序)。这样，在顶层目标服务看来，封装和分用似乎没有发生过。<strong>解析交给各一层的东西，直接发送到各自的端口，所以看起来是封装的，端到端的。</strong></p>
<h2 id="14-测试网络"><a class="markdownIt-Anchor" href="#14-测试网络"></a> 1.4 测试网络</h2>
<p><strong>测试网络如下图所示</strong>，其中包括两台主机A和B，以及一个连接到因特网的路由器。如没有特别声明，所有测试硬件指的都是该网络。我们将使用机器名来标识测试机器。</p>
<p>![截屏2022-05-05 下午9.19.45](…/…/…/Library/Application Support/typora-user-images/截屏2022-05-05 下午9.19.45.png)</p>
<p>该测试网络主要用于分析<strong>ARP协议</strong>、<strong>IP协议</strong>、<strong>ICMP协议</strong>、<strong>TCP协议</strong>和<strong>DNS协议</strong>。我们通过抓取该网络上的以太网帧，查看其中的以太网帧头部、IP数据报头部、TCP报文段头部信息，以获取网络通信的细节。【对于路由器，我们仅列出了其LAN网络IP地址(192.168.1.1)，而 忽略了ISP(Internet Service Provider，因特网服务提供商)给它分配的WAN网络IP地址】</p>
<h2 id="15-arp协议工作原理"><a class="markdownIt-Anchor" href="#15-arp协议工作原理"></a> 1.5 ARP协议工作原理</h2>
<p>ARP协议能实现任意<strong>网络层地址</strong>到任意<strong>物理地址</strong>的转换，不过这里仅讨论从<strong>IP地址</strong>到**以太网地址(MAC地址)**的转换。</p>
<h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3>
<p>1、主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。</p>
<p>2、此网络上的其他机器都将收到这个请求，但<strong>只有</strong>被请求的目标机器会<u>回应一个ARP应答</u>，其中<strong>包含自己的物理地址</strong>。</p>
<h3 id="151-以太网arp请求应答报文"><a class="markdownIt-Anchor" href="#151-以太网arp请求应答报文"></a> 1.5.1 以太网ARP请求/应答报文</h3>
<p>以太网ARP请求/应答报文的格式如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052120702.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.20.13" /></p>
<p><strong>硬件类型字段</strong>：定义物理地址的类型，它的值为1表示MAC地址。</p>
<p><strong>协议类型字段</strong>：表示要映射的协议地址类型，它的值为0x800，表示IP地址。</p>
<p><strong>硬件地址长度字段</strong>和<strong>协议地址长度字段</strong>：顾名思义，其单位是字节。对MAC地址来说，其长度为6;对IP(v4)地址来说，其长度为4。</p>
<p><strong>操作字段</strong>：指出4种操作类型：ARP请求(值为1)、ARP应答(值 为2)、RARP请求(值为3)和RARP应答(值为4)。</p>
<p>最后4个字段指定<strong>通信双方的以太网地址</strong>和<strong>IP地址</strong>。</p>
<p>1、发送端填充除目的端以太网地址外的其他3个字段，以构建ARP请求并发送之。</p>
<p>2、接收端发现该请求的目的端IP地址是自己，就把自己的以太网地址填进去。</p>
<p>3、然后交换两个目的端地址和两个发送端地址，以构建ARP应答并返回之(当然，如前所述，操作字段需要设置为2)。</p>
<p>就是一个交互的小过程</p>
<p>由上图可知，ARP请求/应答报文的长度为28字节。如果再加上以太网帧头部和尾部的18字节(见图1-6)，则一个携带ARP请求/应答报文的以太网帧长度为46字节。不过有的实现要求以太网帧数据部分长度至少为46字节(见图1-4)，此时ARP请求/应答报文将增加一些填充字节，以满足这个要求。在这种情况下，一个携带ARP请求/应答报文的以太网帧长度为64字节。</p>
<h3 id="152-arp高速缓存的查看和修改"><a class="markdownIt-Anchor" href="#152-arp高速缓存的查看和修改"></a> 1.5.2 ARP高速缓存的查看和修改</h3>
<p>通常，ARP维护一个高速缓存，其中<strong>包含经常访问(比如网关地址)<strong>或</strong>最近访问的机器的IP地址到物理地址的映射</strong>。这样就<u>避免了重复的ARP请求</u>，提高了发送数据包的速度。</p>
<p>Linux下可以使用arp命令来查看和修改ARP高速缓存。比如， ernest-laptop在某一时刻(注意，ARP高速缓存是动态变化的)的ARP 缓存内容如下(使用<strong>arp -a</strong>命令):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Kongming20</span>(<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>)at <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>[ether]on eth0<br>?(<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>)at <span class="hljs-number">14</span>:e6:e4:<span class="hljs-number">93</span>:<span class="hljs-number">5b</span>:<span class="hljs-number">78</span>[ether]on eth0<br></code></pre></td></tr></table></figure>
<p>第一项描述的是另一台测试机器Kongming20(注意，其IP 地址、MAC地址都与上面的总图描述的一致)。</p>
<p>第二项描述的是路由器。下面两条命令则分别删除和添加一个ARP缓存项。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo arp -d <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>#删除Kongming20对应的ARP缓存项<br>$sudo arp -s <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>#添加Kongming20对应的 ARP缓存项<br></code></pre></td></tr></table></figure>
<h3 id="153-使用tcpdump观察arp通信过程"><a class="markdownIt-Anchor" href="#153-使用tcpdump观察arp通信过程"></a> 1.5.3 使用tcpdump观察ARP通信过程</h3>
<p>为了清楚地了解ARP的运作过程，我们从ernest-laptop上执行telnet 命令登录Kongming20的echo服务(已经开启)，并用tcpdump(详见第 17章)抓取这个过程中两台测试机器之间交换的以太网帧。具体的操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo arp -d <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>#清除ARP缓存中Kongming20对应的项<br>$sudo tcpdump -i eth0-ent<span class="hljs-number">&#x27;</span>(dst <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-keyword">and</span> src <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>) <span class="hljs-built_in"><span class="hljs-keyword">or</span></span><br>(dst <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-keyword">and</span> src <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>)<span class="hljs-string">&#x27;#如无特殊声明，抓包都在机器 ernest-laptop上执行</span><br><span class="hljs-string">$telnet 192.168.1.109 echo#开启另一个终端执行telnet命令 Trying 192.168.1.109...</span><br><span class="hljs-string">Connected to 192.168.1.109.</span><br><span class="hljs-string">Escape character is &#x27;</span>^]<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">^](回车)#输入Ctrl+]并回车 telnet&gt;quit(回车) Connection closed.</span><br></code></pre></td></tr></table></figure>
<p>1、在执行telnet命令之前，应先清除ARP缓存中与Kongming20对应的项，否则ARP通信不被执行，我们也就无法抓取到期望的以太网帧。</p>
<p>2、当执行telnet命令并在两台通信主机之间建立TCP连接后(telnet输 出“Connected to 192.168.1.109”)</p>
<p>3、输入Ctrl+]以调出telnet程序的命令提示符，然后在telnet命令提示符后输入quit，退出telnet客户端程序(因为ARP通信在TCP连接建立之前就已经完成，故我们不关心后续内容)。</p>
<p>4、tcpdump抓取到的众多数据包中，只有最靠前的两个和ARP通信有关系，现在将它们列出(数据包前面的编号是笔者加入的，后同):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.00</span>:<span class="hljs-number">16</span>:d3:<span class="hljs-number">5</span>c:b9:e3&gt;ff:ff:ff:ff:ff:ff,<span class="hljs-function">ethertype <span class="hljs-title">ARP</span><span class="hljs-params">(<span class="hljs-number">0x0806</span>)</span>,length 42:Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>,length <span class="hljs-number">28</span></span><br><span class="hljs-function"><span class="hljs-number">2.08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>&gt;<span class="hljs-number">00</span>:<span class="hljs-number">16</span>:d3:<span class="hljs-number">5</span>c:b9:e3,ethertype ARP(<span class="hljs-number">0x0806</span>),length <span class="hljs-number">60</span>:Reply <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> is-at <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>,length <span class="hljs-number">46</span></span><br></code></pre></td></tr></table></figure>
<p>由tcpdump<u>抓取的数据包</u>本质上是<strong>以太网帧</strong>，我们通过该命令的众多选项来控制帧的过滤(比如用dst和src指定通信的目的端IP地址和源端IP地址)和显示(比如用-e选项开启以太网帧头部信息的显示)。</p>
<p><strong>第一个数据包</strong>中，ARP通信的<strong>源端的物理地址</strong>是00:16:d3:5c:b9:e3(ernest-laptop)，<strong>目的端的物理地址</strong>是ff:ff:ff:ff:ff:ff， 这是以太网的广播地址，用以表示整个LAN。</p>
<p>1、该LAN上的所有机器都会收到并处理这样的帧。</p>
<p>2、数值0x806是以太网帧头部的类型字段的值， 它表示分用的目标是ARP模块。</p>
<p>3、该以太网帧的长度为42字节(实际上是46字节，tcpdump未统计以太网帧尾部4字节的CRC字段)，其中数据部分长度为28字节。</p>
<p>4、“Request”表示这是一个ARP请求，“who-has 192.168.1.109 tell 192.168.1.108”则表示是ernest-laptop要查询Kongming20的IP地址。</p>
<p><strong>第二个数据包</strong>中，ARP通信的<strong>源端的物理地址</strong>是 08:00:27:53:10:67(Kongming20)，<strong>目的端的物理地址</strong>是 00:16:d3:5c:b9:e3(ernest-laptop)。</p>
<p>1、“Reply”表示这是一个ARP应答，“192.168.1.109 is-at 08:00:27:53:10:67”则表示目标机器Kongming20 报告其物理地址。</p>
<p>2、该以太网帧的长度为60字节(实际上是64字节)， 可见它使用了填充字节来满足最小帧长度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052117137.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.16.56" /></p>
<p>1、我们将两次传输的以太网帧按照图1-6所描述的以太网帧封装格式绘制在图的下半部分。</p>
<p>2、ARP请求和应答是从<u>以太网驱动程序发出的，而并非像图中描述的那样从ARP模块直接发送到以太网上</u>，所以我们将它们用虚线表示，这主要是为了体现携带ARP数据的以太网帧和其他以太网帧 (比如携带IP数据报的以太网帧)的区别。</p>
<p>3、路由器也将接收到以太网帧1，因为该<strong>帧是一个广播帧</strong>。不过很显然，<u>路由器并没有回应其中的ARP请求</u>，正如前文讨论的那</p>
<p>样。</p>
<h2 id="16-dns工作原理"><a class="markdownIt-Anchor" href="#16-dns工作原理"></a> 1.6 DNS工作原理</h2>
<p>我们通常使用机器的<u>域名来访问</u>这台机器，而<u>不直接使用其IP</u>地址，比如访问因特网上的各种网站。那么如何将机器的域名转换成IP地址呢?这就需要使用域名查询服务。域名查询服务有很多种实现方式，比如NIS(Network Information Service，网络信息服务)、DNS和本地静态文件等。本节主要讨论DNS。</p>
<h3 id="161-dns查询和应答报文详解"><a class="markdownIt-Anchor" href="#161-dns查询和应答报文详解"></a> 1.6.1 DNS查询和应答报文详解</h3>
<p>DNS是一套分布式的域名服务系统。</p>
<p>每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且是动态更新的。</p>
<p>众多网络客户端程序都使用DNS协议来向DNS服务器查询目标主机的IP地址。</p>
<p>DNS查询和应答报文的格式如图1-11所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052125476.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.25.01" /></p>
<p>16位标识[1]字段用于标记一对<strong>DNS查询</strong>和<strong>应答</strong>，以此<u>区分一个DNS应答是哪个DNS查询的回应</u>。</p>
<p>16位标志字段用于<strong>协商具体的通信方式</strong>和<strong>反馈通信状态</strong>。DNS报文头部的16位标志字段的细节如图1-12所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052126399.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.26.22" /></p>
<p><strong>QR</strong>：查询/应答标志。0表示这是一个查询报文，1表示这是一个应答报文。</p>
<p><strong>opcode</strong>：定义查询和应答的类型。0表示标准查询，1表示反向查询(由IP地址获得主机域名)，2表示请求服务器状态。</p>
<p><strong>AA</strong>：授权应答标志，仅由应答报文使用。1表示域名服务器是授权服务器。</p>
<p><strong>TC</strong>：截断标志，仅当DNS报文使用UDP服务时使用。因为UDP数据报有长度限制，所以过长的DNS报文将被截断。1表示DNS报文超过512字节，并被截断。</p>
<p><strong>RD</strong>：递归查询标志。1表示执行递归查询，即如果目标DNS服务器无法解析某个主机名，则它将向其他DNS服务器继续查询，如此递 归，直到获得结果并把该结果返回给客户端。0表示执行迭代查询，即如果目标DNS服务器无法解析某个主机名，则它将自己知道的其他 DNS服务器的IP地址返回给客户端，以供客户端参考。</p>
<p><strong>RA</strong>：允许递归标志。仅由应答报文使用，1表示DNS服务器支持递归查询。</p>
<p><strong>zero</strong>：这3位未用，必须都设置为0。</p>
<p><strong>rcode</strong>：4位返回码，表示应答的状态。常用值有0(无错误)和3(域名不存在)。</p>
<p>接下来的4个字段则分别指出DNS报文的最后4个字段的资源记录数目。对<strong>查询报文</strong>而言，它一般包含1个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。<strong>应答报文</strong>的应答资源记录数则至少为1，而授权资源记录数和额外资源记录数可为0或非0。</p>
<p>查询问题的格式如图1-13所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052130947.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.30.27" /></p>
<p><strong>查询名</strong>以<u>一定的格式封装了要查询的主机域名</u>。16位查询类型表示如何执行查询操作，常见的类型有如下几种:</p>
<p>类型A：值是1，表示获取目标主机的IP地址。</p>
<p>类型CNAME：值是5，表示获得目标主机的别名。</p>
<p>类型PTR：值是12，表示反向查询。</p>
<p><strong>16位查询类</strong>：通常为1，表示获取因特网地址(IP地址)。</p>
<p>应答字段、授权字段和额外信息字段都使用资源记录(Resource Record，RR)格式。资源记录格式如图1-14所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052133025.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.33.13" /></p>
<p><strong>32位域名</strong>：是该记录中与资源对应的名字，其格式和查询问题中的查询名字段相同。</p>
<p><strong>16位类型</strong>和<strong>16位类</strong>字段：含义也与DNS查询问题的对应字段相同。</p>
<p><strong>32位生存时间</strong>：表示该查询记录结果可被本地客户端程序缓存多长时间，单位是秒。</p>
<p><strong>16位资源数据长度字段和资源数据字段</strong>：的内容取决于类型字段对类型A而言，资源数据是32位的IPv4地址，而资源数据长度则为 4(以字节为单位)。</p>
<p>至此，我们简要地介绍了DNS协议。我们将在后面给出一个DNS通信的具体例子。DNS协议的更多细节请参考其RFC文档(DNS协议 存在诸多RFC文档，每个RFC文档介绍其一个侧面，比如RFC 1035介绍的是域名的实现和规范，RFC 1886则描述DNS协议对IPv6的扩展支 持)。</p>
<h3 id="162-linux下访问dns服务"><a class="markdownIt-Anchor" href="#162-linux下访问dns服务"></a> 1.6.2 Linux下访问DNS服务</h3>
<p>我们要访问DNS服务，就必须先知道DNS服务器的IP地址。Linux 使用/etc/resolv.conf文件来存放DNS服务器的IP地址。机器ernest-laptop上，该文件的内容如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">#Generated by Network Manager<br> nameserver <span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><br> nameserver <span class="hljs-number">124.207</span><span class="hljs-number">.160</span><span class="hljs-number">.106</span><br></code></pre></td></tr></table></figure>
<p>其中的两个IP地址分别是<strong>首选DNS服务器地址</strong>和<strong>备选DNS服务器</strong>地址。</p>
<p>文件中的注释语句“Generated by Network Manager”告诉我们，这<u>两个DNS服务器地址是由网络管理程序写入</u>的。</p>
<p>Linux下一个常用的<strong>访问DNS服务器的客户端程序</strong>是host，比如下面的命令是<u>向首选DNS服务器219.239.26.42查询</u>机器www.baidu.com的IP地址:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">$host -t A www.baidu.com<br>www.baidu.com is an alias <span class="hljs-keyword">for</span> www.a.shifen.com.<br>www.a.shifen.com has address <span class="hljs-number">119.75</span><span class="hljs-number">.217</span><span class="hljs-number">.56</span><br>www.a.shifen.com has address <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><br></code></pre></td></tr></table></figure>
<p>1、host命令的输出告诉我们，机器名www.baidu.com是 www.a.shifen.com.的<strong>别名</strong>（alias），并且该机器名对应两个IP地址。</p>
<p>2、host命令使用<strong>DNS协议</strong>和<strong>DNS服务器通信</strong>，其-t选项<u>告诉DNS协议使用哪种查询类型</u>。</p>
<p>3、我们这里使用的是<strong>A类型</strong>，即<strong>通过机器的域名获得其IP地址</strong>(但实际上返回的资源记录中还包含机器的别名)。</p>
<h3 id="163-使用tcpdump观察dns通信过程"><a class="markdownIt-Anchor" href="#163-使用tcpdump观察dns通信过程"></a> 1.6.3 使用tcpdump观察DNS通信过程</h3>
<p>为了看清楚DNS通信的过程，下面我们将从ernest-laptop上运行<strong>host命令</strong>以查询主机www.baidu.com对应的IP地址，并使用<strong>tcpdump抓取</strong>这一过程中<u>LAN上传输的以太网帧</u>。具体的操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -i eth0 -nt -s <span class="hljs-number">500</span> port domain<br>$host -t A www.baidu.com<br></code></pre></td></tr></table></figure>
<p>这一次执行tcpdump抓包时，我们使用“port domain”来过滤数据包，表示<u>只抓取使用domain(域名)服务的数据包</u>，即DNS查询和应答报文。tcpdump的输出如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34319</span> &gt; <span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><span class="hljs-number">.53</span>: <span class="hljs-number">57428</span>+ A? www.baidu.com. (<span class="hljs-number">31</span>)<br><span class="hljs-number">2.</span>IP <span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><span class="hljs-number">.53</span> &gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34319</span>: <span class="hljs-number">57428</span> <span class="hljs-number">3</span>/<span class="hljs-number">4</span>/<span class="hljs-number">4</span> CNAME www.a.shifen.com.,A <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span>,A <span class="hljs-number">119.75</span><span class="hljs-number">.217</span><span class="hljs-number">.56</span>(<span class="hljs-number">226</span>)<br></code></pre></td></tr></table></figure>
<p>1、这两个数据包开始的“IP”指出，它们后面的内容描述的是<strong>IP数据报</strong>。</p>
<p>2、tcpdump以“<strong>IP地址.端口号</strong>”的形式来描述通信的某一端。</p>
<p>3、以“&gt;”表 示数据传输的方向，“&gt;”前面是<strong>源端</strong>，后面是<strong>目的端</strong>。</p>
<p>4、可见，第一个数据包是测试机器ernest-laptop(IP地址是192.168.1.108)向其首选DNS服务器(IP地址是219.239.26.42)发送的<strong>DNS查询报文</strong>(目标端口53是<strong>DNS服务使用的端口</strong>，这一点我们在前面介绍过)，第二个数据包是<strong>服务器反馈的DNS应答报文</strong>。</p>
<p><strong>第一个数据包中</strong>：</p>
<p>数值57428是<strong>DNS查询报文</strong>的标识值，因此该值也出现在<strong>DNS应答报文</strong>中。“+”表示启用<strong>递归查询标志</strong>。“A?”表示使用<strong>A类型的查询方式</strong>。“<a target="_blank" rel="noopener" href="http://www.baidu.com">www.baidu.com</a>”则是<strong>DNS查询问题中的查询名</strong>。 括号中的数值31是DNS查询报文的长度(以字节为单位)。</p>
<p><strong>第二个数据包中</strong>：</p>
<p>“3/4/4”表示该报文中包含<strong>3个应答资源记录</strong>、<strong>4 个授权资源记录</strong>和<strong>4个额外信息记录</strong>。“CNAME <a target="_blank" rel="noopener" href="http://www.a.shifen.com">www.a.shifen.com</a>.，A 119.75.218.77，A 119.75.217.56”则表示3个应答资源记录的内容。其中<strong>CNAME表示紧随其后的记录是机器的别名</strong>，<strong>A表示紧随其后的记录是IP地址</strong>。该应答报文的长度为226字节。</p>
<p>PS：我们抓包的时候没有开启tcpdump的-X选项(或者-x选 项)。如果使用-X选项，我们将能看到DNS报文的每一个字节，也就 能明白上面31字节的查询报文和226字节的应答报文的具体含义。</p>
<h2 id="17-socket和tcpip协议族的关系"><a class="markdownIt-Anchor" href="#17-socket和tcpip协议族的关系"></a> 1.7 socket和TCP/IP协议族的关系</h2>
<p>由于<u>数据链路层、网络层、传输层</u>协议是在<strong>内核</strong>中实现的。因此<strong>操作系统</strong>需要实现一组系统调用，使得应用程序能够访问这些协议提供的服务。实现这组系统调用的**API(Application Programming Interface，应用程序编程接口)**主要有两套:<strong>socket</strong>和 XTI。<u>XTI现在基本不再使用</u>，所以这里仅讨论socket，如图1-1显示了socket与TCP/IP协议族的关系。</p>
<p>由socket定义的这一组API提供如下两点功能:</p>
<p>1、将应用程序数据从<u>用户缓冲区中复制到TCP/UDP内核发送缓冲区</u>，以<u>交付内核来发送数据</u>(比如图1-5所示的send函数)，或者是<u>从内核TCP/UDP接收缓冲区中复制数据到用户缓冲区</u>，以读取数据。</p>
<p>2、应用程序可以通过它们来<u>修改内核中各层协议的某些头部信息或其他数据结构</u>，从而精细地<u>控制底层通信</u>的行为。比如可以通过setsockopt函数来<u>设置IP数据报在网络上的存活时间</u>。</p>
<p>socket是一套通用网络编程接口，它不但可以访问内核中TCP/IP协议栈，而且可以访问其他网络协议栈(比如X.25协议栈、UNIX本地域协议栈等)。</p>
<h1 id="第2章-ip协议详解"><a class="markdownIt-Anchor" href="#第2章-ip协议详解"></a> 第2章 IP协议详解</h1>
<p>IP协议是TCP/IP协议族的<strong>核心协议</strong>，也是socket网络编程的基础之一。本章从两个方面较为深入地探讨IP协议:</p>
<p><strong>IP头部信息</strong>：IP头部信息出现在每个IP数据报中，用于指定IP通信的源端IP地址、目的端IP地址，指导IP分片和重组，以及指定部分通信行为。</p>
<p><strong>IP数据报的路由和转发</strong>：IP数据报的路由和转发发生在除目标机器之外的所有主机和路由器上。它们决定数据报<u>是否应该转发</u>以及<u>如何转发</u>。</p>
<p>由于32位表示的IP地址即将全部使用完，因此人们开发出了新版本的IP协议，称为IPv6协议，而原来的版本则称为IPv4协议。本章前面部分的讨论都是基于IPv4协议的，只在最后一节简要讨论IPv6协议。</p>
<h2 id="21-ip服务的特点"><a class="markdownIt-Anchor" href="#21-ip服务的特点"></a> 2.1 IP服务的特点</h2>
<p>IP协议是TCP/IP协议族的动力，它为上层协议提供<u>无状态、无连接、不可靠</u>的服务。</p>
<h3 id="无状态stateless"><a class="markdownIt-Anchor" href="#无状态stateless"></a> 无状态(stateless)</h3>
<p><strong>IP通信双方不同步传输数据的状态信息</strong>， 因此所有IP数据报的发送、传输和接收都是<u>相互独立、没有上下文关系</u>的。</p>
<p>这种服务最大的<strong>缺点</strong>是无法处理乱序和重复的IP数据报。比如发送端发送出的第N个IP数据报可能比第N+1个IP数据报后到达接收端，而同一个IP数据报也可能经过不同的路径多次到达接收端。在这两种情况下，接收端的IP模块无法检测到乱序和重复，因为这些IP数据报之间没有任何上下文关系。</p>
<p>接收端的IP模块只要收到了<strong>完整</strong>的IP数据报(如果是IP分片的话，IP模块将先执行重组)，就将其数据部分(TCP报文段、UDP数据报或者ICMP报文)上交给上层协议。那么<strong>从上层协议来看</strong>，这些数据就可能是<u>乱序的、重复</u>的。</p>
<p>面向连接的协议，比如<strong>TCP协议</strong>，则能够自己处理乱序的、重复的报文段，它递交给上层协议的内容绝对是<strong>有序的、正确</strong>的。</p>
<p>虽然IP数据报头部提供了一个<strong>标识</strong>字段(见后文)用以唯一标识一个IP数据报，但它是被用来<strong>处理IP分片和重组</strong>的，而<strong>不是用来指示接收顺序</strong>的。</p>
<p>无状态服务的优点也很明显:<strong>简单、高效</strong>。我们无须为保持通信的状态而分配一些内核资源，也无须每次传输数据时都携带状态信息。在网络协议中，无状态是很常见的，比如<u>UDP协议和HTTP协议都是无状态协议</u>。以HTTP协议为例，一个浏览器的连续两次网页请求之间没有任何关联，它们将被Web服务器独立地处理。</p>
<h3 id="无连接connectionless"><a class="markdownIt-Anchor" href="#无连接connectionless"></a> 无连接(connectionless)</h3>
<p>IP通信双方都<strong>不长久地维持</strong>对方的任何信息。这样，上层协议<strong>每次</strong>发送数据的时候，都必须<strong>明确指定</strong>对方的IP地址。</p>
<h3 id="不可靠"><a class="markdownIt-Anchor" href="#不可靠"></a> 不可靠</h3>
<p>IP协议<strong>不能保证</strong>IP数据报准确地到达接收端，它只是承诺尽最大努力(best effort)。</p>
<p>很多种情况都能导致IP数据报发送失败。比如，某个中转路由器发现IP数据报在网络上存活的时间太长(根据IP数据报头部字段TTL判断，见后文)，那么它将丢弃之，并返回一个ICMP错误消息(超时错误)给发送端。</p>
<p>又比如，接收端发现收到的IP数据报不正确(通过校验机制)，它也将丢弃之，并返回一个ICMP错误消息(IP头部参数错误)给发送端。</p>
<p>无论哪种情况，发送端的IP模块一旦检测到IP数据报发送失败，就通知上层协议发送失败，而不会试图重传。因此，使用IP服务的上层协议(比如TCP协 议)需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。</p>
<h2 id="22-ipv4头部结构"><a class="markdownIt-Anchor" href="#22-ipv4头部结构"></a> 2.2 IPv4头部结构</h2>
<h3 id="221-ipv4头部结构"><a class="markdownIt-Anchor" href="#221-ipv4头部结构"></a> 2.2.1 IPv4头部结构</h3>
<p>IPv4的头部结构如图2-1所示。其长度通常为20字节，除非含有可变长的选项部分。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071553191.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-07 下午3.53.42" /></p>
<p><strong>4位版本号(version)</strong>：指定IP协议的版本。对IPv4来说，其值是4。其他IPv4协议的扩展版本(如SIP协议和PIP协议)，则具有不同的版本号(它们的头部结构也和图2-1不同)。</p>
<p><strong>4位头部长度(header length)</strong>：标识该IP头部有多少个32bit字(4字 节)。因为4位最大能表示15，所以IP头部最长是60字节。</p>
<p><strong>8位服务类型(Type Of Service，TOS)</strong>：包括一个3位的优先权字段 (现在已经被忽略)，4位的TOS字段和1位保留字段(必须置0)。4位的TOS字段分别表示:最小延时，最大吞吐量，最高可靠性和最小费用。其中最多有一个能置为1，应用程序应该根据实际需要来设置它。 比如像ssh和telnet这样的登录程序需要的是最小延时的服务，而文件传输程序ftp则需要最大吞吐量的服务。</p>
<p><strong>16位总长度(total length)</strong>：整个IP数据报的长度，以字节为单位，因此IP数据报的最大长度为65 535(216-1)字节。但由于MTU的限制，长度超过MTU的数据报都将被分片传输，所以实际传输的IP数据报(或分片)的长度都远远没有达到最大值。接下来的3个字段则描述了如何实现分片。</p>
<p><strong>16位标识(identification)</strong>：唯一地标识主机发送的每一个数据报。 其初始值由系统随机生成;每发送一个数据报，其值就<strong>加1</strong>。该值在数 据报分片时被<strong>复制</strong>到每个分片中，因此<u>同一个数据报的所有分片都具有相同</u>的标识值。</p>
<p><strong>3位标志字段</strong>：第一位保留。第二位(Don’t Fragment，DF)表示“禁止分片”。如果设置了这个位，IP模块将不对数据报进行分片。在这种情况下，如果IP数据报长度超过MTU的话，IP模块将丢弃该数据报并返回一个ICMP差错报文。第三位(More Fragment，MF)表示“更多分片”。除了数据报的最后一个分片外，其他分片都要把它置1。</p>
<p><strong>13位分片偏移(fragmentation offset)</strong>：分片相对原始IP数据报开始处(仅指数据部分)的偏移。实际的偏移值是该值左移3位(乘8)后得到的。由于这个原因，除了最后一个IP分片外，每个IP分片的数据部分的长度必须是<strong>8的整数倍</strong>(这样才能保证后面的IP分片拥有一个合适的偏移值)。</p>
<p><strong>8位生存时间(Time To Live，TTL)</strong>：数据报到达目的地之前允许经过的路由器跳数。TTL值被发送端设置(常见的值是64)。数据报在转发过程中每经过一个路由，该值就被路由器减1。当TTL值减为0时，路由器将丢弃数据报，并向源端发送一个ICMP差错报文。TTL值可以 防止数据报陷入路由循环。</p>
<p><strong>8位协议(protocol)</strong>：用来区分上层协议，我们在第1章讨论过。/etc/protocols文件定义了所有上层协议对应的protocol字段的数值。 其中，ICMP是1，TCP是6，UDP是17。/etc/protocols文件是RFC 1700的一个子集。</p>
<p><strong>16位头部校验和(header checksum)</strong>：由发送端填充，接收端对其使用<u>CRC算法以检验IP数据报头部</u>(注意，<strong>仅检验头部</strong>)在传输过程中是否损坏。</p>
<p><strong>32位的源端IP地址和目的端IP地址</strong>：用来标识数据报的发送端和接收端。一般情况下，这两个地址在整个数据报的传递过程中保持不变，而不论它中间经过多少个中转路由器。关于这一点，我们将在第4章进一步讨论。</p>
<p><strong>IPv4最后一个选项字段(option)</strong>：是可变长的可选信息。这部分最多包含40字节，因为IP头部最长是60字节(其中还包含前面讨论的20字节的固定部分)。可用的IP选项包括:</p>
<p>1、记录路由(record route)，告诉数据报途经的所有路由器都将自己的IP地址填入IP头部的选项部分，这样我们就可以跟踪数据报的传递 路径。</p>
<p>2、时间戳(timestamp)，告诉每个路由器都将数据报被转发的时间(或时间与IP地址对)填入IP头部的选项部分，这样就可以测量途经路由之间数据报传输的时间。</p>
<p>3、松散源路由选择(loose source routing)，指定一个路由器IP地址列表，数据报发送过程中必须经过其中所有的路由器。</p>
<p>4、严格源路由选择(strict source routing)，和松散源路由选择类似，不过数据报只能经过被指定的路由器。</p>
<h3 id="222-使用tcpdump观察ipv4头部结构"><a class="markdownIt-Anchor" href="#222-使用tcpdump观察ipv4头部结构"></a> 2.2.2 使用tcpdump观察IPv4头部结构</h3>
<p>为了深入理解IPv4头部中每个字段的含义，我们从测试机器ernest-laptop上<u>执行telnet命令登录本机</u>，并用tcpdump抓取这个过程中telnet客户端程序和telnet服务器程序之间交换的数据包。具体的操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -ntx -i lo #抓取本地回路上的数据包<br>$telnet <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>#开启另一个终端执行telnet命令登录本机 Trying <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>...<br>Connected to <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>.<br>Escape character is<span class="hljs-number">&#x27;</span>^]<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">Ubuntu 9.10</span><br><span class="hljs-string">ernest-laptop login:ernest#输入用户名并回车 Password:#输入密码并回车</span><br></code></pre></td></tr></table></figure>
<p>此时观察tcpdump输出的第一个数据包，其内容如代码清单2-1所示。</p>
<p>代码清单2-1 用tcpdump抓取数据包</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.41621</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[S],seq <span class="hljs-number">3499745539</span>,win <span class="hljs-number">32792</span>,<br>   options[mss <span class="hljs-number">16396</span>,sackOK,TS val <span class="hljs-number">40781017</span> ecr <span class="hljs-number">0</span>,nop,wscale<br><span class="hljs-number">6</span>],length <span class="hljs-number">0</span><br>   <span class="hljs-number">0x0000</span>:<span class="hljs-number">4510</span> <span class="hljs-number">003</span>c a5da <span class="hljs-number">4000</span> <span class="hljs-number">4006</span> <span class="hljs-number">96</span>cf <span class="hljs-number">7f</span>00 <span class="hljs-number">0001</span><br>   <span class="hljs-number">0x0010</span>:<span class="hljs-number">7f</span>00 <span class="hljs-number">0001</span> a295 <span class="hljs-number">0017</span> d099 e103 <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>   <span class="hljs-number">0x0020</span>:a002 <span class="hljs-number">8018</span> fe30 <span class="hljs-number">0000</span> <span class="hljs-number">0204</span> <span class="hljs-number">400</span>c <span class="hljs-number">0402</span> <span class="hljs-number">080</span>a<br></code></pre></td></tr></table></figure>
<p>该数据包描述的是一个<strong>IP数据报</strong>。由于我们是使<u>用telnet登录本机</u>的，所以IP数据报的<strong>源端IP地址</strong>和<strong>目的端IP地址</strong>都是“127.0.0.1”。telnet 服务器程序使用的端口号是23(参见/etc/services文件)，而telnet客户端程序使用临时端口号41621与服务器通信。关于临时端口号，我们将 在第3章讨论。“Flags”、“seq”、“win”和“options”描述的都是TCP头部信息，这也将在第3章讨论。“length”指出该IP数据报所携带的应用程序数据的长度。</p>
<p>这次抓包我们开启了tcpdump的-x选项，使之输出数据包的<strong>二进制码</strong>。此数据包共包含60字节，其中前20字节是IP头部，后40字节是TCP 头部，不包含应用程序数据(length值为0)。现在我们分析IP头部的每个字节，如表2-1所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205072139077.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-07 下午9.39.25" /></p>
<p>由表2-1可见，telnet服务选择<u>使用具有最小延时的服务</u>，并且默认<u>使用的传输层协议是TCP协议</u>(回顾第1章讨论的分用)。这些都符合我们通常的理解。这个IP数据报<u>没有被分片</u>，因为它没有携带任何应用程序数据。接下来我们将<u>抓取并讨论被分片的IP数据报</u>。</p>
<h2 id="23-ip分片"><a class="markdownIt-Anchor" href="#23-ip分片"></a> 2.3 IP分片</h2>
<p>前文曾提到，当IP数据报的长度<u>超过帧的MTU</u>时，它将被<u>分片传输</u>。分片<u>可能发生在发送端</u>，也可能<u>发生在中转路由器</u>上，而且可能在<u>传输过程中被多次</u>分片，但只有在<strong>最终的目标机器上，这些分片才会被内核中的IP模块重新组装</strong>。</p>
<p>IP头部中的如下三个字段给IP的分片和重组提供了足够的信息:数据报标识、标志和片偏移。一个IP数据报的每个分片都具有自己的IP头 部，它们具有相同的标识值，但具有不同的片偏移。并且除了最后一个分片外，其他分片都将设置MF标志。此外，每个分片的IP头部的总长度字段将被设置为该分片的长度。</p>
<p>以太网帧的MTU是1500字节(可以通过ifconfig命令或者netstat命令查看)，因此它携带的IP数据报的数据部分<strong>最多是1480字节</strong>(IP头部占用20字节)。考虑用IP数据报封装一个<strong>长度为1481字节</strong>的<strong>ICMP报文</strong> (包括8字节的ICMP头部，所以其数据部分长度为1473字节)，则该数据报在使用以太网帧传输时<strong>必须被分片</strong>，如图2-2所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205072159863.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-07 下午9.59.01" /></p>
<p>图2-2中，长度为1501字节的IP数据报被拆分成两个IP分片，第一个IP分片长度为1500字节，第二个IP分片的长度为21字节。每个IP分片 都包含自己的IP头部(20字节)，且第一个IP分片的IP头部<strong>设置了MF标志</strong>，而第二个IP分片的IP头部则<strong>没有设置该标志</strong>，因为它<strong>已经是最后 一个分片</strong>了。原始IP数据报中的ICMP头部内容<strong>被完整地复制</strong>到了第一个IP分片中。第二个IP分片<strong>不包含ICMP头部信息</strong>，因为IP模块重组该 ICMP报文的时候<strong>只需要一份ICMP头部</strong>信息，<u>重复传送这个信息没有任何益处</u>。1473字节的ICMP报文数据的前1472字节被IP模块复制到第一个IP分片中，使其总长度为1500字节，从而满足MTU的要求;而多出的最后1字节则被复制到第二个IP分片中。</p>
<p>需要指出的是，<strong>ICMP报文</strong>的<strong>头部长度取决于报文的类型</strong>，其变化范围很大。图2-2以8字节为例，因为后面的例子用到了ping程序，而 ping程序使用的ICMP回显和应答报文的头部长度是8字节。</p>
<p>为了看清楚IP分片的具体过程，考虑从ernest-laptop来ping机器Kongming20，每次传送1473字节的数据(<strong>这是ICMP报文的数据部分</strong>) 以强制引起IP分片，并用tcpdump抓取这一过程中双方交换的数据包。 具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -ntv -i eth0 icmp#只抓取ICMP报文<br>$ping Kongming20 -s <span class="hljs-number">1473</span>#用-s选项指定每次发送<span class="hljs-number">1473</span>字节的数据<br></code></pre></td></tr></table></figure>
<p>下面我们考察tcpdump输出的一个IP数据报的两个分片，其内容如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span><span class="hljs-built_in">IP</span>(tos <span class="hljs-number">0x0</span>,ttl <span class="hljs-number">64</span>,id <span class="hljs-number">61197</span>,offset <span class="hljs-number">0</span>,flags[+],proto <span class="hljs-built_in">ICMP</span>(<span class="hljs-number">1</span>),length <span class="hljs-number">1500</span>)<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.110</span>:ICMP echo request,id <span class="hljs-number">41737</span>,seq <span class="hljs-number">1</span>,length <span class="hljs-number">1480</span><br><span class="hljs-number">2.</span><span class="hljs-built_in">IP</span>(tos <span class="hljs-number">0x0</span>,ttl <span class="hljs-number">64</span>,id <span class="hljs-number">61197</span>,offset <span class="hljs-number">1480</span>,flags[none],proto <span class="hljs-built_in">ICMP</span>(<span class="hljs-number">1</span>),length <span class="hljs-number">21</span>)<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.110</span>:icmp<br></code></pre></td></tr></table></figure>
<p>这两个IP分片的标识值都是61197，说明它们是<strong>同一个IP数据报</strong>的分片。</p>
<p>第一个分片的片偏移值为0，而第二个则是1480。很显然，第二个分片的片<strong>偏移值</strong>实际上也是<strong>第一个分片的ICMP报文的长度</strong>。</p>
<p>第一个 分片设置了MF标志以<strong>表示还有后续分片</strong>，所以tcpdump输出“flags[+]”。</p>
<p>而第二个分片则<strong>没有设置任何标志</strong>，所以tcpdump输出“flags[none]”。</p>
<p>这个两个分片的长度分别为1500字节和21字节，这与图2-2描述的一致。</p>
<p>最后，IP层传递给数据链路层的数据可能是一个<u>完整的IP数据报</u>， 也<u>可能是一个IP分片</u>，它们统称为<strong>IP分组(packet)</strong>。本书如无特殊声 明，<strong>不区分IP数据报和IP分组</strong>。</p>
<h2 id="24-ip路由"><a class="markdownIt-Anchor" href="#24-ip路由"></a> 2.4 IP路由</h2>
<p>IP协议的一个核心任务是<strong>数据报的路由</strong>，即<u>决定发送数据报到目标机器的路径</u>。为了理解IP路由过程，我们先简要分析IP模块的基本工作流程。</p>
<h3 id="241-ip模块工作流程"><a class="markdownIt-Anchor" href="#241-ip模块工作流程"></a> 2.4.1 IP模块工作流程</h3>
<p>IP模块基本工作流程如图2-3所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205081527791.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-08 下午3.26.53" /></p>
<p>我们从右往左来分析图2-3。</p>
<p>1、当IP模块接收到来自数据链路层的IP数据报时，它首先对该数据报的头部做<strong>CRC校验</strong>，确认无误之后就分析其头部的具体信息。</p>
<p>2、如果该IP数据报的头部设置了<strong>源站选路选项</strong>(松散源路由选择或严格源路由选择)，则IP模块<u>调用数据报转发子模块来处理该数据报</u>。</p>
<p>3、如果该IP数据报的头部中目标IP地址是<u>本机的某个IP地址，或者是广播地址，即该数据报是发送给本机</u>的，则IP模块就根据数据报头部 中的协议字段来决定将它<strong>派发给哪个上层应用</strong>(分用)；如果IP模块发现这个数据报不是发送给本机的，则也<strong>调用数据报转发子模块</strong>来处理该数据报。</p>
<p>4、数据报转发子模块将首先检测系统<strong>是否允许转发</strong>，如果不允许，IP模块就将数据报丢弃。如果允许，数据报转发子模块将对该数据报 执行一些操作，然后将它交给IP数据报输出子模块。</p>
<p>5、IP数据报应该发送至哪个下一跳路由(或者目标机器)，以及经过哪个网卡来发送，就是IP路由过程，即图2-3中“计算下一跳路由”子模块。IP模块实现数据报路由的<strong>核心数据结构是路由表</strong>。这个表<u>按照数据报的目标IP地址分类</u>，同一类型的IP数据报将被发往相同的下一跳 路由器(或者目标机器)。</p>
<p>IP输出队列中存放的是<strong>所有等待发送的IP数据报</strong>，其中除了需要转发的IP数据报外，还包括封装了本机上层数据(ICMP报文、TCP报文段和UDP数据报)的IP数据报。图2-3中的虚线箭头显示了路由表更新的过程。这一过程是指通过路由协议或者route命令调整路由表，使之更适应最新的网络拓扑结构，称为<strong>IP路由策略</strong>。</p>
<h3 id="242-路由机制"><a class="markdownIt-Anchor" href="#242-路由机制"></a> 2.4.2 路由机制</h3>
<p>要研究IP路由机制，需要先了解路由表的内容。我们可以使用<strong>route命令</strong>或<strong>netstat命令</strong>查看路由表。在测试机器ernest-laptop上执行 route命令，输出内容如代码清单2-2所示。</p>
<p>代码清单2-2 路由表实例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Kernel IP routing table<br>Destination Gateway Genmask Flags Metric Ref Use Iface<br><span class="hljs-keyword">default</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> UG <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> eth0<br><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>*<span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span> U <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> eth0<br></code></pre></td></tr></table></figure>
<p>该路由表包含两项，每项都包含8个字段，如表2-2所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205081554166.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-08 下午3.54.38" /></p>
<p>1、第一项的目标地址是default，即所谓的默认路由项。该项包含一个“G”标志，说明路由的下一跳目标是<strong>网关</strong>，其地址是192.168.1.1(这是测试网络中路由器的本地IP地址)。</p>
<p>2、另外一个路由项的目标地址是192.168.1.0，它指的是<strong>本地局域网</strong>。该路由项的网关地址为*，说明数据报不需要路由中转，可以直接发送到目标机器。</p>
<p>那么路由表是如何按照IP地址分类的呢?或者说给定数据报的目标IP地址，它将匹配路由表中的哪一项呢?这就是IP的路由机制，分为 3个步骤:</p>
<p>1)查找<strong>路由表</strong>中和<strong>数据报的目标IP地址</strong>完全<strong>匹配</strong>的主机IP地址。 如果找到，就使用该路由项，没找到则转步骤2。</p>
<p>2)查找路由表中和数据报的目标IP地址具有相同<strong>网路ID的网络IP地址</strong>(比如代码清单2-2所示的路由表中的第二项)。如果找到，就使用该路由项;没找到则转步骤3。（这相当于在同一个网关）</p>
<p>3)选择默认路由项，这通常意味着数据报的下一跳路由是网关。</p>
<p>因此，对于测试机器ernest-laptop而言，所有发送到IP地址为192.168.1.*的机器的IP数据报都可以直接发送到目标机器(匹配路由表第二项)，而所有访问因特网的请求都将通过网关来转发(匹配默认路由项)。</p>
<h3 id="243-路由表更新"><a class="markdownIt-Anchor" href="#243-路由表更新"></a> 2.4.3 路由表更新</h3>
<p>路由表必须能够更新，以反映网络连接的变化，这样IP模块才能准确、高效地转发数据报。route命令可以修改路由表。我们看如下几个例子(在机器ernest-laptop上执行):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo route add -host <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> dev eth0<br> $sudo route del -net <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> netmask <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span><br> $sudo route del <span class="hljs-keyword">default</span><br> $sudo route add <span class="hljs-keyword">default</span> gw <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> dev eth0<br></code></pre></td></tr></table></figure>
<p><strong>第1行</strong>表示添加主机192.168.1.109(机器Kongming20)对应的路由项。这样设置之后，所有<u>从ernest-laptop发送到Kongming20</u>的IP数据报 将通过网卡eth0直接发送至目标机器的接收网卡。</p>
<p><strong>第2行</strong>表示删除网络192.168.1.0对应的路由项。这样除了机器Kongming20外，测试机器ernest-laptop将<strong>无法访问该局域网上的任何其他机器</strong>(能访问到Kongming20是由于执行了上一条命令)。</p>
<p><strong>第3行</strong>表示<u>删除默认路由项</u>， 这样做的后果是<u>无法访问因特网</u>。</p>
<p><strong>第4行</strong>表示<u>重新设置默认路由项</u>，不过这次其<u>网关是机器Kongming20</u>(而不是能直接访问因特网的路由器)!</p>
<p>经过上述修改后的路由表如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Kernel IP routing table<br> Destination Gateway Genmask Flags Metric Ref Use Iface<br> Kongming20*<span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.255</span> UH <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> eth0<br> <span class="hljs-keyword">default</span> Kongming20 <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> UG <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> eth0<br></code></pre></td></tr></table></figure>
<p>这个新的路由表中，第一个路由项是<u>主机路由项</u>，所以它被设置了“H”标志。我们设计这样一个路由表的目的是为后文讨论ICMP重定向提供环境。</p>
<p>通过route命令或其他工具手工修改路由表，是静态的路由更新方式。</p>
<p>对于大型的路由器，它们通常通过BGP(Border Gateway Protocol，边际网关协议)、RIP(Routing Information Protocol，路由信息协议)、OSPF等协议来发现路径，并更新自己的路由表。这种更新方式是动态的、自动的。</p>
<h2 id="25-ip转发"><a class="markdownIt-Anchor" href="#25-ip转发"></a> 2.5 IP转发</h2>
<p>前文提到，<strong>不是发送给本机</strong>的IP数据报<u>将由数据报转发子模块来处理</u>。路由器都<strong>能执行数据报的转发操作</strong>，而主机<strong>一般只发送和接收数据报</strong>，这是因为主机上/proc/sys/net/ipv4/ip_forward内核参数默认被设置为0。</p>
<p>我们可以通过修改它<strong>来使能主机的数据报转发功能</strong>(在测试机器Kongming20上以root身份执行):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#echo 1&gt;/proc/sys/net/ipv4/ip_forward</span><br></code></pre></td></tr></table></figure>
<p>对于允许IP数据报转发的系统(主机或路由器)，<strong>数据报转发子模块</strong>将<u>对期望转发的数据报</u>执行如下操作:</p>
<p>1)检查数据报头部的TTL值。如果TTL值已经是0，则丢弃该数据报。</p>
<p>2)查看数据报头部的严格源路由选择选项。如果该选项被设置， 则检测数据报的目标IP地址是否是本机的某个IP地址。如果不是，则发送一个ICMP源站选路失败报文给发送端。</p>
<p>3)如果有必要，则给源端发送一个ICMP<strong>重定向</strong>报文，以<u>告诉它一个更合理的下一跳</u>路由器。（优化路径）</p>
<p>4)将TTL值减1。</p>
<p>5)处理IP头部选项。</p>
<p>6)如果有必要，则执行IP分片操作。</p>
<h2 id="26-重定向"><a class="markdownIt-Anchor" href="#26-重定向"></a> 2.6 重定向</h2>
<p>图2-3显示了<u>ICMP重定向报文也能用于更新路由表</u>，因此本节我们简要讨论ICMP重定向。</p>
<h3 id="261-icmp重定向报文"><a class="markdownIt-Anchor" href="#261-icmp重定向报文"></a> 2.6.1 ICMP重定向报文</h3>
<p>ICMP重定向报文格式如图2-4所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091446138.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午2.46.34" /></p>
<p>我们在1.1节讨论过ICMP报文头部的3个固定字段:8位类型、8位代码和16位校验和。ICMP重定向报文的类型值是5，代码字段有4个可选值，用来区分不同的重定向类型。本书仅讨论<strong>主机重定向</strong>，其代码值为1。</p>
<p>ICMP重定向报文的数据部分含义很明确，它给接收方提供了如下两个信息:</p>
<p>1、引起重定向的IP数据报(即图2-4中的原始IP数据报)的源端IP地址。</p>
<p>2、应该使用的路由器的IP地址。</p>
<p>接收主机根据这两个信息就可以断定引起重定向的IP数据报<u>应该使用哪个路由器来转发</u>，并且以此来更新路由表(通常是<strong>更新路由表缓冲</strong>，而不是直接更改路由表)。</p>
<p>/proc/sys/net/ipv4/conf/all/send_redirects内核参数指定<u>是否允许发送ICMP重定向报文</u>，而/proc/sys/net/ipv4/conf/all/accept_redirects内核参数则指定<u>是否允许接收ICMP重定向</u>报文。一般来说，<strong>主机只能接收</strong>ICMP重定向报文，而<strong>路由器只能发送</strong>ICMP重定向报文。</p>
<h3 id="262-主机重定向实例"><a class="markdownIt-Anchor" href="#262-主机重定向实例"></a> 2.6.2 主机重定向实例</h3>
<p>2.4.3节中，我们把机器ernest-laptop的<strong>网关</strong>设置成了机器Kongming20，2.5节中我们又使能了Kongming20的<strong>数据报转发</strong>功能，因此机器ernest-laptop将通过Kongming20来访问因特网，比如在ernest- laptop上执行如下ping命令:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">	 $ping www.baidu.com<br>   PING www.a.shifen.<span class="hljs-built_in">com</span>(<span class="hljs-number">119.75</span><span class="hljs-number">.217</span><span class="hljs-number">.56</span>)<span class="hljs-number">56</span>(<span class="hljs-number">84</span>)bytes of data.<br>   <span class="hljs-function">From <span class="hljs-title">Kongming20</span><span class="hljs-params">(<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>)</span>:icmp_seq=</span><span class="hljs-number">1</span> <span class="hljs-function">Redirect <span class="hljs-title">Host</span><span class="hljs-params">(New</span></span><br><span class="hljs-params"><span class="hljs-function">nexthop:<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>)</span></span><br><span class="hljs-function">   64 bytes from 119.75.217.56:icmp_seq=</span><span class="hljs-number">1</span> ttl=<span class="hljs-number">54</span> time=<span class="hljs-number">6.78</span> ms<br>   ---www.a.shifen.com ping statistics---<br>   <span class="hljs-number">1</span> packets transmitted,<span class="hljs-number">1</span> received,<span class="hljs-number">0</span>%packet loss,time <span class="hljs-number">0</span>ms<br>   rtt min/avg/max/mdev=<span class="hljs-number">6.789</span>/<span class="hljs-number">6.789</span>/<span class="hljs-number">6.789</span>/<span class="hljs-number">0.000</span> ms<br></code></pre></td></tr></table></figure>
<p>从ping命令的输出来看，Kongming20给ernest-laptop发送了一个 ICMP重定向报文，告诉它请通过192.168.1.1来访问目标机器，因为这对ernest-laptop来说是更合理的路由方式。当主机ernest-laptop收到这样的ICMP重定向报文后，它将更新其路由表缓冲(使用命令route-Cn查看)，并使用新的路由方式来发送后续数据报。上面讨论的重定向过程可用图2-5来总结。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091501261.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午3.01.26" /></p>
<p>PS: 相当于告诉你这条路不好使，告诉你一条更好的路线</p>
<h2 id="27-ipv6头部结构"><a class="markdownIt-Anchor" href="#27-ipv6头部结构"></a> 2.7 IPv6头部结构</h2>
<p>Pv6协议是网络层技术发展的必然趋势。它<strong>不仅解决了IPv4地址不够用</strong>的问题，还做了很大的改进。比如，<strong>增加了多播和流</strong>的功能，为网络上多媒体内容的质量提供精细的控制;引入自动配置功能，使得局域网管理更方便;<strong>增加了专门的网络安全功能</strong>等。本节简要地讨论 IPv6头部结构，它的更多细节请参考其标准文档RFC 2460。</p>
<h3 id="271-ipv6固定头部结构"><a class="markdownIt-Anchor" href="#271-ipv6固定头部结构"></a> 2.7.1 IPv6固定头部结构</h3>
<p>IPv6头部由40字节的固定头部和可变长的扩展头部组成。图2-6所示是IPv6的固定头部结构。<img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091506319.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午3.06.55" /></p>
<p><strong>4位版本号(version)</strong>：指定IP协议的版本。对IPv6来说，其值是6。 8位通信类型(traffic class)指示数据流通信类型或优先级，和IPv4中的TOS类似。</p>
<p><strong>20位流标签(flow label)</strong>：是IPv6新增加的字段，用于某些对连接的服务质量有特殊要求的通信，比如音频或视频等实时数据传输。</p>
<p><strong>16位净荷长度(payload length)</strong>：指的是IPv6扩展头部和应用程序数 据长度之和，不包括固定头部长度。</p>
<p><strong>8位下一个包头(next header)</strong>：指出紧跟IPv6固定头部后的包头类 型，如扩展头(如果有的话)或某个上层协议头(比如TCP，UDP或 ICMP)。它类似于IPv4头部中的协议字段，且相同的取值有相同的含 义。</p>
<p><strong>8位跳数限制(hop limit)<strong>和</strong>IPv4中的TTL</strong>含义相同。</p>
<p><strong>IPv6用128位(16字节)</strong>:来表示IP地址，使得IP地址的总量达到了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>128</mn></msup></mrow><annotation encoding="application/x-tex">2^{128}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>个。所以有人说，“IPv6使得地球上的每粒沙子都有一个IP地址”。</p>
<p><strong>32位表示的IPv4地址</strong>一般用点分十进制来表示，而<strong>IPv6地址</strong>则用十六进制字符串表示，比如“FE80:0000:0000:0000:2234:5678:0000:0012”。可见，<strong>IPv6地址</strong>用“:”分割成8组，每组包含2字节。但这种表示方法过于麻烦，通常可以使用所谓的<strong>零压缩法</strong>来将其简写，也就是<strong>省略连续的、全零</strong>的组。 比如，上面的例子使用零压缩法可表示为“FE80::2234:5678:0000:0012”。不过零压缩法对一个IPv6地址<strong>只能使用一次</strong>，比如上面的例子中，字节组“5678”后面的全零组就不能再省略，否则我们就<u>无法计算每个“::”之间省略了多少个</u>全零组。</p>
<h3 id="272-ipv6扩展头部"><a class="markdownIt-Anchor" href="#272-ipv6扩展头部"></a> 2.7.2 IPv6扩展头部</h3>
<p>可变长的扩展头部使得IPv6能支持更多的选项，并且很便于将来的扩展需要。它的长度可以是0，表示<strong>数据报没使用任何扩展头部</strong>。一个数据报可以包含<strong>多个</strong>扩展头部，每个扩展头部的<u>类型由前一个头部</u> (固定头部或扩展头部)中的<u>下一个报头字段</u>指定。目前可以使用的m扩展头部如表2-3所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091514830.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午3.14.02" /></p>
<p><strong>注意</strong> <u>IPv6协议并不是IPv4协议的简单扩展</u>，而是完全<strong>独立</strong>的协议。用以太网帧封装的IPv6数据报和IPv4数据报具有不同的类型值。</p>
<p>第1章提到，<strong>IPv4数据报</strong>的以太网帧封装类型值是0x800，而<strong>IPv6数据报</strong>的以太网帧封装类型值是0x86dd(见RFC 2464)。</p>
<h1 id="第3章-tcp协议详解"><a class="markdownIt-Anchor" href="#第3章-tcp协议详解"></a> 第3章 TCP协议详解</h1>
<p>TCP协议是TCP/IP协议族中另一个重要的协议。和IP协议相比， TCP协议<u>更靠近应用层</u>，因此在应用程序中具有<strong>更强的可操作性</strong>。一些 重要的socket选项都和TCP协议相关。</p>
<p>本章从如下四方面来讨论TCP协议:</p>
<p><strong>TCP头部信息</strong>:TCP头部信息出现在每个TCP报文段中，用于指定通信的源端端口号、目的端端口号，管理TCP连接，控制两个方向的数据流。</p>
<p><strong>TCP状态转移过程</strong>:TCP连接的任意一端都是一个状态机。在 TCP连接从建立到断开的整个过程中，连接两端的状态机将经历不同的状态变迁。理解TCP状态转移对于调试网络应用程序将有很大的帮助。</p>
<p><strong>TCP数据流</strong>:通过分析TCP数据流，我们就可以从网络应用程序外部来了解应用层协议和通信双方交换的应用程序数据。这一部分将讨论两种类型的TCP数据流:<u>交互数据流</u>和<u>成块数据流</u>。TCP数据流中有一种特殊的数据，称为<u>紧急数据</u>，我们也将简单讨论之。</p>
<p><strong>TCP数据流的控制</strong>:为了保证可靠传输和提高网络通信质量，内核需要对TCP数据流进行控制。这一部分讨论TCP数据流控制的两个方面:<u>超时重传</u>和<u>拥塞控制</u>。</p>
<p>不过在详细讨论TCP协议之前，我们先简单介绍一下TCP服务的特点，以及它和UDP服务的区别。</p>
<h2 id="31-tcp服务的特点"><a class="markdownIt-Anchor" href="#31-tcp服务的特点"></a> 3.1 TCP服务的特点</h2>
<p><strong>传输层协议</strong>主要有两个:<strong>TCP协议</strong>和<strong>UDP协议</strong>。TCP协议相对于UDP协议的特点是:面向连接、字节流和可靠传输。</p>
<p>使用TCP协议通信的双方必须<u>先建立连接</u>，然后才能开始数据的读写。双方都必须为该<u>连接分配必要的内核</u>资源，以管理连接的状态和连接上数据的传输。TCP连接是<strong>全双工</strong>的，即<u>双方的数据读写可以通过一个连接进行</u>。完成数据交换之后，通信双方都<u>必须断开</u>连接以释放 系统资源。</p>
<p>TCP协议的这种连接是<strong>一对一</strong>的，所以基于<strong>广播</strong>和<strong>多播</strong>(目标是多个主机地址)的应用程序<strong>不能使用</strong>TCP服务。而无连接协议<u>UDP则非常适合于广播和多播</u>。</p>
<p>我们在1.1节中简单介绍过<strong>字节流服务</strong>和<strong>数据报服务</strong>的区别。这种区别对应到实际编程中，则体现为通信双方<u>是否必须执行相同次数的 读、写操作</u>(当然，这只是表现形式)。</p>
<p>当发送端应用程序连续执行多次写操作时，TCP模块先将这些数据放入<strong>TCP发送缓冲区</strong>中。当TCP模块<strong>真正开始发送</strong>数据时，发送缓冲区中这些等待发送的数据可能被<strong>封装成一个或多个TCP报文</strong>段发出。因此，TCP模块发送出的<u>TCP报文段的个数和应用程序执行的写操作次数之间没有固定的数量关系</u>。(<u>因为是两个阶段的，所以他可以读和写不用同步</u>)</p>
<p>当接收端收到一个或多个TCP报文段后，TCP模块将它们携带的应用程序数据<u>按照TCP报文段的序号</u>(见后文)依次放入TCP接收缓冲区 中，并<u>通知应用程序读取</u>数据。接收端应用程序可以一次性将TCP接收缓冲区中的数据<u>全部读出，也可以分多次读取</u>，这取决于用户指定的应用程序读缓冲区的大小。因此，应用程序执行的读操作次数和TCP模块接收到的TCP报文段个数之间也没有固定的数量关系。（跟上面一样也是有缓冲区，所以是两个阶段）</p>
<p>综上所述，<strong>发送端执行的写操作次数和接收端执行的读操作次数之间没有任何数量关系</strong>，这就是<strong>字节流</strong>的概念:应用程序对数据的发送和接收是没有边界限制的。UDP则不然。发送端应用程序每执行一次写操作，UDP模块就将其封装成一个UDP数据报并发送之。接收端必须及时针对每一个UDP数据报执行读操作(通过recvfrom系统调用)，否则就会丢包(这经常发生在较慢的服务器上)。并且，如果用户没有指定足够的应用程序缓冲区来读取UDP数据，则UDP数据将被截断。（<u>UDP属于是一一对应的发送</u>）</p>
<p>图3-1和图3-2显示了TCP字节流服务和UDP数据报服务的上述区别。两图中省略了传输层以下的通信细节。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091554080.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午3.54.17" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091554401.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午3.54.30" /></p>
<p>TCP传输是<strong>可靠的</strong>。</p>
<p>1、TCP协议采用发送应答机制，即发送端发送的每个TCP报文段都必须得到接收方的应答，才认为这个TCP报文段传输成功。</p>
<p>2、TCP协议采用超时重传机制，发送端在发送出一个 TCP报文段之后启动定时器，如果在定时时间内未收到应答，它将重发该报文段。3、因为TCP报文段最终是以IP数据报发送的，而IP数据报到达接收端<strong>可能乱序、重复</strong>，所以TCP协议还会对接收到的TCP报文段<strong>重排、整理，再交付</strong>给应用层。</p>
<p><u>UDP协议则和IP协议一样，提供不可靠服务</u>。它们都需要上层协议来处理数据确认和超时重传。</p>
<h2 id="32-tcp头部结构"><a class="markdownIt-Anchor" href="#32-tcp头部结构"></a> 3.2 TCP头部结构</h2>
<p>TCP头部信息出现在每个TCP报文段中，用于指定通信的源端端口，目的端端口，管理TCP连接等，本节详细介绍TCP的头部结构，包括固定头部结构和头部选项。</p>
<h3 id="321-tcp固定头部结构"><a class="markdownIt-Anchor" href="#321-tcp固定头部结构"></a> 3.2.1 TCP固定头部结构</h3>
<p>TCP头部结构如图3-3所示，其中的诸多字段为管理TCP连接和控制数据流提供了足够的信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091600766.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午4.00.34" /></p>
<p><strong>16位端口号(port number)</strong>:告知主机该报文段是来自哪里(源端口)以及传给哪个上层协议或应用程序(目的端口)的。进行TCP通信时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号。1.3节中提到过，所有知名服务使用的端口号都定义在/etc/services文件中。</p>
<p><strong>32位序号(sequence number)</strong>:一次TCP通信(从TCP连接建立到断开)过程中某一个传输方向上的字节流的每个字节的编号。假设主机A和主机B进行TCP通信，A发送给B的第一个TCP报文段中，序号值被系统初始化为某个随机值ISN(Initial Sequence Number，初始序号 值)。那么在该传输方向上(从A到B)，后续的TCP报文段中序号值<u>将被系统设置成ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移</u>。例如，某个TCP报文段传送的数据是字节流中的第1025~2048字节，那么该报文段的序号值就是ISN+1025。另外一个传输方向 (从B到A)的TCP报文段的序号值也具有相同的含义。</p>
<p><strong>32位确认号(acknowledgement number)</strong>:用作对<u>另一方发送来的TCP报文段的响应</u>。其值是收到的TCP报文段的序号值加1。假设主机 A和主机B进行TCP通信，那么A发送出的TCP报文段不仅携带自己的序号，而且包含对B发送来的TCP报文段的确认号。反之，B发送出的 TCP报文段也同时携带自己的序号和对A发送来的报文段的确认号。</p>
<p><strong>4位头部长度(header length)</strong>:标识该TCP头部有多少个32bit字 (4字节)。因为4位最大能表示15，所以TCP头部最长是60字节。</p>
<p><strong>6位标志位</strong>包含如下几项:</p>
<p>1、URG标志，表示紧急指针(urgent pointer)是否有效。</p>
<p>2、ACK标志，表示确认号是否有效。我们称携带ACK标志的TCP报文段为确认报文段。</p>
<p>3、PSH标志，提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间(如果应用程序不将接收到的数据读走，它们就会一直停留在TCP接收缓冲区中)。</p>
<p>4、RST标志，表示要求对方重新建立连接。我们称携带RST标志的TCP报文段为复位报文段。</p>
<p>5、SYN标志，表示请求建立一个连接。我们称携带SYN标志的TCP报文段为同步报文段。</p>
<p>6、FIN标志，表示通知对方本端要关闭连接了。我们称携带FIN标志的TCP报文段为结束报文段。</p>
<p><strong>16位窗口大小(window size)</strong>:是<u>TCP流量控制</u>的一个手段。这里说的窗口，指的是接收通告窗口(Receiver Window，RWND)。它告诉对方本端的<u>TCP接收缓冲区还能容纳多少字节</u>的数据，这样对方就可以控制发送数据的速度。</p>
<p><strong>16位校验和(TCP checksum)</strong>:由发送端填充，接收端对TCP报 文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这 个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一 个重要保障。</p>
<p><strong>16位紧急指针(urgent pointer)</strong>:是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是<u>紧急指针相对当前序号的偏移</u>，不妨称之为紧急偏移。TCP的紧急指针是<u>发送端向接收端发送紧急数据</u>的方法。我们将在后面讨论TCP紧急数据。</p>
<h3 id="322-tcp头部选项"><a class="markdownIt-Anchor" href="#322-tcp头部选项"></a> 3.2.2 TCP头部选项</h3>
<p>TCP头部的最后一个选项字段(options)是<u>可变长的可选</u>信息。这部分最多包含40字节，因为TCP头部最长是60字节(其中还包含前面讨论的20字节的固定部分)。典型的TCP头部选项结构如图3-4所示。<img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091629187.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午4.29.12" /></p>
<p>选项的第一个字段kind说明选项的类型。有的TCP选项没有后面两个字段，仅包含1字节的kind字段。第二个字段length(如果有的话)指定该选项的总长度，该长度包括kind字段和length字段占据的2字节。第三个字段info(如果有的话)是选项的具体信息。常见的TCP选项有7 种，如图3-5所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091633489.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午4.33.50" /></p>
<p>kind=0是选项表结束选项。</p>
<p>kind=1是空操作(nop)选项，没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍。</p>
<p>kind=2是最大报文段长度选项。TCP连接初始化时，通信双方使用 该选项来协商最大报文段长度(Max Segment Size，MSS)。TCP模块 通常将MSS设置为(MTU-40)字节(减掉的这40字节包括20字节的 TCP头部和20字节的IP头部)。这样携带TCP报文段的IP数据报的长度就不会超过MTU(假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况)，从而避免本机发生IP分片。对以太网而言，MSS值是1460(1500-40)字节。</p>
<p>kind=3是窗口扩大因子选项。TCP连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子。在TCP的头部中，接收通告窗口 大小是用16位表示的，故最大为65535字节，但实际上TCP模块允许的接收通告窗口大小远不止这个数(为了提高TCP通信的吞吐量)。窗口扩大因子解决了这个问题。假设TCP头部中的接收通告窗口大小是N， 窗口扩大因子(移位数)是M，那么TCP报文段的实际接收通告窗口大小是N乘2M，或者说N左移M位。注意，M的取值范围是0~14。我们可以通过修改/proc/sys/net/ipv4/tcp_window_scaling内核变量来启用或关闭窗口扩大因子选项。</p>
<p>和MSS选项一样，窗口扩大因子选项只能出现在同步报文段中， 否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该TCP报文段的实际接收通告窗口大小。当连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了。关于窗口扩大因子选项的细节，可参考标准文档RFC 1323。</p>
<p>kind=4是选择性确认(Selective Acknowledgment，SACK)选项。 TCP通信时，如果某个TCP报文段丢失，则TCP模块会重传最后被确认 的TCP报文段后续的所有报文段，这样<u>原先已经正确传输的TCP报文段也可能重复发送，从而降低了TCP性能</u>。SACK技术正是为改善这种情况而产生的，它使TCP模块只重新发送丢失的TCP报文段，不用发送所有未被确认的TCP报文段。选择性确认选项用在连接初始化时，表示是否支持SACK技术。我们可以通过修改/proc/sys/net/ipv4/tcp_sack内核变量来启用或关闭选择性确认选项。</p>
<p>kind=5是SACK实际工作的选项。该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。每个块边沿(edge of block)参数包含一个4字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数(块左边沿和块右边沿)之间的数据是没有收到的。因为一个块信息占用8字节，所以TCP头部选项中实际上最多可以包含4个这样的不连续数据块(考虑选项类型和长度占用的2字节)。</p>
<p>kind=8是时间戳选项。该选项提供了较为准确的计算通信双方之间的回路时间(Round Trip Time，RTT)的方法，从而为TCP流量控制提供重要信息。我们可以通过修改/proc/sys/net/ipv4/tcp_timestamps内核变量来启用或关闭时间戳选项。</p>
<h3 id="323-使用tcpdump观察tcp头部信息"><a class="markdownIt-Anchor" href="#323-使用tcpdump观察tcp头部信息"></a> 3.2.3 使用tcpdump观察TCP头部信息</h3>
<p>在2.3节中，我们利用tcpdump抓取了一个数据包并分析了其中的IP头部信息，本节分析其中与TCP协议相关的部分(后面的分析中，我们 将所有<u>tcpdump抓取到的数据包都称为TCP报文段</u>，因为TCP报文段既是数据包的主要内容，也是我们主要讨论的对象)。为了方便阅读， 先将该TCP报文段的内容复制于代码清单3-1中。</p>
<p>代码清单3-1 用tcpdump抓取数据包</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.41621</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[S],seq <span class="hljs-number">3499745539</span>,win <span class="hljs-number">32792</span>,options[mss <span class="hljs-number">16396</span>,sackOK,TS val <span class="hljs-number">40781017</span> ecr <span class="hljs-number">0</span>,nop,wscale <span class="hljs-number">6</span>],length <span class="hljs-number">0</span><br><span class="hljs-number">0x0000</span>:<span class="hljs-number">4510</span> <span class="hljs-number">003</span>c a5da <span class="hljs-number">4000</span> <span class="hljs-number">4006</span> <span class="hljs-number">96</span>cf <span class="hljs-number">7f</span>00 <span class="hljs-number">0001</span><br><span class="hljs-number">0x0010</span>:<span class="hljs-number">7f</span>00 <span class="hljs-number">0001</span> a295 <span class="hljs-number">0017</span> d099 e103 <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0x0020</span>:a002 <span class="hljs-number">8018</span> fe30 <span class="hljs-number">0000</span> <span class="hljs-number">0204</span> <span class="hljs-number">400</span>c <span class="hljs-number">0402</span> <span class="hljs-number">080</span>a<br><span class="hljs-number">0x0030</span>:<span class="hljs-number">026</span>e <span class="hljs-number">44</span>d9 <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0103</span> <span class="hljs-number">0306</span><br></code></pre></td></tr></table></figure>
<p><strong>tcpdump输出Flags[S]</strong>，表示该TCP报文段包含SYN标志，因此它是一个<strong>同步报文段</strong>。如果TCP报文段包含其他标志，则tcpdump也会将该<strong>标志的首字母</strong>显示在“Flags”后的方括号中。</p>
<p><strong>seq是序号值</strong>。因为该同步报文段是从127.0.0.1.41621(客户端IP地址和端口号)到127.0.0.1.23(服务器IP地址和端口号)这个传输方向上的第一个TCP报文段，所以这个序号值也就是此次通信过程中该传输方向的<strong>ISN值</strong>。并且，因为这是整个通信过程中的第一个TCP报文段， 所以它没有针对对方发送来的TCP报文段的确认值(尚未收到任何对方发送来的TCP报文段)。</p>
<p><strong>win是接收通告窗口的大小</strong>。因为这是一个同步报文段，所以win值反映的是实际的接收通告窗口大小。</p>
<p><strong>options是TCP选项</strong>，其具体内容列在方括号中。<strong>mss</strong>是发送端(客户端)通告的最大报文段长度。通过ifconfig命令查看回路接口的MTU为16436字节，因此可以预想到TCP报文段的MSS为16396(16436-40) 字节。<strong>sackOK</strong>表示发送端支持并同意使用SACK选项。<strong>TS val</strong>是发送端的时间戳。<strong>ecr</strong>是时间戳回显应答。因为这是一次TCP通信的第一个 TCP报文段，所以它针对对方的时间戳的应答为0(尚未收到对方的时 间戳)。紧接着的<strong>nop</strong>是一个空操作选项。<strong>wscale</strong>指出发送端使用的窗口扩大因子为6。</p>
<p>接下来我们分析tcpdump输出的字节码中TCP头部对应的信息，它从第21字节开始，如表3-1所示。第一列的16进制没用，就是代表行号。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091654334.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午4.54.28" /></p>
<p>从表3-1中可见，TCP报文段头部的二进制码和tcpdump输出的TCP报文段描述信息完全对应。在后面的tcpdump输出中，我们将省略大部 分TCP头部信息，仅显示序号、确认号、窗口大小以及标志位等与主题相关的字段。</p>
<h2 id="33-tcp连接的建立和关闭"><a class="markdownIt-Anchor" href="#33-tcp连接的建立和关闭"></a> 3.3 TCP连接的建立和关闭</h2>
<p>本节我们讨论建立和关闭TCP连接的过程。</p>
<h3 id="331-使用tcpdump观察tcp连接的建立和关闭"><a class="markdownIt-Anchor" href="#331-使用tcpdump观察tcp连接的建立和关闭"></a> 3.3.1 使用tcpdump观察TCP连接的建立和关闭</h3>
<p>首先从ernest-laptop上<u>执行telnet命令登录Kongming20的80端口</u>，然后抓取这一过程中<u>客户端和服务器交换的TCP报文段</u>。具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -i eth0 -nt<span class="hljs-number">&#x27;</span>(src <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-keyword">and</span> dst <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>)<span class="hljs-built_in"><span class="hljs-keyword">or</span></span>(src <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-keyword">and</span> dst <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>)&#x27;<br>$telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">80</span> Trying <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>... Connected to <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>. Escape character is<span class="hljs-number">&#x27;</span>^]<span class="hljs-string">&#x27;. ^](回车)#输入ctrl+]并回车 telnet&gt;quit(回车) Connection closed.</span><br></code></pre></td></tr></table></figure>
<p>当执行telnet命令并在两台通信主机之间建立TCP连接后(telnet输出“Connected to 192.168.1.109”)，输入Ctrl+]以调出telnet程序的命令提 示符，然后在telnet命令提示符后输入quit以退出telnet客户端程序，从而结束TCP连接。整个过程中(从连接建立到结束)，tcpdump输出的 内容如代码清单3-2所示。</p>
<p><strong>代码清单3-2 建立和关闭TCP连接的过程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>:Flags[S],seq <span class="hljs-number">535734930</span>,win <span class="hljs-number">5840</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>:Flags[S.],seq <span class="hljs-number">2159701207</span>,ack <span class="hljs-number">535734931</span>,win <span class="hljs-number">5792</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">1</span>,win <span class="hljs-number">92</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>:Flags[F.],seq <span class="hljs-number">1</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">92</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>:Flags[.],ack <span class="hljs-number">2</span>,win <span class="hljs-number">91</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">6.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>:Flags[F.],seq <span class="hljs-number">1</span>,ack <span class="hljs-number">2</span>,win <span class="hljs-number">91</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">7.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">2</span>,win <span class="hljs-number">92</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>因为整个过程并<strong>没有发生应用层数据的交换</strong>，所以TCP报文段的数据部分的<strong>长度(length)总是0</strong>。为了更清楚地表示建立和关闭TCP连接 的整个过程，我们将tcpdump输出的内容绘制成图3-6所示的时序图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091740284.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<h4 id="tcp三次握手tcp连接"><a class="markdownIt-Anchor" href="#tcp三次握手tcp连接"></a> TCP三次握手（TCP连接）</h4>
<p><strong>第1个TCP报文段</strong>包含SYN标志，因此它是一个<u>同步报文段</u>，即ernest-laptop(客户端)向Kongming20(服务器)发起连接请求。同时，该同步报文段包含一个ISN值为535734930的序号。</p>
<p><strong>第2个TCP报文段</strong>也是<u>同步报文段</u>，表示Kongming20同意与ernest-laptop建立连接。同时它发送自己的ISN值为2159701207的序号，并<u>对第1个同步报文段进行确认</u>。确认值是535734931，即第1个同步报文段的序号值加1。</p>
<p>前文说过，序号值是<u>用来标识TCP数据流中的每一字节</u>的。但<u>同步报文段比较特殊</u>，即使它并没有携带任何应用程序数据，它也要占用一个序号值。</p>
<p><strong>第3个TCP报文段</strong>是ernest-laptop对第2个同步报文段的确认。至此，TCP连接就建立起来了。建立TCP连接的这3个步骤被称为<strong>TCP三次握手。</strong></p>
<p>从第3个TCP报文段开始，tcpdump输出的序号值和确认值都是<u>相对初始ISN值的偏移</u>。当然，我们可以开启tcpdump的-S选项来选择打印 序号的绝对值。</p>
<h4 id="tcp四次握手tcp断开连接"><a class="markdownIt-Anchor" href="#tcp四次握手tcp断开连接"></a> TCP四次握手（TCP断开连接）</h4>
<p>后面4个TCP报文段是关闭连接的过程。</p>
<p><strong>第4个TCP报文段</strong>包含FIN标志，因此它是一个结束报文段，即ernest-laptop要求关闭连接。结束报文段和同步报文段一样，也要占用一个序号值。</p>
<p><strong>Kongming20用TCP报文段5</strong>来确认该结束报文段。紧接着Kongming20发送自己的结束报文段6，ernest-laptop则用TCP报文段7给予确认。实际上，仅用于确认目的的确认报文段5是<u>可以省略</u>的，因为<strong>结束报文段6也携带了该确认信息</strong>。确认报文段5是否出现在连接断开的过程中，取决于TCP的延迟确认特性。延迟确认将在后面讨论。</p>
<p>在连接的关闭过程中，因为ernest-laptop先发送结束报文段(telnet客户端程序主动退出)，故称<strong>ernest-laptop执行主动关闭</strong>，而称 <strong>Kongming20执行被动关闭</strong>。</p>
<p>一般而言，TCP连接是由客户端发起，并通过三次握手建立(特殊情况是所谓同时打开[1])的。TCP连接的关闭过程相对复杂一些。可能是客户端执行主动关闭，比如前面的例子;也可能是服务器执行主动关闭，比如服务器程序被中断而强制关闭连接;还可能是同时关闭(和同时打开一样，非常少见)。</p>
<h3 id="332-半关闭状态"><a class="markdownIt-Anchor" href="#332-半关闭状态"></a> 3.3.2 半关闭状态</h3>
<p>TCP连接是<strong>全双工</strong>的，所以<strong>它允许两个方向的数据传输被独立关闭</strong>。换言之，通信的一端可以发送结束报文段给对方，告诉它本端已经完成了数据的发送，但允许继续接收来自对方的数据，直到对方也发送结束报文段以关闭连接。TCP连接的这种状态称为<strong>半关闭(half close)状态</strong>，如图3-7所示。（一方结束了，等待另一方也结束的状态叫半关闭）</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091833324.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午6.33.29" /></p>
<p>请注意，在图3-7中，服务器和客户端应用程序判断对方<u>是否已经关闭连接</u>的方法是:<u>read系统调用返回0</u>(收到结束报文段)。当然， Linux还提供其他检测连接是否被对方关闭的方法，这将在后续章节讨论。</p>
<p>socket网络编程接口通过shutdown函数提供了对半关闭的支持，我们将在后续章节讨论它。这里强调一下，虽然我们介绍了<strong>半关闭状态</strong>，但是使用半关闭的应用程序很少见。</p>
<h3 id="333-连接超时"><a class="markdownIt-Anchor" href="#333-连接超时"></a> 3.3.3 连接超时</h3>
<p>前面我们讨论的是很快建立连接的情况。如果客户端访问一个距离它<strong>很远</strong>的服务器，或者由于网络繁忙，导致服务器对于客户端发送出的同步报文段没有应答，此时客户端程序将产生什么样的行为呢? 显然，对于提供可靠服务的TCP来说，它必然是先进行重连(可能执行多次)，如果重连仍然无效，则通知应用程序连接超时。</p>
<p>为了观察连接超时，我们模拟一个繁忙的服务器环境，在ernest-laptop上执行下面的操作:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo iptables -F<br>$sudo iptables -I INPUT -p tcp --syn -i eth0 -j DROP<br></code></pre></td></tr></table></figure>
<p>iptable命令用于<strong>过滤数据包</strong>，这里我们利用它来<u>丢弃所有接收到的连接请求</u>(丢弃所有同步报文段，这样客户端就无法得到任何确认报文段)。</p>
<p>接下来从Kongming20上执行telnet命令登录到ernest-laptop，并用tcpdump抓取这个过程中双方交换的TCP报文段。具体操作如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -n -i eth0 port <span class="hljs-number">23</span>#仅抓取telnet客户端和服务器交换的数据包<br>$date; telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>; date#在telnet命令前后都执行date命令，以计算超时时间<br>Mon Jun <span class="hljs-number">11</span> <span class="hljs-number">21</span>:<span class="hljs-number">23</span>:<span class="hljs-number">35</span> CST <span class="hljs-number">2012</span><br>Trying <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>...<br>telnet:connect to address <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:Connection timed out<br>Mon Jun <span class="hljs-number">11</span> <span class="hljs-number">21</span>:<span class="hljs-number">24</span>:<span class="hljs-number">38</span> CST <span class="hljs-number">2012</span><br></code></pre></td></tr></table></figure>
<p>从两次date命令的输出来看，Kongming20建立TCP连接的超时时间是63s。本次tcpdump的输出如代码清单3-3所示。</p>
<p>代码清单3-3 TCP超时重连</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.21</span>:<span class="hljs-number">23</span>:<span class="hljs-number">35.612136</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.39385</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.telnet:Flags[S],seq <span class="hljs-number">1355982096</span>，length <span class="hljs-number">0</span><br><span class="hljs-number">2.21</span>:<span class="hljs-number">23</span>:<span class="hljs-number">36.613146</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.39385</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.telnet:Flags[S],seq <span class="hljs-number">1355982096</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">3.21</span>:<span class="hljs-number">23</span>:<span class="hljs-number">38.617279</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.39385</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.telnet:Flags[S],seq <span class="hljs-number">1355982096</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.21</span>:<span class="hljs-number">23</span>:<span class="hljs-number">42.625140</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.39385</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.telnet:Flags[S],seq <span class="hljs-number">1355982096</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">5.21</span>:<span class="hljs-number">23</span>:<span class="hljs-number">50.641344</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.39385</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.telnet:Flags[S],seq <span class="hljs-number">1355982096</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">6.21</span>:<span class="hljs-number">24</span>:<span class="hljs-number">06.673331</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.39385</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.telnet:Flags[S],seq <span class="hljs-number">1355982096</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>这次抓包我们保留了tcpdump输出的时间戳(不使用其-t选项)，以便推理Linux的超时重连策略。</p>
<p>我们一共抓取到6个TCP报文段，它们都是<strong>同步报文段</strong>，并且具有<strong>相同的序号值</strong>，这说明后面5个同步报文段都是<u>超时重连报文段</u>。观察 这些TCP报文段被发送的时间间隔，它们分别为1s、2s、4s、8s和16s(由于定时器精度的问题，这些时间间隔都有一定偏差)，可以推断最后一个TCP报文段的超时时间是32s(63s-16s-8s-4s-2s-1s)。因此，TCP模块一共执行了5次重连操作，这是由/proc/sys/net/ipv4/tcp_syn_retries内核变量所定义的。<strong>每次重连的超时时间都增加一倍</strong>。在5次重连均失败的情况下，TCP模块放弃连接并通知应用程序。</p>
<p>在应用程序中，我们可以修改连接超时时间，具体方法将在本书后续章节中进行介绍。</p>
<h2 id="34-tcp状态转移"><a class="markdownIt-Anchor" href="#34-tcp状态转移"></a> 3.4 TCP状态转移</h2>
<p>TCP连接的<u>任意一端在任一时刻都处于某种状态</u>，当前状态可以通过netstat命令(见第17章)查看。本节我们要讨论的是TCP连接从建立到关闭的整个过程中通信两端状态的变化。图3-8是完整的状态转移图，它描绘了所有的TCP状态以及可能的状态转换。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205092023605.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午8.23.24" /></p>
<p>图3-8中的<strong>粗虚线</strong>表示<strong>典型的服务器端连接的状态转移</strong>;<strong>粗实线</strong>表示<strong>典型的客户端连接的状态转移</strong>。<strong>CLOSED</strong>是一个<strong>假想的起始点</strong>，并不是一个实际的状态。</p>
<h3 id="341-tcp状态转移总图"><a class="markdownIt-Anchor" href="#341-tcp状态转移总图"></a> 3.4.1 TCP状态转移总图</h3>
<p>我们先讨论服务器的典型状态转移过程，此时我们说的<u>连接状态都是指该连接的服务器端的状态</u>。</p>
<p>1、服务器通过listen系统调用(见第5章)进入<strong>LISTEN状态</strong>，<u>被动等待客户端连接</u>，因此执行的是所谓的被动打开。</p>
<p>2、服务器一旦监听到某个连接请求(收到同步报文段)，就将该连接放入内核等待队列中，并向客户端发送带SYN标志的确认报文段。此时该连接处于SYN_RCVD状态。</p>
<p>3、如果服务器成功地接收到客户端发送回的确认报文段，则该连接转移到ESTABLISHED状态。<strong>ESTABLISHED状态</strong>是<strong>连接双方能够进行双向数据传输的状态</strong>。</p>
<p>4、当客户端主动关闭连接时(通过close或shutdown系统调用向服务器发送结束报文段)，服务器通过返回确认报文段使连接进入<strong>CLOSE_WAIT</strong>状态。这个状态的含义很明确:<u>等待服务器应用程序关闭连接</u>。通常，<u>服务器检测到客户端关闭连接后，也会立即给客户端发送一个结束报文段来关闭连接</u>。这将使连接转移到<strong>LAST_ACK</strong>状态，以等待客户端对结束报文段的最后一次确认。一旦确认完成，连 接就彻底关闭了。</p>
<p>下面讨论客户端的典型状态转移过程，此时我们说的<strong>连接状态</strong>都是指<strong>该连接的客户端的状态</strong>。</p>
<p>客户端通过connect系统调用(见第5章)<u>主动与服务器建立连接</u>。 connect系统调用首先给服务器发送一个同步报文段，使连接转移到 SYN_SENT状态。此后，connect系统调用可能因为如下两个原因失败返回:</p>
<p>1、如果connect连接的目标端口不存在(未被任何进程监听)，或者该端口仍被处于TIME_WAIT状态的连接所占用(见后文)，则服务器将给客户端发送一个复位报文段，connect调用失败。</p>
<p>2、如果目标端口存在，但connect在超时时间内<u>未收到服务器的确认报文段</u>，则connect调用失败。</p>
<p>connect调用失败将使连接立即返回到初始的<strong>CLOSED状态</strong>。如果客户端成功收到服务器的同步报文段和确认，则connect调用成功返 回，连接转移至ESTABLISHED状态。</p>
<p>当客户端执行主动关闭时，它将向服务器发送一个结束报文段， 同时连接进入FIN_WAIT_1状态。若此时客户端收到服务器专门用于确认目的的确认报文段(比如图3-6中的TCP报文段5)，则连接转移至FIN_WAIT_2状态。当客户端处于FIN_WAIT_2状态时，服务器处于 CLOSE_WAIT状态，这一对状态是可能发生半关闭的状态。此时如果服务器也关闭连接(发送结束报文段)，则客户端将给予确认并进入 TIME_WAIT状态。关于TIME_WAIT状态的含义，我们将在下一节讨论。</p>
<p>图3-8还给出了客户端从FIN_WAIT_1状态直接进入TIME_WAIT状态的一条线路(不经过FIN_WAIT_2状态)，前提是处于<strong>FIN_WAIT_1状态的服务器直接收到带确认信息的结束报文段</strong>(而不是先收到确认报文段，再收到结束报文段)。这种情况对应于图3-6中的服务器不发送TCP报文段5。</p>
<p>前面说过，处于FIN_WAIT_2状态的客户端需要等待服务器发送结束报文段，才能转移至TIME_WAIT状态，否则它将一直停留在这个状 态。如果不是为了在半关闭状态下继续接收数据，<u>连接长时间地停留在FIN_WAIT_2状态并无益处</u>。（属于一个工作一个不工作）连接停留在FIN_WAIT_2状态的情况可能发生在**:客户端执行半关闭<strong>后，未等服务器关闭连接就强行退出了。此时客户端连接由内核来接管，可称之为孤儿连接(和孤儿进程类似)。</strong>（相当于找了个保姆替你看着）<strong>Linux为了防止孤儿连接长时间存留在内核中，定义了两个内核变量:/proc/sys/net/ipv4/tcp_max_orphans 和/proc/sys/net/ipv4/tcp_fin_timeout。前者指定内核能接管的</strong>孤儿连接数目**，后者指定孤儿连接在内核中<strong>生存的时间</strong>。</p>
<p>至此，我们简单地讨论了服务器和客户端程序的典型TCP状态转移路线。对应于图3-6所示的TCP连接的建立与断开过程，客户端和服务 器的状态转移如图3-9所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205121608151.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-12 下午4.08.47" /></p>
<p>图3-8<u>还描绘了其他非典型的TCP状态转移路线</u>，比如同时关闭与同时打开，本书不予讨论。</p>
<h3 id="342-time_wait状态"><a class="markdownIt-Anchor" href="#342-time_wait状态"></a> 3.4.2 TIME_WAIT状态</h3>
<p>从图3-9来看，客户端连接在收到服务器的结束报文段(TCP报文段6)之后，并没有直接进入CLOSED状态[1]，而是转移到TIME_WAIT状态。在这个状态，<u>客户端连接要等待一段长为2MSL(Maximum Segment Life，报文段最大生存时间)的时间</u>，才能完全关闭。MSL是 TCP报文段在网络中的最大生存时间，标准文档RFC 1122的建议值是2 min。</p>
<h4 id="time_wait状态存在的原因有两点"><a class="markdownIt-Anchor" href="#time_wait状态存在的原因有两点"></a> TIME_WAIT状态存在的原因有两点:</h4>
<p>1、可靠地终止TCP连接。</p>
<p>2、保证让迟来的TCP报文段有足够的时间被识别并丢弃。</p>
<p>第一个原因很好理解。假设图3-9中用于确认服务器结束报文段6的TCP报文段7丢失，那么服务器将重发结束报文段。因此客户端需要停 留在某个状态以处理重复收到的结束报文段(即向服务器发送确认报文段)。否则，客户端将以复位报文段来回应服务器，服务器则认为这是一个错误，因为它期望的是一个像TCP报文段7那样的确认报文段。</p>
<p>在Linux系统上，<strong>一个TCP端口不能被同时打开多次</strong>(两次及以上)。当一个TCP连接处于TIME_WAIT状态时，我们将无法立即使用该连接占用着的端口来建立一个新连接。反过来思考，如果不存在TIME_WAIT状态，则应用程序能够立即建立一个和刚关闭的连接相似的连接(这里说的相似，是指它们具有相同的IP地址和端口号)。这个新的、和原来相似的连接被称为<strong>原来的连接的化身(incarnation)</strong>。 新的化身可能接收到属于原来的连接的、携带应用程序数据的TCP报文段(迟到的报文段)，这显然是不应该发生的。这就是TIME_WAIT状态存在的第二个原因。</p>
<p>另外，因为TCP报文段的<strong>最大生存时间是MSL</strong>，所以<u>坚持2MSL时间的TIME_WAIT状态能够确保网络上两个传输方向上尚未被接收到的、迟到的TCP报文段都已经消失(被中转路由器丢弃)</u>。因此，一个连接的新的化身可以在2MSL时间之后安全地建立，而绝对不会接收到属于原来连接的应用程序数据，<strong>这就是TIME_WAIT状态要持续2MSL时间</strong>的原因。</p>
<p>有时候我们希望<u>避免TIME_WAIT状态</u>，因为当程序退出后，我们希望能够立即重启它。但由于处在TIME_WAIT状态的连接还占用着端 口，程序将无法启动(直到2MSL超时时间结束)。</p>
<h4 id="考虑一个例子"><a class="markdownIt-Anchor" href="#考虑一个例子"></a> 考虑一个例子:</h4>
<p>在测试机器ernest-laptop上以客户端方式运行nc(用于创建网络连接的工具，见第17章)命令，登录本机的Web服务，且明确指定客户端使用12345端口与服务器通信。然后从终端输入Ctrl+C终止客户端程序，接着又立即重启nc程序，以完全相同的方式再次连接本机的Web服务。具体操作如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">$nc-p <span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-number">80</span><br>ctrl+C#中断客户端程序<br>$nc-p <span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-number">80</span>#重启客户端程序，重新建立连接<br>nc:bind failed:Address already in use#输出显示连接失败，因为<span class="hljs-number">12345</span>端口<br>仍被占用<br>$netstat-nat#用netstat命令查看连接状态<br>Proto Recv-Q Send-Q Local Address Foreign Address State tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">80</span> TIME_WAIT<br></code></pre></td></tr></table></figure>
<p>这里我们使用netstat命令查看连接的状态。其输出显示，客户端程序被中断后，连接进入TIME_WAIT状态，12345端口仍被占用，所以 客户端重启失败。</p>
<p>对客户端程序来说，我们通常不用担心上面描述的重启问题。因为客户端<u>一般使用系统自动分配的临时端口号来建立连接</u>，而由于随机性，临时端口号一般和程序上一次使用的端口号(还处于TIME_WAIT状态的那个连接使用的端口号)不同，所以客户端程序一般可以立即重启。上面的例子仅仅是为了说明问题，我们强制客户端使用12345端口，这才导致立即重启客户端程序失败。</p>
<p>但如果是服务器主动关闭连接后异常终止，则因为它总是使用同一个知名服务端口号，所以连接的TIME_WAIT状态将导致它不能立即 重启。不过，我们可以通过socket选项SO_REUSEADDR来强制进程立 即使用处于TIME_WAIT状态的连接占用的端口，这将在第5章讨论。</p>
<h2 id="35-复位报文段"><a class="markdownIt-Anchor" href="#35-复位报文段"></a> 3.5 复位报文段</h2>
<p>在某些特殊条件下，<u>TCP连接的一端会向另一端发送携带RST标志的报文段，即复位报文段</u>，以通知对方关闭连接或重新建立连接。 本节讨论产生复位报文段的3种情况。</p>
<h3 id="351-访问不存在的端口"><a class="markdownIt-Anchor" href="#351-访问不存在的端口"></a> 3.5.1 访问不存在的端口</h3>
<p>3.4.1小节提到，当客户端程序访问一个不存在的端口时，目标主机将给它发送一个复位报文段。考虑从Kongming20上执行telnet命令登 录ernest-laptop上一个不存在的54321端口，并用tcpdump抓取该过程中两台主机交换的TCP报文段。具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -nt -i eth0 port <span class="hljs-number">54321</span>#仅抓取发送至和来自<span class="hljs-number">54321</span>端口的TCP报文段<br> $telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-number">54321</span><br> Trying <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>...<br> telnet:connect to address <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:Connection refused<br></code></pre></td></tr></table></figure>
<p>telnet程序的输出显示连接被<strong>拒绝</strong>了，因为这个端口<strong>不存在</strong>。 tcpdump抓取到的TCP报文段内容如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.42001</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.54321</span>:Flags[S],seq <span class="hljs-number">21621375</span>,win <span class="hljs-number">14600</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.54321</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.42001</span>:Flags[R.],seq <span class="hljs-number">0</span>,ack <span class="hljs-number">21621376</span>,win <span class="hljs-number">0</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>由此可见，ernest-laptop针对Kongming20的连接请求(同步报文段)回应了一个复位报文段(tcpdump输出R标志)。因为复位报文段的接收通告窗口大小为0，所以可以预见:收到复位报文段的一端应该关闭连接或者重新连接，而不能回应这个复位报文段。</p>
<p>实际上，当客户端程序向服务器的某个端口发起连接，而该端口仍被处于TIME_WAIT状态的连接所占用时，客户端程序也将收到复位报文段。</p>
<h3 id="352-异常终止连接"><a class="markdownIt-Anchor" href="#352-异常终止连接"></a> 3.5.2 异常终止连接</h3>
<p>前面讨论的连接终止方式都是正常的终止方式:数据交换完成之后，一方给另一方发送结束报文段。TCP提供了异常终止一个连接的方法，即给对方发送一个复位报文段。一旦发送了复位报文段，发送端所有排队等待发送的数据都将被丢弃。</p>
<p>应用程序可以使用socket选项SO_LINGER来发送复位报文段，以异常终止一个连接。我们将在第5章讨论SO_LINGER选项。</p>
<h3 id="353-处理半打开连接"><a class="markdownIt-Anchor" href="#353-处理半打开连接"></a> 3.5.3 处理半打开连接</h3>
<p>考虑下面的情况:服务器(或客户端)关闭或者异常终止了连接，而对方没有接收到结束报文段(比如发生了网络故障)，此时，客户端(或服务器)还维持着原来的连接，而服务器(或客户端)即使重启，也已经没有该连接的任何信息了。我们将这种状态称为<strong>半打开状态</strong>，处于这种状态的连接称为半打开连接。如果客户端(或服务器)往处于半打开状态的连接写入数据，则对方将回应一个复位报文段。（属于是客户单方面苦等）</p>
<p>举例来说，我们在Kongming20上使用nc命令模拟一个服务器程序，使之监听12345端口，然后从ernest-laptop运行telnet命令登录到该 端口上，接着拔掉ernest-laptop的网线，并在Kongming20上中断服务器程序。显然，此时ernest-laptop上运行的telnet客户端程序维持着一个半打开连接。然后接上ernest-laptop的网线，并从客户端程序往半打开连接写入1字节的数据“a”。同时，运行tcpdump程序抓取整个过程中telnet客户端和nc服务器交换的TCP报文段。具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">$nc -l <span class="hljs-number">12345</span>#在Kongming20上运行服务器程序<br>$sudo tcpdump -nt -i eth0 port <span class="hljs-number">12345</span><br>$telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">12345</span>#在ernest-laptop上运行客户端程序 Trying <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>...<br>Connected to <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>.<br>Escape character is<span class="hljs-number">&#x27;</span>^]<span class="hljs-string">&#x27;.#此时断开ernest-laptop的网线，并重启服务器 a(回车)#向半打开连接输入字符a</span><br><span class="hljs-string">Connection closed by foreign host.</span><br></code></pre></td></tr></table></figure>
<p>telnet的输出显示，连接被服务器关闭了。tcpdump抓取到的TCP 报文段内容如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.55100</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.12345</span>:Flags[S],seq <span class="hljs-number">3093809365</span>,length <span class="hljs-number">0</span>      <br><span class="hljs-number">2.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.55100</span>:Flags[S.],seq <span class="hljs-number">1495337791</span>,ack <span class="hljs-number">3093809366</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.55100</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.12345</span>:Flags[.],ack <span class="hljs-number">1</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.55100</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.12345</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">4</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">3</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.55100</span>:Flags[R],seq <span class="hljs-number">1495337792</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>该输出内容中，前3个TCP报文段是正常建立TCP连接的3次握手的过程。</p>
<p>第4个TCP报文段由客户端发送给服务器，它携带了3字节的应用程序数据，这3字节依次是:字母“a”、回车符“\r”和换行符“\n”。 不过因为服务器程序已经被中断，所以Kongming20对客户端发送的数据回应了一个复位报文段5。</p>
<h2 id="36-tcp交互数据流"><a class="markdownIt-Anchor" href="#36-tcp交互数据流"></a> 3.6 TCP交互数据流</h2>
<p>前面讨论了TCP连接及其状态，从本节开始我们讨论通过TCP连接交换的应用程序数据。TCP报文段所携带的应用程序数据按照长度分为两种:<strong>交互数据</strong>和<strong>成块数据</strong>。交互数据仅包含<u>很少</u>的字节。使用交互数据的应用程序(或协议)对实时性要求高，比如telnet、ssh等。 成块数据的长度则通常为TCP报文段允许的最大数据长度。使用成块数据的应用程序(或协议)对传输效率要求高，比如ftp。本节我们讨论交互数据流。</p>
<p>考虑如下情况:在ernest-laptop上执行telnet命令登录到本机，然后在shell命令提示符后执行ls命令，同时用tcpdump抓取这一过程中telnet 客户端和telnet服务器交换的TCP报文段。具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">$tcpdump -nt -i lo port <span class="hljs-number">23</span><br>$telnet <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>Trying <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>...<br>Connected to <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>.<br>Escape character is<span class="hljs-number">&#x27;</span>^]<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">Ubuntu 9.10</span><br><span class="hljs-string">ernest-laptop login:ernest(回车)#输入用户名并回车 Password:(回车)#输入密码并回车 ernest@ernest-laptop:~$ls(回车)</span><br></code></pre></td></tr></table></figure>
<p>上述过程将引起客户端和服务器交换很多TCP报文段。下面我们仅列出我们感兴趣的、执行ls命令产生的tcpdump输出，如代码清单3-4所示。</p>
<p>代码清单3-4 TCP交互数据流</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[P.],seq <span class="hljs-number">1408334812</span>:<span class="hljs-number">1408334813</span>,ack <span class="hljs-number">1415955507</span>,win <span class="hljs-number">613</span>,length <span class="hljs-number">1</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">2</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">512</span>,length <span class="hljs-number">1</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[.],ack <span class="hljs-number">2</span>,win <span class="hljs-number">613</span>,length<br><span class="hljs-number">0</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">2</span>,ack <span class="hljs-number">2</span>,win<br><span class="hljs-number">613</span>,length <span class="hljs-number">1</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>:Flags[P.],seq <span class="hljs-number">2</span>:<span class="hljs-number">3</span>,ack <span class="hljs-number">2</span>,win<br><span class="hljs-number">512</span>,length <span class="hljs-number">1</span><br><span class="hljs-number">6.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[.],ack <span class="hljs-number">3</span>,win <span class="hljs-number">613</span>,length<br><span class="hljs-number">0</span><br><span class="hljs-number">7.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[P.],seq <span class="hljs-number">2</span>:<span class="hljs-number">4</span>,ack <span class="hljs-number">3</span>,win<br><span class="hljs-number">613</span>,length <span class="hljs-number">2</span><br><span class="hljs-number">8.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>:Flags[P.],seq <span class="hljs-number">3</span>:<span class="hljs-number">176</span>,ack <span class="hljs-number">4</span>,win<br><span class="hljs-number">512</span>,length <span class="hljs-number">173</span><br><span class="hljs-number">9.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[.],ack <span class="hljs-number">176</span>,win<br><span class="hljs-number">630</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">10.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>:Flags[P.],seq <span class="hljs-number">176</span>:<span class="hljs-number">228</span>,ack<br><span class="hljs-number">4</span>,win <span class="hljs-number">512</span>,length <span class="hljs-number">52</span><br><span class="hljs-number">11.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[.],ack <span class="hljs-number">228</span>,win<br><span class="hljs-number">630</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p><strong>TCP报文段1</strong>由客户端发送给服务器，它携带1个字节的应用程序数据，即字母“l”。</p>
<p><strong>TCP报文段2</strong>是服务器对<u>TCP报文段1</u>的确认，同时回显字母“l”。</p>
<p><strong>TCP报文段3</strong>是客户端对<u>TCP报文段2</u>的确认。</p>
<p><strong>第4~6个TCP报文段</strong>是针对字母“s”的上述过程。</p>
<p><strong>TCP报文段7</strong>传送的2字节数据分别是:客户端键入的回车符和流结束符(EOF，本例中是0x00)。</p>
<p><strong>TCP报文段8</strong>携带服务器返回的客户<u>查询的目录的内容</u>(ls命令的输出)，包括该目录下文件的文件名及其显示控制参数。</p>
<p><strong>TCP报文段9</strong>是客户端对TCP报文段8的确认。</p>
<p><strong>TCP报文段10</strong>携带的也是服务器返回给客户端的数据，包括一个回车符、一个换行符、客户端登录用户的PS1环境变量(第一级命令提示符)。</p>
<p><strong>TCP报文段11</strong>是客户端对TCP报文段10的确认。</p>
<p>在上述过程中，客户端针对服务器返回的数据所发送的确认报文段(TCP报文段6、9和11)都不携带任何应用程序数据(长度为0)， 而服务器每次<u>发送的确认报文段</u>(TCP报文段2、5、8和10)<u>都包含它需要发送的应用程序数据</u>。服务器的这种处理方式称为<strong>延迟确认</strong>，即<u>它不马上确认上次收到的数据，而是在一段延迟时间后查看本端是否有数据需要发送</u>，如果有，则和确认信息一起发出。因为服务器对客户请求处理得很快，所以它发送确认报文段的时候总是有数据一起发送。<strong>延迟确认</strong>可以<strong>减少发送TCP报文段的数</strong>量。而<u>由于用户的输入速度明显慢于客户端程序的处理速度，所以客户端的确认报文段总是不携带任何应用程序数据</u>。前文曾提到，在TCP连接的建立和断开过程中，也可能发生延迟确认。</p>
<p>上例是在本地回路运行的结果，在局域网中也能得到基本相同的结果，但在广域网就未必如此了。广域网上的交互数据流可能经受很大的延迟，并且，携带交互数据的微小TCP报文段数量一般很多(一个按键输入就导致一个TCP报文段)，这些因素都可能导致拥塞发生。解决该问题的一个简单有效的方法是使用Nagle算法。</p>
<p>Nagle算法要求<u>一个TCP连接的通信双方在任意时刻都最多只能发送一个未被确认的TCP报文段</u>，在该TCP报文段的确认到达之前不能发送其他TCP报文段。另一方面，发送方在等待确认的同时收集本端需要发送的微量数据，并在确认到来时以一个TCP报文段将它们全部发出。这样就极大地减少了网络上的微小TCP报文段的数量。该算法的另一个优点在于其自适应性:<u>确认到达得越快，数据也就发送得越 快</u>。</p>
<h2 id="37-tcp成块数据流"><a class="markdownIt-Anchor" href="#37-tcp成块数据流"></a> 3.7 TCP成块数据流</h2>
<p>下面考虑用FTP协议传输一个大文件。在ernest-laptop上启动一个vsftpd服务器程序(升级的、安全版的ftp服务器程序)，并执行ftp命令登录该服务器上，然后在ftp命令提示符后输入get命令，从服务器下载一个几百兆的大文件。同时用tcpdump抓取这一个过程中ftp客户端和vsftpd服务器交换的TCP报文段。具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -nt -i eth0 port <span class="hljs-number">20</span><span class="hljs-meta">#vsftpd服务器程序使用端口号20 $ftp 127.0.0.1</span><br>Connected to <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>.<br><span class="hljs-number">220</span>(vsFTPd <span class="hljs-number">2.3</span><span class="hljs-number">.0</span>) <span class="hljs-built_in">Name</span>(<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:ernest):<span class="hljs-built_in">ernest</span>(回车)#输入用户名并回车<br><span class="hljs-number">331</span> Please specify the password. Password:(回车)#输入密码并回车<br><span class="hljs-number">230</span> Login successful.<br>Remote system type is UNIX.<br>Using binary mode to transfer files. ftp&gt;<span class="hljs-function">get <span class="hljs-title">bigfile</span><span class="hljs-params">(回车)</span>#获取大文件bigfile</span><br></code></pre></td></tr></table></figure>
<p>代码清单3-5 是该过程的部分tcpdump输出。</p>
<p>代码清单3-5 TCP成块数据流</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205783041</span>:<span class="hljs-number">205799425</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205799425</span>:<span class="hljs-number">205815809</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205815809</span>:<span class="hljs-number">205832193</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[P.],seq <span class="hljs-number">205832193</span>:<span class="hljs-number">205848577</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205848577</span>:<span class="hljs-number">205864961</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">6.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205864961</span>:<span class="hljs-number">205881345</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">7.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205881345</span>:<span class="hljs-number">205897729</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">8.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[P.],seq <span class="hljs-number">205897729</span>:<span class="hljs-number">205914113</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">9.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205914113</span>:<span class="hljs-number">205930497</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">10.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205930497</span>:<span class="hljs-number">205946881</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">11.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205946881</span>:<span class="hljs-number">205963265</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">12.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[P.],seq <span class="hljs-number">205963265</span>:<span class="hljs-number">205979649</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">13.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205979649</span>:<span class="hljs-number">205996033</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">14.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205996033</span>:<span class="hljs-number">206012417</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">15.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">206012417</span>:<span class="hljs-number">206028801</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">16.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[P.],seq <span class="hljs-number">206028801</span>:<span class="hljs-number">206045185</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">17.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>:Flags[.],ack <span class="hljs-number">205815809</span>,win <span class="hljs-number">30084</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">18.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>:Flags[.],ack <span class="hljs-number">206045185</span>,win <span class="hljs-number">27317</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>注意，客户端发送的最后两个TCP报文段17和18，它们分别是对TCP报文段2和16的确认(从序号值和确认值来判断)。由此可见，当传输大量大块数据的时候，<strong>发送方</strong>会<strong>连续发送多个TCP报文段</strong>，<strong>接收方</strong>可以<strong>一次确认所有这些报文段</strong>。</p>
<p>那么发送方在收到上一次确认后，能<u>连续发送多少个TCP报文</u>段呢?这是由接收通告<u>窗口(还需要考虑拥塞窗口，见后文)的大小决定</u>的。</p>
<p><strong>TCP报文段17</strong>说明客户端还能接收30 084×64字节(本例中窗口扩大因子为6)，即1 925 376字节的数据。</p>
<p>而在<strong>TCP报文段18</strong>中，接收通告窗口大小为1 748 288字节，即客户端能接收的数据量变小了。这表明客户端的TCP接收缓冲区有更多的数据未被应用程序读取而停留在其中，这些数据都来自TCP报文段3 ~16中的一部分。</p>
<p>服务器收到TCP报文段18后，它至少(因为接收通告窗口可能扩大)还能连续发送的未被确认的报文段数量是1 748 288/16 384个，即106个(但一般不会连续发送这么多)。其中，16 384是成块数据的长度(见TCP报文段1~16的length值)，很显然它小于但接近MSS规定的16 396字节。</p>
<p>另外一个值得注意的地方是，服务器每发送4个TCP报文段就传送一个PSH标志(tcpdump输出标志P)给客户端，以通知客户端的应用程序尽快读取数据。不过这对服务器来说显然不是必需的，因为它知道客户端的TCP接收缓冲区中还有空闲空间(接收通告窗口大小不为0)。</p>
<p>下面我们修改系统的TCP接收缓冲区和TCP发送缓冲区的大小 (如何修改将在第16章介绍)，使之都为4096字节，然后重启vsftpd服务器，并再次执行上述操作。此次tcpdump的部分输出如代码清单3-6 所示。</p>
<p>代码清单3-6 修改TCP接收和发送缓冲区大小后的TCP成块数据流</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.45227</span>:Flags[.],seq <span class="hljs-number">5195777</span>:<span class="hljs-number">5197313</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">3072</span>,length <span class="hljs-number">1536</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.45227</span>:Flags[.],seq <span class="hljs-number">5197313</span>:<span class="hljs-number">5198849</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">3072</span>,length <span class="hljs-number">1536</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.45227</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>:Flags[.],ack <span class="hljs-number">5198849</span>,win <span class="hljs-number">3072</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.45227</span>:Flags[P.],seq <span class="hljs-number">5198849</span>:<span class="hljs-number">5200385</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">3072</span>,length <span class="hljs-number">1536</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.45227</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>:Flags[.],ack <span class="hljs-number">5200385</span>,win <span class="hljs-number">3072</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>从同步报文段(未在代码清单3-6中列出)得知在这次通信过程中，客户端和服务器的窗口扩大因子都为0，因而客户端和服务器每次通告的窗口大小都是3072字节(没超过4096字节，预料之中)。因为每个成块数据的长度为1536字节，所以服务器在收到上一个TCP报文段的确认之前最多还能再发送1个TCP报文段，这正是TCP报文段1~3描述的情形。</p>
<h2 id="38-带外数据"><a class="markdownIt-Anchor" href="#38-带外数据"></a> 3.8 带外数据</h2>
<p>有些传输层协议具有带外(Out Of Band，OOB)数据的概念，用于<u>迅速通告对方本端发生的重要事件</u>。因此，带外数据比普通数据 (也称为带内数据)有<strong>更高的优先级</strong>，它应该总是立即被发送，而不论发送缓冲区中是否有排队等待发送的普通数据。带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接中。实际应用中，带外数据的使用很少见，已知的仅有telnet、ftp等远程非活跃程序。</p>
<p>UDP没有实现带外数据传输，TCP也没有真正的带外数据。不过TCP利用其头部中的紧急指针标志和紧急指针两个字段，给应用程序提供了一种紧急方式。TCP的紧急方式利用传输普通数据的连接来传输紧急数据。这种紧急数据的含义和带外数据类似，因此后文也将<u>TCP紧急数据称为带外数据</u>。</p>
<h3 id="381tcp发送带外数据的过程"><a class="markdownIt-Anchor" href="#381tcp发送带外数据的过程"></a> 3.8.1TCP发送带外数据的过程</h3>
<p>假设一个进程已经往某个TCP连接的发送缓冲区中写入了N字节的普通数据，并等待其发送。在数据被发送前，该进程又向这个连接写入了3字节的带外数据“abc”。此时，待发送的TCP报文段的头部将被设置URG标志，并且紧急指针被设置为指向最后一个带外数据的下一字节(进一步减去当前TCP报文段的序号值得到其头部中的紧急偏移值)，如图3-10所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205131634108.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-13 下午4.34.33" /></p>
<p>由图3-10可见，发送端一次发送的多字节的带外数据中只有最后一字节被当作带外数据(字母c)，而其他数据(字母a和b)被当成了普通数据。如果TCP模块以多个TCP报文段来发送图3-10所示TCP发送缓冲区中的内容，则每个TCP报文段都将设置URG标志，并且它们的紧 急指针指向同一个位置(数据流中带外数据的下一个位置)，但<u>只有一个TCP报文段真正携带带外数据</u>。</p>
<p>现在考虑TCP接收带外数据的过程。TCP接收端只有在接收到紧急指针标志时才检查紧急指针，然后根据紧急指针所指的位置确定带外数据的位置，并将它读入一个特殊的缓存中。这个缓存只有1字节，称为<u>带外缓存</u>。<strong>如果上层应用程序没有及时将带外数据从带外缓存中读 出，则后续的带外数据(如果有的话)将覆盖它</strong>。</p>
<p>前面讨论的带外数据的接收过程是TCP模块接收带外数据的默认方式。如果我们给TCP连接设置了SO_OOBINLINE选项，则带外数据将 和普通数据一样被TCP模块存放在TCP接收缓冲区中。此时应用程序需要像读取普通数据一样来读取带外数据。那么这种情况下如何区分带外数据和普通数据呢?显然，紧急指针可以用来指出带外数据的位置，socket编程接口也提供了系统调用来识别带外数据(见第5章)。</p>
<p>至此，我们讨论了TCP模块发送和接收带外数据的过程。至于内核如何通知应用程序带外数据的到来，以及应用程序如何发送和接收带外数据，将在后续章节讨论。</p>
<h2 id="39-tcp超时重传"><a class="markdownIt-Anchor" href="#39-tcp超时重传"></a> 3.9 TCP超时重传</h2>
<p>在3.6节~3.8节中，我们讲述了TCP在正常网络情况下的数据流。 从本节开始，我们讨论异常网络状况下(开始出现超时或丢包)，TCP如何控制数据传输以保证其承诺的可靠服务。</p>
<p>TCP服务必须能够重传超时时间内未收到确认的TCP报文段。为此，TCP模块为每个TCP报文段都维护一个重传定时器，该定时器在TCP报文段第一次被发送时启动。如果超时时间内未收到接收方的应答，TCP模块将重传TCP报文段并重置定时器。至于下次重传的超时时间如何选择，以及最多执行多少次重传，就是TCP的重传策略。我们通过实例来研究Linux下TCP的超时重传策略。</p>
<p>在ernest-laptop上启动iperf服务器程序，然后从Kongming20上执行telnet命令登录该服务器程序。接下来，从telnet客户端发送一些数据 (此处是“1234”)给服务器，然后断开服务器的网线并再次从客户端发送一些数据给服务器(此处是“12”)。同时，用tcpdump抓取这一过程中客户端和服务器交换的TCP报文段。具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump-n-i eth0 port <span class="hljs-number">5001</span> $iperf-s#在ernest-laptop上执行<br>$telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-number">5001</span>#在Kongming20上执行 Trying <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>...<br>Connected to <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.<br>Escape character is<span class="hljs-number">&#x27;</span>^]<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">1234#发送完之后断开服务器网线</span><br><span class="hljs-string">12</span><br><span class="hljs-string">Connection closed by foreign host</span><br></code></pre></td></tr></table></figure>
<p>iperf是一个测量网络状况的工具，-s选项表示将其作为服务器运行。iperf默认监听5001端口，并丢弃该端口上接收到的所有数据，相当于一个discard服务器。上述操作过程的部分tcpdump输出如代码清单3-7所示。</p>
<p>代码清单3-7 TCP超时重传</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">57.580341</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[S],seq <span class="hljs-number">2381272950</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">2.18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">57.580477</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>:Flags[S.],seq <span class="hljs-number">466032301</span>,ack <span class="hljs-number">2381272951</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">3.18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">57.580498</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[.],ack <span class="hljs-number">1</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">59.866019</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">7</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">6</span><br><span class="hljs-number">5.18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">59.866165</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>:Flags[.],ack <span class="hljs-number">7</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">6.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">25.028933</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">7</span>:<span class="hljs-number">11</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">4</span><br><span class="hljs-number">7.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">25.230034</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">7</span>:<span class="hljs-number">11</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">4</span><br><span class="hljs-number">8.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">25.639407</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">7</span>:<span class="hljs-number">11</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">4</span><br><span class="hljs-number">9.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">26.455942</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">7</span>:<span class="hljs-number">11</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">4</span><br><span class="hljs-number">10.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">28.092425</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">7</span>:<span class="hljs-number">11</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">4</span><br><span class="hljs-number">11.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">31.362473</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">7</span>:<span class="hljs-number">11</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">4</span><br><span class="hljs-number">12.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">33.100888</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">13.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">34.098156</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">14.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">35.100887</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">15.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">37.902034</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">16.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">38.903126</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">17.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">39.901421</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">18.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">44.440049</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">19.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">45.438840</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">20.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">46.439932</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">21.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">50.976710</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">22.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">51.974134</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">23.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">52.973939</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br></code></pre></td></tr></table></figure>
<p><strong>TCP报文段1~3</strong>是<strong>三次握手建立连接</strong>的过程。</p>
<p><strong>TCP报文段4~5</strong>是客户端发送数据“1234”(应用程序数据长度为6，包括回车、换行两个字符，后同)及服务器确认的过程。</p>
<p><strong>TCP报文段6</strong>是客户端第一次发送数据“12”的过程。因为服务器的网线被断开，所以客户端无法收到TCP报文段6的确认报文段。此后，客户端对TCP报文段6执行了5次重传，它们是TCP报文段7~11，这可以从每个TCP报文段的序号得知。</p>
<p>此后，<strong>数据包12~23</strong>都是ARP模块的输出内容，即Kongming20查询ernest-laptop的MAC地址。</p>
<p>我们保留了tcpdump输出的时间戳，以便推理TCP的超时重传策略。观察TCP报文段6~11被发送的时间间隔，它们分别为0.2 s、0.4 s、0.8 s、1.6 s和3.2 s。由此可见，TCP一共执行5次重传，每次重传超时时间都增加一倍(因此，和TCP超时重连的策略相似)。</p>
<p>在5次重传均失败的情况下，底层的IP和ARP开始接管，直到telnet客户端放弃连接为止。</p>
<p>Linux有两个重要的内核参数与TCP超时重传相关:/proc/sys/net/ipv4/tcp_retries1和/proc/sys/net/ipv4/tcp_retries2。前者指定在底层IP接管之前TCP最少执行的重传次数，默认值是3。后者指定连接放弃前TCP最多可以执行的重传次数，默认值是15(一般对应 13~30 min)。在我们的实例中，TCP超时重传发生了5次，连接坚持的时间是15 min(可以用date命令来测量)。</p>
<p>虽然超时会导致TCP报文段重传，但TCP报文段的重传可以发生在超时之前，即快速重传，这将在下一节中讨论。</p>
<h2 id="310-拥塞控制"><a class="markdownIt-Anchor" href="#310-拥塞控制"></a> 3.10 拥塞控制</h2>
<h3 id="3101-拥塞控制概述"><a class="markdownIt-Anchor" href="#3101-拥塞控制概述"></a> 3.10.1 拥塞控制概述</h3>
<p>TCP模块还有一个重要的任务，就是<u>提高网络利用率，降低丢包率</u>，并<u>保证网络资源对每条数据流的公平性</u>。这就是所谓的<strong>拥塞控制</strong>。</p>
<p>TCP拥塞控制的标准文档是RFC 5681，其中详细介绍了拥塞控制的四个部分:<strong>慢启动(slow start)</strong>、<strong>拥塞避免(congestion avoidance)</strong>、<strong>快速重传(fast retransmit)<strong>和</strong>快速恢复(fast recovery)</strong>。拥塞控制算法在Linux下有多种实现，比如<strong>reno算法</strong>、 <strong>vegas算法</strong>和<strong>cubic算法</strong>等。它们或者部分或者全部实现了上述四个部分。/proc/sys/net/ipv4/tcp_congestion_control文件指示机器当前所使用的拥塞控制算法。</p>
<p>拥塞控制的最终受控变量是发送端向网络一次连续写入(收到其中第一个数据的确认之前)的数据量，我们称为SWND(Send Window，发送窗口[1])。不过，发送端最终以TCP报文段来发送数据，所以SWND限定了发送端能连续发送的TCP报文段数量。这些**TCP报文段的最大长度(仅指数据部分)**称为SMSS(Sender Maximum Segment Size，发送者最大段大小)，其值一般等于MSS。</p>
<p>发送端需要合理地选择SWND的大小。如果<strong>SWND太小</strong>，会引起明显的<strong>网络延迟</strong>;反之，如果<strong>SWND太大</strong>，则容易导致<strong>网络拥塞</strong>。前文提到，接收方可通过其接收通告窗口(RWND)来控制发送端的SWND。但这显然不够，所以发送端引入了一个称为拥塞窗口(Congestion Window，CWND)的状态变量。实际的SWND值是RWND和CWND中的较小者。图3-11显示了拥塞控制的输入和输出(可见，它是一个闭环反馈控制)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142122368.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-14 下午9.22.16" /></p>
<h3 id="3102-慢启动和拥塞避免"><a class="markdownIt-Anchor" href="#3102-慢启动和拥塞避免"></a> 3.10.2 慢启动和拥塞避免</h3>
<p>TCP连接建立好之后，CWND将被设置成初始值IW(Initial Window)，其大小为2~4个SMSS。但新的Linux内核提高了该初始值，以减小传输滞后。此时发送端最多能发送IW字节的数据。此后发送端每收到接收端的一个确认，其CWND就按照式(3-1)增加:</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142127783.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-14 下午9.27.56" /></p>
<p>其中N是此次确认中包含的之前未被确认的字节数。这样一来， CWND将按照指数形式扩大，这就是所谓的慢启动。慢启动算法的理由是，TCP模块刚开始发送数据时并不知道网络的实际情况，需要用一种<u>试探的方式</u>平滑地增加CWND的大小。</p>
<p>但是如果不施加其他手段，慢启动必然使得CWND很快膨胀(可见慢启动其实不慢)并最终导致网络拥塞。因此TCP拥塞控制中定义了另一个重要的状态变量:慢启动门限(slow start threshold size， ssthresh)。当CWND的大小超过该值时，TCP拥塞控制将进入拥塞避免阶段。</p>
<p>拥塞避免算法使得CWND按照线性方式增加，从而减缓其扩大。 RFC 5681中提到了如下两种实现方式:</p>
<p>1、每个RTT时间内按照式(3-1)计算新的CWND，而不论该RTT时间内发送端收到多少个确认。</p>
<p>2、每收到一个对新数据的确认报文段，就按照式(3-2)来更新CWND。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142147580.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-14 下午9.47.31" /></p>
<p>图3-12粗略地描述了慢启动和拥塞避免发生的时机和区别。该图中，我们以SMSS为单位来显示CWND(实际上它是以字节为单位的)，以次数为单位来显示RTT，这只是为了方便讨论问题。此外，我们假设当前的ssthresh是16SMSS大小(当然，实际的ssthresh显然远不止这么大)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142150680.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-14 下午9.50.06" /></p>
<p>以上我们讨论了发送端在未检测到拥塞时所采用的积极避免拥塞的方法。接下来介绍拥塞发生时(可能发生在慢启动阶段或者拥塞避免阶段)拥塞控制的行为。不过我们先要搞清楚发送端是如何判断拥塞已经发生的。发送端<strong>判断拥塞发生</strong>的依据有如下两个:</p>
<p>1、传输超时，或者说TCP重传定时器溢出。</p>
<p>2、接收到重复的确认报文段。</p>
<p>拥塞控制对这两种情况有不同的处理方式。对第一种情况仍然使用慢启动和拥塞避免。对第二种情况则使用快速重传和快速恢复(如果是真的发生拥塞的话)，这种情况将在后面讨论。注意，第二种情况如果发生在重传定时器溢出之后，则也被拥塞控制当成第一种情况来对待。</p>
<p>如果发送端检测到拥塞发生是由于传输超时，即上述第一种情况，那么它将执行重传并做如下调整:</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142153207.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-14 下午9.53.26" /></p>
<p>其中FlightSize是<strong>已经发送但未收到确认的字节数</strong>。这样调整之后，CWMD将小于SMSS，那么也必然小于新的慢启动门限值ssthresh(因为根据式(3-3)，它一定不小于SMSS的2倍)，故而拥塞控制再次进入慢启动阶段。</p>
<h3 id="3103-快速重传和快速恢复"><a class="markdownIt-Anchor" href="#3103-快速重传和快速恢复"></a> 3.10.3 快速重传和快速恢复</h3>
<p>在很多情况下，发送端都可能接收到重复的确认报文段，比如TCP报文段丢失，或者接收端收到乱序TCP报文段并重排之等。拥塞控制算 法需要判断当收到重复的确认报文段时，网络是否真的发生了拥塞，或者说TCP报文段是否真的丢失了。具体做法是:发送端如果连续收到 3个重复的确认报文段，就认为是拥塞发生了。然后它启用快速重传和快速恢复算法来处理拥塞，过程如下:</p>
<p>1)当收到第3个重复的确认报文段时，按照式(3-3)计算ssthresh，然后立即重传丢失的报文段，并按照式(3-4)设置CWND。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142156591.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-14 下午9.56.04" /></p>
<p>2)每次收到1个重复的确认时，设置CWND=CWND+SMSS。此时发送端可以发送新的TCP报文段(如果新的CWND允许的话)。【扩大窗口，快速重传】</p>
<p>3)当收到新数据的确认时，设置CWND=ssthresh(ssthresh是新的慢启动门限值，由第一步计算得到)。【如果能收到说明没问题，重新确定阈值，快速恢复】</p>
<p>快速重传和快速恢复完成之后，拥塞控制将<u>恢复到拥塞避免阶段</u>，这一点由第3步操作可得知。</p>
<h1 id="第4章-tcpip通信案例访问internet上的web服务器"><a class="markdownIt-Anchor" href="#第4章-tcpip通信案例访问internet上的web服务器"></a> 第4章 TCP/IP通信案例:访问Internet上的Web服务器</h1>
<p>在第1章中，我们简单地讨论了TCP/IP协议族各层的功能和部分协议，以及它们之间是如何协作完成网络通信的。在第2章和第3章中， 我们详细地探讨了IP协议和TCP协议。本章，我们分析一个完整的 TCP/IP通信的实例——访问Internet上的Web服务器，通过该实例把这些知识串联起来。选择使用Web服务器展开讨论的理由是:</p>
<p>1、Internet上的Web服务器随处都可以获得，我们通过浏览器访问任何一个网站都是在与Web服务器通信。</p>
<p>2、本书后续章节将编写简单的Web服务器程序，因此先学习其工作原理是有好处的。</p>
<p>Web客户端和服务器之间使用<strong>HTTP协议通信</strong>。HTTP协议的内容相当广泛，涵盖了网络应用层协议需要考虑的诸多方面。因此，学习 HTTP协议对应用层协议设计将大有裨益。</p>
<h2 id="41-实例总图"><a class="markdownIt-Anchor" href="#41-实例总图"></a> 4.1 实例总图</h2>
<p>我们按照如下方法来部署通信实例:在Kongming20上运行wget客户端程序，在ernest-laptop上运行squid代理服务器程序。客户端通过代 理服务器的中转，获取Internet上的主机www.baidu.com的首页文档 index.html，如图4-1所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142201066.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-14 下午10.01.32" /></p>
<p>由图4-1可见，wget客户端程序和代理服务器之间，以及代理服务器与Web服务器之间都是使用HTTP协议通信的。HTTP协议是一种应用 层协议，它默认使用的传输层协议是TCP协议。我们将在后文中简单讨论HTTP协议。</p>
<p>为了将ernest-laptop设置为Kongming20的<strong>HTTP代理服务器</strong>，我们需要在Kongming20上设置环境变量http_proxy:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">$<span class="hljs-keyword">export</span> http_proxy=<span class="hljs-string">&quot;ernest-laptop:3128&quot;</span>#在Kongming20上执行<br></code></pre></td></tr></table></figure>
<p>其中，3128是squid服务器默认使用的端口号(可以通过lsof命令查看服务器程序监听的端口号，见第17章)。设置好环境变量之后， Kongming20访问任何Internet上的Web服务器时，其HTTP请求都将首先发送至ernest-laptop的3128端口。</p>
<p>squid代理服务器接收到wget客户端的HTTP请求之后，将简单地修改这个请求，然后把它发送给最终的目标Web服务器。既然代理服务器 访问的是Internet上的机器，可以预见它发送的IP数据报都将经过路由器的中转，这一点也体现在图4-1中了。</p>
<h2 id="42-部署代理服务器"><a class="markdownIt-Anchor" href="#42-部署代理服务器"></a> 4.2 部署代理服务器</h2>
<p>由于通信实例中使用了HTTP代理服务器(squid程序)，所以先简单介绍一下HTTP代理服务器的工作原理，以及如何部署squid代理服务 器。</p>
<h3 id="421-http代理服务器的工作原理"><a class="markdownIt-Anchor" href="#421-http代理服务器的工作原理"></a> 4.2.1 HTTP代理服务器的工作原理</h3>
<p>在HTTP通信链上，客户端和目标服务器之间通常存在某些中转代理服务器，它们提供对目标资源的中转访问。一个HTTP请求可能被多 个代理服务器转发，<u>后面的服务器称为前面服务器的上游服务器</u>。代理服务器按照其使用方式和作用，分为<strong>正向代理服务器</strong>、<strong>反向代理服务器</strong>和<strong>透明代理服务器</strong>。</p>
<h4 id="正向代理"><a class="markdownIt-Anchor" href="#正向代理"></a> 正向代理</h4>
<p>要求客户端自己设置代理服务器的地址。<u>客户的每次请求都将直接发送到该代理服务器，并由代理服务器来请求目标资源</u>。 比如处于防火墙内的局域网机器要访问Internet，或者要访问一些被屏蔽掉的国外网站，就需要使用正向代理服务器。</p>
<h4 id="反向代理"><a class="markdownIt-Anchor" href="#反向代理"></a> 反向代理</h4>
<p>则被设置在服务器端，因而客户端无须进行任何设置。 反向代理是<u>指用代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从内部服务器上得到的结果返回给客户端</u>。</p>
<p>这种情况下，代理服务器对外就表现为一个真实的服务器。各大网站通常分区域设置了多个代理服务器，所以在不同的地方ping同一个域名可能得到不同的IP地址，因为这些IP地址实际上是代理服务器的IP地址。图4-2显示了正向代理服务器和反向代理服务器在HTTP通信链上的逻辑位置。</p>
<p>图4-2中，正向代理服务器和客户端主机处于同一个逻辑网络中。 该逻辑网络可以是一个本地LAN，也可以是一个更大的网络。反向代理服务器和真正的Web服务器也位于同一个逻辑网络中，这通常由提供网站的公司来配置和管理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205161643321.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-16 下午4.43.52" /></p>
<p>透明代理只能设置在网关上。用户访问Internet的数据报必然都经过网关，如果在网关上设置代理，则该代理对用户来说显然是透明的。透明代理可以看作正向代理的一种特殊情况。</p>
<p>代理服务器通常还提供缓存目标资源的功能(可选)，这样用户下次访问同一资源时速度将很快。优秀的开源软件squid、varnish都是提供了缓存能力的代理服务器软件，其中squid支持所有代理方式，而varnish仅能用作反向代理。</p>
<h3 id="422-部署squid代理服务器"><a class="markdownIt-Anchor" href="#422-部署squid代理服务器"></a> 4.2.2 部署squid代理服务器</h3>
<p>现在我们在ernest-laptop上部署squid代理服务器。这个过程很简单，只需修改squid服务器的配置文件/etc/squid3/squid.conf，在其中加 入如下两行代码(需要root权限，且应该加在合适的位置，详情可参考其他类似条目的设置):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">acl localnet src <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span><br> http_access allow localnet<br></code></pre></td></tr></table></figure>
<p>这两行代码的含义是:允许网络192.168.1.0上的所有机器通过该代理服务器来访问Web服务器。其中，“192.168.1.0/24”是CIDR(Classless Inter-Domain Routing，无类域间路由)风格的IP地址表示方法:“/”前的部分指定网络的IP地址，“/”后的部分则指定子网掩码中“1”的位数。 对IPv4而言，上述表示等价于“192.168.1.0/255.255.255.0”(IP地址/子网掩码)。</p>
<p>我们通过上面的两行代码简单地配置了squid的访问控制。但实际应用中，squid提供更多、更安全的配置，比如用户验证等。</p>
<p>接下来在ernest-laptop上执行如下命令，以重启squid服务器:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo service squid3 restart<br>*Restarting Squid HTTP Proxy <span class="hljs-number">3.0</span> squid3[OK]<br></code></pre></td></tr></table></figure>
<p>service是一个脚本程序(/usr/sbin/service)，它为/etc/init.d/目录下的众多服务器程序(比如httpd、vsftpd、sshd和mysqld等)的启动 (start)、停止(stop)和重启(restart)等动作提供了一个统一的管理。现在，Linux程序员已经越来越偏向于使用service脚本来管理服务器程序了。</p>
<h2 id="43-使用tcpdump抓取传输数据包"><a class="markdownIt-Anchor" href="#43-使用tcpdump抓取传输数据包"></a> 4.3 使用tcpdump抓取传输数据包</h2>
<p>在执行wget命令前，我们首先应删除ernest-laptop的ARP高速缓存中路由器对应的项，以便观察TCP/IP通信过程中ARP协议何时起作 用。然后，使用tcpdump命令抓取整个通信过程中传输的数据包。完整的操作过程如代码清单4-1所示。</p>
<p>代码清单4-1 使用wget抓取网页</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo arp-d <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br>$sudo tcpdump -s <span class="hljs-number">2000</span> -i eth0 -ntX <span class="hljs-string">&#x27;(src 192.168.1.108)or(dst 192.168.1.108)or(arp)&#x27;</span><br>$wget --header=<span class="hljs-string">&quot;Connection:close&quot;</span> http:<span class="hljs-comment">//www.baidu.com/index.html</span><br>-<span class="hljs-number">-2012</span><span class="hljs-number">-07</span><span class="hljs-number">-03</span> <span class="hljs-number">00</span>:<span class="hljs-number">51</span>:<span class="hljs-number">12</span> --http:<span class="hljs-comment">//www.baidu.com/index.html</span><br>Resolving ernest-laptop..<span class="hljs-number">.192</span><span class="hljs-number">.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><br>Connecting to ernest-laptop|<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>|:<span class="hljs-number">3128.</span>..connected.<br>Proxy request sent,awaiting response..<span class="hljs-number">.200</span> OK<br>Length:<span class="hljs-number">8024</span>(<span class="hljs-number">7.8</span>K)[text/html]<br>Saving to:“index.html” <br><span class="hljs-number">100</span>%[=======================&gt;]<span class="hljs-number">8</span>,<span class="hljs-number">024</span>--.-K/s in <span class="hljs-number">0.001</span>s <span class="hljs-number">2012</span><span class="hljs-number">-07</span><span class="hljs-number">-03</span> <span class="hljs-number">00</span>:<span class="hljs-number">51</span>:<span class="hljs-number">12</span>(<span class="hljs-number">8.76</span> MB/s)-“index.html”              saved[<span class="hljs-number">8024</span>/<span class="hljs-number">8024</span>]<br></code></pre></td></tr></table></figure>
<p>wget命令的输出显示，HTTP请求确实是先被送至代理服务器的3128端口，并且代理服务器正确地返回了文件index.html的内容。</p>
<p>这次通信的完整tcpdump输出内容如代码清单4-2所示。</p>
<p>代码清单4-2 访问Internet上的Web服务器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[S],seq <span class="hljs-number">227192137</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[S.],seq <span class="hljs-number">1084588508</span>,ack <span class="hljs-number">227192138</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">1</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">137</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">136</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[.],ack <span class="hljs-number">137</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">6.</span>ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>,length <span class="hljs-number">28</span> <br><span class="hljs-number">7.</span>ARP,Reply <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> is-at <span class="hljs-number">14</span>:e6:e4:<span class="hljs-number">93</span>:<span class="hljs-number">5b</span>:<span class="hljs-number">78</span>,length <span class="hljs-number">46</span> <br><span class="hljs-number">8.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.46149</span>&gt;<span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><span class="hljs-number">.53</span>:<span class="hljs-number">59410</span>+A? www.baidu.com.(<span class="hljs-number">31</span>)<br><span class="hljs-number">9.</span>IP <span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><span class="hljs-number">.53</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.46149</span>:<span class="hljs-number">59410</span> <span class="hljs-number">3</span>/<span class="hljs-number">4</span>/<span class="hljs-number">0</span> CNAME www.a.shifen.com.,A <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span>,A <span class="hljs-number">119.75</span><span class="hljs-number">.217</span><span class="hljs-number">.56</span>(<span class="hljs-number">162</span>) <br><span class="hljs-number">10.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[S],seq <span class="hljs-number">1084002207</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">11.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[S.],seq <span class="hljs-number">4261071806</span>,ack <span class="hljs-number">1084002208</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">12.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">1</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">13.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">226</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">225</span><br><span class="hljs-number">14.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[.],ack <span class="hljs-number">226</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">15.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">380</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">379</span><br><span class="hljs-number">16.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">380</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">17.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[.],seq <span class="hljs-number">380</span>:<span class="hljs-number">1820</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">1440</span><br><span class="hljs-number">18.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">1820</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">19.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[.],seq <span class="hljs-number">1820</span>:<span class="hljs-number">3260</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">1440</span><br><span class="hljs-number">20.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">3260</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">21.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[P.],seq <span class="hljs-number">3260</span>:<span class="hljs-number">4700</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">1440</span><br><span class="hljs-number">22.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">4700</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">23.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[.],seq <span class="hljs-number">1</span>:<span class="hljs-number">1449</span>,ack <span class="hljs-number">137</span>,length <span class="hljs-number">1448</span><br><span class="hljs-number">24.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[P.],seq <span class="hljs-number">1449</span>:<span class="hljs-number">2166</span>,ack <span class="hljs-number">137</span>,length <span class="hljs-number">717</span><br><span class="hljs-number">25.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[.],seq <span class="hljs-number">2166</span>:<span class="hljs-number">3614</span>,ack <span class="hljs-number">137</span>,length <span class="hljs-number">1448</span><br><span class="hljs-number">26.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[.],seq <span class="hljs-number">4700</span>:<span class="hljs-number">6140</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">1440</span><br><span class="hljs-number">27.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">6140</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">28.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[.],seq <span class="hljs-number">6140</span>:<span class="hljs-number">7580</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">1440</span><br><span class="hljs-number">29.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">7580</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">30.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[FP.],seq <span class="hljs-number">7580</span>:<span class="hljs-number">8404</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">824</span><br><span class="hljs-number">31.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[F.],seq <span class="hljs-number">226</span>,ack <span class="hljs-number">8405</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">32.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">1449</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">33.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[.],seq <span class="hljs-number">3614</span>:<span class="hljs-number">6510</span>,ack <span class="hljs-number">137</span>,length <span class="hljs-number">2896</span><br><span class="hljs-number">34.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">2166</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">35.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[.],seq <span class="hljs-number">6510</span>:<span class="hljs-number">7958</span>,ack <span class="hljs-number">137</span>,length <span class="hljs-number">1448</span><br><span class="hljs-number">36.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[FP.],seq <span class="hljs-number">7958</span>:<span class="hljs-number">8523</span>,ack <span class="hljs-number">137</span>,length <span class="hljs-number">565</span><br><span class="hljs-number">37.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">3614</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">38.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">5062</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">39.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">6510</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">40.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">7958</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">41.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[.],ack <span class="hljs-number">227</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">42.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[F.],seq <span class="hljs-number">137</span>,ack <span class="hljs-number">8524</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">43.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[.],ack <span class="hljs-number">138</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>我们一共抓取了43个数据包。与前面章节的讨论不同，这些数据包不是一对客户端和服务器之间交换的内容，而是两对客户端和服务器(wget客户端和代理服务器，以及代理服务器和目标Web服务器) 之间通信的全部内容。所以，tcpdump的输出把这两组通信的内容交织在一起。但为了讨论问题的方便，我们将这43个数据包按照其逻辑关系分为如下4个部分:</p>
<p>1、代理服务器访问DNS服务器以查询域名www.baidu.com对应的IP地址，包括数据包8、9。</p>
<p>2、代理服务器查询路由器MAC地址的ARP请求和应答，包括数据包6、7。</p>
<p>3、wget客户端(192.168.1.109)和代理服务器(192.168.1.108)之间的HTTP通信，包括数据包1<sub>5、23</sub>25、32~40、42和43。</p>
<p>4、代理服务器和Web服务器(119.75.218.77)之间的HTTP通信， 包括数据包10<sub>22、26</sub>31和41。</p>
<p>下面我们将依次讨论前3个部分，第4个部分与第3个部分的内容基本相似，不再赘述。</p>
<h2 id="44-访问dns服务器"><a class="markdownIt-Anchor" href="#44-访问dns服务器"></a> 4.4 访问DNS服务器</h2>
<p>数据包8、9表示代理服务器ernest-laptop向DNS服务器(219.239.26.42，首选DNS服务器的IP地址，见1.6.2节)查询域名www.baidu.com对应的IP地址，并得到了回复。该回复包括一个主机别名(<a target="_blank" rel="noopener" href="http://www.a.shifen.com">www.a.shifen.com</a>)和两个IP地址(119.75.218.77和 119.75.217.56)。代理服务器执行DNS查询的完整过程如图4-3所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205161712755.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-16 下午5.12.04" /></p>
<p>squid程序通过读取/etc/resolv.conf文件获得DNS服务器的IP地址 (见1.6.2节)，然后将控制权传递给内核中的UDP模块。</p>
<p>UDP模块将DNS查询报文封装成UDP数据报，同时把源端口号和目标端口号加入UDP数据报头部，然后UDP模块调用IP服务。IP模块则将UDP数据报封装成IP数据报，并把源端IP地址(192.168.1.108)和DNS服务器的IP地址加入IP数据报头部。</p>
<p>接下来，IP模块查询路由表以决定如何发送该IP数据报。根据路由策略，目标IP地址(219.239.26.42)仅能匹配路由表中的默认路由项，因此该IP数据报先被发送至路由器(IP地址为192.168.1.1)，然后通过路由器来转发。</p>
<p>因为ernest-laptop的ARP缓存中没有与路由器对应的缓存项(我们手动将其删除了)，所以ernest-laptop需要发起一个ARP广播以查询路由器的IP地址，而这正是数据包6描述的内容。</p>
<p>路由器则通过ARP应答告诉ernest-laptop自己的MAC地址是14:e6:e4:93:5b:78，如数据包7所示。</p>
<p>最终，以太网驱动程序将IP数据报封装成以太网帧发送给路由器。</p>
<p>此后，代理服务器再次发送数据到Internet时将不再需要ARP查询，因为ernest-laptop的ARP高速缓存中已经记录了路由器的IP地址和MAC地址的映射关系。</p>
<p>需要指出的是，虽然IP数据报是先发送到路由器，再由它转发给目标主机，但是其头部的目标IP地址却是最终的目标主机(DNS服务器)的IP地址，而不是中转路由器的IP地址(192.168.1.1)。这说明， <u>IP头部的源端IP地址和目的端IP地址在转发过程中是始终不变</u>的(一种例外是源路由选择)。但<u>帧头部的源端物理地址和目的端物理地址在转发过程中则是一直在变化</u>的。</p>
<h2 id="45-本地名称查询"><a class="markdownIt-Anchor" href="#45-本地名称查询"></a> 4.5 本地名称查询</h2>
<p>一般来说，通过域名来访问Internet上的某台主机时，需要使用DNS服务来获取该主机的IP地址。但如果我们通过主机名来访问本地局域网上的机器，则可通过本地的静态文件来获得该机器的IP地址。</p>
<p>Linux将目标主机名及其对应的IP地址存储在/etc/hosts配置文件中。当需要查询某个主机名对应的IP地址时，程序将首先检查这个文件。Kongming20上/etc/hosts文件的内容如下(笔者手动修改过):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> localhost<br><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> Kongming20<br><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> ernest-laptop<br></code></pre></td></tr></table></figure>
<p>其中第一项指出本地回路地址127.0.0.1的名称是localhost，第二项和第三项则分别描述了Kongming20和ernest-laptop的IP地址及对应的主机名。</p>
<p>代码清单4-1中，wget命令输出“Resolving ernest- laptop…192.168.1.108”，即它成功地解析了主机名ernest-laptop对应的IP地址，原因如下:当wget访问某个Web服务器时，它先读取环境变量http_proxy。如果该环境变量被设置，并且我们没有阻止wget使用代理服务，则wget将通过http_proxy指定的代理服务器来访问Web服务。</p>
<p>但http_proxy环境变量中包含主机名ernest-laptop，因此wget将首先读取/etc/hosts配置文件，试图通过它来解析主机名ernest-laptop对应的IP地址。其结果正如wget的输出所示，解析成功。</p>
<p>如果程序在/etc/hosts文件中<strong>未找到</strong>目标机器名对应的IP地址，它将求助于DNS服务。</p>
<p>用户可以通过修改/etc/host.conf文件来自定义系统解析主机名的方法和顺序(一般是先访问本地文件/etc/hosts，再访问DNS服务)， Kongming20上的该文件内容如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">order hosts,bind<br>multi on<br></code></pre></td></tr></table></figure>
<p>其中第一行表示优先使用/etc/hosts文件来解析主机名(hosts)， 失败后再使用DNS服务(bind)。第二行表示如果/etc/hosts文件中一个主机名对应多个IP地址，那么解析的结果就包含多个IP地址。/etc/host.conf文件通常仅包含这两行，但它支持更多选项，具体使用请参考其man手册。</p>
<p>标准文档RFC 1123指出，网络上的主机都应该实现一个简单的本地名称查询服务。</p>
<h2 id="46-http通信"><a class="markdownIt-Anchor" href="#46-http通信"></a> 4.6 HTTP通信</h2>
<p>为了方便讨论，我们将wget客户端和代理服务器之间的通信过程画成图4-4所示的TCP时序图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205161827241.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-16 下午6.26.57" /></p>
<p>首先应该注意的是，TCP连接从建立到关闭的过程中，客户端仅给服务器发送了一个HTTP请求(即TCP报文段4)，该请求的长度为136 字节(见代码清单4-2中TCP报文段4的length值)。代理服务器则用6个TCP报文段(23、24、25、33、35和36)给客户端返回了总长度为8522 字节(这可以从对方的最后一个确认报文段42的确认值计算得到，考虑同步报文段和结束报文段各占用一个序号)的HTTP应答。客户端使 用了7个TCP报文段(32、34、37、38、39、40和42)来确认这8522字节的HTTP应答数据。</p>
<p>下面我们简单分析一下这136字节的HTTP请求和8522字节的HTTP应答的部分主要内容(开启tcpdump的-X选项来查看)。</p>
<h3 id="461-http请求"><a class="markdownIt-Anchor" href="#461-http请求"></a> 4.6.1 HTTP请求</h3>
<p>HTTP请求的部分内容如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">GET http:<span class="hljs-comment">//www.baidu.com/index.html HTTP/1.0</span><br>User-Agent:Wget/<span class="hljs-number">1.12</span>(linux-gnu)<br>Host:www.baidu.com<br>Connection:close<br></code></pre></td></tr></table></figure>
<p>第1行是请求行。其中“GET”是请求方法，表示客户端以只读的方式来申请资源。常见的HTTP请求方法有9种，如表4-1所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205162120269.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-16 下午9.20.40" /></p>
<p>这些方法中，HEAD、GET、OPTIONS和TRACE被视为安全的方法，因为它们只是从服务器获得资源或信息，而不对服务器进行任何修改。而POST、PUT、DELETE和PATCH则影响服务器上的资源。</p>
<p>另一方面，GET、HEAD、OPTIONS、TRACE、PUT和DELETE等请求方法被认为是等幂的(idempotent)，即<u>多次连续的、重复的请求和只发送一次该请求具有完全相同</u>的效果。而<strong>POST方法则不同</strong>，<u>连续多次发送同样一个请求可能进一步影响服务器上</u>的资源。</p>
<p>值得一提的是，Linux上提供了几个命令:HEAD、GET和POST。其含义基本与HTTP协议中的同名请求方法相同。它们适合用来快速测试Web服务器。</p>
<p>“<a target="_blank" rel="noopener" href="http://www.baidu.com/index.html%E2%80%9D%E6%98%AF%E7%9B%AE%E6%A0%87%E8%B5%84%E6%BA%90%E7%9A%84URL%E3%80%82%E5%85%B6%E4%B8%AD%E2%80%9Chttp%E2%80%9D%E6%98%AF%E6%89%80%E8%B0%93%E7%9A%84scheme%EF%BC%8C%E8%A1%A8%E7%A4%BA">http://www.baidu.com/index.html”是目标资源的URL。其中“http”是所谓的scheme，表示</a><strong>获取目标资源需要使用的应用层协议</strong>。</p>
<p>其他常见的scheme还有ftp、rtsp和file等。“<a target="_blank" rel="noopener" href="http://www.baidu.com">www.baidu.com</a>”指定资源所在的目标主机。“index.html”指定资源文件的名称，这里指的是服务器根目录(站点的根目录，而不是服务器的文件系统根目录“/”)中的索引文件。</p>
<p>“HTTP/1. 0”表示客户端(wget程序)使用的HTTP的版本号是1.0。 目前的主流HTTP版本是1.1。</p>
<p>HTTP请求内容中的第2~4行都是HTTP请求的头部字段。一个HTTP请求可以包含多个头部字段。一个头部字段用一行表示，包含字段名称、冒号、空格和字段的值。HTTP请求中的头部字段可按任意顺序排列。</p>
<p>“User-Agent:Wget/1.12(linux-gnu)”表示客户端使用的程序是wget。</p>
<p>“Host:www.baidu.com”<a target="_blank" rel="noopener" href="http://xn--www-g88d49x1m3amsb25b822e81ekv2c.baidu.com">表示目标主机名是www.baidu.com</a>。HTTP协议规定HTTP请求中<strong>必须包含</strong>的头部字段就是目标主机名。</p>
<h4 id="短连接"><a class="markdownIt-Anchor" href="#短连接"></a> 短连接</h4>
<p>“Connection:close”是我们执行wget命令时传入的(见代码清单4-1)，用以告诉服务器处理完这个HTTP请求之后就关闭连接。在旧的HTTP协议中，Web客户端和Web服务器之间的一个TCP连接只能为一个HTTP请求服务。当处理完客户的一个HTTP请求之后，Web服务器就 (主动)将TCP连接关闭了。此后，同一客户如果要再发送一个HTTP请求的话，必须与服务器建立一个新的TCP连接。也就是说，同一个客户的多个连续的HTTP请求不能共用同一个TCP连接，这称为短连接。</p>
<h4 id="长连接"><a class="markdownIt-Anchor" href="#长连接"></a> 长连接</h4>
<p>与之相反，是指多个请求可以使用同一个TCP连接。长连接在编程上稍微复杂一些，但性能上却有很大提高:它极大地减少了网络上为建立TCP连接导致的负荷，同时对每次请求而言缩减了处理时间。 HTTP请求和应答中的“Connection”头部字段就是专门用于告诉对方一个请求完成之后该如何处理连接的，比如立即关闭连接(该头部字段的值为“close”)或者保持一段时间以等待后续请求(该头部字段的值为“keep-alive”)。当用浏览器访问一个网页时，读者不妨使用netstat命令来查看浏览器和Web服务器之间的连接是否是长连接，以及该连接维持了多长时间。</p>
<p>在所有头部字段之后，HTTP请求必须包含一个空行，以标识头部字段的结束。请求行和每个头部字段都必须以<CR><LF>结束(回车符和换行符);而空行则必须只包含一个<CR><LF>，不能有其他字符，甚至是空白字符。</p>
<p>在空行之后，HTTP请求可以包含可选的消息体。如果消息体非空，则HTTP请求的头部字段中必须包含描述该消息体长度的字段“Content-Length”。我们的实例只是获取目标服务器上的资源，所以没有消息体。</p>
<h3 id="462-http应答"><a class="markdownIt-Anchor" href="#462-http应答"></a> 4.6.2 HTTP应答</h3>
<p>HTTP应答的部分内容如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">	 HTTP/<span class="hljs-number">1.0</span> <span class="hljs-number">200</span> OK<br>   Server:BWS/<span class="hljs-number">1.0</span><br>   Content-Length:<span class="hljs-number">8024</span><br>   Content-Type:text/html;charset=gbk<br>   Set-<br>Cookie:BAIDUID=A5B6C72D68CF639CE8896FD79A03FBD8:FG=<span class="hljs-number">1</span>;expires=Wed,<span class="hljs-number">04</span>-<br>Jul<span class="hljs-number">-42</span> <span class="hljs-number">00</span>:<span class="hljs-number">10</span>:<span class="hljs-number">47</span> GMT;path=/;domain=.baidu.com<br>   Via:<span class="hljs-number">1.0</span> <span class="hljs-built_in">localhost</span>(squid/<span class="hljs-number">3.0</span> STABLE18)<br></code></pre></td></tr></table></figure>
<p>第一行是状态行。“HTTP/1.0”是服务器使用的HTTP协议的版本号。通常，服务器需要使用和客户端相同的HTTP协议版本。“200 OK”是状态码和状态信息。常见的状态码和状态信息及其含义如表4-2 所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205162146797.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-16 下午9.46.49" /></p>
<p><strong>第2~7行</strong>是HTTP应答的头部字段。其表示方法与HTTP请求中的头部字段相同。</p>
<p>**“Server:BWS/1. 0”**表示目标Web服务器程序的名字是BWS(Baidu Web Server)。</p>
<p>**“Content-Length:8024”**表示目标文档的长度为8024字节。这个值和wget输出的文档长度一致。</p>
<p>**“Content-Type:text/html;charset=gbk”**表示目标文档的MIME类型。 其中“text”是主文档类型，“html”是子文档类型。“text/html”表示目标文档index.html是text类型中的html文档。“charset”是text文档类型的一个参数，用于指定文档的字符编码。</p>
<p>**“Set-Cookie:BAIDUID=A5B6C72D68CF639CE8896FD79A03FBD8:FG=1;expi res=Wed,04-Jul-42 00:10:47 GMT;path=/;domain=. <a target="_blank" rel="noopener" href="http://baidu.com">baidu.com</a>”<strong>表示服务器传送一个Cookie给客户端。其中，</strong>“BAIDUID”<strong>指定Cookie的名字，</strong>“expires”<strong>指定Cookie的生存时间，</strong>“domain”<strong>和</strong>“path”**指定该Cookie生效的域名和路径。下面我们简单分析一下Cookie的作用。</p>
<p>第2章中曾提到，HTTP协议是一种<strong>无状态</strong>的协议，即每个HTTP请求之间没有任何上下文关系。如果服务器处理后续HTTP请求时需要用到前面的HTTP请求的相关信息，客户端必须重传这些信息。这样就<u>导致HTTP请求必须传输更多</u>的数据。</p>
<p>在交互式Web应用程序兴起之后，HTTP协议的这种无状态特性就显得不适应了，因为交互程序<u>通常要承上启下</u>。因此，我们要<u>使用额外的手段来保持HTTP连接状态，常见的解决方法就是Cookie</u>。Cookie是服务器发送给客户端的特殊信息(通过HTTP应答的头部字段“Set- Cookie”)，客户端每次向服务器发送请求的时候都需要带上这些信息 (通过HTTP请求的头部字段“Cookie”)。这样服务器就可以区分不同 的客户了。<strong>基于浏览器的自动登录就是用Cookie实现的</strong>。</p>
<p>**“Via:1. 0 localhost(squid/3.0 STABLE18)”**表示HTTP应答在返回过程中经历过的所有代理服务器的地址和名称。这里的localhost实际上指的是“192.168.1.108”。这个头部字段的功能有点类似于IP协议的记录路由功能。</p>
<p>在所有头部字段之后，HTTP应答必须包含一个空行，以标识头部字段的结束。状态行和每个头部字段都必须以<CR><LF>结束;而空行则必须只包含一个<CR><LF>，不能有其他字符，甚至是空白字符。</p>
<p>空行之后是被请求文档index.html的内容(当然，我们并不关心它)，其长度是8024字节。</p>
<h2 id="47-实例总结"><a class="markdownIt-Anchor" href="#47-实例总结"></a> 4.7 实例总结</h2>
<p>至此，我们成功地访问了Internet上的Web服务器，通过该实例，我们分析了TCP/IP协议族各层的部分协议:应用层的HTTP和DNS、传输层的TCP和UDP、网络层的IP、数据链路层的ARP，以及它们之间是如何协作来完成网络通信的。我们的分析方法是使用tcpdump抓包， 然后观察各层协议的头部内容以推断其工作原理。在后续章节中，我们还将多次使用这种方法来分析问题。</p>
<h1 id="第5章-linux网络编程基础api"><a class="markdownIt-Anchor" href="#第5章-linux网络编程基础api"></a> 第5章 Linux网络编程基础API</h1>
<p>本章是承前启后的一章。它探讨Linux网络编程基础API与内核中TCP/IP协议族之间的关系，并为后续章节提供编程基础。我们将从如下3个方面讨论Linux网络API:</p>
<p><strong>socket地址API</strong></p>
<p>socket最开始的含义是一个IP地址和端口对(ip，port)。它唯一地表示了使用TCP通信的一端。本书称其为socket地址。</p>
<p><strong>socket基础API</strong></p>
<p>socket的主要API都定义在sys/socket.h头文件中，包括创建socket、命名socket、监听socket、接受连接、发起连接、读写数据、获取地址信息、检测带外标记，以及读取和设置socket选项。</p>
<p><strong>网络信息API</strong></p>
<p>Linux提供了一套网络信息API，以实现主机名和IP地址之间的转换，以及服务名称和端口号之间的转换。这些API都定义在netdb.h头文件中，我们将讨论其中几个主要的函数。</p>
<h2 id="51-socket地址api"><a class="markdownIt-Anchor" href="#51-socket地址api"></a> 5.1 socket地址API</h2>
<p>要学习socket地址API，先要理解<strong>主机字节序</strong>和<strong>网络字节序</strong>。</p>
<h3 id="511-主机字节序和网络字节序"><a class="markdownIt-Anchor" href="#511-主机字节序和网络字节序"></a> 5.1.1 主机字节序和网络字节序</h3>
<p>现代CPU的累加器一次都能装载(至少)4字节(这里考虑32位机，下同)，即一个整数。那么这4字节在内存中排列的顺序将影响它被累加器装载成的整数的值。这就是字节序问题。字节序分为<strong>大端字节序(big endian)<strong>和</strong>小端字节序(little endian)</strong>。大端字节序是指<u>一个整数的高位字节(23~31bit)存储在内存的低地址处</u>，<u>低位字节(0 ~7 bit)存储在内存的高地址处</u>。小端字节序则是指<u>整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处</u>。代码清单5-1可用于检查机器的字节序。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205172044910.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-17 下午8.44.34" /></p>
<p>代码清单5-1 判断机器字节序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">byteorder</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">	&#123;</span><br>		<span class="hljs-keyword">short</span> value;<br>		<span class="hljs-keyword">char</span> union_bytes[ <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( <span class="hljs-keyword">short</span> ) ];<br>	&#125; test;<br>	test.value = <span class="hljs-number">0x0102</span>; <span class="hljs-comment">// 用一个共用体来表示一个16进制的数，通过两种方式来表示结果</span><br>	<span class="hljs-keyword">if</span> (  ( test.union_bytes[ <span class="hljs-number">0</span> ] == <span class="hljs-number">1</span> ) &amp;&amp; ( test.union_bytes[ <span class="hljs-number">1</span> ] == <span class="hljs-number">2</span> ) )<br>	&#123;<br>		<span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;big endian\n&quot;</span> ); <span class="hljs-comment">// 判断低位是不是小的高位是不是大的</span><br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( ( test.union_bytes[ <span class="hljs-number">0</span> ] == <span class="hljs-number">2</span> ) &amp;&amp; ( test.union_bytes[ <span class="hljs-number">1</span> ] == <span class="hljs-number">1</span> ) )<br>	&#123;<br>		<span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;little endian\n&quot;</span> ); <span class="hljs-comment">// 判断低位是不是大的高位是不是小的</span><br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;unknown...\n&quot;</span> );<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现代PC大多采用小端字节序，因此小端字节序又被称为<strong>主机字节序</strong>。</p>
<p>当格式化的数据(比如32bit整型数和16bit短整型数)在两台使用不同字节序的主机之间直接传递时，接收端必然错误地解释之。解决问题的方法是:发送端总是把要发送的数据<u>转化成大端字节序数据后再发送</u>，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端<u>可以根据自身采用的字节序决定是否对接收到的数据进行转换</u>(小端机转换，大端机不转换)。因此大端字节序也称为<strong>网络字节序</strong>，它给所有接收数据的主机提供了一个正确解释收到的格式化数据的保证。</p>
<p>需要指出的是，即使是同一台机器上的两个进程(比如一个由C语言编写，另一个由JAVA编写)通信，也要考虑字节序的问题(JAVA虚拟机采用大端字节序)。</p>
<p>Linux提供了如下4个函数来完成<u>主机字节序和网络字节序之间的转换</u>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">htonl</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> hostlong)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> <span class="hljs-title">htons</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> hostshort)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ntohl</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> netlong)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ntohs</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> netshort)</span></span>;<br></code></pre></td></tr></table></figure>
<p>它们的含义很明确，比如htonl表示“host to network long”，即将长整型(32 bit)的主机字节序数据转化为网络字节序数据。这4个函数中，长整型函数通常<u>用来转换IP地址</u>，短整型函数用来<u>转换端口号</u>(当然不限于此。任何格式化的数据通过网络传输时，都应该使用这些函数来转换字节序)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205181750387.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-18 下午5.49.36" /></p>
<h3 id="512-通用socket地址"><a class="markdownIt-Anchor" href="#512-通用socket地址"></a> 5.1.2 通用socket地址</h3>
<p>socket网络编程接口中表示<strong>socket地址</strong>的是结构体sockaddr，其定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/socket.h&gt;</span> </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">sa_family_t</span> sa_family; <br>  <span class="hljs-keyword">char</span> sa_data[<span class="hljs-number">14</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>sa_family成员</strong>是**地址族类型(sa_family_t)**的变量。地址族类型通常与协议族类型对应。常见的协议族(protocol family，也称domain， 见后文)和对应的地址族如表5-1所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205172102909.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-17 下午9.02.11" /></p>
<p>宏PF_ *和AF_ *都定义在bits/socket.h头文件中，且后者与前者有完全相同的值，所以二者通常混用。</p>
<p><strong>sa_data成员</strong>用于存放socket地址值。但是，不同的协议族的地址值具有不同的含义和长度，如表5-2所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205172105793.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-17 下午9.05.36" /></p>
<p>由表5-2可见，14字节的sa_data根本无法完全容纳多数协议族的地址值。因此，Linux定义了下面这个新的通用socket地址结构体:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/socket.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">sa_family_t</span> sa_family;<br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> __ss_align; <br>	<span class="hljs-keyword">char</span> __ss_padding[<span class="hljs-number">128</span> - <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(__ss_align)];  <span class="hljs-comment">// 为什么是128 - sizeof是因为保证二三元素的大小一定是128个字节</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个结构体不仅提供了足够大的空间用于存放地址值，而且是<strong>内存对齐</strong>的(这是__ss_align成员的作用)。</p>
<p>内存对齐相关的知识：<a target="_blank" rel="noopener" href="https://blog.csdn.net/feng__shuai/article/details/115768166">https://blog.csdn.net/feng__shuai/article/details/115768166</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/suoyudong/article/details/88366235?utm_medium=distribute.pc_relevant.none-task-blog-2">https://blog.csdn.net/suoyudong/article/details/88366235?utm_medium=distribute.pc_relevant.none-task-blog-2</a><sub>default</sub>baidujs_baidulandingword~default-0-88366235-blog-115768166.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=1</p>
<p>这部分说白了就是，当你的变量大小没办法一次性全部读取出来的话，会造成地址的浪费，不如直接补齐这部分都是你的。</p>
<h3 id="513-专用socket地址"><a class="markdownIt-Anchor" href="#513-专用socket地址"></a> 5.1.3 专用socket地址</h3>
<p>上面这两个通用socket地址结构体显然很不好用，比如设置与获取IP地址和端口号就需要执行烦琐的位操作。所以Linux为各个协议族提 供了专门的socket地址结构体。</p>
<p><strong>UNIX本地域协议族</strong>使用如下专用socket地址结构体:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/un.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">sa_family_t</span> sin_family;<span class="hljs-comment">/*地址族:AF_UNIX*/</span> <br>	<span class="hljs-keyword">char</span> sun_path[<span class="hljs-number">108</span>];<span class="hljs-comment">/*文件路径名*/</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>TCP/IP协议族有sockaddr_in和sockaddr_in6两个专用socket地址结构体，它们分别用于IPv4和IPv6:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">sa_family_t</span> sin_family;<span class="hljs-comment">/*地址族:AF_INET*/</span><br>	<span class="hljs-keyword">u_int16_t</span> sin_port;<span class="hljs-comment">/*端口号，要用网络字节序表示*/</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span><span class="hljs-comment">/*IPv4地址结构体，见下面*/</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">u_int32_t</span> s_addr;<span class="hljs-comment">/*IPv4地址，要用网络字节序表示*/</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in6</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">sa_family_t</span> sin6_family;<span class="hljs-comment">/*地址族:AF_INET6*/</span><br>	<span class="hljs-keyword">u_int16_t</span> sin6_port;<span class="hljs-comment">/*端口号，要用网络字节序表示*/</span> <br>  <span class="hljs-keyword">u_int32_t</span> sin6_flowinfo;<span class="hljs-comment">/*流信息，应设置为0*/</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> <span class="hljs-title">sin6_addr</span>;</span><span class="hljs-comment">/*IPv6地址结构体，见下面*/</span> <br>  <span class="hljs-keyword">u_int32_t</span> sin6_scope_id;<span class="hljs-comment">/*scope ID，尚处于实验阶段*/</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> sa_addr[<span class="hljs-number">16</span>];<span class="hljs-comment">/*IPv6地址，要用网络字节序表示*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这两个专用socket地址结构体各字段的含义都很明确，我们只在右边稍加注释。</p>
<p>所有专用socket地址(以及sockaddr_storage)类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr(强制转换即可)，因为<u>所有socket编程接口使用的地址参数</u>的类型都是<strong>sockaddr</strong>。</p>
<h3 id="514-ip地址转换函数"><a class="markdownIt-Anchor" href="#514-ip地址转换函数"></a> 5.1.4 IP地址转换函数</h3>
<p>通常，人们习惯用可读性好的字符串来表示IP地址，比如用点分十进制字符串表示IPv4地址，以及用十六进制字符串表示IPv6地址。但编程中我们需要先把它们转化为整数(二进制数)方能使用。</p>
<p>而记录日志时则相反，我们要把整数表示的IP地址转化为可读的字符串。下面3个函数可用于用<u>点分十进制</u>字符串表示的<strong>IPv4地址</strong>和<strong>用网络字节序</strong>整数表示的IPv4地址之间的转换:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">in_addr_t</span> <span class="hljs-title">inet_addr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*strptr)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inet_aton</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*cp, struct in_addr*inp)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">char</span>*<span class="hljs-title">inet_ntoa</span><span class="hljs-params">(struct in_addr in)</span></span>;<br></code></pre></td></tr></table></figure>
<p>inet_addr函数将用<u>点分十进制字符串</u>表示的IPv4地址转化为用<u>网络字节序整数</u>表示的IPv4地址。它失败时返回INADDR_NONE。</p>
<p>inet_aton函数完成和inet_addr同样的功能，但是将转化结果存储于 参数inp指向的地址结构中。它成功时返回1，失败则返回0。</p>
<p>inet_ntoa函数将用<u>网络字节序整数</u>表示的IPv4地址转化为<u>用点分十进制字符串</u>表示的IPv4地址。但需要注意的是，该函数内部用一个静 态变量存储转化结果，函数的返回值指向该静态内存，因此inet_ntoa是<strong>不可重入</strong>的。代码清单5-2揭示了其不可重入性。</p>
<p>代码清单5-2 不可重入的inet_ntoa函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">char</span>* szValue1 = <span class="hljs-built_in">inet_ntoa</span>(“<span class="hljs-number">1.2</span><span class="hljs-number">.3</span><span class="hljs-number">.4</span>”);<br><span class="hljs-keyword">char</span>* szValue2 = <span class="hljs-built_in">inet_ntoa</span>(“<span class="hljs-number">10.194</span><span class="hljs-number">.71</span><span class="hljs-number">.60</span>”);<br><span class="hljs-built_in">printf</span>(“address <span class="hljs-number">1</span>:%s\n”, szValue1);<br><span class="hljs-built_in">printf</span>(“address <span class="hljs-number">2</span>:%s\n”, szValue2);<br></code></pre></td></tr></table></figure>
<p>运行这段代码，得到的结果是: （说明了他们指向的是同一片区域，不可以用作并发执行）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">address1:<span class="hljs-number">10.194</span><span class="hljs-number">.71</span><span class="hljs-number">.60</span><br>address2:<span class="hljs-number">10.194</span><span class="hljs-number">.71</span><span class="hljs-number">.60</span><br></code></pre></td></tr></table></figure>
<p>下面这对更新的函数也能完成和前面3个函数同样的功能，并且它们同时适用于IPv4地址和IPv6地址:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inet_pton</span><span class="hljs-params">(<span class="hljs-keyword">int</span> af, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* src, <span class="hljs-keyword">void</span>* dst)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">inet_ntop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> af, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* src, <span class="hljs-keyword">char</span>* dst, <span class="hljs-keyword">socklen_t</span> cnt)</span></span>;<br></code></pre></td></tr></table></figure>
<p>inet_pton函数将用字符串表示的IP地址src(用点分十进制字符串表示的IPv4地址或用十六进制字符串表示的IPv6地址)转换成用网络字节序整数表示的IP地址，并把转换结果存储于<strong>dst指向的内存</strong>中。其中，af参数<u>指定地址族</u>，可以是AF_INET或者AF_INET6。inet_pton成功时返回1，失败则返回0并设置errno[1]。</p>
<p>inet_ntop函数进行相反的转换，前三个参数的含义与inet_pton的参数相同，最后一个参数cnt指定目标存储单元的大小。下面的两个宏能 帮助我们指定这个大小(分别用于IPv4和IPv6):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netinet/in.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INET_ADDRSTRLEN 16 </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INET6_ADDRSTRLEN 46</span><br></code></pre></td></tr></table></figure>
<p>inet_ntop成功时返回目标存储单元的地址，失败则返回NULL并设置errno。</p>
<p>[1]Linux提供众多errno以表示各种错误。如非特殊情况，本书将不一一指出各函数可能反馈的errno值。</p>
<h2 id="52-创建socket"><a class="markdownIt-Anchor" href="#52-创建socket"></a> 5.2 创建socket</h2>
<h3 id="用netstat命令显示套接字内容这个贯通全文"><a class="markdownIt-Anchor" href="#用netstat命令显示套接字内容这个贯通全文"></a> 用netstat命令显示套接字内容这个贯通全文</h3>
<p>UNIX/Linux的一个哲学是:<strong>所有东西都是文件</strong>。socket也不例外，它就是可读、可写、可控制、可关闭的文件描述符。下面的socket系统调用可创建一个socket:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> domain,<span class="hljs-keyword">int</span> type,<span class="hljs-keyword">int</span> protocol)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>domain参数</strong></p>
<p>告诉系统<u>使用哪个底层协议族</u>。对TCP/IP协议族而言，该参数应该设置为<strong>PF_INET</strong>(Protocol Family of Internet，用于IPv4)或<strong>PF_INET6</strong>(用于IPv6);对于UNIX本地域协议族而言，该参数应该设置为PF_UNIX。关于socket系统调用支持的所有协议族， 请读者自己参考其man手册。</p>
<p><strong>type参数</strong></p>
<p>指定服务类型。服务类型主要有<strong>SOCK_STREAM</strong>服务(流服务)和<strong>SOCK_UGRAM</strong>(数据报)服务。对TCP/IP协议族而言，其值取SOCK_STREAM表示传输层使用TCP协议，取SOCK_DGRAM表示传输层使用UDP协议。</p>
<p>值得指出的是，自Linux内核版本2.6.17起，type参数可以<u>接受上述服务类型与下面两个重要的标志相与</u>的值:SOCK_NONBLOCK和SOCK_CLOEXEC。它们分别表示将新创建的socket设为非阻塞的，以及用fork调用创建子进程时在子进程中关闭该socket。在内核版本 2.6.17之前的Linux中，文件描述符的这两个属性都需要使用额外的系统调用(比如fcntl)来设置。</p>
<p><strong>protocol参数</strong></p>
<p>是在前两个参数构成的协议集合下，再选择一个具体的协议。不过这个值通常都是唯一的(前两个参数已经完全决定了它的值)。几乎在所有情况下，我们都应该把它设置为0，表示使用默认协议。</p>
<p>socket系统调用成功时返回一个socket文件描述符，失败则返回-1并设置errno。</p>
<h2 id="53-命名socket"><a class="markdownIt-Anchor" href="#53-命名socket"></a> 5.3 命名socket</h2>
<p>创建socket时，我们给它指定了地址族，但是并未指定使用该地址族中的哪个具体<strong>socket地址</strong>。<u>将一个socket与socket地址绑定</u>称为给<strong>socket命名</strong>。在服务器程序中，我们通常要命名socket，因为只有命名后客户端才能知道该如何连接它。客户端则通常不需要命名socket，而是采用匿名方式，即使用操作系统自动分配的socket地址。命名socket的系统调用是bind，其定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">const</span> struct sockaddr* my_addr,<span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure>
<p>bind将<u>my_addr所指的socket地址</u>分配给未命名的<strong>sockfd文件描述符</strong>。</p>
<p><strong>addrlen参数</strong>指出该<strong>socket地址的长度</strong>。</p>
<p>bind成功时返回0，失败则返回-1并设置errno。其中两种常见的errno是EACCES和EADDRINUSE，它们的含义分别是:</p>
<p><strong>EACCES</strong></p>
<p>被绑定的地址是受保护的地址，仅超级用户能够访问。比如普通用户将socket绑定到知名服务端口(端口号为0~1023) 上时，bind将返回EACCES错误。</p>
<p><strong>EADDRINUSE</strong></p>
<p>被绑定的地址正在使用中。比如将socket绑定到一个处于TIME_WAIT状态的socket地址。</p>
<h2 id="54-监听socket"><a class="markdownIt-Anchor" href="#54-监听socket"></a> 5.4 监听socket</h2>
<p>socket被命名之后，还不能马上接受客户连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户连接:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">int</span> backlog)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>sockfd参数</strong>指定被监听的socket。</p>
<p><strong>backlog参数</strong>提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客户连接，客户端也将收到ECONNREFUSED错误信息。在内核版本2.2 之前的Linux中，backlog参数是指所有处于半连接状态 (SYN_RCVD)和完全连接状态(ESTABLISHED)的socket的上限。 但自内核版本2.2之后，它只表示处于完全连接状态的socket的上限，处于半连接状态的socket的上限则由/proc/sys/net/ipv4/tcp_max_syn_backlog内核参数定义。backlog参数的典型值是5。</p>
<p>listen成功时返回0，失败则返回-1并设置errno。</p>
<p>下面我们编写一个<strong>服务器程序</strong>，如代码清单5-3所示，以研究 backlog参数对listen系统调用的实际影响。</p>
<p>代码清单5-3 backlog参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> stop = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">/*SIGTERM信号的处理函数，触发时结束主程序中的循环*/</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle_term</span><span class="hljs-params">( <span class="hljs-keyword">int</span> sig )</span></span><br><span class="hljs-function"></span>&#123;<br>    stop = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span> <span class="hljs-comment">// argv[] : IP地址、端口号和backlog值</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">signal</span>( SIGTERM, handle_term );<br><br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">3</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number backlog\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) ); <span class="hljs-comment">// 0代表的是文件名字</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>]; <span class="hljs-comment">// IP地址</span><br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] ); <span class="hljs-comment">// 端口号</span><br>    <span class="hljs-keyword">int</span> backlog = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">3</span>] ); <span class="hljs-comment">// backlog值</span><br><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> ); <span class="hljs-comment">// 创立TCP写一个socket</span><br>    <span class="hljs-comment">// socket系统调用成功时返回一个socket文件描述符，失败则返回-1并设置errno。</span><br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">/*创建一个IPv4 socket地址 用于接收监听的ip*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;  <span class="hljs-comment">// 地址族 ： AF_INET</span><br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr ); <span class="hljs-comment">// 将IPv4地址转换成网络字节序整数表示的IP地址</span><br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );  <span class="hljs-comment">// 端口号，用网络字节序表示</span><br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );  <span class="hljs-comment">// 给sock套接字赋予地址</span><br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><br>    ret = <span class="hljs-built_in">listen</span>( sock, backlog );  <span class="hljs-comment">// 来监听这个套接字 backlog来确定可以监听队列的最大长度，再多就不听了</span><br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">/*循环等待连接，直到有SIGTERM信号将它中断*/</span><br>    <span class="hljs-keyword">while</span> ( ! stop )<br>    &#123;<br>        <span class="hljs-built_in">sleep</span>( <span class="hljs-number">1</span> );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-comment">/*关闭socket，见后文*/</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该服务器程序(名为testlisten)接收3个参数:IP地址、端口号和backlog值。我们在Kongming20上运行该服务器程序，并在ernest-laptop上多次执行telnet命令来连接该服务器程序。同时，每使用telnet命令建立一个连接，就执行一次netstat命令来查看服务器上连接的状态。具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">$./testlisten <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">12345</span> <span class="hljs-number">5</span>#监听<span class="hljs-number">12345</span>端口，给backlog传递典 型值<span class="hljs-number">5</span><br>$telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">12345</span>#多次执行之 <br>$netstat-nt|grep <span class="hljs-number">12345</span>#多次执行之<br></code></pre></td></tr></table></figure>
<p>代码清单5-4是netstat命令某次输出的内容，它显示了这一时刻listen监听队列的内容。</p>
<p>代码清单5-4 listen监听队列的内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">Proto Recv-Q Send-Q Local Address Foreign Address Statetcp<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2240</span> SYN_RECV<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2228</span> SYN_RECV[<span class="hljs-number">1</span>]<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2230</span> SYN_RECV<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2238</span> SYN_RECV<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2236</span> SYN_RECV<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2217</span> ESTABLISHED<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2226</span> ESTABLISHED<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2224</span> ESTABLISHED<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2212</span> ESTABLISHED<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2220</span> ESTABLISHED<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2222</span> ESTABLISHED<br></code></pre></td></tr></table></figure>
<p>可见，在监听队列中，处于ESTABLISHED状态的连接只有6个 (backlog值加1)，其他的连接都处于SYN_RCVD状态。我们改变服务器程序的第3个参数并重新运行之，能发现同样的规律，即完整连接最多有(backlog+1)个。在不同的系统上，运行结果会有些差别，不过监听队列中完整连接的上限通常比backlog值略大。</p>
<h2 id="55-接受连接"><a class="markdownIt-Anchor" href="#55-接受连接"></a> 5.5 接受连接</h2>
<p>下面的系统调用从listen监听队列中接受一个连接:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,struct sockaddr*addr,<span class="hljs-keyword">socklen_t</span>*addrlen)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>sockfd参数</strong>是执行过listen系统调用的<strong>监听socket</strong>[1]。</p>
<p><strong>addr参数</strong>用来获取被接受连接的<strong>远端socket地址</strong>，该socket地址的长度由addrlen参数指出。</p>
<p>accept成功时返回一个<strong>新的连接socket</strong>，该socket唯一地<u>标识了被接受的这个连接</u>，服务器可通过读写该socket来与被接受连接对应的客户端通信。accept失败时返回-1并设置errno。</p>
<p>现在考虑如下情况:如果监听队列中处于ESTABLISHED状态的连接对应的客户端出现网络异常(比如掉线)，或者提前退出，那么服务器对这个连接执行的accept调用是否成功?我们编写一个简单的服务器程序来测试之，如代码清单5-5所示。</p>
<p>代码清单5-5 接受一个异常的连接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>		<span class="hljs-comment">/*创建一个IPv4 socket地址 用于接收得到的ip地址*/</span> <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );  <span class="hljs-comment">// 创建一个socket对象 用来准备接收处理过后结果</span><br>    <span class="hljs-comment">// sock本身是文件描述符可以找到对应的套接字</span><br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) ); <span class="hljs-comment">// sock接收</span><br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 以上就是监听ip : port ret socket为获取的那个对象</span><br>    <span class="hljs-comment">/*暂停20秒以等待客户端连接和相关操作(掉线或者退出)完成*/</span><br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-comment">/*创建一个IPv4 socket地址 用于接收得到的ip地址*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );  <br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength ); <span class="hljs-comment">// 接收接受套接字的结果</span><br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )  <br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">/*接受连接成功则打印出客户端的IP地址和端口号*/</span><br>    &#123; <br>        <span class="hljs-keyword">char</span> remote[INET_ADDRSTRLEN ];<br>        <span class="hljs-comment">// 获取对应的连接成功套接字信息</span><br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;connected with ip: %s and port: %d\n&quot;</span>, <br>            <span class="hljs-built_in">inet_ntop</span>( AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN ), <span class="hljs-built_in">ntohs</span>( client.sin_port ) );<br>        <span class="hljs-built_in">close</span>( connfd );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们在Kongming20上运行该服务器程序(名为testaccept)，并在ernest-laptop上执行telnet命令来连接该服务器程序。具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$./testaccept <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">54321</span>#监听<span class="hljs-number">54321</span>端口 <br>$ telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">54321</span><br></code></pre></td></tr></table></figure>
<p>启动telnet客户端程序后，立即断开该客户端的网络连接(建立和断开连接的过程要在服务器启动后20秒内完成)。结果发现accept调用能够正常返回，服务器输出如下:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">connected</span> with ip:<span class="hljs-number">192.168.1.108</span> and port:<span class="hljs-number">38545</span><br></code></pre></td></tr></table></figure>
<p>接着，在服务器上运行netstat命令以查看accept返回的连接socket的状态:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$netstat -nt|grep <span class="hljs-number">54321</span><br>tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">54321</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">38545</span> ESTABLISHED<br></code></pre></td></tr></table></figure>
<p>netstat命令的输出说明，accept调用对于客户端网络断开毫不知情。下面我们重新执行上述过程，不过这次不断开客户端网络连接，而是在建立连接后立即退出客户端程序。这次accept调用同样正常返回，服务器输出如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">connected with ip:<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-keyword">and</span> port:<span class="hljs-number">52070</span><br></code></pre></td></tr></table></figure>
<p>再次在服务器上运行netstat命令:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$netstat -nt|grep <span class="hljs-number">54321</span><br>tcp <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">54321</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">52070</span> CLOSE_WAIT<br></code></pre></td></tr></table></figure>
<p>由此可见，accept只是从<u>监听队列中取出连接</u>，而不论连接处于何种状态(如上面的ESTABLISHED状态和CLOSE_WAIT状态)，更不关心任何网络状况的变化。</p>
<h2 id="56-发起连接"><a class="markdownIt-Anchor" href="#56-发起连接"></a> 5.6 发起连接</h2>
<p>如果说服务器通过listen调用来<u>被动接受连接</u>，那么客户端需要通过如下系统调用来<u>主动与服务器建立连接</u>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">const</span> struct sockaddr*serv_addr,<span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>sockfd参数</strong>由socket系统调用返回一个socket。</p>
<p><strong>serv_addr参数</strong>是服务器监听的socket地址，<strong>addrlen参数</strong>则指定这个地址的长度。</p>
<p>connect成功时返回0。一旦成功建立连接，sockfd就唯一地标识了这个连接，<strong>客户端就可以通过读写sockfd</strong>【连接建立好，我们可以从socket对应的那个地方写入或者选择读取】来与服务器通信。connect失 败则返回-1并设置errno。其中两种常见的errno是ECONNREFUSED和 ETIMEDOUT，它们的含义如下:</p>
<p>1、ECONNREFUSED，目标端口不存在，连接被拒绝。我们在 3.5.1小节讨论过这种情况。</p>
<p>2、ETIMEDOUT，连接超时。我们在3.3.3小节讨论过这种情况。</p>
<h2 id="57-关闭连接"><a class="markdownIt-Anchor" href="#57-关闭连接"></a> 5.7 关闭连接</h2>
<p>关闭一个连接实际上就是关闭该连接对应的socket，这可以通过如下关闭普通文件描述符的系统调用来完成:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<br></code></pre></td></tr></table></figure>
<p>fd参数是待关闭的socket。不过，close系统调用并非<u>总是立即关闭一个连接，而是将fd的引用计数减1</u>。只有当fd的引用计数为0时，才真 正关闭连接。多进程程序中，一次fork系统调用默认将使父进程中打开的socket的引用计数加1，因此我们必须在父进程和子进程中都对该socket执行close调用才能将连接关闭。</p>
<p>如果无论如何都要立即终止连接(而不是将socket的引用计数减1)，可以使用如下的shutdown系统调用(相对于close来说，它是专门为网络编程设计的):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shutdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">int</span> howto)</span></span>;<br></code></pre></td></tr></table></figure>
<p>sockfd参数是待关闭的socket。<strong>howto参数</strong>决定了shutdown的行为， 它可取表5-3中的某个值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205182136344.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-18 下午9.36.47" /></p>
<p>由此可见，shutdown能够分别关闭socket上的读或写，或者都关闭。而close在关闭连接时只能将socket上的读和写同时关闭。</p>
<p>shutdown成功时返回0，失败则返回-1并设置errno。</p>
<h2 id="58-数据读写"><a class="markdownIt-Anchor" href="#58-数据读写"></a> 5.8 数据读写</h2>
<h3 id="581-tcp数据读写"><a class="markdownIt-Anchor" href="#581-tcp数据读写"></a> 5.8.1 TCP数据读写</h3>
<p>对文件的读写操作read和write同样适用于socket。但是socket编程接口提供了几个专门用于socket数据读写的系统调用，它们增加了对数据读写的控制。其中用于<strong>TCP流数据读写</strong>的系统调用是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">void</span>*buf,<span class="hljs-keyword">size_t</span> len,<span class="hljs-keyword">int</span> flags)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*buf,<span class="hljs-keyword">size_t</span> len,<span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>recv</strong>读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小，flags参数的含义见后文，通常设置为0即可。recv成功时返回 实际读取到的数据的长度，它可能小于我们期望的长度len。因此我们可能要多次调用recv，才能读取到完整的数据。<u>recv可能返回0，这意味着通信对方已经关闭连接</u>了。recv出错时返回-1并设置errno。</p>
<p><strong>send</strong>往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。send成功时返回实际写入的数据的长度，失败则返回-1并设置 errno。</p>
<p>flags参数为数据收发提供了额外的控制，它可以取表5-4所示选项中的一个或几个的逻辑或。</p>
<p>由于socket连接是<strong>全双工</strong>的，这里的“读端”是针对通信对方而言的</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205182140957.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-18 下午9.40.39" /></p>
<p>我们举例来说明如何使用这些选项。MSG_OOB选项给应用程序<u>提供了发送和接收带外数据的方法</u>，如代码清单5-6和代码清单5-7所示。</p>
<p>代码清单5-6 发送带外数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 创建IPv4 地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;server_address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( server_address ) );<br>    server_address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;server_address.sin_addr );<br>    server_address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 建立套接字</span><br>    <span class="hljs-keyword">int</span> sockfd = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sockfd &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">connect</span>( sockfd, ( struct sockaddr* )&amp;server_address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( server_address ) ) &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">// 建立连接套接字并判断是否链接</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;connection failed\n&quot;</span> );<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;send oob data out\n&quot;</span> );<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* oob_data = <span class="hljs-string">&quot;abc&quot;</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* normal_data = <span class="hljs-string">&quot;123&quot;</span>;<br>        <span class="hljs-comment">// 发送套接字</span><br>        <span class="hljs-built_in">send</span>( sockfd, normal_data, <span class="hljs-built_in">strlen</span>( normal_data ), <span class="hljs-number">0</span> );<br>        <span class="hljs-built_in">send</span>( sockfd, oob_data, <span class="hljs-built_in">strlen</span>( oob_data ), MSG_OOB );<br>        <span class="hljs-built_in">send</span>( sockfd, normal_data, <span class="hljs-built_in">strlen</span>( normal_data ), <span class="hljs-number">0</span> );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sockfd );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码清单5-7 接收带外数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUF_SIZE 1024</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 建立监听套接字</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>     <br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// ipv4地址设置</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );<br>    <span class="hljs-comment">// 接受连接（从监听套接字里提取接结果）</span><br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );<br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">char</span> buffer[ BUF_SIZE ];<br>        <span class="hljs-comment">// 接受套接字 ret存储字节数，buffer存储结果</span><br>        <span class="hljs-built_in">memset</span>( buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE );<br>        ret = <span class="hljs-built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span> );<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );<br><br>        <span class="hljs-built_in">memset</span>( buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE );<br>        ret = <span class="hljs-built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="hljs-number">-1</span>, MSG_OOB );<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;got %d bytes of oob data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );<br><br>        <span class="hljs-built_in">memset</span>( buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE );<br>        ret = <span class="hljs-built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span> );<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );<br><br>        <span class="hljs-built_in">close</span>( connfd );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们先在Kongming20上启动代码清单5-7所示的服务器程序(名为testoobrecv)，然后从ernest-laptop上执行代码清单5-6所示的客户端程序(名为testoobsend)来向服务器发送带外数据。同时用tcpdump抓取这一过程中客户端和服务器交换的TCP报文段。具体操作如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">$./testoobrecv <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">54321</span>#在Kongming20上执行服务器程序，监听 <span class="hljs-number">54321</span>端口<br>$./testoobsend <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">54321</span>#在ernest-laptop上执行客户端程序 <br>$sudo tcpdump-ntx -i eth0 port <span class="hljs-number">54321</span><br></code></pre></td></tr></table></figure>
<p>服务器程序的输出如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">got <span class="hljs-number">5</span> bytes of normal data<span class="hljs-number">&#x27;123</span>ab<span class="hljs-number">&#x27;</span><br>got <span class="hljs-number">1</span> bytes of oob data<span class="hljs-number">&#x27;</span>c<span class="hljs-number">&#x27;</span><br>got <span class="hljs-number">3</span> bytes of normal data<span class="hljs-number">&#x27;123&#x27;</span><br></code></pre></td></tr></table></figure>
<p>由此可见，客户端发送给服务器的3字节的带外数据“abc”中，<strong>仅有</strong>最后一个字符“c”被服务器当成真正的带外数据接收(<strong>正如3.8节</strong>讨论的 那样)。并且，<strong>服务器对正常数据的接收将被带外数据截断</strong>，即前一部分正常数据“123ab”和后续的正常数据“123”是不能被一个recv调用全部读出的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205182200198.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-18 下午10.00.09" /></p>
<p>tcpdump的输出内容中，和带外数据相关的是代码清单5-8所示的TCP报文段。</p>
<p>代码清单5-8 <u>含带外数据</u>的TCP报文段</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60460</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.54321</span>:Flags[P.U],seq <span class="hljs-number">4</span>:<span class="hljs-number">7</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">92</span>,urg <span class="hljs-number">3</span>,options[nop,nop,TS val <span class="hljs-number">102794322</span> ecr <span class="hljs-number">154703423</span>],length <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p>这里我们第一次看到tcpdump输出<strong>标志U</strong>，这表示该TCP报文段的头部被设置了紧急标志。**“urg 3”**是紧急偏移值，它指出带外数据在字节流中的位置的下一字节位置是7【说明当前最后一个位置是6】(3+4，其中4是该TCP报文段的序号值相对初始序号值的偏移)。因此，带外数据是字节流中的第6字节， 即字符“c”。</p>
<p>值得一提的是，flags参数只对send和recv的当前调用生效，而后面我们将看到如何通过setsockopt系统调用永久性地修改socket的某些属 性。</p>
<h3 id="582-udp数据读写"><a class="markdownIt-Anchor" href="#582-udp数据读写"></a> 5.8.2 UDP数据读写</h3>
<p>socket编程接口中用于UDP数据报读写的系统调用是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recvfrom</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">void</span>*buf,<span class="hljs-keyword">size_t</span> len,<span class="hljs-keyword">int</span> flags,struct sockaddr*src_addr,<span class="hljs-keyword">socklen_t</span>*addrlen)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendto</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*buf,<span class="hljs-keyword">size_t</span> len,<span class="hljs-keyword">int</span> flags,<span class="hljs-keyword">const</span> struct sockaddr*dest_addr,<span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>recvfrom</strong>读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小。因为UDP通信<strong>没有连接</strong>的概念【像tcp就有连接套接字和监听套接字提供一个平台让数据互通，但udp都是一个对一个的没法按照流发送】，所以我们<u>每次读取数据都 需要获取发送端的socket地址</u>，即参数src_addr所指的内容，addrlen参数则指定该地址的长度。</p>
<p><strong>sendto</strong>往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。dest_addr参数指定接收端的socket地址，addrlen参数则指定该地址的长度。</p>
<p>这两个系统调用的flags参数以及返回值的含义均与send/recv系统调用的flags参数及返回值相同。</p>
<p>值得一提的是，recvfrom/sendto系统调用<u>也可以用于面向连接 (STREAM)的socket的数据读写</u>，只需要把最后两个参数都设置为 NULL以忽略发送端/接收端的socket地址(因为我们已经和对方建立了连接，所以已经知道其socket地址了)。</p>
<h3 id="583-通用数据读写函数"><a class="markdownIt-Anchor" href="#583-通用数据读写函数"></a> 5.8.3 通用数据读写函数</h3>
<p>socket编程接口还提供了一对通用的数据读写系统调用。它们不仅能用于TCP流数据，也能用于UDP数据报:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recvmsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,struct msghdr*msg,<span class="hljs-keyword">int</span> flags)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendmsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,struct msghdr*msg,<span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure>
<p>sockfd参数指定<strong>被操作的目标socket</strong>。msg参数是msghdr结构体类型的指针，msghdr结构体的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msghdr</span> &#123;</span><br>      <span class="hljs-keyword">void</span>*msg_name;<span class="hljs-comment">/*socket地址*/</span><br>      <span class="hljs-keyword">socklen_t</span> msg_namelen;<span class="hljs-comment">/*socket地址的长度*/</span><br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span>*<span class="hljs-title">msg_iov</span>;</span><span class="hljs-comment">/*分散的内存块，见后文*/</span><br>      <span class="hljs-keyword">int</span> msg_iovlen;<span class="hljs-comment">/*分散内存块的数量*/</span><br>      <span class="hljs-keyword">void</span>*msg_control;<span class="hljs-comment">/*指向辅助数据的起始位置*/</span><br>      <span class="hljs-keyword">socklen_t</span> msg_controllen;<span class="hljs-comment">/*辅助数据的大小*/</span><br>      <span class="hljs-keyword">int</span> msg_flags;<span class="hljs-comment">/*复制函数中的flags参数，并在调用过程中更新*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure>
<p>msg_name成员指向一个socket地址结构变量。它指定通信对方的socket地址。对于<strong>面向连接的TCP协议</strong>，该成员没有意义，必须被设置 为NULL。这是因为对数据流socket而言，对方的地址已经知道。 msg_namelen成员则指定了msg_name所指socket地址的长度。</p>
<p>msg_iov成员是iovec结构体类型的指针，iovec结构体的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">void</span>*iov_base;<span class="hljs-comment">/*内存起始地址*/</span> <br>  <span class="hljs-keyword">size_t</span> iov_len;<span class="hljs-comment">/*这块内存的长度*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure>
<p>由上可见，iovec结构体封装了一块内存的起始位置和长度。 msg_iovlen指定这样的iovec结构对象有多少个。对于<strong>recvmsg</strong>而言，数据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长度则由<u>msg_iov指向的数组指定</u>，这称为<strong>分散读</strong>(scatter read);对于 <strong>sendmsg</strong>而言，msg_iovlen块分散内存中的数据将被一并发送，这称为<strong>集中写</strong>(gather write)。</p>
<p>msg_control和msg_controllen成员用于辅助数据的传送。我们不详细讨论它们，仅在第13章介绍如何使用它们来实现在进程间传递文件 描述符。</p>
<p>msg_flags成员无须设定，它会复制recvmsg/sendmsg的flags参数的内容以影响数据读写过程。recvmsg还会在调用结束前，将某些更新后的标志设置到msg_flags中。</p>
<p>recvmsg/sendmsg的flags参数以及返回值的含义均与send/recv的flags 参数及返回值相同。</p>
<h2 id="59-带外标记"><a class="markdownIt-Anchor" href="#59-带外标记"></a> 5.9 带外标记</h2>
<p>代码清单5-7演示了TCP带外数据的接收方法。但在实际应用中，我们通常无法预期带外数据何时到来。好在Linux内核检测到TCP紧急标志时，将通知应用程序有带外数据需要接收。内核通知应用程序带外数据到达的两种常见方式是:<strong>I/O复用产生的异常事件</strong>和<strong>SIGURG信 号</strong>。但是，即使应用程序得到了有带外数据需要接收的通知，还需要知道带外数据在数据流中的具体位置，才能准确接收带外数据。这一 点可通过如下系统调用实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sockatmark</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd)</span></span>;<br></code></pre></td></tr></table></figure>
<p>sockatmark判断<u>sockfd是否处于带外标记</u>，即下一个被读取到的数据是否是带外数据。如果是，sockatmark返回1，此时我们就可以利用 带MSG_OOB标志的recv调用来接收带外数据。如果不是，则 sockatmark返回0。</p>
<h2 id="510-地址信息函数"><a class="markdownIt-Anchor" href="#510-地址信息函数"></a> 5.10 地址信息函数</h2>
<p>在某些情况下，我们想知道一个<u>连接socket的本端socket地址</u>，以及<u>远端的socket地址</u>。下面这两个函数正是用于解决这个问题:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsockname</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,struct sockaddr* address,<span class="hljs-keyword">socklen_t</span>* address_len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getpeername</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,struct sockaddr* address,<span class="hljs-keyword">socklen_t</span>* address_len)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>getsockname</strong>获取<u>sockfd对应的本端socket地址</u>，并将其存储于address参数指定的内存中，该socket地址的长度则存储于address_len参数指向的变量中。如果实际socket地址的长度大于address所指内存区的大小，那么该socket地址将被截断。getsockname成功时返回0，失败返回-1并设置errno。</p>
<p><strong>getpeername</strong>获取<u>sockfd对应的远端socket地址</u>，其参数及返回值的含义与getsockname的参数及返回值相同。</p>
<h2 id="511-socket选项"><a class="markdownIt-Anchor" href="#511-socket选项"></a> 5.11 socket选项</h2>
<p>如果说fcntl系统调用是控制文件描述符属性的通用POSIX方法，那么下面两个系统调用则是专门用来<u><strong>读取</strong>和<strong>设置</strong>socket文件描述符属性</u>的 方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsockopt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">int</span> level,<span class="hljs-keyword">int</span> option_name,<span class="hljs-keyword">void</span>* option_value,<span class="hljs-keyword">socklen_t</span>* <span class="hljs-keyword">restrict</span> option_len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">int</span> level,<span class="hljs-keyword">int</span> option_name,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* option_value,<span class="hljs-keyword">socklen_t</span> option_len)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>sockfd参数</strong></p>
<p>指定被操作的目标socket。</p>
<p><strong>level参数</strong></p>
<p>指定要操作哪个协议的选项(即属性)，比如IPv4、IPv6、TCP等。</p>
<p><strong>option_name参数</strong></p>
<p>则指定选项的名字。我们在表5-5中列举了socket通信中几个比较常用的socket选项。</p>
<p><strong>option_value和option_len参数</strong></p>
<p>分别是被操作选项的值和长度。不同的选项具有不同类型的值，如表5-5中“数据类型”一列所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205192105914.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-19 下午9.05.38" /></p>
<p>getsockopt和setsockopt这两个函数成功时返回0，失败时返回-1并设置errno。</p>
<p>值得指出的是，对服务器而言，有部分socket选项只能在调用listen系统调用前针对监听socket[1]</p>
<p>PS: 确切地说，socket<u>在执行listen调用前是不能称为监听socket</u>的，此处是指将执行listen调用的socket。</p>
<p>设置才有效。这是因为连接socket只能由accept调用返回，而accept从listen监听队列中接受的连接至少已经完成了TCP三次握手的前两个步骤(因为listen监听队列中的连接至少已进入SYN_RCVD状态，参见图3-8和代码清单5-4)，这说明服务器已经往被接受连接上发送出了TCP同步报文段。但有的socket选项却应该在TCP同步报文段中设置，比如TCP最大报文段选项(回忆3.2.2小节，该选项只能由同步报文段来发送)。对这种情况，Linux给开发人员提供的解决方案是:对监听socket设置这些socket选项，那么accept返回的连接socket将自动继承这些选项。这些socket选项包括:SO_DEBUG、 SO_DONTROUTE、SO_KEEPALIVE、SO_LINGER、 SO_OOBINLINE、SO_RCVBUF、SO_RCVLOWAT、SO_SNDBUF、 SO_SNDLOWAT、TCP_MAXSEG和TCP_NODELAY。而对客户端而言，这些<u>socket选项则应该在调用connect函数之前设置，因为connect调用成功返回之后，TCP三次握手已完成</u>。</p>
<p>下面我们详细讨论部分重要的socket选项。</p>
<h3 id="5111-so_reuseaddr选项"><a class="markdownIt-Anchor" href="#5111-so_reuseaddr选项"></a> 5.11.1 SO_REUSEADDR选项</h3>
<p>我们在3.4.2小节讨论过TCP连接的TIME_WAIT状态，并提到服务器程序可以通过设置socket选项SO_REUSEADDR来<u>强制使用被处于 TIME_WAIT状态的连接占用的socket地址</u>。具体实现方法如代码清单5-9所示。</p>
<p>代码清单5-9 重用本地地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 书中代码</span><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-keyword">int</span> reuse = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">setsockopt</span>( sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( reuse ) ); <span class="hljs-comment">// 给代码赋予重用功能</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>		<span class="hljs-comment">// 书中代码</span><br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );<br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );<br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">char</span> remote[INET_ADDRSTRLEN ];<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;connected with ip: %s and port: %d\n&quot;</span>, <br>        <span class="hljs-built_in">inet_ntop</span>( AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN ), <span class="hljs-built_in">ntohs</span>( client.sin_port ) );<br>        <span class="hljs-built_in">close</span>( connfd );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>经过setsockopt的设置之后，即使sock处于TIME_WAIT状态，与之绑定的socket地址也可以立即被重用。此外，我们也可以通过修改内核参数/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket，从而使得TCP连接根本就不进入TIME_WAIT状态，进而允许应用程序立即重用本地的socket地址。</p>
<h3 id="5112-so_rcvbuf和so_sndbuf选项"><a class="markdownIt-Anchor" href="#5112-so_rcvbuf和so_sndbuf选项"></a> 5.11.2 SO_RCVBUF和SO_SNDBUF选项</h3>
<p><strong>SO_RCVBUF</strong>和<strong>SO_SNDBUF</strong>选项分别表示<strong>TCP接收缓冲区</strong>和<strong>发送缓冲区</strong>的大小。不过，当我们用setsockopt来设置TCP的接收缓冲区和 发送缓冲区的大小时，<u>系统都会将其值加倍，并且不得小于某个最小值</u>。TCP接收缓冲区的最小值是256字节，而发送缓冲区的最小值是 2048字节(不过，不同的系统可能有不同的默认最小值)。系统这样做的目的，主要是确保一个TCP连接拥有足够的空闲缓冲区来处理拥塞 (比如快速重传算法就期望TCP接收缓冲区能至少容纳4个大小为SMSS的TCP报文段)。此外，我们可以直接修改内核参数/proc/sys/net/ipv4/tcp_rmem和/proc/sys/net/ipv4/tcp_wmem来强制TCP 接收缓冲区和发送缓冲区的大小没有最小值限制。我们将在第16章讨论这两个内核参数。</p>
<p>下面我们编写一对客户端和服务器程序，如代码清单5-10和代码清单5-11所示，它们分别修改TCP发送缓冲区和接收缓冲区的大小。</p>
<p>代码清单5-10 修改TCP发送缓冲区的客户端程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 512</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">3</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number send_bufer_size\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;server_address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( server_address ) );<br>    server_address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;server_address.sin_addr );<br>    server_address.sin_port = <span class="hljs-built_in">htons</span>( port );<br><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br><br>    <span class="hljs-keyword">int</span> sendbuf = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">3</span>] );<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( sendbuf );<br>    <span class="hljs-comment">/*先设置TCP发送缓冲区的大小，然后立即读取之*/</span><br>    <span class="hljs-built_in">setsockopt</span>( sock, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( sendbuf ) );  <span class="hljs-comment">// 设置socket tcp发送缓冲区</span><br>    <span class="hljs-built_in">getsockopt</span>( sock, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, ( <span class="hljs-keyword">socklen_t</span>* )&amp;len ); <span class="hljs-comment">// 查看socket tcp发送缓冲区</span><br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;the tcp send buffer size after setting is %d\n&quot;</span>, sendbuf );<br><br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">connect</span>( sock, ( struct sockaddr* )&amp;server_address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( server_address ) ) != <span class="hljs-number">-1</span> ) <span class="hljs-comment">// 连接socket</span><br>    &#123;<br>        <span class="hljs-keyword">char</span> buffer[ BUFFER_SIZE ];<br>        <span class="hljs-built_in">memset</span>( buffer, <span class="hljs-string">&#x27;a&#x27;</span>, BUFFER_SIZE );<br>        <span class="hljs-built_in">send</span>( sock, buffer, BUFFER_SIZE, <span class="hljs-number">0</span> ); <span class="hljs-comment">// 发送socket</span><br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码清单5-11 修改TCP接收缓冲区的服务器程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 1024</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">3</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number receive_buffer_size\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-keyword">int</span> recvbuf = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">3</span>] );<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( recvbuf );<br>    <span class="hljs-comment">/*先设置TCP接收缓冲区的大小，然后立即读取之*/</span><br>    <span class="hljs-built_in">setsockopt</span>( sock, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( recvbuf ) );<br>    <span class="hljs-built_in">getsockopt</span>( sock, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, ( <span class="hljs-keyword">socklen_t</span>* )&amp;len );<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;the receive buffer size after settting is %d\n&quot;</span>, recvbuf );<br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) ); <span class="hljs-comment">// 命名socket 相当于给对应端口安排一个人</span><br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> ); <span class="hljs-comment">// 监听</span><br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );<br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength ); <span class="hljs-comment">// accept监听结果</span><br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 如果监听到结果开始接收</span><br>    &#123;<br>        <span class="hljs-keyword">char</span> buffer[ BUFFER_SIZE ];<br>        <span class="hljs-built_in">memset</span>( buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE );<br>        <span class="hljs-keyword">while</span>( <span class="hljs-built_in">recv</span>( connfd, buffer, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span> ) &gt; <span class="hljs-number">0</span> )&#123;&#125;<br>        <span class="hljs-built_in">close</span>( connfd );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们在ernest-laptop上运行代码清单5-11所示的服务器程序(名为set_recv_buffer)，然后在Kongming20上运行代码清单5-10所示的客户 端程序(名为set_send_buffer)来向服务器发送512字节的数据，然后用 tcpdump抓取这一过程中双方交换的TCP报文段。具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">$./set_recv_buffer <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-number">12345</span> <span class="hljs-number">50</span> #将TCP接收缓冲区的大小设置为 <span class="hljs-number">50</span>字节<br> the tcp receive buffer size after settting is <span class="hljs-number">256</span><br>$./set_send_buffer <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-number">12345</span> <span class="hljs-number">2000</span> #将TCP发送缓冲区的大小设置为 <span class="hljs-number">2000</span>字节<br> the tcp send buffer size after setting is <span class="hljs-number">4000</span><br>$tcpdump -nt -i eth0 port <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure>
<p>从服务器的输出来看，系统允许的TCP接收缓冲区最小为256字节。当我们设置TCP接收缓冲区的大小为50字节时，系统将<strong>忽略</strong>我们的设置。从客户端的输出来看，我们设置的<strong>TCP发送缓冲区的大小被系统增加了一倍</strong>。这两种情况和我们前面讨论的一致。下面是此次TCP通信的tcpdump输出:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[S],seq <span class="hljs-number">1425875256</span>,win <span class="hljs-number">14600</span>,options[mss <span class="hljs-number">1460</span>,sackOK,TS val <span class="hljs-number">7782289</span> ecr <span class="hljs-number">0</span>,nop,wscale <span class="hljs-number">4</span>],length <span class="hljs-number">0</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>:Flags[S.],seq <span class="hljs-number">3109725840</span>,ack <span class="hljs-number">1425875257</span>,win <span class="hljs-number">192</span>,options[mss <span class="hljs-number">1460</span>,sackOK,TS val <span class="hljs-number">126229160</span> ecr <span class="hljs-number">7782289</span>,nop,wscale <span class="hljs-number">6</span>],length <span class="hljs-number">0</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[.],ack <span class="hljs-number">1</span>,win <span class="hljs-number">913</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">193</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">913</span>,length <span class="hljs-number">192</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>:Flags[.],ack <span class="hljs-number">193</span>,win <span class="hljs-number">0</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">6.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>:Flags[.],ack <span class="hljs-number">193</span>,win <span class="hljs-number">3</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">7.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[P.],seq <span class="hljs-number">193</span>:<span class="hljs-number">385</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">913</span>,length <span class="hljs-number">192</span><br><span class="hljs-number">8.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>:Flags[.],ack <span class="hljs-number">385</span>,win <span class="hljs-number">3</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">9.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[P.],seq <span class="hljs-number">385</span>:<span class="hljs-number">513</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">913</span>,length <span class="hljs-number">128</span><br><span class="hljs-number">10.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>:Flags[.],ack <span class="hljs-number">513</span>,win <span class="hljs-number">3</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">11.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[F.],seq <span class="hljs-number">513</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">913</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">12.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>:Flags[F.],seq <span class="hljs-number">1</span>,ack <span class="hljs-number">514</span>,win <span class="hljs-number">3</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">13.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[.],ack <span class="hljs-number">2</span>,win <span class="hljs-number">913</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>首先注意<strong>第2个TCP报文段</strong>，它指出服务器的接收通告窗口大小为192字节。该值小于256字节，显然是在情理之中。同时，该同步报文段还指出服务器采用的窗口扩大因子是6【将窗口大小乘以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">2^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>】。所以服务器后续发送的大部分TCP报文段(6、8、10和12)的实际接收通告窗口大小都是3×26字节，即192字节。因此客户端每次最多给服务器发送192字节的数据。 客户端一共给服务器发送了512字节的数据，这些数据必须至少被分为3个TCP报文段(4、7和9)来发送。</p>
<p>有意思的是<strong>TCP报文段5和6</strong>。当服务器收到客户端发送过来的第一批数据(TCP报文段4)时，它立即用TCP报文段5给予了确认，但该确认报文段的接收通告窗口的大小为0。这说明<u>TCP模块发送该确认报文段时，应用程序还没来得及将数据从TCP接收缓冲中读出</u>。所以此时客户端是不能发送数据给服务器的，直到服务器发送一个重复的确认报文段(TCP报文段6)来扩大其接收通告窗口。</p>
<h3 id="5113-so_rcvlowat和so_sndlowat选项"><a class="markdownIt-Anchor" href="#5113-so_rcvlowat和so_sndlowat选项"></a> 5.11.3 SO_RCVLOWAT和SO_SNDLOWAT选项</h3>
<p>SO_RCVLOWAT和SO_SNDLOWAT选项分别表示TCP接收缓冲区和发送缓冲区的<strong>低水位标记</strong>。它们一般被I/O复用系统调用(见第9章)用来<u>判断socket是否可读或可写</u>。当<strong>TCP接收缓冲区</strong>中可读数据的总数大于其低水位标记时，I/O复用系统调用将通知应用程序可以从对应的 socket上读取数据;当<strong>TCP发送缓冲区</strong>中的空闲空间(可以写入数据的空间)大于其低水位标记时，I/O复用系统调用将通知应用程序可以往 对应的socke上写入数据。</p>
<p>默认情况下，TCP接收缓冲区的低水位标记和TCP发送缓冲区的低水位标记均为1字节。</p>
<h3 id="5114-so_linger选项"><a class="markdownIt-Anchor" href="#5114-so_linger选项"></a> 5.11.4 SO_LINGER选项</h3>
<p>SO_LINGER选项用于控制close系统调用在<u>关闭TCP连接时的行为</u>。<strong>默认</strong>情况下，当我们使用close系统调用来关闭一个socket时，close 将立即返回，TCP模块负责把该socket<u>对应的TCP发送缓冲区中残留的数据发送</u>给对方。</p>
<p>如表5-5所示，设置(获取)SO_LINGER选项的值时，我们需要给setsockopt(getsockopt)系统调用传递一个linger类型的结构体，其定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linger</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">int</span> l_onoff;<span class="hljs-comment">/*开启(非0)还是关闭(0)该选项*/</span> <br>  <span class="hljs-keyword">int</span> l_linger;<span class="hljs-comment">/*滞留时间*/</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>根据linger结构体中两个成员变量的不同值，close系统调用可能产生如下3种行为之一:</p>
<p>1、l_onoff == 0。此时SO_LINGER选项不起作用，close用默认行为来关闭socket。</p>
<p>2、l_onoff != 0，l_linger == 0。此时close系统调用立即返回，TCP模块将丢弃被关闭的socket对应的TCP发送缓冲区中残留的数据，同时 给对方发送一个复位报文段(见3.5.2小节)。因此，这种情况给服务器提供了异常终止一个连接的方法。</p>
<p>3、l_onoff != 0，l_linger &gt; 0。此时close的行为取决于两个条件:一是被关闭的socket对应的TCP发送缓冲区中是否还有残留的数据;二是该socket是阻塞的，还是非阻塞的。对于<strong>阻塞</strong>的socket，close将等待一段长为l_linger的时间，直到TCP模块发送完所有残留数据并得到对方的确认。如果这段时间内TCP模块没有发送完残留数据并得到对方的确认，那么close系统调用将返回-1并设置errno为 EWOULDBLOCK。如果socket是非阻塞的，close将立即返回，此时我们需要根据其返回值和errno来判断残留数据是否已经发送完毕。关于阻塞和非阻塞，我们将在第8章讨论。</p>
<h2 id="512-网络信息api"><a class="markdownIt-Anchor" href="#512-网络信息api"></a> 5.12 网络信息API</h2>
<p>socket地址的两个要素，即<strong>IP地址和端口号</strong>，都是用数值表示的。这不便于记忆，也不便于扩展(比如从IPv4转移到IPv6)。因此在前面的章节中，我们用主机名来访问一台机器，而避免直接使用其IP地址。同样，我们用服务名称来代替端口号。比如，下面两条telnet命令具有完全相同的作用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">telnet <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">80</span><br> telnet localhost www<br></code></pre></td></tr></table></figure>
<p>上面的例子中，telnet客户端程序是通过<u>调用某些网络信息API</u>来<u>实现主机名到IP地址</u>的转换，以及服务名称到端口号的转换的。下面我们将讨论网络信息API中比较重要的几个。</p>
<h3 id="5121-gethostbyname和gethostbyaddr"><a class="markdownIt-Anchor" href="#5121-gethostbyname和gethostbyaddr"></a> 5.12.1 gethostbyname和gethostbyaddr</h3>
<p>gethostbyname<u>函数根据主机名称获取主机的完整信息</u>， gethostbyaddr函数根据<u>IP地址获取主机的完整信息</u>。gethostbyname函数通常先在本地的/etc/hosts配置文件中查找主机，如果没有找到，再去访问DNS服务器。这些在前面章节中都讨论过。这两个函数的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function">struct hostent* <span class="hljs-title">gethostbyname</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name)</span></span>;<br><span class="hljs-function">struct hostent* <span class="hljs-title">gethostbyaddr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* addr,<span class="hljs-keyword">size_t</span> len,<span class="hljs-keyword">int</span> type)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>name参数</strong>指定目标主机的主机名，<strong>addr参数</strong>指定目标主机的IP地址，<strong>len参数</strong>指定addr所指IP地址的长度，<strong>type参数</strong>指定addr所指IP地址 的类型，其合法取值包括AF_INET(用于IPv4地址)和AF_INET6(用于IPv6地址)。</p>
<p>这两个函数返回的都是hostent结构体类型的指针，hostent结构体的定义如下:</p>
<p>**可以理解为指针数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span>* h_name;<span class="hljs-comment">/*主机名*/</span> <br>  <span class="hljs-keyword">char</span>** h_aliases;<span class="hljs-comment">/*主机别名列表，可能有多个*/</span> <br>  <span class="hljs-keyword">int</span> h_addrtype;<span class="hljs-comment">/*地址类型(地址族)*/</span><br>  <span class="hljs-keyword">int</span> h_length;<span class="hljs-comment">/*地址长度*/</span> <br>  <span class="hljs-keyword">char</span>** h_addr_list<span class="hljs-comment">/*按网络字节序列出的主机IP地址列表*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="5122-getservbyname和getservbyport"><a class="markdownIt-Anchor" href="#5122-getservbyname和getservbyport"></a> 5.12.2 getservbyname和getservbyport</h3>
<p>getservbyname函数<u>根据名称获取某个服务的完整信息</u>， getservbyport函数<u>根据端口号获取某个服务的完整信息</u>。它们实际上都是通过读取/etc/services文件来获取服务的信息的。这两个函数的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function">struct servent* <span class="hljs-title">getservbyname</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* proto)</span></span>; <br><span class="hljs-function">struct servent* <span class="hljs-title">getservbyport</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* proto)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>name参数</strong>指定目标服务的名字，<strong>port参数</strong>指定目标服务对应的端口号。<strong>proto参数</strong>指定服务类型，给它传递“tcp”表示获取流服务，给它传递“udp”表示获取数据报服务，给它传递NULL则表示获取所有类型的服务。</p>
<p>这两个函数返回的都是servent结构体类型的指针，结构体servent的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">servent</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span>* s_name;<span class="hljs-comment">/*服务名称*/</span> <br>    <span class="hljs-keyword">char</span>** s_aliases;<span class="hljs-comment">/*服务的别名列表，可能有多个*/</span> <br>    <span class="hljs-keyword">int</span> s_port;<span class="hljs-comment">/*端口号*/</span> <br>    <span class="hljs-keyword">char</span>* s_proto;<span class="hljs-comment">/*服务类型,通常是tcp或者udp*/</span> <br>&#125;;<br><br></code></pre></td></tr></table></figure>
<p>下面我们通过主机名和服务名来访问目标服务器上的<strong>daytime服务</strong>，以获取该机器的系统时间，如代码清单5-12所示。</p>
<p>代码清单5-12 访问daytime服务</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>( argc == <span class="hljs-number">2</span> );<br>    <span class="hljs-keyword">char</span> *host = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">/*获取目标主机地址信息*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span>* <span class="hljs-title">hostinfo</span> =</span> <span class="hljs-built_in">gethostbyname</span>( host );<br>    <span class="hljs-built_in">assert</span>( hostinfo );<br>    <span class="hljs-comment">/*获取daytime服务信息*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">servent</span>* <span class="hljs-title">servinfo</span> =</span> <span class="hljs-built_in">getservbyname</span>( <span class="hljs-string">&quot;daytime&quot;</span>, <span class="hljs-string">&quot;tcp&quot;</span> );<br>    <span class="hljs-built_in">assert</span>( servinfo );<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;daytime port is %d\n&quot;</span>, <span class="hljs-built_in">ntohs</span>( servinfo-&gt;s_port ) );<br>    <span class="hljs-comment">// 设置socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    address.sin_family = AF_INET;<br>    address.sin_port = servinfo-&gt;s_port;<br>    <span class="hljs-comment">/*注意下面的代码，因为h_addr_list本身是使用网络字节序的地址列表，所以使用其中的IP地址时，无须对目标IP地址转换字节序*/</span><br>    address.sin_addr = *( struct in_addr* )*hostinfo-&gt;h_addr_list;<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-keyword">int</span> sockfd = <span class="hljs-built_in">socket</span>( AF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 请求链接</span><br>    <span class="hljs-keyword">int</span> result = <span class="hljs-built_in">connect</span>( sockfd, (struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( result != <span class="hljs-number">-1</span> );<br><br>    <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">128</span>];<br>    <span class="hljs-comment">// 获取返回的套接字数据部分进入buffer</span><br>    result = <span class="hljs-built_in">read</span>( sockfd, buffer, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( buffer ) );<br>    <span class="hljs-built_in">assert</span>( result &gt; <span class="hljs-number">0</span> );<br>    buffer[ result ] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-comment">// 打印结果</span><br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;the day tiem is: %s&quot;</span>, buffer );<br>    <span class="hljs-built_in">close</span>( sockfd );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>重入</strong></p>
<p>一般可以理解为一个函数在同时多次调用,例如操作系统在进程调度过程中,或者单片机、处理器等的中断的时候会发生重入的现象</p>
<p>需要指出的是，上面讨论的4个函数都是不可重入的，即<u>非线程安全</u>的。不过netdb.h头文件给出了它们的可重入版本。正如Linux下所有 其他函数的可重入版本的命名规则那样，这些函数的函数名是在原函数名尾部加上_r(re-entrant)。</p>
<h3 id="5123-getaddrinfo"><a class="markdownIt-Anchor" href="#5123-getaddrinfo"></a> 5.12.3 getaddrinfo</h3>
<p>getaddrinfo函数既能通过<u>主机名获得IP地址</u>(内部使用的是gethostbyname函数)，也能通过<u>服务名获得端口号</u>(内部使用的是getservbyname函数)。它<strong>是否可重入取决</strong>于其内部调用的gethostbyname和getservbyname函数是否是它们的可重入版本。该函数的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getaddrinfo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* hostname,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* service,<span class="hljs-keyword">const</span> struct addrinfo* hints,struct addrinfo** result)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>hostname参数</strong>可以接收<strong>主机名</strong>，也可以接收字符串表示的IP地址 (IPv4采用点分十进制字符串，IPv6则采用十六进制字符串)。同样， <strong>service参数</strong>可以接收<strong>服务名</strong>，也可以接收字符串表示的十进制端口号。</p>
<p><strong>hints参数</strong>是应用程序给getaddrinfo的一个提示，以对getaddrinfo的输出进行更精确的控制。hints参数可以被设置为NULL，表示允许 getaddrinfo反馈任何可用的结果。</p>
<p><strong>result参数</strong>指向一个链表，该链表用于存储getaddrinfo反馈的结果。</p>
<p>getaddrinfo反馈的每一条结果都是addrinfo结构体类型的对象，结构体addrinfo的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">int</span> ai_flags;<span class="hljs-comment">/*见后文*/</span><br>  <span class="hljs-keyword">int</span> ai_family;<span class="hljs-comment">/*地址族*/</span><br>  <span class="hljs-keyword">int</span> ai_socktype;<span class="hljs-comment">/*服务类型，SOCK_STREAM或SOCK_DGRAM*/</span> <br>  <span class="hljs-keyword">int</span> ai_protocol;<span class="hljs-comment">/*见后文*/</span><br>  <span class="hljs-keyword">socklen_t</span> ai_addrlen;<span class="hljs-comment">/*socket地址ai_addr的长度*/</span><br>  <span class="hljs-keyword">char</span>* ai_canonname;<span class="hljs-comment">/*主机的别名*/</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span>* <span class="hljs-title">ai_addr</span>;</span><span class="hljs-comment">/*指向socket地址*/</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span>* <span class="hljs-title">ai_next</span>;</span><span class="hljs-comment">/*指向下一个sockinfo结构的对象*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure>
<p>该结构体中，ai_protocol成员是指具体的网络协议，其含义和socket系统调用的第三个参数相同，它通常被设置为0。ai_flags成员可以取表5-6中的标志的按位或。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205201338156.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-20 下午1.38.28" /></p>
<p>当我们使用hints参数的时候，可以设置其ai_flags，ai_family， ai_socktype和ai_protocol四个字段，其他字段则必须被设置为NULL。 例如，代码清单5-13利用了hints参数获取主机ernest-laptop上的“daytime”流服务信息。</p>
<p>代码清单5-13 使用getaddrinfo函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> <span class="hljs-title">hints</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span>* <span class="hljs-title">res</span>;</span><br><span class="hljs-comment">//  bzero(void *s, int n) 与 memset((void*)s, 0,size_tn)是等价</span><br><span class="hljs-built_in">bzero</span>(&amp;hints,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(hints)); <br>hints.ai_socktype = SOCK_STREAM; <br><span class="hljs-built_in">getaddrinfo</span>(<span class="hljs-string">&quot;ernest-laptop&quot;</span>,<span class="hljs-string">&quot;daytime&quot;</span>,&amp;hints,&amp;res);<br></code></pre></td></tr></table></figure>
<p>从代码清单5-13中我们能分析出，getaddrinfo将隐式地分配堆内存 (可以通过valgrind等工具查看)，因为res指针原本是没有指向一块合法内存的，所以，getaddrinfo调用结束后，我们必须使用如下配对函数来释放这块内存:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeaddrinfo</span><span class="hljs-params">(struct addrinfo* res)</span></span>;<br></code></pre></td></tr></table></figure>
<h3 id="5124-getnameinfo"><a class="markdownIt-Anchor" href="#5124-getnameinfo"></a> 5.12.4 getnameinfo</h3>
<p>getnameinfo函数能<u>通过socket地址同时获得以字符串表示的主机名</u>(内部使用的是gethostbyaddr函数)和服务名(内部使用的是 getservbyport函数)。它是否可重入取决于其内部调用的gethostbyaddr和getservbyport函数是否是它们的可重入版本。该函数的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getnameinfo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct sockaddr* sockaddr,<span class="hljs-keyword">socklen_t</span> addrlen,<span class="hljs-keyword">char</span>* host,<span class="hljs-keyword">socklen_t</span> hostlen,<span class="hljs-keyword">char</span>* serv,<span class="hljs-keyword">socklen_t</span> servlen,<span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure>
<p>getnameinfo将返回的主机名存储在host参数指向的缓存中，将服务名存储在serv参数指向的缓存中，hostlen和servlen参数分别指定这两块缓存的长度。flags参数控制getnameinfo的行为，它可以接收表5-7中的选项。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205201347161.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-20 下午1.47.47" /></p>
<p>getaddrinfo和getnameinfo函数成功时返回0，失败则返回错误码，可能的错误码如表5-8所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205201348081.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-20 下午1.48.13" /></p>
<p>Linux下strerror函数能将数值错误码errno转换成易读的字符串形式。同样，下面的函数可将表5-8中的错误码转换成其字符串形式:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*<span class="hljs-title">gai_strerror</span><span class="hljs-params">(<span class="hljs-keyword">int</span> error)</span></span>;<br></code></pre></td></tr></table></figure>
<h1 id="第6章-高级io函数"><a class="markdownIt-Anchor" href="#第6章-高级io函数"></a> 第6章 高级I/O函数</h1>
<p>Linux提供了很多高级的I/O函数。它们并不像Linux基础I/O函数 (比如open和read)那么常用(编写内核模块时一般要实现这些I/O函数)，但在特定的条件下却表现出优秀的性能。本章将讨论其中和网络编程相关的几个，这些函数大致分为三类:</p>
<p>1、用于创建文件描述符的函数，包括pipe、dup/dup2函数。</p>
<p>2、用于读写数据的函数，包括readv/writev、sendfile、mmap/munmap、splice和tee函数。</p>
<p>3、用于控制I/O行为和属性的函数，包括fcntl函数。</p>
<h2 id="61-pipe函数"><a class="markdownIt-Anchor" href="#61-pipe函数"></a> 6.1 pipe函数</h2>
<p>pipe函数可用于创建一个管道，以实现进程间通信。我们将在13.4节讨论如何使用管道来实现进程间通信，本章只介绍其基本使用方式。pipe函数的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span> </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd[<span class="hljs-number">2</span>])</span></span>;<br></code></pre></td></tr></table></figure>
<h3 id="管道定义"><a class="markdownIt-Anchor" href="#管道定义"></a> 管道定义：</h3>
<p>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为<strong>进程间通信</strong>。</p>
<p>不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F&amp;spm=1001.2101.3001.7020">通信方式</a>不同，而pipe就是提供这份公共资源的形式的一种。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/skyroben/article/details/71513385">https://blog.csdn.net/skyroben/article/details/71513385</a></p>
<h3 id="fork"><a class="markdownIt-Anchor" href="#fork"></a> fork：</h3>
<p>一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。<br />
一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/stpeace/article/details/38805369?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-38805369-blog-107159115.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-38805369-blog-107159115.pc_relevant_paycolumn_v3&amp;utm_relevant_index=2">https://blog.csdn.net/stpeace/article/details/38805369?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-38805369-blog-107159115.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-38805369-blog-107159115.pc_relevant_paycolumn_v3&amp;utm_relevant_index=2</a></p>
<p>pipe函数的参数是一个包含两个int型整数的数组指针。该函数成功时返回0，并将一对打开的文件描述符值填入其参数指向的数组。如果失败，则返回-1并设置errno。</p>
<p>通过pipe函数创建的这两个文件描述符fd[0]和fd[1]分别构成管道的两端，往fd[1]写入的数据可以从fd[0]读出。并且，fd[0]只能用于从管道<strong>读出数据</strong>，fd[1]则只能用于往管道<strong>写入数据</strong>，而不能反过来使用。</p>
<p>如果要实现<u>双向的数据传输，就应该使用两个管道</u>。默认情况下，这一对文件描述符都是阻塞的。此时如果我们用read系统调用来读取一个空的管道，则read将被阻塞，直到管道内有数据可读;如果我们用write系统调用来往一个满的管道(见后文)中写入数据，则write亦将被阻塞，直到管道有足够多的空闲空间可用。</p>
<p>但如果应用程序将fd[0]和fd[1]都设置为非阻塞的，则read和write会有不同的行为。 关于阻塞和非阻塞的讨论，见第8章。如果管道的写端文件描述符fd[1]的引用计数(见5.7节)减少至0，即没有任何进程需要往管道中写入数据，则针对该管道的读端文件描述符fd[0]的read操作将返回0，即读取到了文件结束标记(End Of File，EOF); 反之，如果管道的读端文件描述符fd[0]的引用计数减少至0，即没有任何进程需要从管道读取数据，则针对该管道的写端文件描述符fd[1]的write操作将失败，并引发SIGPIPE信号。关于SIGPIPE信号，我们将在第10章讨论。</p>
<p>管道内部传输的数据是<strong>字节流</strong>，这和TCP字节流的概念相同。但二者又有细微的区别。应用层程序能往一个TCP连接中写入多少字节的数据，取决于对方的<u>接收通告窗口的大小和本端的拥塞窗口的大小</u>。而管道本身拥有一个容量限制，它规定如果应用程序不将数据从管道读走的话，该管道最多能被写入多少字节的数据。自Linux 2.6.11内核起，管道容量的大小默认是65536字节。我们可以使用fcntl函数来修改管道容量(见后文)。</p>
<p>此外，socket的基础API中有一个socketpair函数。它能够方便地创建双向管道。其定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">socketpair</span><span class="hljs-params">(<span class="hljs-keyword">int</span> domain,<span class="hljs-keyword">int</span> type,<span class="hljs-keyword">int</span> protocol,<span class="hljs-keyword">int</span> fd[<span class="hljs-number">2</span>])</span></span>;<br></code></pre></td></tr></table></figure>
<p>socketpair前三个参数的含义与socket系统调用的三个参数完全相同，但domain只能使用UNIX本地域协议族AF_UNIX，因为我们仅能在本地使用这个双向管道。最后一个参数则和pipe系统调用的参数一样，只不过socketpair创建的这对文件描述符都是既可读又可写的。 socketpair成功时返回0，失败时返回-1并设置errno。</p>
<h2 id="62-dup函数和dup2函数"><a class="markdownIt-Anchor" href="#62-dup函数和dup2函数"></a> 6.2 dup函数和dup2函数</h2>
<p>有时我们希望把标准输入重定向到一个文件，或者把标准输出重定向到一个网络连接(比如CGI编程)。这可以通过下面的用于复制文件描述符的dup或dup2函数来实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> file_descriptor)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dup2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> file_descriptor_one,<span class="hljs-keyword">int</span> file_descriptor_two)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>dup函数</strong>创建一个新的文件描述符，该新文件描述符和原有文件描述符file_descriptor指向相同的文件、管道或者网络连接。并且dup返回 的文件描述符总是取系统当前可用的最小整数值。dup2和dup类似，不过它将返回第一个不小于file_descriptor_two的整数值。dup和dup2系统调用失败时返回-1并设置errno。</p>
<p>注意通过dup和dup2创建的文件描述符<u>并不继承原文件描述符</u>的属性，比如close-on-exec和non-blocking等。</p>
<p>代码清单6-1利用dup函数实现了一个基本的CGI服务器。</p>
<p>代码清单6-1 CGI服务器原理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 创建并设置IPv4socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 将sock进行命名</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 监听socket</span><br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 再次创建一个socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );<br>    <span class="hljs-comment">// 接收连接</span><br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );<br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">// 没有接收到</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 若接收到了连接 -- 相当于成功建立连接</span><br>    &#123;<br>        <span class="hljs-comment">//我们先关闭标准输出文件描述符 STDOUT_FILENO(其值是1)</span><br>        <span class="hljs-built_in">close</span>( STDOUT_FILENO );<br>        <span class="hljs-comment">// 复制socket文件描述符connfd</span><br>        <span class="hljs-built_in">dup</span>( connfd );<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;abcd\n&quot;</span> );<br>        <span class="hljs-built_in">close</span>( connfd );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在代码清单6-1中，我们先关闭标准输出文件描述符STDOUT_FILENO(其值是1)，然后复制socket文件描述符connfd。因为dup总是返回系统中最小的可用文件描述符，所以它的返回值实际上是1，即之前关闭的标准输出文件描述符的值。这样一来，<u>服务器输出到标准输出的内容(这里是“abcd”)就会直接发送到与客户连接对应的socket</u>上，因此printf调用的输出将被客户端获得(而不是显示在服务器程序的终端上)。这就是CGI服务器的基本工作原理。</p>
<h2 id="63-readv函数和writev函数"><a class="markdownIt-Anchor" href="#63-readv函数和writev函数"></a> 6.3 readv函数和writev函数</h2>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205201626146.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-20 下午4.26.38" /></p>
<p>readv函数将数据从文件描述符读到分散的内存块中，即<strong>分散读</strong>; writev函数则将多块分散的内存数据一并写入文件描述符中，即<strong>集中写</strong>。它们的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/uio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">readv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd,<span class="hljs-keyword">const</span> struct iovec* vector,<span class="hljs-keyword">int</span> count)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">writev</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd,<span class="hljs-keyword">const</span> struct iovec* vector,<span class="hljs-keyword">int</span> count)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>fd参数</strong>是被操作的目标文件描述符。</p>
<p><strong>vector参数</strong>的类型是iovec结构数组。</p>
<p>我们在第5章讨论过<u>结构体iovec，该结构体描述一块内存区</u>。</p>
<p><strong>count参数</strong>是vector数组的长度，即有多少块内存数据需要从fd读出或写到fd。readv和writev在成功时返回读出/写入fd的字节数，失败则返回-1并设置errno。它们相当于简化版的recvmsg和sendmsg函数。</p>
<p>考虑第4章讨论过的Web服务器。当Web服务器解析完一个HTTP请求之后，如果目标文档存在且客户具有读取该文档的权限，那么它就需要发送一个HTTP应答来传输该文档。这个HTTP应答包含<u>1个状态行、多个头部字段、1个空行</u>和文档的内容。其中，前3部分的内容可能被Web服务器放置在一块内存中，而文档的内容则通常被读入到另外一块单独的内存中(通过read函数或mmap函数)。我们并不需要把这两部分内容拼接到一起再发送，而是可以使用writev函数将它们同时写出，如代码清单6-2所示。</p>
<p>代码清单6-2 Web服务器上的集中写</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 1024</span><br><span class="hljs-comment">/*定义两种HTTP状态码和状态信息*/</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* status_line[<span class="hljs-number">2</span>] = &#123; <span class="hljs-string">&quot;200 OK&quot;</span>, <span class="hljs-string">&quot;500 Internal server error&quot;</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span>  <span class="hljs-comment">// 这个文件就是本地的问题</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">3</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number filename\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 读入获得的ip、port还有文件名</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* file_name = argv[<span class="hljs-number">3</span>];<br>    <span class="hljs-comment">// 建立IPv4 socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 给socket命名</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 监听socket</span><br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 建立IPv4 socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );<br>    <span class="hljs-comment">// 接收连接到文件描述符connfd</span><br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );<br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">// 连接失败</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span>  <span class="hljs-comment">// 连接成功</span><br>    &#123;<br>        <span class="hljs-comment">/*用于保存HTTP应答的状态行、头部字段和一个空行的缓存区*/</span><br>        <span class="hljs-keyword">char</span> header_buf[ BUFFER_SIZE ];<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-built_in">memset</span>( header_buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE );<br>        <span class="hljs-comment">/*用于存放目标文件内容的应用程序缓存*/</span><br>        <span class="hljs-keyword">char</span>* file_buf;<br>        <span class="hljs-comment">/*用于获取目标文件的属性，比如是否为目录，文件大小等*/</span><br>        <span class="hljs-comment">// struct stat这个结构体是用来描述一个linux系统文件系统中的文件属性的结构。</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">file_stat</span>;</span><br>        <span class="hljs-comment">/*记录目标文件是否是有效文件*/</span><br>        <span class="hljs-keyword">bool</span> valid = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">/*缓存区header_buf目前已经使用了多少字节的空间*/</span><br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>( <span class="hljs-built_in">stat</span>( file_name, &amp;file_stat ) &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">/*目标文件不存在*/</span><br>        &#123;<br>            valid = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>( <span class="hljs-built_in">S_ISDIR</span>( file_stat.st_mode ) )  <span class="hljs-comment">/*目标文件是一个目录*/</span><br>            &#123;<br>                valid = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( file_stat.st_mode &amp; S_IROTH ) <span class="hljs-comment">/*当前用户有读取目标文件的权限*/</span><br>            &#123;<br>                <span class="hljs-comment">/*动态分配缓存区file_buf，并指定其大小为目标文件的大小file_stat.st_size加1*/</span><br>                <span class="hljs-keyword">int</span> fd = <span class="hljs-built_in">open</span>( file_name, O_RDONLY ); <span class="hljs-comment">// 将fd文件描述符 指向服务器端的本地文件</span><br>                file_buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span> [ file_stat.st_size + <span class="hljs-number">1</span> ];<br>                <span class="hljs-built_in">memset</span>( file_buf, <span class="hljs-string">&#x27;\0&#x27;</span>, file_stat.st_size + <span class="hljs-number">1</span> );<br>                <span class="hljs-comment">/*将目标文件读入缓存区file_buf中*/</span><br>                <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">read</span>( fd, file_buf, file_stat.st_size ) &lt; <span class="hljs-number">0</span> )<br>                &#123;<br>                    valid = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                valid = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*如果目标文件有效，则发送正常的HTTP应答*/</span><br>        <span class="hljs-keyword">if</span>( valid ) <br>        &#123;<br>            <span class="hljs-comment">/*下面这部分内容将HTTP应答的状态行、“Content-Length”头部字段和一个空行依次加入header_buf中*/</span><br>            ret = <span class="hljs-built_in">snprintf</span>( header_buf, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-string">&quot;%s %s\r\n&quot;</span>, <span class="hljs-string">&quot;HTTP/1.1&quot;</span>, status_line[<span class="hljs-number">0</span>] );<br>            len += ret;<br>            ret = <span class="hljs-built_in">snprintf</span>( header_buf + len, BUFFER_SIZE<span class="hljs-number">-1</span>-len, <br>                             <span class="hljs-string">&quot;Content-Length: %d\r\n&quot;</span>, file_stat.st_size );<br>            len += ret;<br>            ret = <span class="hljs-built_in">snprintf</span>( header_buf + len, BUFFER_SIZE<span class="hljs-number">-1</span>-len, <span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;\r\n&quot;</span> );<br>            <span class="hljs-comment">// 上面这部分是在制作头部信息</span><br>            <span class="hljs-comment">/*利用writev将header_buf和file_buf的内容一并写出*/</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">iv</span>[2];</span><br>            <span class="hljs-comment">// 分别制定对应的内存缓冲区以及其大小</span><br>            iv[ <span class="hljs-number">0</span> ].iov_base = header_buf;<br>            iv[ <span class="hljs-number">0</span> ].iov_len = <span class="hljs-built_in">strlen</span>( header_buf );<br>            iv[ <span class="hljs-number">1</span> ].iov_base = file_buf;<br>            iv[ <span class="hljs-number">1</span> ].iov_len = file_stat.st_size;<br>            <span class="hljs-comment">// 一起写回给套接字发送回去 【集中写】</span><br>            ret = <span class="hljs-built_in">writev</span>( connfd, iv, <span class="hljs-number">2</span> );<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">/*如果目标文件无效，则通知客户端服务器发生了“内部错误”*/</span><br>        &#123;<br>            ret = <span class="hljs-built_in">snprintf</span>( header_buf, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-string">&quot;%s %s\r\n&quot;</span>, <span class="hljs-string">&quot;HTTP/1.1&quot;</span>, status_line[<span class="hljs-number">1</span>] );<br>            len += ret;<br>            ret = <span class="hljs-built_in">snprintf</span>( header_buf + len, BUFFER_SIZE<span class="hljs-number">-1</span>-len, <span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;\r\n&quot;</span> );<br>            <span class="hljs-built_in">send</span>( connfd, header_buf, <span class="hljs-built_in">strlen</span>( header_buf ), <span class="hljs-number">0</span> );<br>        &#125;<br>        <span class="hljs-built_in">close</span>( connfd );<br>        <span class="hljs-keyword">delete</span> [] file_buf;  <span class="hljs-comment">// 清空文件缓存区</span><br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码清单6-2中，我们省略了HTTP请求的接收及解析，因为现在关注的重点是HTTP应答的发送。我们直接将目标文件作为第3个参数传递给服务器程序，客户telnet到该服务器上【对应ip和port即可触发socket套接字】即可获得该文件。关于HTTP请求的解析，我们将在第8章给出相关代码。</p>
<h2 id="64-sendfile函数"><a class="markdownIt-Anchor" href="#64-sendfile函数"></a> 6.4 sendfile函数</h2>
<p>sendfile函数在<u>两个文件描述符之间直接传递数据</u>(完全在内核中操作)，从而<strong>避免</strong>了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，这被称为<strong>零拷贝</strong>。sendfile函数的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/sendfile.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendfile</span><span class="hljs-params">(<span class="hljs-keyword">int</span> out_fd,<span class="hljs-keyword">int</span> in_fd,<span class="hljs-keyword">off_t</span>*offset,<span class="hljs-keyword">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>in_fd参数</strong>是待读出内容的文件描述符，<strong>out_fd参数</strong>是待写入内容的文件描述符。<strong>offset参数</strong>指定从读入文件流的哪个位置开始读，如果 为空，则使用读入文件流默认的起始位置。<strong>count参数</strong>指定在文件描述符in_fd和out_fd之间传输的字节数。sendfile成功时返回传输的字节 数，失败则返回-1并设置errno。该函数的man手册明确指出，in_fd必须是一个支持类似mmap函数的文件描述符，即它必须指向真实的文 件，不能是socket和管道;而out_fd则必须是一个socket。由此可见，sendfile几乎是专门为在网络上传输文件而设计的。下面的代码清单6-3 利用sendfile函数将服务器上的一个文件传送给客户端。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205210748418.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-21 上午7.48.15" /></p>
<p>代码清单6-3 用sendfile函数传输文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/sendfile.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">3</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number filename\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 转换获取到的网络信息</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* file_name = argv[<span class="hljs-number">3</span>];<br>    <span class="hljs-comment">// 定位服务器端需要发送的文件描述符</span><br>    <span class="hljs-keyword">int</span> filefd = <span class="hljs-built_in">open</span>( file_name, O_RDONLY );<br>    <span class="hljs-built_in">assert</span>( filefd &gt; <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 用来获取指定路径的文件或者文件夹的信息的结构体</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">stat_buf</span>;</span><br>    <span class="hljs-comment">// fstat（由文件描述词取得文件状态）</span><br>    <span class="hljs-built_in">fstat</span>( filefd, &amp;stat_buf );<br>    <span class="hljs-comment">// 创建IPv4 socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 命名socket</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 监听socket</span><br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 创建IPv4 socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );<br>    <span class="hljs-comment">// 接收监听socket</span><br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );<br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">// 如果没有成功获取到</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 如果成功获取到</span><br>    &#123;<br>        <span class="hljs-comment">// 不需要分配任何的用户空间 将数据从filefd -&gt; connfd</span><br>        <span class="hljs-built_in">sendfile</span>( connfd, filefd, <span class="hljs-literal">NULL</span>, stat_buf.st_size );<br>        <span class="hljs-built_in">close</span>( connfd );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码清单6-3中，我们将目标文件作为<u>第3个参数传递给服务器程序</u>，客户telnet到该服务器上即可获得该文件。相比代码清单6-2，代码清单6-3没有为目标文件分配任何用户空间的缓存，也没有执行读取文件的操作，但同样实现了文件的发送，其效率显然要高得多。</p>
<h2 id="65-mmap函数和munmap函数"><a class="markdownIt-Anchor" href="#65-mmap函数和munmap函数"></a> 6.5 mmap函数和munmap函数</h2>
<p>mmap函数用于<strong>申请</strong>一段内存空间。我们可以将这段内存作为<u>进程间通信的共享内存</u>，也可以<u>将文件直接映射到其中</u>。munmap函数则<strong>释 放</strong>由mmap创建的这段内存空间。它们的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span>*<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* start,<span class="hljs-keyword">size_t</span> length,<span class="hljs-keyword">int</span> prot,<span class="hljs-keyword">int</span> flags,<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> offset)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">munmap</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* start,<span class="hljs-keyword">size_t</span> length)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>start参数</strong>允许用户使用某个特定的地址作为这段内存的起始地址。 如果它被设置成NULL，则系统自动分配一个地址。</p>
<p><strong>length参数</strong>指定内存段的长度。</p>
<p><strong>prot参数</strong>用来设置内存段的访问权限。它可以取以下几个值的按位或:</p>
<p>1、PROT_READ，内存段可读。</p>
<p>2、PROT_WRITE，内存段可写。</p>
<p>3、PROT_EXEC，内存段可执行。</p>
<p>4、PROT_NONE，内存段不能被访问。</p>
<p><strong>flags参数</strong>控制内存段内容被修改后程序的行为。它可以被设置为表6-1中的某些值(这里仅列出了常用的值)的按位或(其中MAP_SHARED和MAP_PRIVATE是互斥的，不能同时指定)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205210756313.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-21 上午7.56.55" /></p>
<p><strong>fd参数</strong>是被映射文件对应的文件描述符。它一般通过open系统调用获得。</p>
<p><strong>offset参数</strong>设置从文件的何处开始映射(对于不需要读入整个文件的情况)。</p>
<p>mmap函数成功时返回指向目标内存区域的指针，失败则返回 MAP_FAILED((void*)-1)并设置errno。munmap函数成功时返回0， 失败则返回-1并设置errno。</p>
<p>我们将在第13章进一步讨论如何利用mmap函数实现进程间共享内 存。</p>
<h2 id="66-splice函数"><a class="markdownIt-Anchor" href="#66-splice函数"></a> 6.6 splice函数</h2>
<p>splice函数用于在<u>两个文件描述符之间移动数据</u>，也是<strong>零拷贝操作</strong>。splice函数的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">splice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd_in,<span class="hljs-keyword">loff_t</span>* off_in,<span class="hljs-keyword">int</span> fd_out,<span class="hljs-keyword">loff_t</span>* off_out,<span class="hljs-keyword">size_t</span> len,<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>fd_in参数</strong>是待输入数据的文件描述符。如果fd_in是一个管道文件描述符，那么off_in参数必须被设置为NULL。如果fd_in不是一个管道文件描述符(比如socket)，那么off_in表示从输入数据流的何处开始读取数据。此时，若off_in被设置为NULL，则表示从输入数据流的当前偏移位置读入;若off_in不为NULL，则它将指出具体的偏移位置。</p>
<ul>
<li>
<p><strong>fd_out/off_out参数</strong>的含义与fd_in/off_in相同，不过用于输出数据流。</p>
</li>
<li>
<p><strong>len 参数</strong>指定移动数据的长度;</p>
</li>
<li>
<p><strong>flags参数</strong>则控制数据如何移动，它可以被设置为表6-2中的某些值的按位或。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205210800519.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-21 上午8.00.40" /></p>
<p>使用splice函数时，fd_in和fd_out必须至少有一个是管道文件描述符【说明不是从管道到某个文件就是某个文件到管道要不就是管道和管道之间的通信】。splice函数调用成功时返回移动字节的数量。它可能返回0，表示没有数据需要移动，这发生在从管道中读取数据(fd_in是管道文件描述符)而该管道没有被写入任何数据时。splice函数失败时返回-1并设置errno。常见的errno如表6-3所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205210803060.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-21 上午8.02.59" /></p>
<p>下面我们使用splice函数来实现一个零拷贝的回射服务器，它将客户端发送的数据原样返回给客户端，具体实现如代码清单6-4所示。</p>
<p>代码清单6-4 使用splice函数实现的回射服务器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// ip 和 port 读取</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 创建IPv4 socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 命名socket</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 监听socket</span><br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 创建IPv4 socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );<br>    <span class="hljs-comment">// 接收socket</span><br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );<br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">// 没接受</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span>  <span class="hljs-comment">// 成功接收</span><br>    &#123;   <span class="hljs-comment">// 来我们的管道走一波之后又发回去了</span><br>        <span class="hljs-keyword">int</span> pipefd[<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>        ret = <span class="hljs-built_in">pipe</span>( pipefd ); <span class="hljs-comment">/*创建管道*/</span><br>        <span class="hljs-comment">/*将connfd上流入的客户数据定向到管道中 其中pipefd[1]为管道的入*/</span> <br>        ret = <span class="hljs-built_in">splice</span>( connfd, <span class="hljs-literal">NULL</span>, pipefd[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE ); <br>        <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>        <span class="hljs-comment">/*将管道的输出定向到connfd客户连接文件描述符*/</span><br>        ret = <span class="hljs-built_in">splice</span>( pipefd[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>, connfd, <span class="hljs-literal">NULL</span>, <span class="hljs-number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );<br>        <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>        <span class="hljs-built_in">close</span>( connfd );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们通过splice函数将客户端的内容读入到pipefd[1]中，然后再使用splice函数从pipefd[0]中读出该内容到客户端，从而实现了简单高效</p>
<p>的回射服务。整个过程未执行recv/send操作，因此也未涉及用户空间和内核空间之间的数据拷贝。</p>
<h2 id="67-tee函数"><a class="markdownIt-Anchor" href="#67-tee函数"></a> 6.7 tee函数</h2>
<p>tee函数在<strong>两个管道文件描述符</strong>之间复制数据，也是零拷贝操作。它不消耗数据，因此源文件描述符上的数据<strong>仍然可以用于</strong>后续的读操 作。tee函数的原型如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">tee</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd_in,<span class="hljs-keyword">int</span> fd_out,<span class="hljs-keyword">size_t</span> len,<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure>
<p>该函数的参数的含义与splice相同(但fd_in和fd_out必须都是管道文件描述符)。tee函数成功时返回在两个文件描述符之间复制的数据数量(字节数)。返回0表示没有复制任何数据。tee失败时返回-1并设置errno。</p>
<p>代码清单6-5利用tee函数和splice函数，实现了Linux下tee程序(同时输出数据到终端和文件的程序，不要和tee函数混淆)的基本功能。</p>
<p>代码清单6-5 同时输出数据到终端和文件的程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> ( argc != <span class="hljs-number">2</span> )<br>	&#123;<br>		<span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s &lt;file&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>] );<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br>  <span class="hljs-comment">// 定位电脑中的文件描述符</span><br>	<span class="hljs-keyword">int</span> filefd = <span class="hljs-built_in">open</span>( argv[<span class="hljs-number">1</span>], O_CREAT | O_WRONLY | O_TRUNC, <span class="hljs-number">0666</span> );<br>	<span class="hljs-built_in">assert</span>( filefd &gt; <span class="hljs-number">0</span> );<br>  <span class="hljs-comment">// 创建管道1 -&gt; 终端</span><br>	<span class="hljs-keyword">int</span> pipefd_stdout[<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">pipe</span>( pipefd_stdout );<br>	<span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>  <span class="hljs-comment">// 创建管道2 -&gt; 文件</span><br>	<span class="hljs-keyword">int</span> pipefd_file[<span class="hljs-number">2</span>];<br>  ret = <span class="hljs-built_in">pipe</span>( pipefd_file );<br>	<span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><br>	<span class="hljs-comment">//close( STDIN_FILENO );</span><br>	<span class="hljs-comment">// dup2( pipefd_stdout[1], STDIN_FILENO );</span><br>	<span class="hljs-comment">//write( pipefd_stdout[1], &quot;abc\n&quot;, 4 );</span><br>  <span class="hljs-comment">/*将标准输入内容输入管道pipefd_stdout*/</span><br>	ret = <span class="hljs-built_in">splice</span>( STDIN_FILENO, <span class="hljs-literal">NULL</span>, pipefd_stdout[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );<br>	<span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>  <span class="hljs-comment">/*将管道pipefd_stdout的输出复制到管道pipefd_file的输入端*/</span><br>	ret = <span class="hljs-built_in">tee</span>( pipefd_stdout[<span class="hljs-number">0</span>], pipefd_file[<span class="hljs-number">1</span>], <span class="hljs-number">32768</span>, SPLICE_F_NONBLOCK ); <br>	<span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>  <span class="hljs-comment">/*将管道pipefd_file的输出定向到文件描述符filefd上，从而将标准输入的内容写入文件*/</span><br>	ret = <span class="hljs-built_in">splice</span>( pipefd_file[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>, filefd, <span class="hljs-literal">NULL</span>, <span class="hljs-number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );<br>	<span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>  <span class="hljs-comment">/*将管道pipefd_stdout的输出定向到标准输出，其内容和写入文件的内容完全一致*/</span><br>	ret = <span class="hljs-built_in">splice</span>( pipefd_stdout[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>, STDOUT_FILENO, <span class="hljs-literal">NULL</span>, <span class="hljs-number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );<br>	<span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>  <br>	<span class="hljs-built_in">close</span>( filefd );<br>  <span class="hljs-built_in">close</span>( pipefd_stdout[<span class="hljs-number">0</span>] );<br>  <span class="hljs-built_in">close</span>( pipefd_stdout[<span class="hljs-number">1</span>] );<br>  <span class="hljs-built_in">close</span>( pipefd_file[<span class="hljs-number">0</span>] );<br>  <span class="hljs-built_in">close</span>( pipefd_file[<span class="hljs-number">1</span>] );<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="68-fcntl函数"><a class="markdownIt-Anchor" href="#68-fcntl函数"></a> 6.8 fcntl函数</h2>
<p>fcntl函数，正如其名字(file control)描述的那样，提供了<strong>对文件描述符的各种控制操作</strong>。另外一个常见的控制文件描述符属性和行为的系统调用是ioctl，而且ioctl比fcntl能够执行更多的控制。但是，对于控制文件描述符常用的属性和行为，fcntl函数是由POSIX规范指定的首选方法。所以本书仅讨论fcntl函数。fcntl函数的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd,<span class="hljs-keyword">int</span> cmd,...)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>fd参数</strong>是被操作的文件描述符，<strong>cmd参数</strong>指定执行何种类型的操作。根据操作类型的不同，该函数可能还需要第三个可选参数arg。 fcntl函数支持的常用操作及其参数如表6-4所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205210959142.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-21 上午9.59.48" /></p>
<p>fcntl函数成功时的返回值如表6-4最后一列所示，失败则返回-1并设置errno。</p>
<p>在网络编程中，fcntl函数<u>通常用来将一个文件描述符设置为非阻塞</u>的，如代码清单6-6所示。</p>
<p>代码清单6-6 将文件描述符设置为非阻塞的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">int</span> old_option=<span class="hljs-built_in">fcntl</span>(fd,F_GETFL);<span class="hljs-comment">/*获取文件描述符旧的状态标志*/</span> <br>  <span class="hljs-keyword">int</span> new_option=old_option|O_NONBLOCK;<span class="hljs-comment">/*设置非阻塞标志*/</span> <br>  <span class="hljs-built_in">fcntl</span>(fd,F_SETFL,new_option);<br>	<span class="hljs-keyword">return</span> old_option;<span class="hljs-comment">/*返回文件描述符旧的状态标志，以便*/</span> <span class="hljs-comment">/*日后恢复该状态标志*/</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>此外，SIGIO和SIGURG这两个信号与其他Linux信号不同，它们必须与某个文件描述符相关联方可使用:当被关联的文件描述符可读或可写时，系统将触发SIGIO信号;当被关联的文件描述符(而且必须是一个socket)上有带外数据可读时，系统将触发SIGURG信号。将信号和文件描述符关联的方法，就是使用fcntl函数为目标文件描述符指定宿主进程或进程组，那么被指定的宿主进程或进程组将捕获这两个信号。使用SIGIO时，还需要利用fcntl设置其O_ASYNC标志(异步I/O标志，不过SIGIO信号模型并非真正意义上的异步I/O模型，见第8章)。 关于信号SIGURG的更多内容，我们将在第10章讨论。</p>
<h1 id="第7章-linux服务器程序规范"><a class="markdownIt-Anchor" href="#第7章-linux服务器程序规范"></a> 第7章 Linux服务器程序规范</h1>
<p>除了网络通信外，服务器程序通常还必须考虑许多其他细节问题。这些细节问题涉及面广且零碎，而且基本上是模板式的，所以我们称之为服务器程序规范。比如:</p>
<ul>
<li>Linux服务器程序一般以<strong>后台</strong>进程形式运行。后台进程又称<strong>守护进程(daemon)</strong>。它没有控制终端，因而也不会意外接收到用户输入。守护进程的父进程通常是init进程(PID为1的进程)。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205211008893.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-21 上午10.08.33" /></p>
<ul>
<li>
<p>Linux服务器程序通常有一套日志系统，它至少能输出日志到文件，有的高级服务器还能输出日志到专门的UDP服务器。大部分后台 进程都在/var/log目录下拥有自己的日志目录。</p>
</li>
<li>
<p>Linux服务器程序一般以某个专门的非root身份运行。比如mysqld、httpd、syslogd等后台进程，分别拥有自己的运行账户mysql、 apache和syslog。</p>
</li>
<li>
<p>Linux服务器程序通常是可配置的。服务器程序通常能处理很多命令行选项，如果一次运行的选项太多，则可以用配置文件来管理。 绝大多数服务器程序都有配置文件，并存放在/etc目录下。比如第4章讨论的squid服务器的配置文件是/etc/squid3/squid.conf。</p>
</li>
<li>
<p>Linux服务器进程通常会在启动的时候生成一个PID文件并存入/var/run目录中，以记录该后台进程的PID。比如syslogd的PID文件 是/var/run/syslogd.pid。</p>
</li>
<li>
<p>Linux服务器程序通常需要考虑系统资源和限制，以预测自身能承受多大负荷，比如进程可用文件描述符总数和内存总量等。</p>
</li>
</ul>
<p>在开始系统地学习网络编程之前，我们将用一章的篇幅来探讨服务器程序的一些主要的规范。</p>
<h2 id="71-日志"><a class="markdownIt-Anchor" href="#71-日志"></a> 7.1 日志</h2>
<h3 id="711-linux系统日志"><a class="markdownIt-Anchor" href="#711-linux系统日志"></a> 7.1.1 Linux系统日志</h3>
<p>工欲善其事，必先利其器。服务器的调试和维护都需要一个专业的日志系统。Linux提供一个守护进程来处理系统日志——syslogd，不过现在的Linux系统上使用的都是它的升级版——rsyslogd。</p>
<p>rsyslogd守护进程既能<strong>接收用户进程</strong>输出的日志，又能<strong>接收内核日志</strong>。用户进程是通过调用syslog函数生成系统日志的。该函数将日志输 出到一个UNIX本地域socket类型(AF_UNIX)的文件/dev/log中， rsyslogd则监听该文件以获取用户进程的输出。内核日志在老的系统上是通过另外一个守护进程rklogd来管理的，rsyslogd利用额外的模块实现了相同的功能。内核日志由printk等函数打印至内核的环状缓存 (ring buffer)中。环状缓存的内容直接映射到/proc/kmsg文件中。 rsyslogd则通过读取该文件获得内核日志。</p>
<p>rsyslogd守护进程在接收到用户进程或内核输入的日志后，会把它们输出至某些特定的日志文件。默认情况下，调试信息会保存 至/var/log/debug文件，普通信息保存至/var/log/messages文件，内核消息则保存至/var/log/kern.log文件。不过，日志信息具体如何分发，可以在rsyslogd的配置文件中设置。rsyslogd的主配置文件是/etc/rsyslog.conf，其中主要可以设置的项包括:内核日志输入路径， 是否接收UDP日志及其监听端口(默认是514，见/etc/services文件)， 是否接收TCP日志及其监听端口，日志文件的权限，包含哪些子配置文 件(比如/etc/rsyslog.d/*.conf)。rsyslogd的子配置文件则指定各类日志的目标存储文件。</p>
<p>图7-1总结了Linux的系统日志体系。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205211014062.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-21 上午10.13.57" /></p>
<h3 id="712-syslog函数"><a class="markdownIt-Anchor" href="#712-syslog函数"></a> 7.1.2 syslog函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;syslog.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">syslog</span><span class="hljs-params">(<span class="hljs-keyword">int</span> priority,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*message,...)</span></span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>
<p>该函数采用可变参数(第二个参数message和第三个参数…)来结构化输出。</p>
</li>
<li>
<p>priority参数是所谓的设施值与日志级别的按位或。设施值的默认值是LOG_USER，我们下面的讨论也只限于这一种设施值。日志级别有如下几个:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;syslog.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_EMERG 0<span class="hljs-comment">/*系统不可用*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_ALERT 1<span class="hljs-comment">/*报警，需要立即采取动作*/</span> #<span class="hljs-meta-keyword">define</span> LOG_CRIT 2<span class="hljs-comment">/*非常严重的情况*/</span> #<span class="hljs-meta-keyword">define</span> LOG_ERR 3<span class="hljs-comment">/*错误*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_WARNING 4<span class="hljs-comment">/*警告*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_NOTICE 5<span class="hljs-comment">/*通知*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_INFO 6<span class="hljs-comment">/*信息*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_DEBUG 7<span class="hljs-comment">/*调试*/</span></span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>下面这个函数可以改变syslog的默认输出方式，进一步结构化日志内容:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;syslog.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">openlog</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ident,<span class="hljs-keyword">int</span> logopt,<span class="hljs-keyword">int</span> facility)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>ident参数</strong>指定的字符串将被添加到日志消息的日期和时间之后， 它通常被设置为程序的名字。logopt参数对后续syslog调用的行为进行 配置，它可取下列值的按位或:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_PID 0x01<span class="hljs-comment">/*在日志消息中包含程序PID*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_CONS 0x02<span class="hljs-comment">/*如果消息不能记录到日志文件，则打印至终端*/</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_ODELAY 0x04<span class="hljs-comment">/*延迟打开日志功能直到第一次调用syslog*/</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_NDELAY 0x08<span class="hljs-comment">/*不延迟打开日志功能*/</span></span><br></code></pre></td></tr></table></figure>
<p><strong>facility参数</strong>可用来修改syslog函数中的默认设施值。</p>
<p>此外，日志的过滤也很重要。程序在开发阶段可能需要输出很多调试信息，而发布之后我们又需要将这些调试信息关闭。解决这个问题的方法并不是在程序发布之后删除调试代码(因为日后可能还需要用到)，而是简单地设置日志掩码，使日志级别大于日志掩码的日志信息被系统忽略。下面这个函数用于设置syslog的日志掩码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;syslog.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setlogmask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maskpri)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>maskpri参数</strong>指定日志掩码值。该函数始终会成功，它返回调用进程先前的日志掩码值。最后，不要忘了使用如下函数关闭日志功能:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;syslog.h&gt;</span> </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">closelog</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>
<h2 id="72-用户信息"><a class="markdownIt-Anchor" href="#72-用户信息"></a> 7.2 用户信息</h2>
<h3 id="721-uid-euid-gid和egid"><a class="markdownIt-Anchor" href="#721-uid-euid-gid和egid"></a> 7.2.1 UID、EUID、GID和EGID</h3>
<p>用户信息对于服务器程序的安全性来说是很重要的，比如大部分服务器就必须以root身份启动，但不能以root身份运行。下面这一组函数可以获取和设置当前进程的真实用户ID(UID)、有效用户ID(EUID)、真实组ID(GID)和有效组ID(EGID):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span> #<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">uid_t</span> <span class="hljs-title">getuid</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/*获取真实用户ID*/</span><br><span class="hljs-function"><span class="hljs-keyword">uid_t</span> <span class="hljs-title">geteuid</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/*获取有效用户ID*/</span><br><span class="hljs-function"><span class="hljs-keyword">gid_t</span> <span class="hljs-title">getgid</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/*获取真实组ID*/</span><br><span class="hljs-function"><span class="hljs-keyword">gid_t</span> <span class="hljs-title">getegid</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/*获取有效组ID*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setuid</span><span class="hljs-params">(<span class="hljs-keyword">uid_t</span> uid)</span></span>;<span class="hljs-comment">/*设置真实用户ID*/</span> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">seteuid</span><span class="hljs-params">(<span class="hljs-keyword">uid_t</span> uid)</span></span>;<span class="hljs-comment">/*设置有效用户ID*/</span> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setgid</span><span class="hljs-params">(<span class="hljs-keyword">gid_t</span> gid)</span></span>;<span class="hljs-comment">/*设置真实组ID*/</span> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setegid</span><span class="hljs-params">(<span class="hljs-keyword">gid_t</span> gid)</span></span>;<span class="hljs-comment">/*设置有效组ID*/</span><br></code></pre></td></tr></table></figure>
<p>需要指出的是，<u>一个进程拥有两个用户ID:UID和EUID</u>。</p>
<p>EUID存在的目的是方便资源访问:它使得运行程序的用户拥有该程序的有效用户的权限。比如su程序，任何用户都可以使用它来修改自己的账户信息，但修改账户时su程序不得不访问/etc/passwd文件，而访问该文件是需要root权限的。</p>
<p>那么以普通用户身份启动的su程序如何能访问/etc/passwd文件呢?窍门就在EUID。用ls命令可以查看到，su程序的所有者是root，并且它<u>被设置了set-user-id标志</u>。这个标志表示，任何普通用户运行su程序时，其有效用户就是该程序的所有者root。那么，根据有效用户的含义，任何运行su程序的普通用户都能够访问/etc/passwd文件。<strong>有效用户为root的进程称为特权进程(privileged processes</strong>)。EGID的含义与EUID类似:<u>给运行目标程序的组用户提供有效组的权限</u>。</p>
<p>下面的代码清单7-1可以用来测试进程的UID和EUID的区别。</p>
<p>代码清单7-1 测试进程的UID和EUID的区别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">uid_t</span> uid=<span class="hljs-built_in">getuid</span>(); <span class="hljs-comment">// 获取真实用户ID</span><br>   <span class="hljs-keyword">uid_t</span> euid=<span class="hljs-built_in">geteuid</span>(); <span class="hljs-comment">// 获取有效用户ID</span><br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;userid is %d,effective userid is:%d\n&quot;</span>,uid,euid);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>编译该文件，将生成的可执行文件(名为test_uid)的所有者设置为root，并设置该文件的set-user-id标志，然后运行该程序以查看UID和EUID。具体操作如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo chown root:root test_uid#修改目标文件的所有者为root <br>$sudo chmod +s test_uid#设置目标文件的set-user-id标志 <br>$./test_uid#运行程序<br>userid is <span class="hljs-number">1000</span>, effective userid is:<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>从测试程序的输出来看，进程的UID是启动程序的用户的ID，而EUID则是root账户(文件所有者)的ID。</p>
<h3 id="722-切换用户"><a class="markdownIt-Anchor" href="#722-切换用户"></a> 7.2.2 切换用户</h3>
<p>下面的代码清单7-2展示了如何将以root身份启动的进程切换为以一个普通用户身份运行。</p>
<p>代码清单7-2 切换用户</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">switch_to_user</span><span class="hljs-params">( <span class="hljs-keyword">uid_t</span> user_id, <span class="hljs-keyword">gid_t</span> gp_id )</span></span><br><span class="hljs-function"></span>&#123;<br>  	<span class="hljs-comment">/*先确保目标用户不是root id == 0 就是root */</span><br>    <span class="hljs-keyword">if</span> ( ( user_id == <span class="hljs-number">0</span> ) &amp;&amp; ( gp_id == <span class="hljs-number">0</span> ) )<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">/*确保当前用户是合法用户:root或者目标用户*/</span><br>    <span class="hljs-keyword">gid_t</span> gid = <span class="hljs-built_in">getgid</span>();<br>    <span class="hljs-keyword">uid_t</span> uid = <span class="hljs-built_in">getuid</span>();<br>    <span class="hljs-keyword">if</span> ( ( ( gid != <span class="hljs-number">0</span> ) || ( uid != <span class="hljs-number">0</span> ) ) &amp;&amp; ( ( gid != gp_id ) || ( uid != user_id ) ) )<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">/*如果不是root，则已经是目标用户*/</span><br>    <span class="hljs-keyword">if</span> ( uid != <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">/*切换到目标用户 设置真实用户 和真实组 */</span><br>    <span class="hljs-keyword">if</span> ( ( <span class="hljs-built_in">setgid</span>( gp_id ) &lt; <span class="hljs-number">0</span> ) || ( <span class="hljs-built_in">setuid</span>( user_id ) &lt; <span class="hljs-number">0</span> ) )<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="73-进程间关系"><a class="markdownIt-Anchor" href="#73-进程间关系"></a> 7.3 进程间关系</h2>
<h3 id="731-进程组"><a class="markdownIt-Anchor" href="#731-进程组"></a> 7.3.1 进程组</h3>
<p>Linux下每个进程都隶属于一个进程组，因此它们除了<strong>PID信息</strong>外，还有<strong>进程组ID(PGID)</strong>。我们可以用如下函数来获取指定进程的PGID:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">getpgid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span>;<br></code></pre></td></tr></table></figure>
<p>该函数成功时返回进程<u>pid所属进程组的PGID</u>，失败则返回-1并设置errno。</p>
<p>每个进程组都有一个<strong>首领进程</strong>，其PGID和PID相同。进程组将一 直存在，直到其中所有进程都退出，或者加入到其他进程组。</p>
<p>下面的函数用于设置PGID:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setpgid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid,<span class="hljs-keyword">pid_t</span> pgid)</span></span>;<br></code></pre></td></tr></table></figure>
<p>该函数将PID为pid的进程的PGID设置为pgid。如果<u>pid和pgid相同</u>，则由pid指定的进程将被设置为<strong>进程组首领</strong>;如果pid为0，则表示设置当前进程的PGID为pgid【就是改变进程组为pgid】;如果pgid为0，则使用pid作为目标PGID【如果有就变成首领进程， 如果没有就建立进程成为首领进程】。setpgid函数成功时返回0，失败则返回-1并设置errno。</p>
<p>一个进程只能<u>设置自己或者其子进程</u>的PGID。并且，当子进程调用exec系列函数后，我们也不能再在父进程中对它设置PGID。</p>
<h3 id="732-会话"><a class="markdownIt-Anchor" href="#732-会话"></a> 7.3.2 会话</h3>
<p>Session详解：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sparkdev/p/12146305.html">https://www.cnblogs.com/sparkdev/p/12146305.html</a></p>
<p>一些<u>有关联的进程组</u>将形成一个会话(session)。下面的函数用于创建一个会话:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">setsid</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br></code></pre></td></tr></table></figure>
<p>该函数<strong>不能</strong>由进程组的首领进程调用【因为本身是前台job 相当于当前这个session散了】，否则将产生一个错误。对于非组首领的进程，调用该函数不仅创建新会话，而且有如下额外效果:</p>
<ul>
<li>调用进程成为会话的首领【前台job】，此时该进程是新会话的唯一成员。</li>
<li>新建一个进程组，其PGID就是调用进程的PID，调用进程成为该组的首领。</li>
<li>调用进程将甩开终端(如果有的话)。</li>
</ul>
<p>该函数成功时返回新的进程组的PGID，失败则返回-1并设置 errno。</p>
<p>Linux进程并未提供所谓会话ID(SID)的概念，但Linux系统认为它<u>等于会话首领所在的进程组的PGID</u>，并提供了如下函数来读取SID:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span> </span><br><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">getsid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span>;<br></code></pre></td></tr></table></figure>
<h3 id="733-用ps命令查看进程关系"><a class="markdownIt-Anchor" href="#733-用ps命令查看进程关系"></a> 7.3.3 用ps命令查看进程关系</h3>
<p>执行ps命令可查看进程、进程组和会话之间的关系:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">$ps -o pid,ppid,pgid,sid,comm|less<br>PID PPID PGID SID COMMAND<br><span class="hljs-number">1943</span> <span class="hljs-number">1942</span> <span class="hljs-number">1943</span> <span class="hljs-number">1943</span> bash<br><span class="hljs-number">2298</span> <span class="hljs-number">1943</span> <span class="hljs-number">2298</span> <span class="hljs-number">1943</span> ps<br><span class="hljs-number">2299</span> <span class="hljs-number">1943</span> <span class="hljs-number">2298</span> <span class="hljs-number">1943</span> less<br></code></pre></td></tr></table></figure>
<p>我们是在bash shell下执行ps和less命令的，所以ps和less命令的<strong>父进程</strong>是bash命令，这可以从PPID(父进程PID)一列看出。这3条命令创 建了1个会话(SID是1943)和2个进程组(PGID分别是1943和 2298)。bash命令的PID、PGID和SID都相同，很明显它既是会话的首领，也是组1943的首领。ps命令则是组2298的首领，因为其PID也是2298。图7-2描述了此三者的关系。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205211145639.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-21 上午11.44.53" /></p>
<h2 id="74-系统资源限制"><a class="markdownIt-Anchor" href="#74-系统资源限制"></a> 7.4 系统资源限制</h2>
<p>Linux上运行的程序都会受到资源限制的影响，比如物理设备限制 (CPU数量、内存数量等)、系统策略限制(CPU时间等)，以及具体实现的限制(比如文件名的最大长度)。Linux系统资源限制可以通过如下一对函数来读取和设置:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/resource.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getrlimit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> resource,struct rlimit*rlim)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setrlimit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> resource,<span class="hljs-keyword">const</span> struct rlimit*rlim)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>rlim参数</strong>是rlimit结构体类型的指针，rlimit结构体的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rlimit</span>&#123;</span><br>    <span class="hljs-keyword">rlim_t</span> rlim_cur;<br>    <span class="hljs-keyword">rlim_t</span> rlim_max;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>rlim_t是一个整数类型，它描述资源级别。</li>
<li>rlim_cur成员指定资源的软限制，rlim_max成员指定资源的硬限制。</li>
<li>软限制是一个建议性的、最好不要超越的限制，如果超越的话，系统可能向进程发送信号以终止其运行。例如，当进程CPU时间超过其软限制时，系统将向进程发送SIGXCPU信号;当文件尺寸超过其软限制时，系统将向进程发送SIGXFSZ信号(见第10章)。</li>
<li>硬限制一般是软限制的上限。普通程序可以减小硬限制，而只有以root身份运行的程序才能增加硬限制。</li>
<li>此外，我们可以使用ulimit命令修改当前shell环境下的资源限制(软限制或/和硬限制)，这种修改将对该shell启动的所有后续程序有效。我们也可以通过修改配置文件来改变系统软限制和硬限制，而且这种修改 是永久的，详情见第16章。</li>
</ul>
<p>resource参数指定资源限制类型。表7-1列举了部分比较重要的资源限制类型。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205211150756.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-21 上午11.50.29" /></p>
<p>setrlimit和getrlimit成功时返回0，失败则返回-1并设置errno。</p>
<h2 id="75-改变工作目录和根目录"><a class="markdownIt-Anchor" href="#75-改变工作目录和根目录"></a> 7.5 改变工作目录和根目录</h2>
<p>有些服务器程序还需要改变工作目录和根目录，比如我们第4章讨论的Web服务器。一般来说，Web服务器的逻辑根目录并非文件系统的根目录“/”，而是站点的根目录(对于Linux的Web服务来说，该目录一般是/var/www/)。</p>
<p><strong>获取进程当前工作目录</strong>和<strong>改变进程工作目录</strong>的函数分别是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span> </span><br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">getcwd</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* buf,<span class="hljs-keyword">size_t</span> size)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">chdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path)</span></span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>buf参数</strong>指向的内存用于存储进程当前工作目录的绝对路径名，其大小由size参数指定。如果当前工作目录的绝对路径的长度(再加上 一个空结束字符“\0”)超过了size，则getcwd将返回NULL，并设置 errno为ERANGE。如果buf为NULL并且size非0，则getcwd可能在内部使用malloc动态分配内存，<strong>并将进程的当前工作目录存储</strong>在其中。如果是这种情况，则我们必须自己来释放getcwd在内部创建的这块内存。getcwd函数成功时返回一个指向目标存储区(buf指向的缓存区或是getcwd在内部动态创建的缓存区)的指针，失败则返回NULL并设 置errno。</li>
<li><strong>chdir函数</strong>的path参数指定要<u>切换到的目标目录</u>。它成功时返回0， 失败时返回-1并设置errno。</li>
</ul>
<p>改变进程根目录的函数是chroot，其定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">chroot</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>path参数</strong>指定要切换到的目标根目录。</p>
<p>chdir()用来将当前的工作目录改变成以参数path所指的目录.</p>
<p>它成功时返回0，失败时返 回-1并设置errno。chroot并不改变进程的当前工作目录，所以调用chroot之后，我们仍然需要使用chdir(“/”)来将工作目录切换至新的根目录。改变进程的根目录之后，程序可能无法访问类似/dev的文件(和目录)，因为这些文件(和目录)并非处于新的根目录之下。不过好在调用chroot之后，进程<strong>原先打开的文件描述符依然生效</strong>，所以我们可以利用这些早先打开的文件描述符来访问调用chroot之后不能直接访问的文件(和目录)，尤其是一些日志文件。此外，只有<strong>特权进程</strong>才能改变根目录。</p>
<h2 id="76-服务器程序后台化"><a class="markdownIt-Anchor" href="#76-服务器程序后台化"></a> 7.6 服务器程序后台化</h2>
<p>最后，我们讨论如何在代码中让一个进程以守护进程的方式运行。守护进程的编写遵循一定的步骤[2]，下面我们通过一个具体实现来探讨，如代码清单7-3所示。</p>
<p>代码清单7-3 将服务器程序以守护进程的方式运行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">daemonize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*创建子进程，关闭父进程，这样可以使程序在后台运行*/</span><br>    <span class="hljs-keyword">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> ( pid &lt; <span class="hljs-number">0</span> ) <span class="hljs-comment">// 创建子进程没成功</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( pid &gt; <span class="hljs-number">0</span> ) <span class="hljs-comment">// pid &gt; 0 代表父进程 关闭 pid = 0 代表子进程</span><br>    &#123;<br>        <span class="hljs-built_in">exit</span>( <span class="hljs-number">0</span> );<br>    &#125;<br>    <span class="hljs-comment">/*设置文件权限掩码。当进程创建新文件(使用open(const char*pathname,intflags,mode_t mode)系统调用)时，文件的权限将是mode&amp;0777*/</span><br>    <span class="hljs-built_in">umask</span>( <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">/*创建新的会话，设置本进程为进程组的首领，这个时候子进程父亲进程已经G了*/</span><br>    <span class="hljs-keyword">pid_t</span> sid = <span class="hljs-built_in">setsid</span>();<br>    <span class="hljs-keyword">if</span> ( sid &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">// 没成功就退出</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ( ( <span class="hljs-built_in">chdir</span>( <span class="hljs-string">&quot;/&quot;</span> ) ) &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">// 重新设置子进程的工作路径</span><br>    &#123;<br>        <span class="hljs-comment">/* Log the failure */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">/*关闭标准输入设备、标准输出设备和标准错误输出设备*/</span><br>    <span class="hljs-built_in">close</span>( STDIN_FILENO );<br>    <span class="hljs-built_in">close</span>( STDOUT_FILENO );<br>    <span class="hljs-built_in">close</span>( STDERR_FILENO );<br>    <span class="hljs-comment">/*关闭其他已经打开的文件描述符，代码省略*/</span> <br>    <span class="hljs-comment">/*将标准输入、标准输出和标准错误输出都定向到/dev/null文件【说明此时不会有终端的输出，全部到重定向的文件描述符】*/</span><br>    <span class="hljs-built_in">open</span>( <span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDONLY );<br>    <span class="hljs-built_in">open</span>( <span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDWR );<br>    <span class="hljs-built_in">open</span>( <span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDWR );<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>实际上，Linux提供了完成同样功能的库函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">daemon</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nochdir,<span class="hljs-keyword">int</span> noclose)</span></span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>nochdir参数用于指定是否改变工作目录，如果给它传递0，则工作目录将被设置为“/”(根目录)，否则继续使用当前工作目录。</li>
<li>noclose参数为0时，标准输入、标准输出和标准错误输出都被重定向到/dev/null文件，否则依然使用原来的设备。该函数成功时返回 0，失败则返回-1并设置errno。</li>
</ul>
<h1 id="第8章-高性能服务器程序框架"><a class="markdownIt-Anchor" href="#第8章-高性能服务器程序框架"></a> 第8章 高性能服务器程序框架</h1>
<p>这一章是全书的核心，也是后续章节的总览。在这一章中，我们按照服务器程序的一般原理，将服务器解构为如下三个主要模块:</p>
<ul>
<li>
<p>I/O处理单元。本章将介绍I/O处理单元的<strong>四种I/O模型</strong>和<strong>两种高效事件</strong>处理模式。</p>
</li>
<li>
<p>逻辑单元。本章将介绍逻辑单元的<strong>两种高效并发</strong>模式，以及高效的逻辑处理方式——<strong>有限状态机</strong>。</p>
</li>
<li>
<p>存储单元。本书不讨论存储单元，因为它只是服务器程序的可选模块，而且其内容与网络编程本身无关。</p>
<p>最后，本章还介绍了提高服务器性能的其他建议。</p>
</li>
</ul>
<h2 id="81-服务器模型"><a class="markdownIt-Anchor" href="#81-服务器模型"></a> 8.1 服务器模型</h2>
<h3 id="811-cs模型"><a class="markdownIt-Anchor" href="#811-cs模型"></a> 8.1.1 C/S模型</h3>
<p>TCP/IP协议在设计和实现上并没有客户端和服务器的概念，在通信过程中所有机器都是对等的。但由于资源(视频、新闻、软件等) 都被数据提供者所垄断，所以几乎所有的网络应用程序都很自然地采用了图8-1所示的C/S(客户端/服务器)模型:所有客户端都通过访问服务器来获取所需的资源。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221725664.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午5.25.29" /></p>
<p>采用C/S模型的TCP服务器和TCP客户端的工作流程如图8-2所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221726905.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午5.26.32" /></p>
<p>C/S模型的逻辑很简单。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221731291.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午5.31.09" /></p>
<ul>
<li>服务器启动后，首先创建一个(或多个) 监听socket，并调用bind函数将其绑定到服务器感兴趣的端口上，然后调用listen函数等待客户连接。</li>
<li>服务器稳定运行之后，客户端就可以调用connect函数向服务器发起连接了。由于客户连接请求是随机到达的异步事件，服务器需要使用某种I/O模型来监听这一事件。</li>
<li>I/O模型有多种，图8-2中，服务器使用的是<strong>I/O复用技术</strong>之一的<strong>select系统调用</strong>。</li>
<li>当监听到连接请求后，服务器就调用accept函数接受它，并分配一个<u>逻辑单元为新的连接服务</u>。逻辑单元可以是新创建的子进程、子线程或者其他。</li>
<li>图8-2中，服务器给客户端分配的<strong>逻辑单元</strong>是由fork系统调用创建的子进程。逻辑单元<u>读取客户请求，处理该请求</u>，然后将处理结果 返回给客户端。</li>
<li>客户端接收到服务器反馈的结果之后，可以继续向服务器发送请求，也可以立即主动关闭连接。如果客户端主动关闭连接，则服务器执行被动关闭连接。</li>
<li>至此，双方的通信结束。需要注意的是，服务器在处理一个客户请求的同时还会继续监听其他客户请求，否则就变成了效率低下的串行服务器了(必须先处理完前一个客户的请求，才能继续处理下一个客户请求)。图8-2中，服务器同时监听多个客户请求是通过select系统调用实现的。</li>
</ul>
<p><strong>I/O复用</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/edwardliu2000/p/15047886.html">https://www.cnblogs.com/edwardliu2000/p/15047886.html</a></p>
<p>C/S模型非常适合资源相对集中的场合，并且它的实现也很简单，但其缺点也很明显:服务器是通信的中心，当访问量过大时，可能所有客户都将得到很慢的响应。下面讨论的P2P模型解决了这个问题。</p>
<h3 id="812-p2p模型"><a class="markdownIt-Anchor" href="#812-p2p模型"></a> 8.1.2 P2P模型</h3>
<p>P2P(Peer to Peer，点对点)模型比C/S模型更符合网络通信的实际情况。它摒弃了以服务器为中心的格局，让网络上所有主机重新回归对等的地位。P2P模型如图8-3a所示。</p>
<p>P2P模型使得每台机器在消耗服务的同时也给别人提供服务，这样资源能够充分、自由地共享。云计算机群可以看作P2P模型的一个典 范。但P2P模型的<strong>缺点</strong>也很明显:<u>当用户之间传输的请求过多时，网络的负载将加重</u>。</p>
<p>图8-3a所示的P2P模型存在一个显著的<strong>问题</strong>，即<u>主机之间很难互相发现</u>。所以实际使用的P2P模型通常带有一个专门的发现服务器，如图 8-3b所示。这个发现服务器通常还提供<strong>查找服务</strong>(甚至还可以提供内容服务)，使每个客户都能尽快地找到自己需要的资源。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221752179.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午5.51.56" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221752817.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午5.52.52" /></p>
<p>从编程角度来讲，P2P模型可以看作C/S模型的扩展:每台主机既是客户端，又是服务器。因此，我们仍然采用C/S模型来讨论网络编程。</p>
<h2 id="82-服务器编程框架"><a class="markdownIt-Anchor" href="#82-服务器编程框架"></a> 8.2 服务器编程框架</h2>
<p>虽然服务器程序种类繁多，但其基本框架都一样，不同之处在于逻辑处理。为了让读者能从设计的角度把握服务器编程，本章先讨论基本框架，如图8-4所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221754982.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午5.54.21" /></p>
<p>该图既能用来描述一台服务器，也能用来描述一个服务器机群。 两种情况下各个部件的含义和功能如表8-1所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221757761.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午5.57.09" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221759451.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午5.59.29" /></p>
<p><strong>I/O处理单元</strong>是<u>服务器管理客户连接</u>的模块。</p>
<p>它通常要完成以下工作:等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端。但是，数据的收发不一定在I/O处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式(见后文)。对于一个服务器机群来说，I/O处理单元是一个专门的接入服务器。它实现<strong>负载均衡</strong>，从<u>所有逻辑服务器中选取负荷最小的一台来为新客户服务</u>。</p>
<p><strong>一个逻辑单元</strong>通常是<strong>一个进程或线程</strong>。</p>
<p>它分析并处理客户数据，然后将结果传递给I/O处理单元或者直接发送给客户端(具体使用哪种方式取决于事件处理模式)。对服务器机群而言，一个逻辑单元本身就是一台逻辑服务器。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并行处理。</p>
<p><strong>网络存储单元</strong></p>
<p>可以是数据库、缓存和文件，甚至是一台独立的服务器。但它不是必须的，比如ssh、telnet等登录服务就不需要这个单元。</p>
<p><strong>请求队列</strong>是各单元之间的通信方式的抽象。</p>
<p>I/O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。请求队列通常被实现为池的一部分，我们将在后面讨论池的概念。对于服务器机群而言，请求队列是各台服务器之间预先<strong>建立的、静态的、永久的</strong>TCP连接。这种TCP连接能提高服务器之间交换数据的效率，因为它避免了动态建立TCP连接导致的额外的系统开销。</p>
<h2 id="83-io模型"><a class="markdownIt-Anchor" href="#83-io模型"></a> 8.3 I/O模型</h2>
<p>第5章讲到，socket在创建的时候<u>默认是阻塞</u>的。我们可以给socket系统调用的第2个参数传递SOCK_NONBLOCK标志，或者通过fcntl系 统调用的F_SETFL命令，将其<u>设置为非阻塞</u>的。<strong>阻塞和非阻塞的概念能应用于所有文件描述符</strong>，而不仅仅是socket。我们称<strong>阻塞的文件描述符为阻塞I/O</strong>，称<strong>非阻塞的文件描述符为非阻塞I/O</strong>。</p>
<p>针对阻塞I/O执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。比如，客户端通过connect向服务器发起连接时，connect将首先发送同步报文段给服务器，然后等待服务器返回确认报文段。如果服务器的确认报文段没有立即到达客户端， 则connect调用将被挂起，直到客户端收到确认报文段并唤醒connect调用。socket的基础API中，可能被阻塞的系统调用包括accept、send、 recv和connect。</p>
<p>针对非阻塞I/O执行的系统调用则总是<strong>立即返回</strong>，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用就返回-1，和出错的 情况一样。此时我们必须根据<u>errno来区分这两种</u>情况。对accept、send和recv而言，事件未发生时errno通常被设置成EAGAIN(意为“再来一次”)或者EWOULDBLOCK(意为“期望阻塞”);对connect而言， errno则被设置成EINPROGRESS(意为“在处理中”)。</p>
<p>很显然，我们只有在事件已经发生的情况下操作非阻塞I/O(读、 写等)，才能提高程序的效率。因此，非阻塞I/O通常要和其他I/O通知机制一起使用，比如I/O复用和SIGIO信号。</p>
<p><strong>I/O复用</strong>是最常使用的<strong>I/O通知</strong>机制。它指的是，<u>应用程序通过I/O复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序</u>。Linux上常用的I/O复用函数是select、poll和epoll_wait，我们将在第9章详细讨论它们。需要指出的是，I/O复用函数本身是阻塞的，它们能<strong>提高程序效率</strong>的原因在于它们具有<strong>同时监听多个I/O事件</strong>的能力。</p>
<p><strong>SIGIO信号</strong>也可以用来报告I/O事件。6.8节的最后一段提到，我们可以为一个目标文件描述符指定宿主进程，那么被指定的宿主进程将捕获到SIGIO信号。这样，当目标文件描述符上有事件发生时，SIGIO信号的信号处理函数将被触发，我们也就可以在该信号处理函数中对 目标文件描述符执行非阻塞I/O操作了。关于信号的使用，我们将在第10章讨论。</p>
<p>从理论上说，阻塞I/O、I/O复用和信号驱动I/O都是<strong>同步I/O模型</strong>。 因为在这三种I/O模型中，I/O的读写操作，都是在I/O事件发生之后， 由应用程序来完成的。而POSIX规范所定义的异步I/O模型则不同。对异步I/O而言，用户可以直接对I/O执行读写操作，这些操作告诉内核用 户读写缓冲区的位置，以及I/O操作完成之后内核通知应用程序的方式。异步I/O的读写操作总是立即返回，而不论I/O是否是阻塞的，因为 真正的读写操作已经由内核接管。也就是说，同步I/O模型要求用户代码自行<strong>执行I/O操作(将数据从内核缓冲区读入用户缓冲区，或将数据 从用户缓冲区写入内核缓冲区)</strong>，而异步I/O机制则由<strong>内核来执行I/O操作(数据在内核缓冲区和用户缓冲区之间的移动是由内核在“后台”完 成的</strong>)。你可以这样认为，<strong>同步I/O向应用程序通知的是<u>I/O就绪事件</u>， 而异步I/O向应用程序通知的是<u>I/O完成事件</u></strong>【这句话太重要了】。Linux环境下，aio.h头文件中定义的函数提供了对异步I/O的支持。不过这部分内容不是本书的重点，所以只做简单的讨论。</p>
<p>作为总结，我们将上面讨论的几种I/O模型的差异列于表8-2中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221839581.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午6.39.29" /></p>
<h2 id="84-两种高效的事件处理模式"><a class="markdownIt-Anchor" href="#84-两种高效的事件处理模式"></a> 8.4 两种高效的事件处理模式</h2>
<p>服务器程序通常需要处理三类事件:I/O事件、信号及定时事件。 我们将在后续章节依次讨论这三种类型的事件，这一节先从整体上介绍一下两种高效的事件处理模式:Reactor和Proactor。</p>
<p>随着网络设计模式的兴起，Reactor和Proactor事件处理模式应运而生。同步I/O模型通常用于实现Reactor模式，异步I/O模型则用于实现 Proactor模式。不过后面我们将看到，如何使用同步I/O方式模拟出Proactor模式。</p>
<h3 id="841-reactor模式"><a class="markdownIt-Anchor" href="#841-reactor模式"></a> 8.4.1 Reactor模式</h3>
<p>Reactor是这样一种模式，它要求主线程(<strong>I/O处理单元</strong>，下同)<strong>只负责监听</strong>文件描述上是否有事件发生，有的话就立即将该事件通知工作线程(<strong>逻辑单元</strong>，下同)。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</p>
<p>使用同步I/O模型(以epoll_wait为例)实现的Reactor模式的工作流程是:</p>
<ol>
<li>
<p>主线程往epoll内核事件表中注册socket上的<strong>读就绪</strong>事件。</p>
</li>
<li>
<p>主线程调用epoll_wait等待socket上有数据可读。</p>
</li>
<li>
<p>当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列。</p>
</li>
<li>
<p>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就 绪事件。</p>
</li>
<li>
<p>主线程调用epoll_wait等待socket可写。</p>
</li>
<li>
<p>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。</p>
</li>
<li>
<p>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。</p>
</li>
</ol>
<p>图8-5总结了Reactor模式的工作流程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221901531.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午7.01.16" /></p>
<p>图 8-5 Reactor模式</p>
<p>图8-5中，工作线程从请求队列中取出事件后，将根据事件的类型来决定如何处理它:对于可读事件，执行读数据和处理请求的操作; 对于可写事件，执行写数据的操作。因此，图8-5所示的Reactor模式中，没必要区分所谓的“读工作线程”和“写工作线程”。【说白了主线程用epoll 将监听到的socket放到请求队列里，等待着被处理，就比如消息队列像一个秘书，你告诉他可以处理了他去处理，你只告诉他可以做了就行】</p>
<h3 id="842-proactor模式"><a class="markdownIt-Anchor" href="#842-proactor模式"></a> 8.4.2 Proactor模式</h3>
<p>与Reactor模式不同，Proactor模式将所有I/O操作都交给主线程和内核来处理，<u>工作线程仅仅负责业务逻辑</u>。因此，Proactor模式更符合图 8-4所描述的服务器编程框架。</p>
<p>使用异步I/O模型(以aio_read和aio_write为例)实现的Proactor模式的工作流程是:</p>
<ol>
<li>
<p>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序 (这里以信号为例，详情请参考sigevent的man手册)。</p>
</li>
<li>
<p>主线程继续处理其他逻辑。</p>
</li>
<li>
<p>当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。</p>
</li>
<li>
<p>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注 册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序(仍然以信号为例)。</p>
</li>
<li>
<p>主线程继续处理其他逻辑。</p>
</li>
<li>
<p>当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</p>
</li>
<li>
<p>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221910960.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午7.10.09" /></p>
</li>
</ol>
<p>在图8-6中，连接socket上的读写事件是通过aio_read/aio_write向内核注册的，因此内核将通过信号来向应用程序报告连接socket上的读写事件。所以，主线程中的epoll_wait调用<u>仅能用来检测监听socket上的连接请求事</u>件，而<strong>不能</strong><u>用来检测连接socket上的读写</u>事件。</p>
<p>csdn讲解：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/428693405">https://zhuanlan.zhihu.com/p/428693405</a></p>
<h3 id="843-模拟proactor模式"><a class="markdownIt-Anchor" href="#843-模拟proactor模式"></a> 8.4.3 模拟Proactor模式</h3>
<p>参考文献[3]提到了使用同步I/O方式模拟出Proactor模式的一种方法。其原理是:主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。</p>
<p>使用同步I/O模型(仍然以epoll_wait为例)模拟出的Proactor模式的工作流程如下:</p>
<ol>
<li>
<p>主线程往epoll内核事件表中注册socket上的<strong>读就绪</strong>事件。</p>
</li>
<li>
<p>主线程调用epoll_wait等待socket上有数据可读。</p>
</li>
<li>
<p>当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封 装成一个请求对象并插入请求队列。【这里和reactor非常不一样，这个是主线程读写工作线程是只负责逻辑；那个是工作线程负责读，主线程负责发送信号，所以区别在于他们的分工不同，所以一个epoll的结果是准备读，一个是已经读完了】</p>
</li>
<li>
<p>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的<strong>写就绪</strong>事件。</p>
</li>
<li>
<p>主线程调用epoll_wait等待socket可写。</p>
</li>
<li>
<p>当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。</p>
</li>
</ol>
<p>PS：我自己总结就是发送到消息队列的东西不一样，reactor是提交【读/写+处理】的通知，然后工作线程开始进行【读/写+处理】，而proactor是【读入的数据包】然后给消息队列请求工作线程处理而已。</p>
<p>图8-7总结了用同步I/O模型模拟出的Proactor模式的工作流程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222157650.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午9.57.05" /></p>
<h2 id="85-两种高效的并发模式"><a class="markdownIt-Anchor" href="#85-两种高效的并发模式"></a> 8.5 两种高效的并发模式</h2>
<p>并发编程的目的是让程序“同时”执行多个任务。如果程序是<strong>计算密集型</strong>的，并发编程并没有优势，反而由于任务的切换使效率降低。但如果程序是<strong>I/O密集型</strong>的，比如经常读写文件，访问数据库等，则情况就不同了。由于<u>I/O操作的速度远没有CPU的计算速度快</u>，所以让程序阻塞于I/O操作将浪费大量的CPU时间。如果程序有多个执行线程， 则当前被I/O操作所阻塞的执行线程可主动放弃CPU(或由操作系统来 调度)，并将执行权转移到其他线程。这样一来，CPU就可以用来做更加有意义的事情(除非所有线程都同时被I/O操作所阻塞)，而不是等待I/O操作完成，因此CPU的利用率显著提升。</p>
<p>从实现上来说，并发编程主要有<strong>多进程</strong>和<strong>多线程</strong>两种方式，我们将在后续章节详细讨论它们，这一节先讨论<strong>并发模式</strong>。对应于图8-4，并发模式是指<u>I/O处理单元和多个逻辑单元之间协调完成任务</u>的方法。 服务器主要有两种并发编程模式:半同步/半异步(half-sync/half-async)模式和领导者/追随者(Leader/Followers)模式。我们将依次讨论之。</p>
<h3 id="851-半同步半异步模式"><a class="markdownIt-Anchor" href="#851-半同步半异步模式"></a> 8.5.1 半同步/半异步模式</h3>
<p>首先，半同步/半异步模式中的“同步”和“异步”与前面讨论的I/O模型中的“同步”和“异步”是完全不同的概念。在I/O模型中，“同步”和“异 步”区分的是内核向应用程序通知的是何种I/O事件(是<u>就绪事件还是完成事件</u>)，以及<u>该由谁来完成I/O读写</u>(是应用程序【主线程】还是内核)。</p>
<p>在并发模式中，“<strong>同步</strong>”指的是<u>程序完全按照代码序列的顺序执行</u>;“<strong>异步</strong>”指的是<u>程序的执行需要由系统事件来驱动</u>。常见的系统事件包括中断、信号等。比如，图8-8a描述了同步的读操作，而图8-8b则描述了异步的读操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222203553.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午10.03.54" /></p>
<p>按照同步方式运行的线程称为同步线程，按照异步方式运行的线程称为异步线程。显然，异步线程的执行效率高，实时性强，这是很多嵌入式程序采用的模型。但编写以异步方式执行的程序相对复杂，难于调试和扩展，而且<strong>不适合于大量</strong>的并发。而同步线程则相反，它虽然效率相对较低，实时性较差，但逻辑简单。因此，对于像服务器这种既要求较好的实时性，又要求能同时处理多个客户请求的应用程 序，我们就应该同时使用同步线程和异步线程来实现，即采用半同步/ 半异步模式来实现。</p>
<p>半同步/半异步模式中，<strong>同步线程</strong>用于处理<strong>客户逻辑</strong>，相当于图8-4中的<strong>逻辑单元</strong>;<strong>异步线程</strong>用于处理I/O事件，相当于图8-4中的I/O处理单元。<u>异步线程监听</u>到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并 处理该请求对象。具体选择哪个工作线程来为新的客户请求服务，则取决于请求队列的设计。比如最简单的轮流选取工作线程的Round Robin算法，也可以通过条件变量(见第14章)或信号量(见第14章) 来随机地选择一个工作线程。图8-9总结了半同步/半异步模式的工作流 程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222213581.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午10.13.22" /></p>
<p>在服务器程序中，如果结合考虑两种事件处理模式和几种I/O模型，则半同步/半异步模式就存在多种变体。其中有一种变体称为半同步/半反应堆(half-sync/half-reactive)模式，如图8-10所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222214153.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午10.13.58" /></p>
<p>图8-10中，异步线程只有一个，由主线程来充当。它负责监听所有socket上的事件。如果监听socket上有可读事件发生，即有新的连接请 求到来，主线程就接受之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。【这里知识建立连接】如果连接socket上有读写事件发生，即有新的客户请求到来或有数据要发送至客户端，主线程就将该连接socket插入请求队列中。所有工作线程都睡眠在请求队列上，当有任务到来时，它们将通过竞争(比如申请互斥锁)获得任务的接管权。这种竞争机制使得只有空闲的工作线程才有机会来处理新任务，这是很合理的。</p>
<p>图8-10中，主线程插入请求队列中的任务是<strong>就绪的连接socket</strong>。这说明该图所示的半同步/半反应堆模式采用的事件处理模式是<strong>Reactor模式</strong>:它要求工作线程自己<u>从socket上读取客户请求和往socket写入服务器应答</u>。这就是该模式的名称中“half-reactive”的含义。实际上，半同步/半反应堆模式也可以使用模拟的Proactor事件处理模式，即由主线程来完成数据的读写。在这种情况下，主线程一般会将应用程序数据、任务类型等信息封装为一个任务对象，然后将其(或者指向该任务对象的一个指针)插入请求队列。工作线程从请求队列中取得任务对象之后，即可直接处理之，而无须执行读写操作了。我们将在第15章给出一个用半同步/半反应堆模式实现的简单Web服务器的代码。</p>
<p>半同步/半反应堆模式存在如下<strong>缺点</strong>:</p>
<ul>
<li>
<p>主线程和工作线程共享请求队列。主线程往请求队列中添加任务，或者工作线程从请求队列中取出任务，都需要对请求队列加锁保 护，从而白白耗费CPU时间。</p>
</li>
<li>
<p>每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而<u>工作线程较少</u>，则请求队列中将<u>堆积很多</u>任务对象，客户端的<u>响应速度将越来越慢</u>。如果通过<u>增加工作线程</u>来解决这一问题， 则工作线程的<u>切换也将耗费大量CPU时间</u>。</p>
</li>
</ul>
<p>图8-11描述了一种相对高效的半同步/半异步模式，它的每个工作线程都能同时处理多个客户连接。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222218451.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午10.18.44" /></p>
<p>图8-11中，主线程只管理监听socket，连接socket由工作线程来管理。</p>
<ul>
<li>当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程。</li>
<li>此后该新socket上的任何I/O操作都由被选中的工作线程来处理，直到客户关闭连接。【发给你的小兄弟们】</li>
<li>主线程向工作线程派发socket的最简单的方式，是往它和工作线程之间的管道里写数据。</li>
<li>工作线程检测到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。 如果是，则把该新socket上的读写事件注册到自己的epoll内核事件表中。</li>
</ul>
<p>可见，图8-11中，每个线程(主线程和工作线程)都维持自己的事件循环，它们各自独立地监听不同的事件。因此，在这种高效的半同步/半异步模式中，每个线程都工作在异步模式，所以它并非严格意义上的半同步/半异步模式。我们将在第15章给出一个用这种高效的半同步/半异步模式实现的简单CGI服务器的代码。</p>
<h3 id="852-领导者追随者模式"><a class="markdownIt-Anchor" href="#852-领导者追随者模式"></a> 8.5.2 领导者/追随者模式</h3>
<p>领导者/追随者模式是多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。</p>
<p>在任意时间点，程序都<strong>仅有一个领导者线程</strong>，它<strong>负责监听I/O</strong>事件。而其他线程则都是追随者，它们<u>休眠在线程池中等待成为新的领导者</u>。</p>
<p>当前的领导者如果检测到I/O事件， 首先要从线程池中推<strong>选出新</strong>的领导者线程，然后<strong>处理</strong>I/O事件。此时，新的领导者等待新的I/O事件，而原来的领导者则处理I/O事件，二者实现了并发。【轮流处理，交替给权力】</p>
<p>领导者/追随者模式包含如下几个组件:句柄集(HandleSet)、线程集(ThreadSet)、事件处理器(EventHandler)和具体的事件处理器(ConcreteEventHandler)。它们的关系如图8-12所示[4]。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222224608.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午10.24.12" /></p>
<h4 id="1-句柄集"><a class="markdownIt-Anchor" href="#1-句柄集"></a> 1、句柄集</h4>
<p>句柄(Handle)用于表示I/O资源，在Linux下通常就是一个文件描述符。句柄集管理众多句柄，它使用wait_for_event方法来监听这些句柄上的I/O事件，并将其中的就绪事件通知给领导者线程。领导者则调用绑定到Handle上的事件处理器来处理事件。领导者将Handle和事件处 理器绑定是通过调用句柄集中的<strong>register_handle方法</strong>实现的。</p>
<h4 id="2-线程集"><a class="markdownIt-Anchor" href="#2-线程集"></a> 2、线程集</h4>
<p>这个组件是所有工作线程(包括领导者线程和追随者线程)的管理者。它负责各<strong>线程之间的同步</strong>，以及<strong>新领导者线程的推选</strong>。线程集中的线程在任一时间必处于如下三种状态之一:</p>
<ul>
<li>
<p>Leader:线程当前处于领导者身份，负责等待句柄集上的I/O事件。</p>
</li>
<li>
<p>Processing:线程正在处理事件。领导者<u>检测到I/O事件之后，可以转移到</u>Processing状态来处理该事件，并调用promote_new_leader方法推选新的领导者;</p>
<p>也可以指定其他追随者来处理事件(Event Handoff)，此时领导者的地位不变。当处于Processing状态的线程处理完事件之后，如果当前线程集中<strong>没有领导者</strong>，则它将成为新的领导者，否则它就直接转变为追随者。</p>
</li>
<li>
<p>Follower:线程当前处于追随者身份，通过调用线程集的join方法等待成为新的领导者，也可能被当前的领导者指定来处理新的任务。</p>
</li>
</ul>
<p>图8-13显示了这三种状态之间的转换关系。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222230567.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午10.30.36" /></p>
<p>需要注意的是，领导者线程<strong>推选新的领导者</strong>和<strong>追随者等待成为新领导者</strong>这两个操作都将修改线程集，因此线程集提供一个成员 Synchronizer来同步这两个操作，以避免竞态条件。</p>
<h4 id="3事件处理器和具体的事件处理器"><a class="markdownIt-Anchor" href="#3事件处理器和具体的事件处理器"></a> 3.事件处理器和具体的事件处理器</h4>
<p>事件处理器通常包含一个或多个回调函数handle_event。这些回调函数<strong>用于处理事件对应的业务逻辑</strong>。事件处理器在使用前需要被绑定到某个句柄上，当该句柄上有事件发生时，领导者就执行与之绑定的事件处理器中的回调函数。具体的事件处理器是事件处理器的派生类。它们必须重新实现基类的handle_event方法，以处理特定的任务。根据上面的讨论，我们将领导者/追随者模式的工作流程总结于图8-14中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222236451.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-22 下午10.36.25" /></p>
<p>由于<strong>领导者线程自己监听I/O事件并处理客户请求</strong>，因而领导者/追随者模式<u>不需要在线程之间传递任何额外的数据</u>，也无须像半同步/半 反应堆模式那样在线程之间同步对请求队列的访问。但领导者/追随者的一个明显缺点是<strong>仅支持一个事件源</strong>集合，因此也无法像图8-11所示的那样，让每个工作线程独立地管理多个客户连接。</p>
<h2 id="86-有限状态机"><a class="markdownIt-Anchor" href="#86-有限状态机"></a> 8.6 有限状态机</h2>
<p>前面两节探讨的是服务器的I/O处理单元、请求队列和逻辑单元之间协调完成任务的各种模式，这一节我们介绍逻辑单元内部的一种高效编程方法:有限状态机(finite state machine)。</p>
<p>有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑，如代码清单8-1所示。</p>
<p>代码清单8-1 状态独立的有限状态机</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">代码清单<span class="hljs-number">8</span><span class="hljs-number">-1</span> 状态独立的有限状态机<br><span class="hljs-built_in">STATE_MACHINE</span>(Package_pack)&#123;<br>   PackageType_type=_pack.<span class="hljs-built_in">GetType</span>();<br>   <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(_type)<br>   &#123;<br>       <span class="hljs-keyword">case</span> type_A:<br>       <span class="hljs-built_in">process_package_A</span>(_pack);<br>       <span class="hljs-keyword">break</span>;<br>       <span class="hljs-keyword">case</span> type_B:<br>       <span class="hljs-built_in">process_package_B</span>(_pack);<br>       <span class="hljs-keyword">break</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这就是一个简单的有限状态机，只不过该状态机的每个状态都是<strong>相互独立</strong>的，即状态之间没有相互转移。状态之间的转移是需要状态机内部驱动的，如代码清单8-2所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">STATE_MACHINE</span>()<br></code></pre></td></tr></table></figure>
<p>代码清单8-2 带状态转移的有限状态机</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br>&#123;<br>    State cur_State=type_A;<br>    <span class="hljs-keyword">while</span>(cur_State!=type_C)<br>    &#123;<br>        Package_pack=<span class="hljs-built_in">getNewPackage</span>();<br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(cur_State)<br>        &#123;<br>            <span class="hljs-keyword">case</span> type_A:<br>            <span class="hljs-built_in">process_package_state_A</span>(_pack);<br>            cur_State=type_B;<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> type_B:<br>            <span class="hljs-built_in">process_package_state_B</span>(_pack);<br>            cur_State=type_C;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该状态机包含三种状态:type_A、type_B和type_C，其中type_A是状态机的<strong>开始状态</strong>，type_C是状态机的<strong>结束状态</strong>。状态机的当前状态记录在cur_State变量中。在一趟循环过程中，状态机先通过getNewPackage方法<u>获得一个新的数据包</u>，然后根据cur_State变量的值判断如何处理该数据包。数据包处理完之后，状态机通过给cur_State变量传递目标状态值来实现状态转移。那么当状态机进入下一趟循环时，它将执行新的状态对应的逻辑。</p>
<p>下面我们考虑有限状态机应用的一个实例:HTTP请求的读取和分析。很多网络协议，包括TCP协议和IP协议，都在其头部中提供头部长度字段。程序根据该字段的值就可以知道是否接收到一个完整的协议头部。但HTTP协议并未提供这样的头部长度字段，并且其头部长度变 化也很大，可以只有十几字节，也可以有上百字节。根据协议规定， 我们判断HTTP头部<strong>结束的依据是遇到一个空行</strong>，该空行仅包含一对回车换行符(<CR><LF>)。如果一次读操作没有读入HTTP请求的整个头部，<u>即没有遇到空行</u>，那么我们必须等待客户继续写数据并再次读入。因此，我们每完成一次读操作，就要分析新读入的数据中是否有空行。不过在寻找空行的过程中，我们可以同时完成对整个HTTP请求头部的分析(记住，空行前面还有请求行和头部域)，以提高解析HTTP请求的效率。代码清单8-3使用主、从两个有限状态机实现了最简单的HTTP请求的读取和分析。为了使表述简洁，我们约定，直接称HTTP请求的一行(包括请求行和头部字段)为行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 4096 <span class="hljs-comment">/*读缓冲区大小*/</span></span><br><span class="hljs-comment">/*主状态机的两种可能状态，分别表示:当前正在分析请求行，当前正在分析头部字段 */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">CHECK_STATE</span> &#123;</span> CHECK_STATE_REQUESTLINE = <span class="hljs-number">0</span>, CHECK_STATE_HEADER, CHECK_STATE_CONTENT &#125;;<br><span class="hljs-comment">/*从状态机的三种可能状态，即行的读取状态，分别表示:读取到一个完整的行、行出错和行数据尚且不完整*/</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">LINE_STATUS</span> &#123;</span> LINE_OK = <span class="hljs-number">0</span>, LINE_BAD, LINE_OPEN &#125;;<br><span class="hljs-comment">/*服务器处理HTTP请求的结果:NO_REQUEST表示请求不完整，需要继续读取客户数据;GET_REQUEST表示获得了一个完整的客户请求;BAD_REQUEST表示客户请求有语法错误;FORBIDDEN_REQUEST表示客户对资源没有足够的访问权限;INTERNAL_ERROR表示服务器内部错误;CLOSED_CONNECTION表示客户端已经关闭连接了*/</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">HTTP_CODE</span> &#123;</span> NO_REQUEST, GET_REQUEST, BAD_REQUEST, FORBIDDEN_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION &#125;;<br><span class="hljs-comment">/*为了简化问题，我们没有给客户端发送一个完整的HTTP应答报文，而只是根据服务器的处理结果发送如下成功或失败信息*/</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* szret[] = &#123; <span class="hljs-string">&quot;I get a correct result\n&quot;</span>, <span class="hljs-string">&quot;Something wrong\n&quot;</span> &#125;;<br><span class="hljs-comment">/*从状态机，用于解析出一行内容*/</span><br><span class="hljs-function">LINE_STATUS <span class="hljs-title">parse_line</span><span class="hljs-params">( <span class="hljs-keyword">char</span>* buffer, <span class="hljs-keyword">int</span>&amp; checked_index, <span class="hljs-keyword">int</span>&amp; read_index )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> temp;<br>  <span class="hljs-comment">/*checked_index指向buffer(应用程序的读缓冲区)中当前正在分析的字节，read_index指向buffer中客户数据的尾部的下一字节。buffer中第0~checked_index字节都已分析完毕，第checked_index~(read_index-1)字节由下面的循环挨个分析*/</span><br>    <span class="hljs-keyword">for</span> ( ; checked_index &lt; read_index; ++checked_index )<br>    &#123;<br>      	<span class="hljs-comment">/*获得当前要分析的字节*/</span><br>        temp = buffer[ checked_index ];<br>        <span class="hljs-comment">/*如果当前的字节是“\r”，即回车符，则说明可能读取到一个完整的行*/</span><br>        <span class="hljs-keyword">if</span> ( temp == <span class="hljs-string">&#x27;\r&#x27;</span> )<br>        &#123;<br>            <span class="hljs-comment">/*如果“\r”字符碰巧是目前buffer中的最后一个已经被读入的客户数据【但不代表tcp的结尾】，那么这次分析没有读取到一个完整的行，返回LINE_OPEN以表示还需要继续读取客户数据才能进一步分析*/</span><br>            <span class="hljs-keyword">if</span> ( ( checked_index + <span class="hljs-number">1</span> ) == read_index )<br>            &#123;<br>                <span class="hljs-keyword">return</span> LINE_OPEN;<br>            &#125;<br>            <span class="hljs-comment">/*如果下一个字符是“\n”，则说明我们成功读取到一个完整的行*/</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( buffer[ checked_index + <span class="hljs-number">1</span> ] == <span class="hljs-string">&#x27;\n&#x27;</span> )<br>            &#123;<br>                buffer[ checked_index++ ] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                buffer[ checked_index++ ] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                <span class="hljs-keyword">return</span> LINE_OK;<br>            &#125;<br>            <span class="hljs-comment">/*否则的话，说明客户发送的HTTP请求存在语法问题*/</span><br>            <span class="hljs-keyword">return</span> LINE_BAD;<br>        &#125;<br>        <span class="hljs-comment">/*如果当前的字节是“\n”，即换行符，则也说明可能读取到一个完整的行*/</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( temp == <span class="hljs-string">&#x27;\n&#x27;</span> )<br>        &#123;   <br>            <span class="hljs-keyword">if</span>( ( checked_index &gt; <span class="hljs-number">1</span> ) &amp;&amp;  buffer[ checked_index - <span class="hljs-number">1</span> ] == <span class="hljs-string">&#x27;\r&#x27;</span> )<br>            &#123;<br>                buffer[ checked_index<span class="hljs-number">-1</span> ] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">// 去掉\r </span><br>                buffer[ checked_index++ ] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                <span class="hljs-keyword">return</span> LINE_OK; <span class="hljs-comment">//说明是对滴</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> LINE_BAD;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*如果所有内容都分析完毕也没遇到“\r”字符【说明连一行都不是】，则返回LINE_OPEN，表示还需要继续读取客户数据才能进一步分析*/</span><br>    <span class="hljs-keyword">return</span> LINE_OPEN;<br>&#125;<br><span class="hljs-comment">/*分析请求行*/</span><br><span class="hljs-function">HTTP_CODE <span class="hljs-title">parse_requestline</span><span class="hljs-params">( <span class="hljs-keyword">char</span>* szTemp, CHECK_STATE&amp; checkstate )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span>* szURL = <span class="hljs-built_in">strpbrk</span>( szTemp, <span class="hljs-string">&quot; \t&quot;</span> );<br>    <span class="hljs-comment">/*如果请求行中没有空白字符或“\t”字符，则HTTP请求必有问题*/</span><br>    <span class="hljs-keyword">if</span> ( ! szURL )<br>    &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br>    *szURL++ = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-keyword">char</span>* szMethod = szTemp;<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strcasecmp</span>( szMethod, <span class="hljs-string">&quot;GET&quot;</span> ) == <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;The request method is GET\n&quot;</span> );<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br>    <br>    szURL += <span class="hljs-built_in">strspn</span>( szURL, <span class="hljs-string">&quot; \t&quot;</span> );<br>    <span class="hljs-keyword">char</span>* szVersion = <span class="hljs-built_in">strpbrk</span>( szURL, <span class="hljs-string">&quot; \t&quot;</span> );<br>   <br>    <span class="hljs-keyword">if</span> ( ! szVersion )<br>    &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br>    *szVersion++ = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    szVersion += <span class="hljs-built_in">strspn</span>( szVersion, <span class="hljs-string">&quot; \t&quot;</span> );<br>    <span class="hljs-comment">/*仅支持HTTP/1.1*/</span><br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strcasecmp</span>( szVersion, <span class="hljs-string">&quot;HTTP/1.1&quot;</span> ) != <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br>    <span class="hljs-comment">/*检查URL是否合法*/</span><br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strncasecmp</span>( szURL, <span class="hljs-string">&quot;http://&quot;</span>, <span class="hljs-number">7</span> ) == <span class="hljs-number">0</span> )<br>    &#123;<br>        szURL += <span class="hljs-number">7</span>;<br>        szURL = <span class="hljs-built_in">strchr</span>( szURL, <span class="hljs-string">&#x27;/&#x27;</span> );<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> ( ! szURL || szURL[ <span class="hljs-number">0</span> ] != <span class="hljs-string">&#x27;/&#x27;</span> )<br>    &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br><br>    <span class="hljs-comment">//URLDecode( szURL );</span><br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;The request URL is: %s\n&quot;</span>, szURL );<br>    <span class="hljs-comment">/*HTTP请求行处理完毕，状态转移到头部字段的分析 就是通过状态字转换功能*/</span><br>    checkstate = CHECK_STATE_HEADER;<br>    <span class="hljs-keyword">return</span> NO_REQUEST;<br>&#125;<br><span class="hljs-comment">/*分析头部字段*/</span><br><span class="hljs-function">HTTP_CODE <span class="hljs-title">parse_headers</span><span class="hljs-params">( <span class="hljs-keyword">char</span>* szTemp )</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-comment">/*遇到一个空行，说明我们得到了一个正确的HTTP请求*/</span><br>    <span class="hljs-keyword">if</span> ( szTemp[ <span class="hljs-number">0</span> ] == <span class="hljs-string">&#x27;\0&#x27;</span> )<br>    &#123;<br>        <span class="hljs-keyword">return</span> GET_REQUEST;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strncasecmp</span>( szTemp, <span class="hljs-string">&quot;Host:&quot;</span>, <span class="hljs-number">5</span> ) == <span class="hljs-number">0</span> )  <span class="hljs-comment">/*处理“HOST”头部字段*/</span><br>    &#123;<br>        szTemp += <span class="hljs-number">5</span>;<br>        szTemp += <span class="hljs-built_in">strspn</span>( szTemp, <span class="hljs-string">&quot; \t&quot;</span> );<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;the request host is: %s\n&quot;</span>, szTemp );<br>    &#125;<br>    <span class="hljs-keyword">else</span>  <span class="hljs-comment">/*其他头部字段都不处理*/</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;I can not handle this header\n&quot;</span> );<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> NO_REQUEST;<br>&#125;<br><span class="hljs-comment">/*分析HTTP请求的入口函数*/</span><br><span class="hljs-function">HTTP_CODE <span class="hljs-title">parse_content</span><span class="hljs-params">( <span class="hljs-keyword">char</span>* buffer, <span class="hljs-keyword">int</span>&amp; checked_index, CHECK_STATE&amp; checkstate, <span class="hljs-keyword">int</span>&amp; read_index, <span class="hljs-keyword">int</span>&amp; start_line )</span></span><br><span class="hljs-function"></span>&#123;<br>    LINE_STATUS linestatus = LINE_OK; <span class="hljs-comment">/*记录当前行的读取状态*/</span><br>    HTTP_CODE retcode = NO_REQUEST;  <span class="hljs-comment">/*记录HTTP请求的处理结果*/</span><br>    <span class="hljs-comment">/*主状态机，用于从buffer中取出所有完整的行*/</span><br>    <span class="hljs-keyword">while</span>( ( linestatus = <span class="hljs-built_in">parse_line</span>( buffer, checked_index, read_index ) ) == LINE_OK ) <br>    &#123;<br>        <span class="hljs-keyword">char</span>* szTemp = buffer + start_line;  <span class="hljs-comment">/*start_line是行在buffer中的起始位置*/</span><br>        start_line = checked_index;  <span class="hljs-comment">/*记录下一行的起始位置*/</span><br>        <span class="hljs-comment">/*checkstate记录主状态机当前的状态*/</span><br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> ( checkstate )<br>        &#123;<br>            <span class="hljs-keyword">case</span> CHECK_STATE_REQUESTLINE: <span class="hljs-comment">/*第一个状态，分析请求行*/</span><br>            &#123;<br>                retcode = <span class="hljs-built_in">parse_requestline</span>( szTemp, checkstate );<br>                <span class="hljs-keyword">if</span> ( retcode == BAD_REQUEST )<br>                &#123;<br>                    <span class="hljs-keyword">return</span> BAD_REQUEST;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> CHECK_STATE_HEADER:   <span class="hljs-comment">/*第二个状态，分析头部字段*/</span><br>            &#123;<br>                retcode = <span class="hljs-built_in">parse_headers</span>( szTemp );<br>                <span class="hljs-keyword">if</span> ( retcode == BAD_REQUEST )<br>                &#123;<br>                    <span class="hljs-keyword">return</span> BAD_REQUEST;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( retcode == GET_REQUEST )<br>                &#123;<br>                    <span class="hljs-keyword">return</span> GET_REQUEST;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">default</span>:<br>            &#123;<br>                <span class="hljs-keyword">return</span> INTERNAL_ERROR;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*若没有读取到一个完整的行，则表示还需要继续读取客户数据才能进一步分析*/</span><br>    <span class="hljs-keyword">if</span>( linestatus == LINE_OPEN )<br>    &#123;<br>        <span class="hljs-keyword">return</span> NO_REQUEST;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 读取需要监听的ip 和 端口</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 创建ipv4 的socket</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-keyword">int</span> listenfd = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( listenfd &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 命名socket</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( listenfd, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 开始监听</span><br>    ret = <span class="hljs-built_in">listen</span>( listenfd, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 创建ipv4 socket套接字 用于获取远端的ip</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_address</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client_address );<br>    <span class="hljs-keyword">int</span> fd = <span class="hljs-built_in">accept</span>( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );<br>    <span class="hljs-keyword">if</span>( fd &lt; <span class="hljs-number">0</span> ) <span class="hljs-comment">// 如果没有接收到</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 接收套接字</span><br>    &#123;<br>        <span class="hljs-keyword">char</span> buffer[ BUFFER_SIZE ]; <span class="hljs-comment">/*读缓冲区*/</span><br>        <span class="hljs-built_in">memset</span>( buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE );<br>        <span class="hljs-keyword">int</span> data_read = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> read_index = <span class="hljs-number">0</span>; <span class="hljs-comment">/*当前已经读取了多少字节的客户数据*/</span><br>        <span class="hljs-keyword">int</span> checked_index = <span class="hljs-number">0</span>; <span class="hljs-comment">/*当前已经分析完了多少字节的客户数据*/</span><br>        <span class="hljs-keyword">int</span> start_line = <span class="hljs-number">0</span>; <span class="hljs-comment">/*行在buffer中的起始位置*/</span><br>        <span class="hljs-comment">/*设置主状态机的初始状态*/</span><br>        CHECK_STATE checkstate = CHECK_STATE_REQUESTLINE;<br>        <span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> ) <span class="hljs-comment">/*循环读取客户数据并分析之*/</span><br>        &#123;<br>            data_read = <span class="hljs-built_in">recv</span>( fd, buffer + read_index, BUFFER_SIZE - read_index, <span class="hljs-number">0</span> ); <span class="hljs-comment">//通过连接socket获取信息</span><br>            <span class="hljs-keyword">if</span> ( data_read == <span class="hljs-number">-1</span> )<br>            &#123;<br>                <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;reading failed\n&quot;</span> );<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( data_read == <span class="hljs-number">0</span> )<br>            &#123;<br>                <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;remote client has closed the connection\n&quot;</span> );<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>    <br>            read_index += data_read;<br>            <span class="hljs-comment">/*分析目前已经获得的所有客户数据*/</span><br>            HTTP_CODE result = <span class="hljs-built_in">parse_content</span>( buffer, checked_index, checkstate, read_index, start_line );<br>            <span class="hljs-comment">// 判断状态</span><br>            <span class="hljs-keyword">if</span>( result == NO_REQUEST )<br>            &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( result == GET_REQUEST )<br>            &#123;<br>                <span class="hljs-built_in">send</span>( fd, szret[<span class="hljs-number">0</span>], <span class="hljs-built_in">strlen</span>( szret[<span class="hljs-number">0</span>] ), <span class="hljs-number">0</span> );<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">send</span>( fd, szret[<span class="hljs-number">1</span>], <span class="hljs-built_in">strlen</span>( szret[<span class="hljs-number">1</span>] ), <span class="hljs-number">0</span> );<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">close</span>( fd );<br>    &#125;<br>    <br>    <span class="hljs-built_in">close</span>( listenfd );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们将代码清单8-3中的两个有限状态机分别称为主状态机和从状态机，这体现了它们之间的关系:主状态机在内部调用从状态机。下面先分析从状态机，即parse_line函数，它从buffer中解析出一个行。图 8-15描述了其可能的状态及状态转移过程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205230716467.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-23 上午7.16.31" /></p>
<p>这个状态机的初始状态是LINE_OK，其原始驱动力来自于buffer中新到达的客户数据。在main函数中，我们循环调用recv函数往buffer中 读入客户数据。每次成功读取数据后，我们就调用parse_content函数来分析新读入的数据。parse_content函数首先要做的就是调用parse_line函数来获取一个行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205230718544.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-23 上午7.18.38" /></p>
<p>a)调用recv后，buffer里的初始内容和部分变量的值</p>
<p>b)parse_line函数处理buffer后的结果</p>
<p>c)再次调用recv后的结果</p>
<p>d)parse_line函数再次处理buffer后的结果</p>
<ul>
<li>
<p>现在假设服务器经过一次recv调用之后，buffer的内容以及部分变量的值如图8-16a所示。</p>
</li>
<li>
<p>parse_line函数处理后的结果如图8-16b所示，它挨个检查图8-16a所示的buffer中checked_index到(read_index-1)之间的字节，判断是否存在行结束符，并更新checked_index的值。当前buffer中不存在行结束符，所以parse_line返回LINE_OPEN。</p>
</li>
<li>
<p>程序继续调用recv以<u>读取更多客户数据</u>，这次读操作后buffer中的内容以及部分变量的值如图 8-16c所示。然后parse_line函数就又开始处理这部分新到来的数据，如图8-16d所示。这次它读取到了一个完整的行， 即“HOST:localhost\r\n”。</p>
</li>
<li>
<p>parse_line函数就可以将这行内容递交给 parse_content函数中的主状态机来处理了。</p>
</li>
</ul>
<p>主状态机使用checkstate变量来记录当前的状态。</p>
<ul>
<li>如果当前的状态是CHECK_STATE_REQUESTLINE，则表示parse_line函数解析出的行 是请求行，于是主状态机调用parse_requestline来分析请求行;</li>
<li>如果当前的状态是CHECK_STATE_HEADER，则表示parse_line函数解析出的是头部字段，于是主状态机调用parse_headers来分析头部字段。 checkstate变量的初始值是CHECK_STATE_REQUESTLINE， parse_requestline函数在成功地分析完请求行之后将其设置为CHECK_STATE_HEADER，从而实现状态转移。</li>
</ul>
<h2 id="87-提高服务器性能的其他建议"><a class="markdownIt-Anchor" href="#87-提高服务器性能的其他建议"></a> 8.7 提高服务器性能的其他建议</h2>
<p>性能对服务器来说是至关重要的，毕竟每个客户都期望其请求能很快地得到响应。影响服务器性能的首要因素就是系统的硬件资源，比如CPU的个数、速度，内存的大小等。不过由于硬件技术的飞速发展，现代服务器都不缺乏硬件资源。因此，我们需要考虑的主要问题是如何从“软环境”来提升服务器的性能。服务器的“软环境”，一方面是指系统的软件资源，比如操作系统允许用户打开的最大文件描述符数量;另一方面指的就是服务器程序本身，即如何从编程的角度来确保服务器的性能，这是本节要讨论的问题。</p>
<p>前面我们介绍了几种高效的事件处理模式和并发模式，以及高效的逻辑处理方式——有限状态机，它们都有助于提高服务器的整体性 能。下面我们进一步分析高性能服务器需要注意的其他几个方面: 池、数据复制、上下文切换和锁。</p>
<h3 id="871-池"><a class="markdownIt-Anchor" href="#871-池"></a> 8.7.1 池</h3>
<p>既然服务器的硬件资源“充裕”，那么提高服务器性能的一个很直接的方法就是以空间换时间，即“浪费”服务器的硬件资源，以换取其运行效率。这就是<strong>池(pool)<strong>的概念。池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为</strong>静态资源分配</strong>。</p>
<ul>
<li>当服务器进入正式运行阶段，即开始处理客户请求的时候，如果它需要相关的资源，就可以直接从池中获取，无须动态分配。很显然，直接从池中取得所需资源比动态分配资源的速度要快得多，因为分配系统资源的<u>系统调用都是很耗时</u>的。</li>
<li>当服务器处理完一个客户连接后，可以把相关的资源放回池中，无须执行系统调用来释放资源。从最终的效果来看，池相当于服务器管理系统资源的应用层设施，它<u>避免了服务器对内核的频繁访问</u>。</li>
</ul>
<p>不过，既然池中的资源是预先静态分配的，我们就无法预期应该分配多少资源。这个问题又该如何解决呢?最简单的解决方案就是分配“足够多”的资源，即针对每个可能的客户连接都分配必要的资源。 这通常会导致资源的浪费，因为任一时刻的客户数量都可能远远没有达到服务器能支持的最大客户数量。好在这种资源的浪费对服务器来说一般不会构成问题。还有一种解决方案是预先分配一定的资源，此后如果发现资源不够用，就再动态分配一些并加入池中。</p>
<p>根据不同的资源类型，池可分为多种，常见的有内存池、进程池、线程池和连接池。它们的含义都很明确。</p>
<h4 id="内存池"><a class="markdownIt-Anchor" href="#内存池"></a> 内存池</h4>
<p>通常用于socket的<u>接收缓存和发送缓存</u>。对于某些长度有限的客户请求，比如HTTP请求，预先分配一个大小足够(比如5000字节)的接收缓存区是很合理的。当客户请求的长度超过接收缓冲区的大小时，我们可以选择丢弃请求或者动态扩大接收缓冲区。</p>
<h4 id="进程池和线程池"><a class="markdownIt-Anchor" href="#进程池和线程池"></a> 进程池和线程池</h4>
<p>都是<strong>并发编程</strong>常用的“伎俩”。当我们需要一个工作进程或工作线程来处理新到来的客户请求时，我们可以直接从进程池或线程池中取得一个执行实体，而无须动态地调用fork或pthread_create等函数来创建进程和线程。</p>
<h4 id="连接池"><a class="markdownIt-Anchor" href="#连接池"></a> 连接池</h4>
<p>通常<u>用于服务器或服务器机群的内部永久连接</u>。图8-4中， 每个逻辑单元可能都需要频繁地访问本地的某个数据库。简单的做法是:逻辑单元每次需要访问数据库的时候，就向数据库程序发起连接，而访问完毕后释放连接。很显然，这种做法的效率太低。一种解决方案是使用连接池。连接池是服务器预先和数据库程序建立的一组连接的集合。当某个逻辑单元需要访问数据库时，它可以直接从连接池中取得一个连接的实体并使用之。待完成数据库的访问之后，逻辑单元再将该连接返还给连接池。</p>
<h3 id="872-数据复制"><a class="markdownIt-Anchor" href="#872-数据复制"></a> 8.7.2 数据复制</h3>
<p>高性能服务器应该<u>避免不必要的数据复制</u>，尤其是当数据复制发生在<u>用户代码和内核之间</u>的时候。如果内核可以直接处理从socket或者文件读入的数据，则应用程序就没必要将这些数据从内核缓冲区复制到应用程序缓冲区中【只是简单，不需要大量逻辑处理的部分可以这么操作】。</p>
<p>这里说的“直接处理”指的是<u>应用程序不关心这些数据</u>的内容，不需要对它们做任何分析。比如ftp服务器，当客户请求一个文件时，服务器只需要检测目标文件是否存在，以及客户是否有读取它的权限，而绝对不会关心文件的具体内容。这样的话，ftp服务器就无须把目标文件的内容完整地读入到应用程序缓冲区中并调用send函数来发送，而是可以使用“零拷贝”【不通过任何缓冲区】函数sendfile来直接将其发送给客户端。</p>
<p>此外，用户代码内部(不访问内核)的数据复制也是应该避免的。举例来说，当两个工作进程之间要传递大量的数据时，我们就应该考虑使用<strong>共享内存</strong>来在它们之间直接共享这些数据，而不是使用管道或者消息队列来传递。【类似于全局变量，总设置缓冲区，会造成资源浪费】又比如代码清单8-3所示的解析HTTP请求的实例中，我们用指针(start_line)来指出每个行在buffer中的起始位置，以便随后对行内容进行访问，而不是把行的内容复制到另外一个缓冲区中来使用，因为这样既浪费空间，又效率低下。</p>
<h3 id="873-上下文切换和锁"><a class="markdownIt-Anchor" href="#873-上下文切换和锁"></a> 8.7.3 上下文切换和锁</h3>
<p>并发程序必须考虑**上下文切换(context switch)**的问题，即<u>进程切换或线程切换导致的的系统开销</u>。即使是I/O密集型的服务器，也不应该使用过多的工作线程(或工作进程，下同)，否则线程间的切换将占用大量的CPU时间，服务器<u>真正用于处理业务逻辑的CPU时间的比重就显得不足</u>了。因此，<u>为每个客户连接都创建一个工作线程的服务器模型是不可取的</u>。图8-11所描述的半同步/半异步模式是一种比较合理的解决方案，它允许一个线程同时处理多个客户连接。此外，多线程服务器的一个优点是不同的线程可以同时运行在不同的CPU上。 当线程的数量不大于CPU的数目时，上下文的切换就不是问题了。</p>
<p>并发程序需要考虑的另外一个问题是<strong>共享资源的加锁保护</strong>。锁通常被认为是<u>导致服务器效率低下</u>的一个因素，因为由它引入的代码不仅不处理任何业务逻辑，而且需要访问内核资源。因此，服务器如果有更好的解决方案，就<u>应该避免使用锁</u>。显然，图8-11所描述的半同步/半异步模式就比图8-10所描述的半同步/半反应堆模式的效率高。</p>
<ul>
<li>前者是将连接请求的就续分配给各个工作线程，单独监听就绪连接请求；</li>
<li>后者是将一个主线程负责监听所有的监听/连接请求，然后将事情通过消息队列分发（竞争）给工作线程。</li>
<li>以上两个为什么带上同步两个字，是因为他们都并不是将读取好的数据一并给工作线程，而是这个整体的任务给工作线程，所以是reactor模式</li>
</ul>
<p>如果服务器必须使用“锁”，则可以考虑减小锁的粒度，比如使用读写 锁。当所有工作线程都只读取一块共享内存的内容时，读写锁并不会增加系统的额外开销。只有当其中某一个工作线程需要写这块内存 时，系统才必须去锁住这块区域。【读不影响，写有影响，可能导致不同步】</p>
<h1 id="第9章-io复用"><a class="markdownIt-Anchor" href="#第9章-io复用"></a> 第9章 I/O复用</h1>
<p>I/O复用使得程序能<strong>同时监听多个文件描述符</strong>，这对提高程序的性能至关重要。通常，网络程序在下列情况下需要使用I/O复用技术:</p>
<ul>
<li>客户端程序要同时处理多个socket。比如本章将要讨论的非阻塞connect技术。</li>
<li>客户端程序要同时处理用户输入和网络连接。比如本章将要讨论的聊天室程序。</li>
<li>TCP服务器要同时处理监听socket和连接socket。这是I/O复用使用最多的场合。后续章节将展示很多这方面的例子。</li>
<li>服务器要同时处理TCP请求和UDP请求。比如本章将要讨论的回射服务器。</li>
<li>服务器要同时监听多个端口，或者处理多种服务。比如本章将要讨论的xinetd服务器。</li>
</ul>
<p>需要指出的是，I/O复用虽然能同时监听多个文件描述符，但它<strong>本身是阻塞</strong>的。并且当多个文件描述符同时就绪时，如果不采取额外的措施，程序就只能按顺序依次处理其中的每一个文件描述符，这使得服务器程序看起来像是串行工作的。如果要实现并发，只能使用多进<br />
程或多线程等编程手段。</p>
<p>Linux下实现I/O复用的系统调用主要有select、poll和epoll，本章将依次讨论之，然后介绍使用它们的几个实例。</p>
<h2 id="91-select系统调用"><a class="markdownIt-Anchor" href="#91-select系统调用"></a> 9.1 select系统调用</h2>
<p>select系统调用的用途是:在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。</p>
<p>本节先介绍select系统调用的API，然后讨论select判断文件描述符就绪的条件，最后给出它在处理带外数据中的实际应用。</p>
<h3 id="911-select-api"><a class="markdownIt-Anchor" href="#911-select-api"></a> 9.1.1 select API</h3>
<p>select系统调用的原型如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nfds,fd_set* readfds,fd_set* writefds,fd_set* exceptfds,struct timeval* timeout)</span></span>;<br></code></pre></td></tr></table></figure>
<ol>
<li>
<p><strong>nfds参数</strong>指定被监听的文件描述符的总数。它通常被设置为select监听的所有文件描述符中的最大值加1，因为文件描述符是从0开始计数的。</p>
</li>
<li>
<p><strong>readfds、writefds和exceptfds参数</strong>分别指向<u>可读、可写和异常等事件</u>对应的文件描述符集合。应用程序调用select函数时，通过这3 个参数传入自己感兴趣的文件描述符。select调用返回时，内核将修改它们来通知应用程序哪些文件描述符已经就绪。这3个参数是fd_set结构指针类型。fd_set结构体的定义如下:</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;typesizes.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __FD_SETSIZE 1024 </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FD_SETSIZE __FD_SETSIZE</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> __fd_mask; <br><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> __NFDBITS </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> __NFDBITS (8*(int)sizeof(__fd_mask)) </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    #ifdef__USE_XOPEN<br>    __fd_mask fds_bits[__FD_SETSIZE/__NFDBITS]; <br>    #<span class="hljs-built_in">define__FDS_BITS</span>(set)((set)-&gt;fds_bits) <br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span> __fd_mask__fds_bits[__FD_SETSIZE/__NFDBITS]; </span><br>    #<span class="hljs-built_in">define__FDS_BITS</span>(set)((set)-&gt;__fds_bits) <br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>&#125;fd_set;<br></code></pre></td></tr></table></figure>
<p>由以上定义可见，fd_set结构体仅包含一个整型数组，该数组的每个元素的<u>每一位(bit)标记一个文件描述符</u>。fd_set能容纳的文件描述符数量由FD_SETSIZE指定，这就限制了select能同时处理的文件描述符的总量。</p>
<p>由于位操作过于烦琐，我们应该使用下面的一系列宏来访问fd_set 结构体中的位:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/select.h&gt;</span> </span><br><span class="hljs-built_in">FD_ZERO</span>(fd_set* fdset);<span class="hljs-comment">/*清除fdset的所有位*/</span><br><span class="hljs-built_in">FD_SET</span>(<span class="hljs-keyword">int</span> fd,fd_set* fdset);<span class="hljs-comment">/*设置fdset的位fd*/</span><br><span class="hljs-built_in">FD_CLR</span>(<span class="hljs-keyword">int</span> fd,fd_set* fdset);<span class="hljs-comment">/*清除fdset的位fd*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FD_ISSET</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd,fd_set* fdset)</span></span>;<span class="hljs-comment">/*测试fdset的位fd是否被设置*/</span><br></code></pre></td></tr></table></figure>
<ol start="3">
<li><strong>timeout参数</strong>用来设置select函数的超时时间。它是一个timeval结构类型的指针，采用指针参数是因为内核将修改它以告诉应用程序 select等待了多久。不过我们<u>不能完全信任select调用返回后的timeout值</u>，比如调用失败时<strong>timeout值是不确定</strong>的。timeval结构体的定义如下:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">long</span> tv_sec;<span class="hljs-comment">/*秒数*/</span> <br>    <span class="hljs-keyword">long</span> tv_usec;<span class="hljs-comment">/*微秒数*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure>
<p>由以上定义可见，select给我们提供了一个微秒级的定时方式。如果给timeout变量的tv_sec成员和tv_usec成员都传递0【不允许超时，有问题直接就走了】，则select将立即返回。如果给timeout传递NULL【类似于无限时间】，则select将一直阻塞，直到某个文件描述符就绪。</p>
<p>select成功时返回就绪(可读、可写和异常)文件描述符的总数。 如果在超时时间内没有任何文件描述符就绪，select将返回0。select失败时返回-1并设置errno。如果在select等待期间，程序接收到信号，则select立即返回-1，并设置errno为EINTR。</p>
<h3 id="912-文件描述符就绪条件"><a class="markdownIt-Anchor" href="#912-文件描述符就绪条件"></a> 9.1.2 文件描述符就绪条件</h3>
<p>哪些情况下文件描述符可以被认为是可读、可写或者出现异常，对于select的使用非常关键。在网络编程中，下列情况下socket可读:</p>
<ul>
<li>socket内核接收缓存区中的字节数大于或等于其低水位标记SO_RCVLOWAT。此时我们可以无阻塞地读该socket，并且读操作返回的字节数大于0。</li>
<li>socket通信的对方关闭连接。此时对该socket的读操作将返回0。</li>
<li>监听socket上有新的连接请求。</li>
<li>socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。</li>
</ul>
<p>下列情况下socket可写:</p>
<ul>
<li>
<p>socket内核发送缓存区中的可用字节数大于或等于其低水位标记 SO_SNDLOWAT。此时我们可以无阻塞地写该socket，并且写操作返回的字节数大于0。</p>
</li>
<li>
<p>socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205231548114.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-23 下午3.48.07" /></p>
</li>
<li>
<p>socket使用非阻塞connect连接成功或者失败(超时)之后。</p>
</li>
<li>
<p>socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。</p>
</li>
</ul>
<p>网络程序中，select能处理的异常情况只有一种:socket上接收到带外数据。下面我们详细讨论之。</p>
<h3 id="913-处理带外数据"><a class="markdownIt-Anchor" href="#913-处理带外数据"></a> 9.1.3 处理带外数据</h3>
<p>上一小节提到，socket上接收到普通数据和带外数据都将使select返回，但socket处于不同的就绪状态:前者处于可读状态，后者处于异常状态。代码清单9-1描述了select是如何同时处理二者的。</p>
<p>代码清单9-1 同时接收普通数据和带外数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>	&#123;<br>		<span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br>  <span class="hljs-comment">//获取命令行的ip port</span><br>	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>	<span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>	<span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;ip is %s and port is %d\n&quot;</span>, ip, port );<br> <br>	<span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 创建IPv4的socket地址</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>  <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>  address.sin_family = AF_INET;<br>  <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>  address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>  <span class="hljs-comment">// 监听socket</span><br>	<span class="hljs-keyword">int</span> listenfd = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>	<span class="hljs-built_in">assert</span>( listenfd &gt;= <span class="hljs-number">0</span> );<br>  <span class="hljs-comment">// 命名socket</span><br>  ret = <span class="hljs-built_in">bind</span>( listenfd, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>	<span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>  <span class="hljs-comment">// 监听socket</span><br>	ret = <span class="hljs-built_in">listen</span>( listenfd, <span class="hljs-number">5</span> );<br>	<span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>  <span class="hljs-comment">// 创建IPv4的socket地址</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_address</span>;</span><br>  <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client_address );<br>  <span class="hljs-comment">// 接收socket</span><br>	<span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );<br>	<span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> ) <span class="hljs-comment">// 没有接收到</span><br>	&#123;<br>		<span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>		<span class="hljs-built_in">close</span>( listenfd );<br>	&#125;<br>  <span class="hljs-comment">// 显示连接的ip和端口</span><br>	<span class="hljs-keyword">char</span> remote_addr[INET_ADDRSTRLEN];<br>	<span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;connected with ip: %s and port: %d\n&quot;</span>, <span class="hljs-built_in">inet_ntop</span>( AF_INET, &amp;client_address.sin_addr, remote_addr, INET_ADDRSTRLEN ), <span class="hljs-built_in">ntohs</span>( client_address.sin_port ) );<br>	<span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>];<br>  <span class="hljs-comment">// 创建可读和异常的fdset</span><br>  fd_set read_fds;<br>  fd_set exception_fds;<br>  <span class="hljs-comment">/*清除fdset的所有位*/</span><br>  <span class="hljs-built_in">FD_ZERO</span>( &amp;read_fds );<br>  <span class="hljs-built_in">FD_ZERO</span>( &amp;exception_fds );<br>  <br>  <span class="hljs-keyword">int</span> nReuseAddr = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 获取或者设置与某个套接字关联的选项。</span><br>	<span class="hljs-built_in">setsockopt</span>( connfd, SOL_SOCKET, SO_OOBINLINE, &amp;nReuseAddr, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( nReuseAddr ) );<br>	<span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> )<br>	&#123;<br>      <span class="hljs-built_in">memset</span>( buf, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( buf ) );<br>    <span class="hljs-comment">/*每次调用select前都要重新在read_fds和exception_fds中设置文件描述符connfd，因为事件发生之后，文件描述符集合将被内核修改*/</span><br>      <span class="hljs-built_in">FD_SET</span>( connfd, &amp;read_fds ); <span class="hljs-comment">/*重新设置一波当前的状态*/</span><br>      <span class="hljs-built_in">FD_SET</span>( connfd, &amp;exception_fds );<br>      <span class="hljs-comment">// 调用selet系统，获取是否有就绪，有的话在看是哪种类型的集合 这个时候是阻塞态</span><br>      ret = <span class="hljs-built_in">select</span>( connfd + <span class="hljs-number">1</span>, &amp;read_fds, <span class="hljs-literal">NULL</span>, &amp;exception_fds, <span class="hljs-literal">NULL</span> );<br>      <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;select one\n&quot;</span> );<br>      <span class="hljs-comment">// 无就绪</span><br>      <span class="hljs-keyword">if</span> ( ret &lt; <span class="hljs-number">0</span> )<br>      &#123;<br>          <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;selection failure\n&quot;</span> );<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-comment">/*测试fdset的位read_fds是否被设置，是否有读事件文件描述符*/</span><br>      <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">FD_ISSET</span>( connfd, &amp;read_fds ) )<br>      &#123;<br>          <span class="hljs-comment">// 如果有就接受数据</span><br>          ret = <span class="hljs-built_in">recv</span>( connfd, buf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( buf )<span class="hljs-number">-1</span>, <span class="hljs-number">0</span> );<br>          <span class="hljs-keyword">if</span>( ret &lt;= <span class="hljs-number">0</span> )<br>          &#123;<br>              <span class="hljs-keyword">break</span>;<br>          &#125;<br>          <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;get %d bytes of normal data: %s\n&quot;</span>, ret, buf );<br>      &#125;<br>      <span class="hljs-comment">/*测试fdset的位exception_fds是否被设置, 检查是否有异常事件文件描述符*/</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( <span class="hljs-built_in">FD_ISSET</span>( connfd, &amp;exception_fds ) )<br>      &#123;<br>          <span class="hljs-comment">// 如果有就接受数据</span><br>          ret = <span class="hljs-built_in">recv</span>( connfd, buf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( buf )<span class="hljs-number">-1</span>, MSG_OOB );<br>          <span class="hljs-keyword">if</span>( ret &lt;= <span class="hljs-number">0</span> )<br>          &#123;<br>              <span class="hljs-keyword">break</span>;<br>          &#125;<br>          <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;get %d bytes of oob data: %s\n&quot;</span>, ret, buf );<br>      &#125;<br><br>	&#125;<br><br>	<span class="hljs-built_in">close</span>( connfd );<br>	<span class="hljs-built_in">close</span>( listenfd );<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="92-poll系统调用"><a class="markdownIt-Anchor" href="#92-poll系统调用"></a> 9.2 poll系统调用</h2>
<p>poll系统调用和select类似，也是在<u>指定时间内轮询一定数量的文件描述符</u>，以测试其中是否有就绪者。但是好像poll不想select需要输入三种不同的文件描述符。直接用一个结构体囊括所有。poll的原型如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">poll</span><span class="hljs-params">(struct pollfd* fds,<span class="hljs-keyword">nfds_t</span> nfds,<span class="hljs-keyword">int</span> timeout)</span></span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>fds参数</strong>是一个pollfd结构类型的数组，它指定<u>所有我们感兴趣的文件描述符上发生的可读、可写和异常等事件</u>。pollfd结构体的定义如下:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> fd;<span class="hljs-comment">/*文件描述符*/</span><br>    <span class="hljs-keyword">short</span> events;<span class="hljs-comment">/*注册的事件*/</span><br>    <span class="hljs-keyword">short</span> revents;<span class="hljs-comment">/*实际发生的事件，由内核填充*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>fd成员指定文件描述符;</li>
<li>events成员告诉poll监听fd上的哪些事件，它是一系列事件的按位或;</li>
<li>revents成员则由内核修改，以通知应用程序fd上实际发生了哪些事件。poll支持的事件类型如表9-1所示。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205231802604.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-23 下午6.02.44" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205231803566.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-23 下午6.03.00" /></p>
<p>表9-1中，POLLRDNORM、POLLRDBAND、POLLWRNORM、POLLWRBAND由XOPEN规范定义。它们实际上是将POLLIN事件和 POLLOUT事件分得更细致，以区别对待普通数据和优先数据。但Linux并不完全支持它们。</p>
<p>通常，应用程序需要根据recv调用的<strong>返回值</strong>来区分socket上接收到的是有效数据还是对方关闭连接的请求，并做相应的处理。不过，自 Linux内核2.6.17开始，GNU为poll系统调用增加了一个POLLRDHUP事件，它在socket上接收到对方关闭连接的请求之后触发。这为我们区分上述两种情况提供了一种更简单的方式。但使用POLLRDHUP事件时，我们需要在代码最开始处定义_GNU_SOURCE。</p>
<ul>
<li><strong>nfds参数</strong>指定被监听事件集合fds的大小。其类型nfds_t的定义如下:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">nfds_t</span>;<br></code></pre></td></tr></table></figure>
<p>3)timeout参数指定poll的超时值，单位是毫秒。当timeout为-1时，poll调用将<strong>永远阻塞</strong>，直到某个事件发生;当timeout为0时，poll调用将立即返回。</p>
<p>poll系统调用的返回值的含义与select相同。</p>
<h2 id="93-epoll系列系统调用"><a class="markdownIt-Anchor" href="#93-epoll系列系统调用"></a> 9.3 epoll系列系统调用</h2>
<h3 id="931-内核事件表"><a class="markdownIt-Anchor" href="#931-内核事件表"></a> 9.3.1 内核事件表</h3>
<p>epoll是Linux特有的I/O复用函数。它在实现和使用上与select、poll有很大差异。</p>
<ul>
<li>首先，epoll使用一组函数来完成任务，而不是单个函数（select和poll都是一个函数轮询）。</li>
<li>其次，epoll把用户关心的文件描述符上的<strong>事件</strong>放在内核里的一个<strong>事件表</strong>中，从而无须像select和poll那样每次调用都要重复传入文件 描述符集或事件集【因为他函数的入口就有一个这个，也就是每次都要设置一下文件描述符/事件的状态】。但epoll需要使用一个<u>额外</u>的文件描述符，来唯一标识内核中的这个事件表。</li>
</ul>
<p>这个文件描述符使用如下epoll_create函数来创建:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span></span><br></code></pre></td></tr></table></figure>
<p><strong>size参数</strong>现在并不起作用，只是给内核一个提示，告诉它事件表需要多大。该函数返回的文件描述符将用作其他所有epoll系统调用的第一个参数，以<strong>指定要访问的内核事件表</strong>。</p>
<p>下面的函数用来操作epoll的内核事件表:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd,<span class="hljs-keyword">int</span> op,<span class="hljs-keyword">int</span> fd,struct epoll_event*event)</span></span><br></code></pre></td></tr></table></figure>
<p><strong>fd参数</strong>是要操作的文件描述符，op参数则指定操作类型。操作类型有如下3种:</p>
<ul>
<li>
<p>EPOLL_CTL_ADD，往事件表中注册fd上的事件。</p>
</li>
<li>
<p>EPOLL_CTL_MOD，修改fd上的注册事件。</p>
</li>
<li>
<p>EPOLL_CTL_DEL，删除fd上的注册事件。</p>
</li>
</ul>
<p><strong>event参数</strong>指定事件，它是epoll_event结构指针类型。epoll_event的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">__uint32_t</span> events;<span class="hljs-comment">/*epoll事件*/</span> <br>    <span class="hljs-keyword">epoll_data_t</span> data;<span class="hljs-comment">/*用户数据*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure>
<p>其中events成员描述事件类型。epoll支持的事件类型和poll基本相同。表示epoll事件类型的宏是在poll对应的宏前加上“E”，比如epoll的 数据可读事件是EPOLLIN。但epoll有两个额外的事件类型—— EPOLLET和EPOLLONESHOT。它们对于epoll的高效运作非常关键， 我们将在后面讨论它们。data成员用于存储用户数据，其类型 epoll_data_t的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">epoll_data</span></span><br><span class="hljs-class">  &#123;</span><br>      <span class="hljs-keyword">void</span>* ptr;<br>      <span class="hljs-keyword">int</span> fd;<br>      <span class="hljs-keyword">uint32_t</span> u32;<br>      <span class="hljs-keyword">uint64_t</span> u64;<br>  &#125;<span class="hljs-keyword">epoll_data_t</span>;<br></code></pre></td></tr></table></figure>
<p>epoll_data_t是一个<strong>联合体</strong>，其4个成员中使用最多的是fd，它指定事件所从属的目标文件描述符。ptr成员<u>可用来指定与fd相关的用户数 据</u>。但由于epoll_data_t是一个联合体，我们不能同时使用其ptr成员和fd成员，因此，如果要将文件描述符和用户数据关联起来(正如8.5.2 小节讨论的将句柄和事件处理器绑定一样)，以实现快速的数据访问，只能使用其他手段，比如放弃使用epoll_data_t的fd成员，而在ptr指向的用户数据中包含fd。</p>
<p>epoll_ctl成功时返回0，失败则返回-1并设置errno。</p>
<h3 id="932-epoll_wait函数"><a class="markdownIt-Anchor" href="#932-epoll_wait函数"></a> 9.3.2 epoll_wait函数</h3>
<p>epoll系列系统调用的主要接口是epoll_wait函数。它<u>在一段超时时间内等待一组文件描述符上的事件</u>，其原型如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd,struct epoll_event* events,<span class="hljs-keyword">int</span> maxevents,<span class="hljs-keyword">int</span> timeout)</span></span>;<br></code></pre></td></tr></table></figure>
<p>该函数成功时返回就绪的文件描述符的个数，失败时返回-1并设置errno。</p>
<p>关于该函数的参数，我们从后往前讨论。timeout参数的含义与poll接口的timeout参数相同。<strong>maxevents参数</strong>指定最多监听多少个事件，它必须大于0。</p>
<p>epoll_wait函数如果检测到事件，就将所有就绪的事件从内核事件表(由epfd参数指定)中复制到它的第二个参数events指向的数组中。 这个数组<strong>只用于输出epoll_wait检测到的就绪</strong>事件【只当检察官】，而不像select和poll的数组参数那样既用于传入用户注册的事件，又用于输出内核检测到的就绪事件。这就极大地提高了应用程序索引就绪文件描述符的效率。代码清单9-2体现了这个差别。</p>
<p>代码清单9-2 poll和epoll在使用上的差别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*如何索引poll返回的就绪文件描述符*/</span><br><span class="hljs-keyword">int</span> ret=<span class="hljs-built_in">poll</span>(fds,MAX_EVENT_NUMBER,<span class="hljs-number">-1</span>); <span class="hljs-comment">/*必须遍历所有已注册文件描述符并找到其中的就绪者(当然，可以利用ret来稍做优</span><br><span class="hljs-comment">化)*/</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;MAX_EVENT_NUMBER;++i)<br>&#123;<br>    <span class="hljs-keyword">if</span>(fds[i].revents&amp;POLLIN)<span class="hljs-comment">/*判断第i个文件描述符是否就绪*/</span><br>    &#123;<br>        <span class="hljs-keyword">int</span> sockfd=fds[i].fd;<br>        <span class="hljs-comment">/*处理sockfd*/</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">/*如何索引epoll返回的就绪文件描述符*/</span><br><span class="hljs-keyword">int</span> ret=<span class="hljs-built_in">epoll_wait</span>(epollfd,events,MAX_EVENT_NUMBER,<span class="hljs-number">-1</span>); <span class="hljs-comment">/*仅遍历就绪的ret个文件描述符*/</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;ret;i++)<br>&#123;<br>    <span class="hljs-keyword">int</span> sockfd=events[i].data.fd;<br>    <span class="hljs-comment">/*sockfd肯定就绪，直接处理*/</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="933-lt和et模式"><a class="markdownIt-Anchor" href="#933-lt和et模式"></a> 9.3.3 LT和ET模式</h3>
<p>epoll对文件描述符的操作有两种模式:LT(Level Trigger，电平触发)模式和ET(Edge Trigger，边沿触发)模式。LT模式是默认的工作模式，这种模式下epoll相当于一个效率较高的poll。当往epoll内核事件表中注册一个文件描述符上的EPOLLET事件时，epoll将以ET模式来操作该文件描述符。ET模式是epoll的<strong>高效工作</strong>模式。</p>
<ul>
<li>对于采用LT工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事 件。这样，当应用程序下一次调用epoll_wait时，epoll_wait还会<strong>再次</strong>向应用程序通告此事件，直到该事件被处理。</li>
<li>而对于采用ET工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序<strong>必须立即处理</strong>该事件，因为后续的epoll_wait调用将<strong>不再向应用程序通知</strong>这一事件。可见，ET模式在很大程度上<u>降低了同一个epoll事件被重复触发</u>的次数，因此效率要比LT模式高。</li>
</ul>
<p>代码清单 9-3体现了LT和ET在工作方式上的差异。</p>
<p>代码清单9-3 LT和ET模式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 10</span><br><span class="hljs-comment">/*将文件描述符设置成非阻塞的*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">( <span class="hljs-keyword">int</span> fd )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> old_option = <span class="hljs-built_in">fcntl</span>( fd, F_GETFL );<br>    <span class="hljs-keyword">int</span> new_option = old_option | O_NONBLOCK;<br>    <span class="hljs-built_in">fcntl</span>( fd, F_SETFL, new_option );<br>    <span class="hljs-keyword">return</span> old_option;<br>&#125;<br><span class="hljs-comment">/*将文件描述符fd上的EPOLLIN注册到epollfd指示的epoll内核事件表中，参数enable_et指定是否对fd启用ET模式*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">( <span class="hljs-keyword">int</span> epollfd, <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">bool</span> enable_et )</span>  <span class="hljs-comment">// 注册</span></span><br><span class="hljs-function"></span>&#123;<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN;<br>    <span class="hljs-keyword">if</span>( enable_et )  <span class="hljs-comment">// 判断是否启动ET模式</span><br>    &#123;<br>        event.events |= EPOLLET;<br>    &#125;<br>    <span class="hljs-built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_ADD, fd, &amp;event );<br>    <span class="hljs-built_in">setnonblocking</span>( fd );<br>&#125;<br><span class="hljs-comment">/*LT模式的工作流程*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lt</span><span class="hljs-params">( epoll_event* events, <span class="hljs-keyword">int</span> number, <span class="hljs-keyword">int</span> epollfd, <span class="hljs-keyword">int</span> listenfd )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[ BUFFER_SIZE ];<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++ )<br>    &#123;    <br>        <span class="hljs-keyword">int</span> sockfd = events[i].data.fd;<br>        <span class="hljs-comment">/*sockfd肯定就绪，直接处理*/</span><br>        <span class="hljs-keyword">if</span> ( sockfd == listenfd )  <span class="hljs-comment">// 说明这里是监听socket来新的活了  </span><br>        &#123;  <br>            <span class="hljs-comment">// 创建IPv4 socket地址</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_address</span>;</span><br>            <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client_address );<br>            <span class="hljs-comment">// 接收socket</span><br>            <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );<br>            <span class="hljs-built_in">addfd</span>( epollfd, connfd, <span class="hljs-literal">false</span> ); <span class="hljs-comment">/*对connfd禁用ET模式 对于接收到的连接注册*/</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( events[i].events &amp; EPOLLIN ) <span class="hljs-comment">// epoll的数据可读事件是EPOLLIN</span><br>        &#123;   <br>            <span class="hljs-comment">/*只要socket读缓存中还有未读出的数据，这段代码就被触发*/</span><br>            <span class="hljs-comment">// 这里说明没有要求一定要读完 或者完成</span><br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;event trigger once\n&quot;</span> );<br>            <span class="hljs-built_in">memset</span>( buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE );<br>            <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">recv</span>( sockfd, buf, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span> );<br>            <span class="hljs-keyword">if</span>( ret &lt;= <span class="hljs-number">0</span> )<br>            &#123;<br>                <span class="hljs-built_in">close</span>( sockfd );<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf );<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;something else happened \n&quot;</span> );<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*ET模式的工作流程*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">et</span><span class="hljs-params">( epoll_event* events, <span class="hljs-keyword">int</span> number, <span class="hljs-keyword">int</span> epollfd, <span class="hljs-keyword">int</span> listenfd )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[ BUFFER_SIZE ];<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++ )<br>    &#123;<br>        <span class="hljs-keyword">int</span> sockfd = events[i].data.fd; <span class="hljs-comment">// 获得就绪的事件</span><br>        <span class="hljs-keyword">if</span> ( sockfd == listenfd )   <span class="hljs-comment">// 获得监听请求说明来活了</span><br>        &#123;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_address</span>;</span><br>            <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client_address );<br>            <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );<br>            <span class="hljs-built_in">addfd</span>( epollfd, connfd, <span class="hljs-literal">true</span> );  <span class="hljs-comment">// 启动et对于新来的socket进行事件上的注册</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( events[i].events &amp; EPOLLIN ) <span class="hljs-comment">// epoll的 数据可读事件是EPOLLIN</span><br>        &#123;<br>            <span class="hljs-comment">/*这段代码不会被重复触发，所以我们循环读取数据，以确保把socket读缓存中的所有数据读出*/</span><br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;event trigger once\n&quot;</span> );<br>            <span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> )  <span class="hljs-comment">// 这里不读完是没有别的操作的</span><br>            &#123;<br>                <span class="hljs-built_in">memset</span>( buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE );<br>                <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">recv</span>( sockfd, buf, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span> );<br>                <span class="hljs-keyword">if</span>( ret &lt; <span class="hljs-number">0</span> )  <br>                &#123;<br>                <span class="hljs-comment">/*对于非阻塞IO，下面的条件成立表示数据已经全部读取完毕。此后，epoll就能再次触发sockfd上的EPOLLIN事件，以驱动下一次读操作*/</span><br>                    <span class="hljs-keyword">if</span>( ( errno == EAGAIN ) || ( errno == EWOULDBLOCK ) )<br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;read later\n&quot;</span> );<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-built_in">close</span>( sockfd );<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( ret == <span class="hljs-number">0</span> )<br>                &#123;<br>                    <span class="hljs-built_in">close</span>( sockfd );<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf );<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;something else happened \n&quot;</span> );<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取ip和port</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 创建IPv4 的socket地址</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 创建socket 负责监听</span><br>    <span class="hljs-keyword">int</span> listenfd = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( listenfd &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 命名socket</span><br>    ret = <span class="hljs-built_in">bind</span>( listenfd, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 开始监听</span><br>    ret = <span class="hljs-built_in">listen</span>( listenfd, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 创建事件数组 用于描述事件</span><br>    epoll_event events[ MAX_EVENT_NUMBER ];<br>    <span class="hljs-comment">// 创建一个大小为5的内核事件表</span><br>    <span class="hljs-keyword">int</span> epollfd = <span class="hljs-built_in">epoll_create</span>( <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( epollfd != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 先注册一波</span><br>    <span class="hljs-built_in">addfd</span>( epollfd, listenfd, <span class="hljs-literal">true</span> );<br><br>    <span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> )<br>    &#123;   <br>        <span class="hljs-comment">// 获取就绪的事件 这里events就附上结果了</span><br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">epoll_wait</span>( epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span> );<br>        <span class="hljs-keyword">if</span> ( ret &lt; <span class="hljs-number">0</span> )<br>        &#123;<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;epoll failure\n&quot;</span> );<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 触发lt / et模式</span><br>        <span class="hljs-built_in">lt</span>( events, ret, epollfd, listenfd );<br>        <span class="hljs-comment">//et( events, ret, epollfd, listenfd );</span><br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( listenfd );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>读者不妨运行一下这段代码，然后telnet到这个服务器程序上并一次传输超过10字节(BUFFER_SIZE的大小)的数据，然后比较LT模式和ET模式的异同。你会发现，正如我们预期的，ET模式下事件被触发的次数要比LT模式下少很多。</p>
<p>注意每个使用ET模式的文件描述符都应该是非阻塞的【也就是一定是立即处理完的，不能留下】。如果文件描述符是阻塞的【可以挂起来不一定处理完】，那么读或写操作将会因为没有后续的事件而<strong>一直处于阻塞状态(饥渴状态)</strong>。</p>
<h3 id="934-epolloneshot事件"><a class="markdownIt-Anchor" href="#934-epolloneshot事件"></a> 9.3.4 EPOLLONESHOT事件</h3>
<p>即使我们使用ET模式，一个socket上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程(或进程，下同)在读取完某个socket上的数据后开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读(EPOLLIN再次被触发)， 此时另外一个线程被唤醒来读取这些新的数据。于是就出现了<strong>两个线程同时操作</strong>一个socket的局面。这当然不是我们期望的。我们期望的是一个<strong>socket连接</strong>在任一时刻都<strong>只被一个线程处理</strong>。这一点可以使用epoll的EPOLLONESHOT事件实现。</p>
<p>对于注册了EPOLLONESHOT事件的文件描述符，操作系统<strong>最多触发</strong>其上注册的<strong>一个</strong>可读、可写或者异常事件，<strong>且只触发一次</strong>，<u>除非我们使用epoll_ctl函数重置</u>该文件描述符上注册的EPOLLONESHOT事件。这样，当一个线程在处理某个socket时，其他线程是不可能有机会操作该socket的。</p>
<p>但反过来思考，注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，该线程就应该立即重置这个socket上的EPOLLONESHOT事件，以确保这个socket下一次可读时，其EPOLLIN事件能被触发，进而让其他工作线程有机会继续处理这个socket。</p>
<p>代码清单9-4展示了EPOLLONESHOT事件的使用。</p>
<p>代码清单9-4 使用EPOLLONESHOT事件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 1024</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fds</span></span><br><span class="hljs-class">&#123;</span><br>   <span class="hljs-keyword">int</span> epollfd;<br>   <span class="hljs-keyword">int</span> sockfd;<br>&#125;;<br><span class="hljs-comment">/*将文件描述符设置成非阻塞的*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">( <span class="hljs-keyword">int</span> fd )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> old_option = <span class="hljs-built_in">fcntl</span>( fd, F_GETFL );<br>    <span class="hljs-keyword">int</span> new_option = old_option | O_NONBLOCK;<br>    <span class="hljs-built_in">fcntl</span>( fd, F_SETFL, new_option );<br>    <span class="hljs-keyword">return</span> old_option;<br>&#125;<br><span class="hljs-comment">/*将fd上的EPOLLIN和EPOLLET事件注册到epollfd指示的epoll内核事件表中，参数oneshot指定是否注册fd上的EPOLLONESHOT事件*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">( <span class="hljs-keyword">int</span> epollfd, <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">bool</span> oneshot )</span></span><br><span class="hljs-function"></span>&#123;<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN | EPOLLET;<br>    <span class="hljs-keyword">if</span>( oneshot )  <span class="hljs-comment">// 如果true就注册oneshot</span><br>    &#123;<br>        event.events |= EPOLLONESHOT;<br>    &#125;<br>    <span class="hljs-built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_ADD, fd, &amp;event );<br>    <span class="hljs-built_in">setnonblocking</span>( fd );<br>&#125;<br><span class="hljs-comment">/*重置fd上的事件。这样操作之后，尽管fd上的EPOLLONESHOT事件被注册，但是操作系统仍然会触发fd上的EPOLLIN事件，且只触发一次*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset_oneshot</span><span class="hljs-params">( <span class="hljs-keyword">int</span> epollfd, <span class="hljs-keyword">int</span> fd )</span></span><br><span class="hljs-function"></span>&#123;<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN | EPOLLET | EPOLLONESHOT; <span class="hljs-comment">// 恢复可以有的状态</span><br>    <span class="hljs-built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_MOD, fd, &amp;event );<br>&#125;<br><span class="hljs-comment">/*工作线程*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">worker</span><span class="hljs-params">( <span class="hljs-keyword">void</span>* arg )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> sockfd = ( (fds*)arg )-&gt;sockfd;<br>    <span class="hljs-keyword">int</span> epollfd = ( (fds*)arg )-&gt;epollfd;<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;start new thread to receive data on fd: %d\n&quot;</span>, sockfd );<br>    <span class="hljs-keyword">char</span> buf[ BUFFER_SIZE ];<br>    <span class="hljs-built_in">memset</span>( buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE );<br>    <span class="hljs-comment">/*循环读取sockfd上的数据，直到遇到EAGAIN错误*/</span><br>    <span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> )<br>    &#123;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">recv</span>( sockfd, buf, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span> );<br>        <span class="hljs-keyword">if</span>( ret == <span class="hljs-number">0</span> )<br>        &#123;<br>            <span class="hljs-built_in">close</span>( sockfd );<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;foreiner closed the connection\n&quot;</span> );<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( ret &lt; <span class="hljs-number">0</span> ) <span class="hljs-comment">// 最后读完读到末尾</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>( errno == EAGAIN )<br>            &#123;<br>                <span class="hljs-built_in">reset_oneshot</span>( epollfd, sockfd ); <span class="hljs-comment">// 重制一下</span><br>                <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;read later\n&quot;</span> );<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;get content: %s\n&quot;</span>, buf );<br>            <span class="hljs-built_in">sleep</span>( <span class="hljs-number">5</span> ); <span class="hljs-comment">/*休眠5s，模拟数据处理过程*/</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;end thread receiving data on fd: %d\n&quot;</span>, sockfd );<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br><br>    <span class="hljs-keyword">int</span> listenfd = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( listenfd &gt;= <span class="hljs-number">0</span> );<br><br>    ret = <span class="hljs-built_in">bind</span>( listenfd, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><br>    ret = <span class="hljs-built_in">listen</span>( listenfd, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 创建注册事件</span><br>    epoll_event events[ MAX_EVENT_NUMBER ];<br>    <span class="hljs-keyword">int</span> epollfd = <span class="hljs-built_in">epoll_create</span>( <span class="hljs-number">5</span> );  <span class="hljs-comment">// 创建大小为5的表哥</span><br>    <span class="hljs-built_in">assert</span>( epollfd != <span class="hljs-number">-1</span> );<br>    <span class="hljs-built_in">addfd</span>( epollfd, listenfd, <span class="hljs-literal">false</span> );  <span class="hljs-comment">// 让listenfd socket注册进去</span><br><br>    <span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> )<br>    &#123;<br>        <span class="hljs-comment">// 获取就绪的事件</span><br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">epoll_wait</span>( epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span> );<br>        <span class="hljs-keyword">if</span> ( ret &lt; <span class="hljs-number">0</span> )<br>        &#123;<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;epoll failure\n&quot;</span> );<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <br>        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; i++ )<br>        &#123;   <br>            <span class="hljs-comment">// 获取就绪事件</span><br>            <span class="hljs-keyword">int</span> sockfd = events[i].data.fd;<br>            <span class="hljs-keyword">if</span> ( sockfd == listenfd )  <span class="hljs-comment">// 如果是监听 获取新的socket并注册</span><br>            &#123;<br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_address</span>;</span><br>                <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client_address );<br>                <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );<br>             		 <span class="hljs-comment">/*对每个非监听文件描述符都注册EPOLLONESHOT事件*/</span>  <br>              	<span class="hljs-built_in">addfd</span>( epollfd, connfd, <span class="hljs-literal">true</span> );<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( events[i].events &amp; EPOLLIN )  <span class="hljs-comment">// 如果是写 那就 创建线程去干</span><br>            &#123;<br>                <span class="hljs-keyword">pthread_t</span> thread;<br>                fds fds_for_new_worker;<br>                fds_for_new_worker.epollfd = epollfd;<br>                fds_for_new_worker.sockfd = sockfd;<br>                <span class="hljs-comment">/*新启动一个工作线程为sockfd服务， 有oneshot不担心两个线程控制一个了*/</span><br>                <span class="hljs-built_in">pthread_create</span>( &amp;thread, <span class="hljs-literal">NULL</span>, worker, ( <span class="hljs-keyword">void</span>* )&amp;fds_for_new_worker );<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;something else happened \n&quot;</span> );<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( listenfd );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从工作线程函数worker来看，如果一个工作线程处理完某个socket上的一次请求(我们用休眠5s来模拟这个过程)之后，又接收到该socket上新的客户请求，则该线程将继续为这个socket服务。并且因为该socket上注册了EPOLLONESHOT事件，其他线程没有机会接触这个socket，如果工作线程等待5s后仍然没收到该socket上的下一批客户数据，则它将放弃为该socket服务。同时，它调用reset_oneshot函数来重置该socket上的注册事件，这将使epoll有机会再次检测到该socket上的EPOLLIN事件，进而使得其他线程有机会为该socket服务。</p>
<p>由此看来，尽管一个socket在不同时间可能被不同的线程处理，但同一时刻肯定只有一个线程在为它服务。这就保证了连接的完整性，从而避免了很多可能的竞态条件。</p>
<h2 id="94-三组io复用函数的比较"><a class="markdownIt-Anchor" href="#94-三组io复用函数的比较"></a> 9.4 三组I/O复用函数的比较</h2>
<p>前面我们讨论了select、poll和epoll三组I/O复用系统调用，这3组系统<strong>调用都能同时监听多个文件描述符</strong>。它们将等待由timeout参数指定 的超时时间，直到一个或者多个文件描述符上有事件发生时返回，返回值是<u>就绪的文件描述符的数量</u>。返回0表示没有事件发生。现在我们从事件集、最大支持文件描述符数、工作模式和具体实现等四个方面进一步比较它们的异同，以明确在实际应用中应该选择使用哪个(或哪些)。</p>
<p>这3组函数都通过某种结构体变量来告诉内核监听哪些文件描述符上的哪些事件，并使用该结构体类型的参数来获取内核处理的结果。</p>
<ul>
<li>
<p>select的参数类型fd_set<u>没有将文件描述符和事件绑定</u>，它仅仅是一个文件描述符集合，因此select需要提供3个这种类型的参数来分别传入和输出可读、可写及异常等事件【因为他只是一个类似于bool类型的数组用来提供可以判断该文件描述符是否有事件发生的文件描述符，需要自主判断】。这一方面使得select<u>不能处理更多类型</u>的事件，另一方面由于内核对fd_set集合的在线修改，应用程序下次调用select前<u>不得不重置这3个fd_set</u>集合，时间复杂度也是O(n)， 不过每一种文件描述符都需要进行逐个判断。</p>
</li>
<li>
<p>poll的参数类型pollfd则多少“聪明”一些。它把文件描述符和事件都定义其中，任何事件都被统一处理，从而使得编程接口简洁得多。并且内核每次修改的是pollfd结构体的revents成员，而events成员保持不变，因此下次调用poll时应用程序无须重置pollfd类型的事件集参数。由于每次select和poll调用都返回整个用户注册的事件集合(其中包括就绪的和未就绪的)，所以应用程序索引就绪文件描述符的时间复杂度为O(n)【因为每个都需要遍历】。</p>
</li>
<li>
<p>epoll则采用与select和poll完全不同的方式来管理用户注册的事件。它在内核中维护一个事件表，并提供了一个独立的系统调用epoll_ctl来控制往其中<u>添加、删除、修改事件</u>。这样，每次epoll_wait调用都直接从该内核事件表中取得用户注册的事件，而无须反复从用户空间读入这些事件【不用用户主动更新】。epoll_wait系统调用的events参数仅用来返回就绪的事件，这使得应用程序索引就绪文件描述符的时间复杂度达到O(1)【因为是就绪数组】。</p>
</li>
</ul>
<p>poll和epoll_wait分别用nfds和maxevents参数指定最多监听多少个文件描述符和事件。这两个数值都能达到系统允许打开的最大文件描述 符数目，即65 535(cat/proc/sys/fs/file-max)。而select允许监听的最大文件描述符数量<u>通常有限制</u>。虽然用户可以修改这个限制，但这可能导致不可预期的后果。</p>
<p>select和poll都只能工作在相对低效的LT模式，而epoll则可以工作在ET高效模式。并且epoll还支持EPOLLONESHOT事件。该事件能进一步减少可读、可写和异常等事件被触发的次数。</p>
<p>从实现原理上来说，select和poll采用的都是<strong>轮询</strong>的方式，即每次调用都要扫描整个注册文件描述符集合，并将其中就绪的文件描述符返 回给用户程序，因此它们检测就绪事件的算法的时间复杂度是 O(n)。epoll_wait则不同，它采用的是<strong>回调</strong>的方式。内核检测到就绪的文件描述符时，将触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪事件队列。内核最后在适当的时机将该就绪事件队列中的内容拷贝到用户空间。因此epoll_wait无须轮询整个文件描述符集合来检测哪些事件已经就绪，其算法时间复杂度是O(1)。但是，当活动连接比较多的时候，epoll_wait的效率未必比select和poll高，因为此时回调函数被触发得过于频繁。所以epoll_wait适用于<strong>连接数量多，但活动连接较少</strong>的情况。</p>
<p>最后，为了便于阅读，我们将这3组I/O复用系统调用的区别总结于表9-2中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205241029029.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-24 上午10.29.41" /></p>
<h2 id="95-io复用的高级应用一非阻塞connect"><a class="markdownIt-Anchor" href="#95-io复用的高级应用一非阻塞connect"></a> 9.5 I/O复用的高级应用一:非阻塞connect</h2>
<p>connect系统调用的man手册中有如下一段内容:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">EINPROGRESS<br>   The socket is nonblocking <span class="hljs-keyword">and</span> the connection cannot be completed<br>immediately.<span class="hljs-function">It is possible to <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span><span class="hljs-keyword">or</span> <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span><span class="hljs-keyword">for</span> completion by</span><br><span class="hljs-function">selecting the socket <span class="hljs-keyword">for</span> writing.After <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>indicates</span><br><span class="hljs-function">writability,use <span class="hljs-title">getsockopt</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>to read the SO_ERROR option at level</span><br><span class="hljs-function">SOL_SOCKET to determine whether <span class="hljs-title">connect</span><span class="hljs-params">()</span>completed</span><br><span class="hljs-function"><span class="hljs-title">successfully</span><span class="hljs-params">(SO_ERROR is zero)</span><span class="hljs-keyword">or</span> <span class="hljs-title">unsuccessfully</span><span class="hljs-params">(SO_ERROR is one of</span></span><br><span class="hljs-params"><span class="hljs-function">the usual error codes listed here,explaining the reason <span class="hljs-keyword">for</span> the</span></span><br><span class="hljs-params"><span class="hljs-function">failure)</span>.</span><br></code></pre></td></tr></table></figure>
<p>这段话描述了connect出错时的一种errno值:EINPROGRESS。这种错误发生在对非阻塞的socket调用connect，而连接又没有立即建立 时。根据man文档的解释，在这种情况下，我们可以调用select、poll等函数来监听这个连接失败的socket上的可写事件。当select、poll等函数返回后，再利用getsockopt来读取错误码并清除该socket上的错误。 如果错误码是0，表示连接成功建立，否则连接失败。</p>
<p>通过上面描述的非阻塞connect方式，我们就能同时发起多个连接并一起等待。下面看看非阻塞connect的一种实现[2]，如代码清单9-5所 示。</p>
<p>代码清单9-5 非阻塞connect</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 1023</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">( <span class="hljs-keyword">int</span> fd )</span> <span class="hljs-comment">// 设置非阻塞</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> old_option = <span class="hljs-built_in">fcntl</span>( fd, F_GETFL );<br>    <span class="hljs-keyword">int</span> new_option = old_option | O_NONBLOCK;<br>    <span class="hljs-built_in">fcntl</span>( fd, F_SETFL, new_option );<br>    <span class="hljs-keyword">return</span> old_option;<br>&#125;<br><span class="hljs-comment">/*超时连接函数，参数分别是服务器IP地址、端口号和超时时间(毫秒)。函数成功时返回已经处于连接状态的socket，失败则返回-1*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">unblock_connect</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip, <span class="hljs-keyword">int</span> port, <span class="hljs-keyword">int</span> time )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br><br>    <span class="hljs-keyword">int</span> sockfd = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-keyword">int</span> fdopt = <span class="hljs-built_in">setnonblocking</span>( sockfd );<br>    ret = <span class="hljs-built_in">connect</span>( sockfd, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-keyword">if</span> ( ret == <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-comment">/*如果连接成功，则恢复sockfd的属性，并立即返回之【接着使用】*/</span><br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;connect with server immediately\n&quot;</span> );<br>        <span class="hljs-built_in">fcntl</span>( sockfd, F_SETFL, fdopt ); <span class="hljs-comment">// 对文件描述符的各种控制操作。</span><br>        <span class="hljs-keyword">return</span> sockfd;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( errno != EINPROGRESS )<br>    &#123;<br>    <span class="hljs-comment">/*如果连接没有立即建立，那么只有当errno是EINPROGRESS时才表示连接还在进行，否则出错返回*/</span><br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;unblock connect not support\n&quot;</span> );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 认为连接还在进行，初始化一下select系统 为了监听该socket</span><br>    fd_set readfds;<br>    fd_set writefds;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">timeout</span>;</span><br><br>    <span class="hljs-built_in">FD_ZERO</span>( &amp;readfds );<br>    <span class="hljs-built_in">FD_SET</span>( sockfd, &amp;writefds );<br><br>    timeout.tv_sec = time;<br>    timeout.tv_usec = <span class="hljs-number">0</span>;<br>    <br>    ret = <span class="hljs-built_in">select</span>( sockfd + <span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>, &amp;writefds, <span class="hljs-literal">NULL</span>, &amp;timeout );<br>    <span class="hljs-keyword">if</span> ( ret &lt;= <span class="hljs-number">0</span> )<br>    &#123;  <br>       <span class="hljs-comment">/*select超时或者出错，立即返回*/</span><br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;connection time out\n&quot;</span> );<br>        <span class="hljs-built_in">close</span>( sockfd );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ( ! <span class="hljs-built_in">FD_ISSET</span>( sockfd, &amp;writefds  ) )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;no events on sockfd found\n&quot;</span> );<br>        <span class="hljs-built_in">close</span>( sockfd );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果检测到就绪写事件发生</span><br>    <span class="hljs-keyword">int</span> error = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">socklen_t</span> length = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( error );<br>    <span class="hljs-comment">/*调用getsockopt来获取并清除sockfd上的错误*/</span><br>    <span class="hljs-keyword">if</span>( <span class="hljs-built_in">getsockopt</span>( sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;length ) &lt; <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;get socket option failed\n&quot;</span> );<br>        <span class="hljs-built_in">close</span>( sockfd );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">/*错误号不为0表示连接出错*/</span><br>    <span class="hljs-keyword">if</span>( error != <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;connection failed after select with the error: %d \n&quot;</span>, error );<br>        <span class="hljs-built_in">close</span>( sockfd );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">/*连接成功*/</span><br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;connection ready after select with the socket: %d \n&quot;</span>, sockfd );<br>    <span class="hljs-built_in">fcntl</span>( sockfd, F_SETFL, fdopt ); <span class="hljs-comment">// 对文件描述符的各种控制操作。</span><br>    <span class="hljs-keyword">return</span> sockfd;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br><br>    <span class="hljs-keyword">int</span> sockfd = <span class="hljs-built_in">unblock_connect</span>( ip, port, <span class="hljs-number">10</span> );<br>    <span class="hljs-keyword">if</span> ( sockfd &lt; <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">shutdown</span>( sockfd, SHUT_WR ); <span class="hljs-comment">// 关闭sockfd的写功能，此选项将不允许sockfd进行写操作，即进程不能在对此套接字发出写操作。</span><br>    <span class="hljs-built_in">sleep</span>( <span class="hljs-number">200</span> );<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;send data out\n&quot;</span> );<br>    <span class="hljs-built_in">send</span>( sockfd, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">//sleep( 600 );</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>但遗憾的是，这种方法存在几处移植性问题。首先，非阻塞的socket可能导致connect始终失败。其次，select对处于EINPROGRESS状态下的socket可能不起作用。最后，对于出错的socket，getsockopt在有些系统(比如Linux)上返回-1(正如代码清单9-5所期望的)，而在有些系统(比如源自伯克利的UNIX)上则返回0。这些问题没有一个统一的解决方法，感兴趣的读者可自行参考相关文献。</p>
<h2 id="96-io复用的高级应用二聊天室程序"><a class="markdownIt-Anchor" href="#96-io复用的高级应用二聊天室程序"></a> 9.6 I/O复用的高级应用二:聊天室程序</h2>
<p>像ssh这样的登录服务通常要同时<strong>处理网络连接</strong>和<strong>用户输入</strong>，这也可以使用I/O复用来实现。本节我们以poll为例实现一个简单的聊天室程序，以阐述如何使用I/O复用技术来同时处理网络连接和用户输入。 该聊天室程序能让所有用户同时在线群聊，它分为客户端和服务器两 个部分。其中客户端程序有两个功能:</p>
<ul>
<li>一是从标准输入终端读入用户数据，并将用户数据发送至服务器;</li>
<li>二是往标准输出终端打印服务器发送给它的数据。</li>
</ul>
<p>服务器的功能是接收客户数据，并把客户数据发送给每一个登录到该服务器上的客户端(数据发送者除外)。下面我们依次给出客户端程序和服务器程序的代码。</p>
<h3 id="961-客户端"><a class="markdownIt-Anchor" href="#961-客户端"></a> 9.6.1 客户端</h3>
<p>客户端程序使用<u>poll同时监听用户输入和网络连接</u>，并利用splice函数将用户输入内容直接定向到网络连接上以发送之，从而实现数据<strong>零拷贝</strong>，提高了程序执行效率。客户端程序如代码清单9-6所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 64</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获得ip和port</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 创建IPv4 socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;server_address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( server_address ) );<br>    server_address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;server_address.sin_addr );<br>    server_address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 创建 socket</span><br>    <span class="hljs-keyword">int</span> sockfd = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sockfd &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 连接socket</span><br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">connect</span>( sockfd, ( struct sockaddr* )&amp;server_address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( server_address ) ) &lt; <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;connection failed\n&quot;</span> );<br>        <span class="hljs-built_in">close</span>( sockfd );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">/*注册文件描述符0(标准输入)和文件描述符sockfd上的可读事件*/</span><br>    pollfd fds[<span class="hljs-number">2</span>];<br>    fds[<span class="hljs-number">0</span>].fd = <span class="hljs-number">0</span>;<br>    fds[<span class="hljs-number">0</span>].events = POLLIN;  <span class="hljs-comment">// 注册数据可读写</span><br>    fds[<span class="hljs-number">0</span>].revents = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化实际发生事件</span><br>    fds[<span class="hljs-number">1</span>].fd = sockfd;<br>    fds[<span class="hljs-number">1</span>].events = POLLIN | POLLRDHUP;  <span class="hljs-comment">// 注册数据可读写</span><br>    fds[<span class="hljs-number">1</span>].revents = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化实际发生事件</span><br>    <span class="hljs-keyword">char</span> read_buf[BUFFER_SIZE];<br>    <span class="hljs-comment">// 创建管道</span><br>    <span class="hljs-keyword">int</span> pipefd[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">pipe</span>( pipefd );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><br>    <span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> )<br>    &#123;<br>        ret = <span class="hljs-built_in">poll</span>( fds, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span> );<br>        <span class="hljs-keyword">if</span>( ret &lt; <span class="hljs-number">0</span> )<br>        &#123;<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;poll failure\n&quot;</span> );<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 判断是不是socket有关闭请求</span><br>        <span class="hljs-keyword">if</span>( fds[<span class="hljs-number">1</span>].revents &amp; POLLRDHUP )<br>        &#123;<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;server close the connection\n&quot;</span> );<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 判断socket是不是有可读的任务到来</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( fds[<span class="hljs-number">1</span>].revents &amp; POLLIN )<br>        &#123;   <br>            <span class="hljs-comment">//清空缓冲区</span><br>            <span class="hljs-built_in">memset</span>( read_buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE );<br>            <span class="hljs-comment">// 接收可读任务</span><br>            <span class="hljs-built_in">recv</span>( fds[<span class="hljs-number">1</span>].fd, read_buf, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span> );<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;%s\n&quot;</span>, read_buf );<br>        &#125;<br>        <span class="hljs-comment">// 如果是标准输入输入任务</span><br>        <span class="hljs-keyword">if</span>( fds[<span class="hljs-number">0</span>].revents &amp; POLLIN )<br>        &#123;   <br>            <span class="hljs-comment">/*使用splice将用户输入的数据直接写到sockfd上(零拷贝)*/</span><br>            <span class="hljs-comment">// 从标准输入 -&gt; pipefd[1] 是管道的写入口</span><br>            ret = <span class="hljs-built_in">splice</span>( <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, pipefd[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );<br>            <span class="hljs-comment">// pipefd[2] 是管道的出口 -&gt; socket</span><br>            ret = <span class="hljs-built_in">splice</span>( pipefd[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>, sockfd, <span class="hljs-literal">NULL</span>, <span class="hljs-number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">close</span>( sockfd );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="962-服务器"><a class="markdownIt-Anchor" href="#962-服务器"></a> 9.6.2 服务器</h3>
<p>服务器程序使用<u>poll同时管理监听socket和连接socket</u>，并且使用牺牲空间换取时间的策略来提高服务器性能，如代码清单9-7所示。</p>
<p>代码清单9-7 聊天室服务器程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;poll.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> USER_LIMIT 5  <span class="hljs-comment">/*最大用户数量*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 64  <span class="hljs-comment">/*读缓冲区的大小*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FD_LIMIT 65535  <span class="hljs-comment">/*文件描述符数量限制*/</span></span><br><span class="hljs-comment">/*客户数据:客户端socket地址、待写到客户端的数据的位置、从客户端读入的数据*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">client_data</span></span><br><span class="hljs-class">&#123;</span><br>    sockaddr_in address;<br>    <span class="hljs-keyword">char</span>* write_buf;<br>    <span class="hljs-keyword">char</span> buf[ BUFFER_SIZE ];<br>&#125;;<br><span class="hljs-comment">// 文件描述符设置非阻塞</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">( <span class="hljs-keyword">int</span> fd )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> old_option = <span class="hljs-built_in">fcntl</span>( fd, F_GETFL );<br>    <span class="hljs-keyword">int</span> new_option = old_option | O_NONBLOCK;<br>    <span class="hljs-built_in">fcntl</span>( fd, F_SETFL, new_option );<br>    <span class="hljs-keyword">return</span> old_option;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 接收 ip ： port</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 创建IPv4 的socket地址</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-keyword">int</span> listenfd = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( listenfd &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 命名socket</span><br>    ret = <span class="hljs-built_in">bind</span>( listenfd, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 监听socket backlog 内核监听队列的最大长度 监听队列的长度如果超过backlog，服务器将不受理新的客户连接</span><br>    ret = <span class="hljs-built_in">listen</span>( listenfd, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">/*创建users数组，分配FD_LIMIT个client_data对象。可以预期:每个可能的socket连接都可以获得一个这样的对象，并且socket的值可以直接用来索引(作为数组的下标)socket连接对应的client_data对象，这是将socket和客户数据关联的简单而高效的方式*/</span><br>    client_data* users = <span class="hljs-keyword">new</span> client_data[FD_LIMIT];<br>    <span class="hljs-comment">// 根据用户最大数量建立poll事件表 +1 是因为 第0个留给监听socket</span><br>    <span class="hljs-comment">/*尽管我们分配了足够多的client_data对象，但为了提高poll的性能，仍然有必要 限制用户的数量*/</span><br>    pollfd fds[USER_LIMIT+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> user_counter = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 给所有用户的poll事件表进行初始化</span><br>    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= USER_LIMIT; ++i )<br>    &#123;<br>        fds[i].fd = <span class="hljs-number">-1</span>;<br>        fds[i].events = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 对于第0位设置监听socket和读写事件注册</span><br>    fds[<span class="hljs-number">0</span>].fd = listenfd;<br>    fds[<span class="hljs-number">0</span>].events = POLLIN | POLLERR;<br>    fds[<span class="hljs-number">0</span>].revents = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> )<br>    &#123;<br>        <span class="hljs-comment">// 调用poll系统</span><br>        ret = <span class="hljs-built_in">poll</span>( fds, user_counter+<span class="hljs-number">1</span>, <span class="hljs-number">-1</span> );<br>        <span class="hljs-keyword">if</span> ( ret &lt; <span class="hljs-number">0</span> )<br>        &#123;<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;poll failure\n&quot;</span> );<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 轮询</span><br>        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; user_counter+<span class="hljs-number">1</span>; ++i )<br>        &#123;<br>            <span class="hljs-comment">// 如果是监听socket 并且 设置可读写 【这里socket可以返回对应的索引，可以用来找是哪个客户】</span><br>            <span class="hljs-keyword">if</span>( ( fds[i].fd == listenfd ) &amp;&amp; ( fds[i].revents &amp; POLLIN ) )<br>            &#123;<br>                <span class="hljs-comment">// 创建IPv4 的socket地址</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_address</span>;</span><br>                <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client_address );<br>                <span class="hljs-comment">// 接收监听socket</span><br>                <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );<br>                <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> ) <span class="hljs-comment">// 没有听到</span><br>                &#123;<br>                    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">/*如果请求太多，则关闭新到的连接*/</span><br>                <span class="hljs-keyword">if</span>( user_counter &gt;= USER_LIMIT ) <br>                &#123;<br>                    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* info = <span class="hljs-string">&quot;too many users\n&quot;</span>;<br>                    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;%s&quot;</span>, info );<br>                    <span class="hljs-built_in">send</span>( connfd, info, <span class="hljs-built_in">strlen</span>( info ), <span class="hljs-number">0</span> );<br>                    <span class="hljs-built_in">close</span>( connfd );<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>              <span class="hljs-comment">/*对于新的连接，同时修改fds和users数组。前文已经提到，users[connfd]对应于新连接文件描述符connfd的客户数据*/</span><br>                user_counter++;  <span class="hljs-comment">// 用户数量增加</span><br>                users[connfd].address = client_address;  <span class="hljs-comment">// 通过socket地址接收到发送方的地址</span><br>                <span class="hljs-built_in">setnonblocking</span>( connfd );  <span class="hljs-comment">// 设置非阻塞connect</span><br>                fds[user_counter].fd = connfd;  <span class="hljs-comment">// 绑定该socket（属于是这个用户专属了）</span><br>                fds[user_counter].events = POLLIN | POLLRDHUP | POLLERR; <span class="hljs-comment">// 设置功能</span><br>                fds[user_counter].revents = <span class="hljs-number">0</span>;  <br>                <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;comes a new user, now have %d users\n&quot;</span>, user_counter );<br>                <span class="hljs-comment">// 新用户注册完毕</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( fds[i].revents &amp; POLLERR )  <span class="hljs-comment">// 检查实际发生事件是否错误</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;get an error from %d\n&quot;</span>, fds[i].fd );<br>                <span class="hljs-keyword">char</span> errors[ <span class="hljs-number">100</span> ];<br>                <span class="hljs-built_in">memset</span>( errors, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-number">100</span> );<br>                <span class="hljs-keyword">socklen_t</span> length = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( errors );<br>                <span class="hljs-keyword">if</span>( <span class="hljs-built_in">getsockopt</span>( fds[i].fd, SOL_SOCKET, SO_ERROR, &amp;errors, &amp;length ) &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">// 给对应socket改错</span><br>                &#123;<br>                    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;get socket option failed\n&quot;</span> );<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// TCP连接被对方关闭，或者对方关闭了写操作。她由GNU引入</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( fds[i].revents &amp; POLLRDHUP )<br>            &#123;<br>                <span class="hljs-comment">/*如果客户端关闭连接，则服务器也关闭对应的连接，并将用户总数减1*/</span><br>                users[fds[i].fd] = users[fds[user_counter].fd];  <span class="hljs-comment">// 将注册的socket进行覆盖掉 更新users</span><br>                <span class="hljs-built_in">close</span>( fds[i].fd );  <span class="hljs-comment">// 关闭要推出的那个事件</span><br>                fds[i] = fds[user_counter];  <span class="hljs-comment">// 用最后一个覆盖第i个</span><br>                i--; <span class="hljs-comment">//处理下一个有效用户</span><br>                user_counter--;  <span class="hljs-comment">// 人数减1</span><br>                <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;a client left\n&quot;</span> );<br>            &#125;<br>            <span class="hljs-comment">// 来了读任务</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( fds[i].revents &amp; POLLIN )<br>            &#123;<br>                <span class="hljs-keyword">int</span> connfd = fds[i].fd;  <span class="hljs-comment">// 将用connfd将注册的套接字接管过来</span><br>                <span class="hljs-built_in">memset</span>( users[connfd].buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE );<br>                ret = <span class="hljs-built_in">recv</span>( connfd, users[connfd].buf, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span> );  <span class="hljs-comment">// 接收数据到connfd</span><br>                <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;get %d bytes of client data %s from %d\n&quot;</span>, ret, users[connfd].buf, connfd );<br>                <span class="hljs-keyword">if</span>( ret &lt; <span class="hljs-number">0</span> )  <br>                &#123;<br>                    <span class="hljs-comment">/*如果读操作出错，则关闭连接*/</span><br>                    <span class="hljs-keyword">if</span>( errno != EAGAIN )<br>                    &#123;<br>                        <span class="hljs-built_in">close</span>( connfd );<br>                        users[fds[i].fd] = users[fds[user_counter].fd];<br>                        fds[i] = fds[user_counter];<br>                        i--;<br>                        user_counter--;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( ret == <span class="hljs-number">0</span> )<br>                &#123;<br>                    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;code should not come to here\n&quot;</span> );<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;   <br>                    <span class="hljs-comment">/*如果接收到客户数据，则通知其他socket连接准备写数据*/</span><br>                    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= user_counter; ++j )<br>                    &#123;<br>                        <span class="hljs-keyword">if</span>( fds[j].fd == connfd ) <span class="hljs-comment">// 跳过自己</span><br>                        &#123;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <br>                        fds[j].events |= ~POLLIN;  <span class="hljs-comment">// 关闭读</span><br>                        fds[j].events |= POLLOUT;  <span class="hljs-comment">// 开始写</span><br>                        users[fds[j].fd].write_buf = users[connfd].buf;  <span class="hljs-comment">// 将connfd中的内容交给别的用户的数据缓存中等待写</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">/*写完数据后需要重新注册fds[i]上的可读事件*/</span> <span class="hljs-comment">//因为上一步大家都变成了写状态</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( fds[i].revents &amp; POLLOUT )<br>            &#123;<br>                <span class="hljs-keyword">int</span> connfd = fds[i].fd;  <span class="hljs-comment">// 获取套接字</span><br>                <span class="hljs-keyword">if</span>( ! users[connfd].write_buf ) <span class="hljs-comment">// 这个说明的就是发送数据的那个</span><br>                &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 发送给每个机器【开写！！！】</span><br>                ret = <span class="hljs-built_in">send</span>( connfd, users[connfd].write_buf, <span class="hljs-built_in">strlen</span>( users[connfd].write_buf ), <span class="hljs-number">0</span> );<br>                users[connfd].write_buf = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//清空缓冲区</span><br>                fds[i].events |= ~POLLOUT; <span class="hljs-comment">//关闭写</span><br>                fds[i].events |= POLLIN; <span class="hljs-comment">// 开始读取</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">delete</span> [] users;<br>    <span class="hljs-built_in">close</span>( listenfd );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="97-io复用的高级应用三同时处理tcp和udp服务"><a class="markdownIt-Anchor" href="#97-io复用的高级应用三同时处理tcp和udp服务"></a> 9.7 I/O复用的高级应用三:同时处理TCP和UDP服务</h2>
<p>至此，我们讨论过的服务器程序都只监听一个端口。在实际应用中，有不少服务器程序能同时监听多个端口，比如超级服务inetd和 android的调试服务adbd。</p>
<p>从bind系统调用的参数来看，一个socket只能与一个socket地址绑定，即一个socket只能用来监听一个端口。因此，服务器如果要同时监听多个端口，就必须创建多个socket，并将它们分别绑定到各个端口上。这样一来，服务器程序就需要同时管理多个监听socket，I/O复 用技术就有了用武之地。另外，即使是同一个端口，如果服务器要同时处理该端口上的TCP和UDP请求，则也需要创建两个不同socket: 一个是<strong>流socket</strong>，另一个是<strong>数据报socket</strong>，并将它们都绑定到该端口上。比如代码清单9-8所示的回射服务器就能同时处理一个端口上的 TCP和UDP请求。</p>
<p>代码清单9-8 同时处理TCP请求和UDP请求的回射服务器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TCP_BUFFER_SIZE 512</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UDP_BUFFER_SIZE 1024</span><br><span class="hljs-comment">// 设置非阻塞</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">( <span class="hljs-keyword">int</span> fd )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> old_option = <span class="hljs-built_in">fcntl</span>( fd, F_GETFL );<br>    <span class="hljs-keyword">int</span> new_option = old_option | O_NONBLOCK;<br>    <span class="hljs-built_in">fcntl</span>( fd, F_SETFL, new_option );<br>    <span class="hljs-keyword">return</span> old_option;<br>&#125;<br><span class="hljs-comment">/*将文件描述符fd上的EPOLLIN注册到epollfd指示的epoll内核事件表中*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">( <span class="hljs-keyword">int</span> epollfd, <span class="hljs-keyword">int</span> fd )</span></span><br><span class="hljs-function"></span>&#123;<br>    epoll_event event;<br>    event.data.fd = fd;<br>    <span class="hljs-comment">//event.events = EPOLLIN | EPOLLET;</span><br>    event.events = EPOLLIN;<br>    <span class="hljs-built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_ADD, fd, &amp;event );<br>    <span class="hljs-built_in">setnonblocking</span>( fd );<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取ip和端口</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 创建IPv4的socket地址</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 创建TCP流socket</span><br>    <span class="hljs-keyword">int</span> listenfd = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( listenfd &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 命名socket</span><br>    ret = <span class="hljs-built_in">bind</span>( listenfd, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 设置为5个队列大小的监听队列</span><br>    ret = <span class="hljs-built_in">listen</span>( listenfd, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 在初始化刚才将IPv4 socket地址</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 建立UDP数据包socket</span><br>    <span class="hljs-keyword">int</span> udpfd = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_DGRAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( udpfd &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 将socket命名</span><br>    ret = <span class="hljs-built_in">bind</span>( udpfd, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 创建epoll的事件结构体数组</span><br>    epoll_event events[ MAX_EVENT_NUMBER ];<br>    <span class="hljs-keyword">int</span> epollfd = <span class="hljs-built_in">epoll_create</span>( <span class="hljs-number">5</span> );  <span class="hljs-comment">// 创建大小为5的epoll内核事件表</span><br>    <span class="hljs-built_in">assert</span>( epollfd != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">/*注册TCP socket和UDP socket上的可读事件*/</span><br>    <span class="hljs-built_in">addfd</span>( epollfd, listenfd );<br>    <span class="hljs-built_in">addfd</span>( epollfd, udpfd );<br><br>    <span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> )<br>    &#123;<br>        <span class="hljs-comment">// 获得超时时间内就绪的事件</span><br>        <span class="hljs-keyword">int</span> number = <span class="hljs-built_in">epoll_wait</span>( epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span> );<br>        <span class="hljs-keyword">if</span> ( number &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">// 无</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;epoll failure\n&quot;</span> );<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 遍历处理就绪的事件</span><br>        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++ )<br>        &#123;   <br>            <span class="hljs-comment">// 创建socket承接对象</span><br>            <span class="hljs-keyword">int</span> sockfd = events[i].data.fd;<br>            <span class="hljs-comment">// 如果是TCP监听事件</span><br>            <span class="hljs-keyword">if</span> ( sockfd == listenfd )<br>            &#123;<br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_address</span>;</span><br>                <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client_address );<br>                <span class="hljs-comment">// 接收连接</span><br>                <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );<br>                <span class="hljs-comment">// 将建立的连接再次注册</span><br>                <span class="hljs-built_in">addfd</span>( epollfd, connfd );<br>            &#125;<br>            <span class="hljs-comment">// 如果是UDP监听事件 （UDP无连接）</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( sockfd == udpfd )<br>            &#123;<br>                <span class="hljs-keyword">char</span> buf[ UDP_BUFFER_SIZE ];<br>                <span class="hljs-built_in">memset</span>( buf, <span class="hljs-string">&#x27;\0&#x27;</span>, UDP_BUFFER_SIZE );<br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_address</span>;</span><br>                <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client_address );<br>                <span class="hljs-comment">// 没有连接建立 所以直接读取结果到buff中</span><br>                ret = <span class="hljs-built_in">recvfrom</span>( udpfd, buf, UDP_BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );<br>                <span class="hljs-keyword">if</span>( ret &gt; <span class="hljs-number">0</span> )  <span class="hljs-comment">// 如果接收到了直接原路发回去</span><br>                &#123;<br>                    <span class="hljs-built_in">sendto</span>( udpfd, buf, UDP_BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, ( struct sockaddr* )&amp;client_address, client_addrlength );<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果是TCP建立的连接注册的可读事件</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( events[i].events &amp; EPOLLIN )<br>            &#123;<br>                <span class="hljs-keyword">char</span> buf[ TCP_BUFFER_SIZE ];<br>                <span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> )<br>                &#123;<br>                    <span class="hljs-built_in">memset</span>( buf, <span class="hljs-string">&#x27;\0&#x27;</span>, TCP_BUFFER_SIZE );<br>                    <span class="hljs-comment">//开读</span><br>                    ret = <span class="hljs-built_in">recv</span>( sockfd, buf, TCP_BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span> );<br>                    <span class="hljs-keyword">if</span>( ret &lt; <span class="hljs-number">0</span> )<br>                    &#123;<br>                        <span class="hljs-keyword">if</span>( ( errno == EAGAIN ) || ( errno == EWOULDBLOCK ) )<br>                        &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        <span class="hljs-built_in">close</span>( sockfd );<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( ret == <span class="hljs-number">0</span> )<br>                    &#123;<br>                        <span class="hljs-built_in">close</span>( sockfd );<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;   <span class="hljs-comment">//将结果发回去</span><br>                        <span class="hljs-built_in">send</span>( sockfd, buf, ret, <span class="hljs-number">0</span> );<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;something else happened \n&quot;</span> );<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( listenfd );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="98-超级服务xinetd"><a class="markdownIt-Anchor" href="#98-超级服务xinetd"></a> 9.8 超级服务xinetd</h2>
<p>Linux因特网服务inetd是超级服务。它同时管理着多个子服务，即监听多个端口。现在Linux系统上使用的inetd服务程序通常是其升级版 本xinetd。xinetd程序的原理与inetd相同，但增加了一些控制选项，并提高了安全性。下面我们从配置文件和工作流程两个方面对xinetd进行介绍。</p>
<h3 id="981-xinetd配置文件"><a class="markdownIt-Anchor" href="#981-xinetd配置文件"></a> 9.8.1 xinetd配置文件</h3>
<p>xinetd采用/etc/xinetd.conf主配置文件和/etc/xinetd.d目录下的子配置文件来管理所有服务。主配置文件包含的是通用选项，这些选项将被所有子配置文件继承。不过子配置文件可以覆盖这些选项。每一个子配置文件用于设置一个子服务的参数。比如，telnet子服务的配置文件/etc/xinetd.d/telnet的典型内容如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1</span> <span class="hljs-meta">#default:on</span><br> <span class="hljs-number">2</span> <span class="hljs-meta">#description:The telnet server serves telnet sessions;it uses\</span><br><span class="hljs-meta"> 3 #unencrypted username/password pairs for authentication.</span><br> <span class="hljs-number">4</span> service telnet<br> <span class="hljs-number">5</span> &#123;<br> <span class="hljs-number">6</span> 		 flags=REUSE<br> <span class="hljs-number">7</span> 		 socket_type=stream<br> <span class="hljs-number">8</span> 		 wait=no<br> <span class="hljs-number">9</span> 		 user=root<br> <span class="hljs-number">10</span> 	 server=/usr/sbin/in.telnetd<br> <span class="hljs-number">11</span> 	 log_on_failure+=USERID<br> <span class="hljs-number">12</span> 	 disable=no<br> <span class="hljs-number">13</span> &#125;<br></code></pre></td></tr></table></figure>
<p>/etc/xinetd. d/telnet文件中的每一项的含义如表9-3所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205241738695.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-24 下午5.38.30" /></p>
<p>xinetd配置文件的内容相当丰富，远不止上面这些。读者可参考其 man文档来获得更多信息。</p>
<h3 id="982-xinetd工作流程"><a class="markdownIt-Anchor" href="#982-xinetd工作流程"></a> 9.8.2 xinetd工作流程</h3>
<p>xinetd管理的子服务中有的是标准服务，比如时间日期服务daytime、回射服务echo和丢弃服务discard。xinetd服务器在内部直接处理这些服务。还有的子服务则需要调用外部的服务器程序来处理。xinetd通过调用fork和exec函数来加载运行这些服务器程序。比如telnet、ftp服务都是这种类型的子服务。我们仍以telnet服务为例来探讨xinetd的工作流程。</p>
<p>首先，查看xinetd守护进程的PID(下面的操作都在测试机器Kongming20上执行):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// cat 只查看文件内容</span><br>$cat /var/run/xinetd.pid<br><span class="hljs-number">9543</span><br></code></pre></td></tr></table></figure>
<p>然后开启两个终端并分别使用如下命令telnet到本机:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">$telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><br></code></pre></td></tr></table></figure>
<p>接下来使用ps命令查看与进程9543相关的进程:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">$ ps-eo pid,ppid,pgid,sid,comm|grep <span class="hljs-number">9543</span><br>PID PPID PGID SESS COMMAND<br><span class="hljs-number">9543</span> <span class="hljs-number">1</span> <span class="hljs-number">9543</span> <span class="hljs-number">9543</span> xinetd<br><span class="hljs-number">9810</span> <span class="hljs-number">9543</span> <span class="hljs-number">9810</span> <span class="hljs-number">9810</span> in.telnetd<br><span class="hljs-number">10355</span> <span class="hljs-number">9543</span> <span class="hljs-number">10355</span> <span class="hljs-number">10355</span> in.telnetd<br></code></pre></td></tr></table></figure>
<p>由此可见，我们每次使用telnet登录到xinetd服务，它都创建一个子进程来为该telnet客户服务。子进程运行in.telnetd程序，这是在/etc/xinetd.d/telnet配置文件中定义的。每个子进程都处于自己独立的进程组和会话中。我们可以使用lsof命令(见第17章)进一步查看子进程都打开了哪些文件描述符:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// lsof 列出当前系统打开文件</span><br>$sudo lsof -p <span class="hljs-number">9810</span>#以子进程<span class="hljs-number">9810</span>为例<br>in.telnet <span class="hljs-number">9810</span> root <span class="hljs-number">0u</span> IPv4 <span class="hljs-number">48189</span> <span class="hljs-number">0</span>t0 TCP Kongming20:telnet-&gt; Kongming20:<span class="hljs-number">38763</span>(ESTABLISHED)<br>in.telnet <span class="hljs-number">9810</span> root <span class="hljs-number">1u</span> IPv4 <span class="hljs-number">48189</span> <span class="hljs-number">0</span>t0 TCP Kongming20:telnet-&gt; Kongming20:<span class="hljs-number">38763</span>(ESTABLISHED)<br>in.telnet <span class="hljs-number">9810</span> root <span class="hljs-number">2u</span> IPv4 <span class="hljs-number">48189</span> <span class="hljs-number">0</span>t0 TCP Kongming20:telnet-&gt; Kongming20:<span class="hljs-number">38763</span>(ESTABLISHED)<br></code></pre></td></tr></table></figure>
<p>这里省略了一些无关的输出。通过lsof的输出我们知道，子进程9810关闭了其标准输入、标准输出和标准错误，而将socket文件描述符 dup到它们上面。因此，telnet服务器程序将网络连接上的输入当作标准输入，并把标准输出定向到同一个网络连接上。</p>
<p>再进一步，对xinetd进程使用lsof命令:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo lsof -p <span class="hljs-number">9543</span><br>xinetd <span class="hljs-number">9543</span> root <span class="hljs-number">5u</span> IPv6 <span class="hljs-number">47265</span> <span class="hljs-number">0</span>t0 TCP*:<span class="hljs-built_in">telnet</span>(LISTEN)<br></code></pre></td></tr></table></figure>
<p>这一条输出说明xinetd将一直监听telnet连接请求，因此in.telnetd子进程只处理连接socket，而不处理监听socket。这是子配置文件中的wait 参数所定义的行为。</p>
<p>对于内部标准服务，xinetd的处理流程也可以用上述方法来分析，这里不再赘述。</p>
<p>综合上面讨论的，我们将xinetd的工作流程(wait选项的值是no的情况)绘制为图9-1所示的形式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205241812903.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-24 下午6.12.22" /></p>
<h1 id="第10章-信号"><a class="markdownIt-Anchor" href="#第10章-信号"></a> 第10章 信号</h1>
<p>信号是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常。Linux信号可由如下条件产生:</p>
<ul>
<li>
<p>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C通常会给进程发送一个中断信号。</p>
</li>
<li>
<p>系统异常。比如浮点异常和非法内存段访问。</p>
</li>
<li>
<p>系统状态变化。比如alarm定时器到期将引起SIGALRM信号。</p>
</li>
<li>
<p>运行kill命令或调用kill函数。</p>
</li>
</ul>
<p>服务器程序必须处理(或至少忽略)一些常见的信号，以免异常终止。</p>
<p>本章先讨论如何在程序中发送信号和处理信号，然后讨论Linux支持的信号种类，并详细探讨其中和网络编程密切相关的几个。</p>
<h2 id="101-linux信号概述"><a class="markdownIt-Anchor" href="#101-linux信号概述"></a> 10.1 Linux信号概述</h2>
<h3 id="1011-发送信号"><a class="markdownIt-Anchor" href="#1011-发送信号"></a> 10.1.1 发送信号</h3>
<p>Linux下，一个进程给其他进程发送信号的API是kill函数。其定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kill</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid,<span class="hljs-keyword">int</span> sig)</span></span>;<br></code></pre></td></tr></table></figure>
<p>该函数把信号sig发送给目标进程;目标进程由pid参数指定，其可能的取值及含义如表10-1所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205252115522.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-25 下午9.15.22" /></p>
<p>Linux定义的信号值都大于0，如果sig取值为0，则kill函数不发送任何信号。但将sig设置为0可以用来检测目标进程或进程组是否存在， 因为检查工作总是在信号发送之前就执行。</p>
<p>不过这种检测方式是不可靠的。一方面由于进程PID的回绕，可能导致被检测的PID不是我们期 望的进程的PID;另一方面，这种检测方法不是原子操作。</p>
<p>该函数成功时返回0，失败则返回-1并设置errno。几种可能的errno 如表10-2所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205252154043.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-25 下午9.54.56" /></p>
<h3 id="1012-信号处理方式"><a class="markdownIt-Anchor" href="#1012-信号处理方式"></a> 10.1.2 信号处理方式</h3>
<p>目标进程在收到信号时，需要定义一个接收函数来处理之。信号处理函数的原型如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*<span class="hljs-keyword">__sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br></code></pre></td></tr></table></figure>
<p>信号处理函数只带有一个整型参数，该参数用来指示信号类型。信号处理函数应该是可重入的，否则很容易引发一些竞态条件。所以<br />
在信号处理函数中严禁调用一些不安全的函数。</p>
<p>除了用户自定义信号处理函数外，bits/signum.h头文件中还定义了信号的两种其他处理方式——SIG_IGN和SIG_DEL:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/signum.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIG_DFL((__sighandler_t)0) </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SIG_IGN((__sighandler_t)1)</span><br></code></pre></td></tr></table></figure>
<p>SIG_IGN表示<u>忽略目标信号</u>，SIG_DFL表示使用信号的<u>默认处理方式</u>。</p>
<p>信号的默认处理方式有如下几种:</p>
<ul>
<li>结束进程(Term)</li>
<li>忽略信号(Ign)</li>
<li>结束进程并生成核心转储文件(Core)</li>
<li>暂停进程 (Stop)</li>
<li>以及继续进程(Cont)。</li>
</ul>
<h3 id="1013-linux信号"><a class="markdownIt-Anchor" href="#1013-linux信号"></a> 10.1.3 Linux信号</h3>
<p>Linux的可用信号都定义在bits/signum.h头文件中，其中包括标准信号和POSIX实时信号。本书仅讨论标准信号，如表10-3所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205271456734.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-27 下午2.56.02" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205271456772.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-27 下午2.56.46" /></p>
<p>我们并不需要在代码中处理所有这些信号。本章后面将重点介绍与网络编程关系紧密的几个信号:SIGHUP、SIGPIPE和SIGURG。后续章节还将介绍SIGALRM、SIGCHLD等信号的使用。</p>
<h3 id="1014-中断系统调用"><a class="markdownIt-Anchor" href="#1014-中断系统调用"></a> 10.1.4 中断系统调用</h3>
<p>如果程序在执行处于<strong>阻塞状态</strong>的系统调用时接收到信号，并且我们为该信号设置了信号处理函数，则默认情况下系统调用将被中断， 并且errno被设置为EINTR。我们可以使用sigaction函数(见后文)为信号设置SA_RESTART标志以自动重启被该信号中断的系统调用。</p>
<p>对于默认行为是暂停进程的信号(比如SIGSTOP、SIGTTIN)，如果我们没有为它们设置信号处理函数，则它们也可以中断某些系统调用(比如connect、epoll_wait)。POSIX没有规定这种行为，这是 Linux独有的。</p>
<h2 id="102-信号函数"><a class="markdownIt-Anchor" href="#102-信号函数"></a> 10.2 信号函数</h2>
<h3 id="1021-signal系统调用"><a class="markdownIt-Anchor" href="#1021-signal系统调用"></a> 10.2.1 signal系统调用</h3>
<p>要为一个信号设置处理函数，可以使用下面的signal系统调用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">_sighandler_t</span> <span class="hljs-title">signal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig,<span class="hljs-keyword">_sighandler_t</span> _handler)</span></span><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>sig参数</strong>指出要捕获的信号类型</li>
<li><strong>handler参数</strong>是sighandler_t类型的函数指针，用于指定信号sig的处理函数。</li>
</ul>
<p>signal函数成功时返回一个函数指针，该函数指针的类型也是 _sighandler_t。这个返回值是<u>前一次调用signal函数</u>时传入的函数指针， 或者是信号<strong>sig对应的默认处理函数指针SIG_DEF</strong>(如果是第一次调用 signal的话)。</p>
<p>signal系统调用出错时返回SIG_ERR，并设置errno。</p>
<h3 id="1022-sigaction系统调用"><a class="markdownIt-Anchor" href="#1022-sigaction系统调用"></a> 10.2.2 sigaction系统调用</h3>
<p>设置信号处理函数的更健壮的接口是如下的系统调用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigaction</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig,<span class="hljs-keyword">const</span> struct sigaction* act,struct sigaction* oact)</span></span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>sig参数指出要捕获的信号类型</li>
<li>act参数指定新的信号处理方式</li>
<li>oact参数则输出信号先前的处理方式(如果不为NULL的话)。</li>
</ul>
<p>act和oact都是sigaction结构体类型的指针，sigaction结构体描述了信号处理的细节，其定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span></span><br><span class="hljs-class">&#123;</span><br>    #ifdef__USE_POSIX199309<br>    <span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">    &#123;</span><br>        <span class="hljs-keyword">_sighandler_t</span> sa_handler;<br>        <span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(*sa_sigaction)(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">siginfo_t</span>*,<span class="hljs-keyword">void</span>*);<br>    &#125;<br>    _sigaction_handler;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sa_handler__sigaction_handler.sa_handler</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> sa_sigaction__sigaction_handler.sa_sigaction</span><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-keyword">_sighandler_t</span> sa_handler;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-keyword">_sigset_t</span> sa_mask;<br>    <span class="hljs-keyword">int</span> sa_flags;<br>    <span class="hljs-built_in"><span class="hljs-keyword">void</span></span>(*sa_restorer)(<span class="hljs-keyword">void</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>
<p>该结构体中的sa_hander成员指定信号处理函数。</p>
</li>
<li>
<p>sa_mask成员设置进程的信号掩码(确切地说是在进程原有信号掩码的基础上增加信号掩码)，以指定哪些信号不能发送给本进程。sa_mask是信号集sigset_t(_sigset_t的同义词)类型，该类型指定一组信号。关于信号集，我们将在后面介绍。</p>
</li>
<li>
<p>sa_flags成员用于设置程序收到信号时的行为，其可选值如表10-4所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205271530985.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-27 下午3.30.45" /></p>
</li>
</ul>
<p>sa_restorer成员已经过时，最好不要使用。sigaction成功时返回0，失败则返回-1并设置errno。</p>
<h2 id="103-信号集"><a class="markdownIt-Anchor" href="#103-信号集"></a> 10.3 信号集</h2>
<h3 id="1031-信号集函数"><a class="markdownIt-Anchor" href="#1031-信号集函数"></a> 10.3.1 信号集函数</h3>
<p>前文提到，Linux使用数据结构sigset_t来表示一组信号。其定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/sigset.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _SIGSET_NWORDS (1024/(8*sizeof(unsigned long int))) </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> int__val[_SIGSET_NWORDS];<br>&#125;<span class="hljs-keyword">__sigset_t</span>;<br></code></pre></td></tr></table></figure>
<p>由该定义可见，sigset_t实际上是一个长整型数组，数组的每个元素的每个位表示一个信号。这种定义方式和文件描述符集fd_set类似。 Linux提供了如下一组函数来设置、修改、删除和查询信号集:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigemptyset</span><span class="hljs-params">(<span class="hljs-keyword">sigset_t</span>*_set)</span><span class="hljs-comment">/*清空信号集*/</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigfillset</span><span class="hljs-params">(<span class="hljs-keyword">sigset_t</span>*_set)</span><span class="hljs-comment">/*在信号集中设置所有信号*/</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigaddset</span><span class="hljs-params">(<span class="hljs-keyword">sigset_t</span>*_set,int_signo)</span><span class="hljs-comment">/*将信号_signo添加至信号集中*/</span> </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigdelset</span><span class="hljs-params">(<span class="hljs-keyword">sigset_t</span>*_set,int_signo)</span><span class="hljs-comment">/*将信号_signo从信号集中删除*/</span> </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigismember</span><span class="hljs-params">(_const <span class="hljs-keyword">sigset_t</span>*_set,int_signo)</span><span class="hljs-comment">/*测试_signo是否在信号集中*/</span></span><br></code></pre></td></tr></table></figure>
<h3 id="1032-进程信号掩码"><a class="markdownIt-Anchor" href="#1032-进程信号掩码"></a> 10.3.2 进程信号掩码</h3>
<p>前文提到，我们可以利用sigaction结构体的sa_mask成员来设置进程的信号掩码。此外，如下函数也可以用于设置或查看进程的信号掩码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigprocmask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _how,_const <span class="hljs-keyword">sigset_t</span>* _set,<span class="hljs-keyword">sigset_t</span>* _oset)</span></span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>set参数指定新的信号掩码</li>
<li>oset参数则输出原来的信号掩码(如果不为NULL的话)。如果set参数不为NULL，则how参数指定设置进程信号掩码的方式，其可选值如表10-5所示。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205271540984.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-27 下午3.40.06" /></p>
<p>如果_set为NULL，则进程信号掩码不变，此时我们仍然可以利用 _oset参数来获得进程当前的信号掩码。</p>
<p>sigprocmask成功时返回0，失败则返回-1并设置errno。</p>
<h3 id="1033-被挂起的信号"><a class="markdownIt-Anchor" href="#1033-被挂起的信号"></a> 10.3.3 被挂起的信号</h3>
<p>设置进程信号掩码后，被屏蔽的信号将不能被进程接收。如果给进程发送一个被屏蔽的信号，则操作系统将该信号设置为进程的一个被挂起的信号。如果我们取消对被挂起信号的屏蔽，则它能立即被进程接收到。如下函数可以<u>获得进程当前被挂起</u>的信号集:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sigpending</span><span class="hljs-params">(<span class="hljs-keyword">sigset_t</span>* set)</span></span>;<br></code></pre></td></tr></table></figure>
<p>set参数用于保存被挂起的信号集。显然，进程即使多次接收到同一个被挂起的信号，sigpending函数也只能反映一次。并且，当我们再 次使用sigprocmask使能该挂起的信号时，该信号的处理函数也只被触发一次。【就跟哈希表一样，多次也表示就是他自己】</p>
<p>sigpending成功时返回0，失败时返回-1并设置errno。</p>
<p>关于信号和信号集，Linux还提供了很多有用的API，这里就不一一介绍了。需要提醒读者的是，要始终清楚地知道进程在每个运行时刻的信号掩码，以及如何适当地处理捕获到的信号。在多进程、多线程环境中，我们要以进程、线程为单位来处理信号和信号掩码。我们不能设想新创建的进程、线程具有和父进程、主线程完全相同的信号特征。比如，fork调用产生的子进程将继承父进程的信号掩码，但具有一个空的挂起信号集【就是信号掩码是一样的，但是挂起信号集不同】。</p>
<h2 id="104-统一事件源"><a class="markdownIt-Anchor" href="#104-统一事件源"></a> 10.4 统一事件源</h2>
<p>信号是一种异步事件:信号处理函数和程序的主循环是两条不同的执行路线。很显然，信号处理函数需要<u>尽可能快</u>地执行完毕，以确保该信号不被屏蔽(前面提到过，为了避免一些竞态条件，信号在处理期间，系统<u>不会再次触发</u>它)太久。一种典型的解决方案是:把信号的主要处理逻辑放到程序的主循环中，当信号处理函数被触发时，它只是简单地通知主循环程序接收到信号，并把信号值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码。</p>
<p>信号处理函数通常使用管道来将信号“传递”给主循环:信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出该信号值。那么 主循环怎么知道管道上何时有数据可读呢?这很简单，我们只需要使用<strong>I/O复用系统</strong>调用来监听管道的读端文件描述符上的可读事件。如此一来，信号事件就能和其他I/O事件一样被处理，即<strong>统一事件源</strong>【个人理解就是将管道读取信号这个事件注册到I/O复用中进行监听】。</p>
<p>很多优秀的I/O框架库和后台服务器程序都统一处理信号和I/O事件，比如Libevent I/O框架库和xinetd超级服务。代码清单10-1给出了统一事件源的一个简单实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span><br><span class="hljs-comment">// static 全局变量 不能被别的文件使用</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> pipefd[<span class="hljs-number">2</span>];<br><span class="hljs-comment">// 设置非阻塞</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">( <span class="hljs-keyword">int</span> fd )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> old_option = <span class="hljs-built_in">fcntl</span>( fd, F_GETFL );<br>    <span class="hljs-keyword">int</span> new_option = old_option | O_NONBLOCK;<br>    <span class="hljs-built_in">fcntl</span>( fd, F_SETFL, new_option );<br>    <span class="hljs-keyword">return</span> old_option;<br>&#125;<br><span class="hljs-comment">// 注册epoll事件 ET模式 就绪的事件必须处理完 ，不会有处理不完下次接着来的情况</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">( <span class="hljs-keyword">int</span> epollfd, <span class="hljs-keyword">int</span> fd )</span></span><br><span class="hljs-function"></span>&#123;<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN | EPOLLET;<br>    <span class="hljs-built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_ADD, fd, &amp;event );<br>    <span class="hljs-built_in">setnonblocking</span>( fd );<br>&#125;<br><span class="hljs-comment">/*信号处理函数*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sig_handler</span><span class="hljs-params">( <span class="hljs-keyword">int</span> sig )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*保留原来的errno，在函数最后恢复，以保证函数的可重入性*/</span><br>    <span class="hljs-keyword">int</span> save_errno = errno;<br>    <span class="hljs-keyword">int</span> msg = sig;<br>    <span class="hljs-built_in">send</span>( pipefd[<span class="hljs-number">1</span>], ( <span class="hljs-keyword">char</span>* )&amp;msg, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> );  <span class="hljs-comment">/*将信号值写入管道，以通知主循环，将sig函数发过去*/</span><br>    errno = save_errno; <span class="hljs-comment">// 【类似于单片机的中断函数，所以需要还原之前的环境】</span><br>&#125;<br><span class="hljs-comment">/*设置信号的处理函数*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addsig</span><span class="hljs-params">( <span class="hljs-keyword">int</span> sig )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sa</span>;</span><br>    <span class="hljs-built_in">memset</span>( &amp;sa, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( sa ) );<br>    sa.sa_handler = sig_handler; <span class="hljs-comment">// 指定信号处理函数</span><br>    sa.sa_flags |= SA_RESTART;  <span class="hljs-comment">// 设置程序收到信号时，重新调用被该信号终止的系统调用</span><br>    <span class="hljs-built_in">sigfillset</span>( &amp;sa.sa_mask ); <span class="hljs-comment">// 在信号集中设置所有的信号【利用sigaction中的信号掩码】</span><br>    <span class="hljs-built_in">assert</span>( <span class="hljs-built_in">sigaction</span>( sig, &amp;sa, <span class="hljs-literal">NULL</span> ) != <span class="hljs-number">-1</span> ); <span class="hljs-comment">// 去捕获sig信号，sa作为处理配置文件</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 设置ip 和 port</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 创建IPv4 socket地址</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-keyword">int</span> listenfd = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( listenfd &gt;= <span class="hljs-number">0</span> );<br><br>    <span class="hljs-comment">//int nReuseAddr = 1;</span><br>    <span class="hljs-comment">//setsockopt( listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;nReuseAddr, sizeof( nReuseAddr ) );</span><br>    <span class="hljs-comment">// socket命名</span><br>    ret = <span class="hljs-built_in">bind</span>( listenfd, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-keyword">if</span>( ret == <span class="hljs-number">-1</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is %d\n&quot;</span>, errno );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//assert( ret != -1 );</span><br>    <span class="hljs-comment">// 监听socket</span><br>    ret = <span class="hljs-built_in">listen</span>( listenfd, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 创建事件数组 用于存储事件</span><br>    epoll_event events[ MAX_EVENT_NUMBER ];<br>    <span class="hljs-comment">// 创建内核事件表</span><br>    <span class="hljs-keyword">int</span> epollfd = <span class="hljs-built_in">epoll_create</span>( <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( epollfd != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 注册监听socket事件</span><br>    <span class="hljs-built_in">addfd</span>( epollfd, listenfd );<br>    <span class="hljs-comment">/*使用socketpair创建管道*/</span><br>    ret = <span class="hljs-built_in">socketpair</span>( PF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, pipefd );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 管道写入口设置非阻塞</span><br>    <span class="hljs-built_in">setnonblocking</span>( pipefd[<span class="hljs-number">1</span>] );<br>    <span class="hljs-comment">// 注册pipefd[0]上的可读事件</span><br>    <span class="hljs-built_in">addfd</span>( epollfd, pipefd[<span class="hljs-number">0</span>] );<br><br>    <span class="hljs-comment">/*设置一些信号的处理函数*/</span><br>    <span class="hljs-built_in">addsig</span>( SIGHUP );<br>    <span class="hljs-built_in">addsig</span>( SIGCHLD );<br>    <span class="hljs-built_in">addsig</span>( SIGTERM );<br>    <span class="hljs-built_in">addsig</span>( SIGINT );<br>    <span class="hljs-keyword">bool</span> stop_server = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">while</span>( !stop_server )<br>    &#123;<br>        <span class="hljs-keyword">int</span> number = <span class="hljs-built_in">epoll_wait</span>( epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span> ); <span class="hljs-comment">// 获取就绪事件</span><br>        <span class="hljs-keyword">if</span> ( ( number &lt; <span class="hljs-number">0</span> ) &amp;&amp; ( errno != EINTR ) )<br>        &#123;<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;epoll failure\n&quot;</span> );<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <br>        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++ )<br>        &#123;<br>            <span class="hljs-keyword">int</span> sockfd = events[i].data.fd;<br>            <span class="hljs-comment">/*如果就绪的文件描述符是listenfd，则处理新的连接*/</span><br>            <span class="hljs-keyword">if</span>( sockfd == listenfd )<br>            &#123;<br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_address</span>;</span><br>                <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client_address );<br>                <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );<br>                <span class="hljs-built_in">addfd</span>( epollfd, connfd );<br>            &#125;<br>            <span class="hljs-comment">/*如果就绪的文件描述符是pipefd[0]，则处理信号*/</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( ( sockfd == pipefd[<span class="hljs-number">0</span>] ) &amp;&amp; ( events[i].events &amp; EPOLLIN ) )<br>            &#123;<br>                <span class="hljs-keyword">int</span> sig;<br>                <span class="hljs-keyword">char</span> signals[<span class="hljs-number">1024</span>];<br>                <span class="hljs-comment">// 从pipefd[0] 读入到 signals</span><br>                ret = <span class="hljs-built_in">recv</span>( pipefd[<span class="hljs-number">0</span>], signals, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( signals ), <span class="hljs-number">0</span> );<br>                <span class="hljs-keyword">if</span>( ret == <span class="hljs-number">-1</span> )<br>                &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( ret == <span class="hljs-number">0</span> )<br>                &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">/*因为每个信号值占1字节，所以按字节来逐个接收信号。我们以SIGTERM为例，来说明如何安全地终止服务器主循环*/</span><br>                    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; ++i )<br>                    &#123;<br>                        <span class="hljs-comment">//printf( &quot;I caugh the signal %d\n&quot;, signals[i] );</span><br>                        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>( signals[i] )<br>                        &#123;<br>                            <span class="hljs-keyword">case</span> SIGCHLD:<br>                            <span class="hljs-keyword">case</span> SIGHUP:<br>                            &#123;<br>                                <span class="hljs-keyword">continue</span>;<br>                            &#125;<br>                            <span class="hljs-keyword">case</span> SIGTERM:<br>                            <span class="hljs-keyword">case</span> SIGINT:<br>                            &#123;<br>                                stop_server = <span class="hljs-literal">true</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;close fds\n&quot;</span> );<br>    <span class="hljs-built_in">close</span>( listenfd );<br>    <span class="hljs-built_in">close</span>( pipefd[<span class="hljs-number">1</span>] );<br>    <span class="hljs-built_in">close</span>( pipefd[<span class="hljs-number">0</span>] );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="105-网络编程相关信号"><a class="markdownIt-Anchor" href="#105-网络编程相关信号"></a> 10.5 网络编程相关信号</h2>
<p>本节中我们详细探讨三个和网络编程密切相关的信号。</p>
<h3 id="1051-sighup"><a class="markdownIt-Anchor" href="#1051-sighup"></a> 10.5.1 SIGHUP</h3>
<p>当挂起进程的控制终端时，SIGHUP信号将被触发。对于没有控制终端的网络后台程序而言，它们通常利用SIGHUP信号来强制服务器重读配置文件。一个典型的例子是xinetd超级服务程序。</p>
<p>xinetd程序在接收到<strong>SIGHUP</strong>信号之后将调用hard_reconfig函数 (见xinetd源码)，它循环读取/etc/xinetd.d/目录下的每个子配置文件，并检测其变化。</p>
<ul>
<li>如果某个正在运行的子服务的配置文件被修改以停止服务，则xinetd主进程将给该子服务进程发送<strong>SIGTERM</strong>信号以<strong>结束</strong>它。</li>
<li>如果某个子服务的配置文件被修改以开启服务，则xinetd将创建新的socket并将其绑定到该服务对应的端口上。</li>
</ul>
<p>下面我们简单地分析xinetd处理SIGHUP信号的流程。</p>
<p>测试机器Kongming20上具有如下环境:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">$ps -ef|grep xinetd<br>root <span class="hljs-number">7438</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">11</span>:<span class="hljs-number">32</span>?<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> /usr/sbin/xinetd-stayalive-pidfile/var/run/xinetd.pid<br>root <span class="hljs-number">7442</span> <span class="hljs-number">7438</span> <span class="hljs-number">0</span> <span class="hljs-number">11</span>:<span class="hljs-number">32</span>?<span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> (xinetd service)echo-stream Kongming20<br>$sudo lsof-p <span class="hljs-number">7438</span><br>xinetd <span class="hljs-number">7438</span> root <span class="hljs-number">3</span>r FIFO <span class="hljs-number">0</span>,<span class="hljs-number">8</span> <span class="hljs-number">0</span>t0 <span class="hljs-number">37639</span> pipe<br>xinetd <span class="hljs-number">7438</span> root <span class="hljs-number">4</span>w FIFO <span class="hljs-number">0</span>,<span class="hljs-number">8</span> <span class="hljs-number">0</span>t0 <span class="hljs-number">37639</span> pipe<br>xinetd <span class="hljs-number">7438</span> root <span class="hljs-number">5u</span> IPv6 <span class="hljs-number">37652</span> <span class="hljs-number">0</span>t0 TCP*:<span class="hljs-built_in">echo</span>(LISTEN)<br></code></pre></td></tr></table></figure>
<ul>
<li>从ps的输出来看，xinetd创建了子进程7442，它运行echo-stream内部服务。</li>
<li>从lsof的输出来看，xinetd打开了一个管道。该管道的读端文件描述符的值是3，写端文件描述符的值是4。</li>
</ul>
<p>后面我们将看到，它们的作用就是<strong>统一事件源</strong>。现在我们修改/etc/xinetd.d/目录下的部分配置文件，并给xinetd发送一个SIGHUP信号。具体操作如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo sed -i <span class="hljs-string">&#x27;s/disable.*=.*no/disable=yes/&#x27;</span> /etc/xinetd.d/echo- stream # 停止echo服务<br>$sudo sed -i <span class="hljs-string">&#x27;s/disable.*=.*yes/disable=no/&#x27;</span> /etc/xinetd.d/telnet # 开启telnet服务<br>$sudo strace -p <span class="hljs-number">7438</span>&amp;&gt;a.txt <br>$sudo kill -HUP xinetd<br></code></pre></td></tr></table></figure>
<p>strace命令(见第17章)能跟踪程序执行时调用的系统调用和接收到的信号。这里我们利用strace命令跟踪进程7438，即xinetd服务器程 序，以观察xinetd是如何处理SIGHUP信号的。此次strace命令的部分输出如代码清单10-2所示。</p>
<p>代码清单10-2 用strace命令查看xinetd处理SIGHUP的流程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// part 1 </span><br>---&#123;si_signo=SIGHUP,si_code=SI_USER,si_pid=<span class="hljs-number">7697</span>,si_uid=<span class="hljs-number">0</span>,<br>   si_value=&#123;<span class="hljs-keyword">int</span>=<span class="hljs-number">1154706400</span>,ptr=<span class="hljs-number">0x44d36be0</span>&#125;&#125;(Hangup)---<br>   <span class="hljs-built_in">write</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;\1&quot;</span>,<span class="hljs-number">1</span>)=<span class="hljs-number">1</span><br>   <span class="hljs-built_in">sigreturn</span>()=?(mask now[])<br>   <span class="hljs-built_in">poll</span>([&#123;fd=<span class="hljs-number">5</span>,events=POLLIN&#125;,&#123;fd=<span class="hljs-number">3</span>,events=POLLIN&#125;],<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>)=<span class="hljs-number">1</span>([&#123;fd=<span class="hljs-number">3</span>,revents=POLLIN&#125;])<br>   <span class="hljs-built_in">ioctl</span>(<span class="hljs-number">3</span>,FIONREAD,[<span class="hljs-number">1</span>])=<span class="hljs-number">0</span><br><span class="hljs-comment">// part 2     </span><br><span class="hljs-built_in">read</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;\1&quot;</span>,<span class="hljs-number">1</span>)=<span class="hljs-number">1</span><br><span class="hljs-comment">// part 3</span><br><span class="hljs-built_in">stat64</span>(<span class="hljs-string">&quot;/etc/xinetd.d/echo-stream&quot;</span>,&#123;st_mode=S_IFREG|<span class="hljs-number">0644</span>,st_size=<span class="hljs-number">1149</span>,...&#125;)=<span class="hljs-number">0</span><br><span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/etc/xinetd.d/echo-stream&quot;</span>,O_RDONLY)=<span class="hljs-number">8</span> <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>)=<span class="hljs-number">1337053896</span><br><span class="hljs-built_in">send</span>(<span class="hljs-number">7</span>,<span class="hljs-string">&quot;&lt;31&gt;May 15 11:51:36 xinetd[7438]&quot;</span>...,<span class="hljs-number">139</span>,MSG_NOSIGNAL)=<span class="hljs-number">139</span><br><span class="hljs-built_in">fstat64</span>(<span class="hljs-number">8</span>,&#123;st_mode=S_IFREG|<span class="hljs-number">0644</span>,st_size=<span class="hljs-number">1149</span>,...&#125;)=<span class="hljs-number">0</span><br><span class="hljs-built_in">lseek</span>(<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,SEEK_CUR)=<span class="hljs-number">0</span><br><span class="hljs-built_in">fcntl64</span>(<span class="hljs-number">8</span>,F_GETFL)=<span class="hljs-number">0</span>(flags O_RDONLY)<br><span class="hljs-built_in">read</span>(<span class="hljs-number">8</span>,<span class="hljs-string">&quot;#This is the configuration for&quot;</span>...,<span class="hljs-number">8192</span>)=<span class="hljs-number">1149</span><br><span class="hljs-built_in">read</span>(<span class="hljs-number">8</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-number">8192</span>)=<span class="hljs-number">0</span><br><span class="hljs-built_in">close</span>(<span class="hljs-number">8</span>)=<span class="hljs-number">0</span><br>   <span class="hljs-built_in">kill</span>(<span class="hljs-number">7442</span>,SIGTERM)=<span class="hljs-number">0</span><br>   <span class="hljs-built_in">waitpid</span>(<span class="hljs-number">7442</span>,<span class="hljs-literal">NULL</span>,WNOHANG)=<span class="hljs-number">0</span><br>  <span class="hljs-comment">// part 4</span><br>   <span class="hljs-built_in">socket</span>(PF_INET6,SOCK_STREAM,IPPROTO_TCP)=<span class="hljs-number">5</span><br>   <span class="hljs-built_in">fcntl64</span>(<span class="hljs-number">5</span>,F_SETFD,FD_CLOEXEC)=<span class="hljs-number">0</span><br>   <span class="hljs-built_in">setsockopt</span>(<span class="hljs-number">5</span>,SOL_IPV6,IPV6_V6ONLY,[<span class="hljs-number">0</span>],<span class="hljs-number">4</span>)=<span class="hljs-number">0</span><br>   <span class="hljs-built_in">setsockopt</span>(<span class="hljs-number">5</span>,SOL_SOCKET,SO_REUSEADDR,[<span class="hljs-number">1</span>],<span class="hljs-number">4</span>)=<span class="hljs-number">0</span><br>   <span class="hljs-built_in">bind</span>(<span class="hljs-number">5</span>,&#123;sa_family=AF_INET6,sin6_port=<span class="hljs-built_in">htons</span>(<span class="hljs-number">23</span>),<span class="hljs-built_in">inet_pton</span>(AF_INET6,<span class="hljs-string">&quot;::&quot;</span>,&amp;sin6_addr),sin6_flowinfo=<span class="hljs-number">0</span>,sin6_scope_id=<span class="hljs-number">0</span>&#125;,<span class="hljs-number">28</span>)=<span class="hljs-number">0</span><br>   <span class="hljs-built_in">listen</span>(<span class="hljs-number">5</span>,<span class="hljs-number">64</span>)=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>该输出分为4个部分，我们用空行将每个部分隔开。</p>
<ul>
<li>第一部分描述程序接收到SIGHUP信号时，信号处理函数使用管道通知主程序该信号的到来。信号处理函数往文件描述符4(管道的写端)写入信号值1(SIGHUP信号)，而主程序使用poll检测到文件描述符3(管道的读端)上有可读事件，就将管道上的数据读入。</li>
<li>第二部分描述了xinetd重新读取一个子配置文件的过程。</li>
<li>第三部分描述了xinetd给子进程echo-stream(PID为7442)发送SIGTERM信号来终止该子进程，并调用waitpid来等待该子进程结束。</li>
<li>第四部分描述了xinetd启动telnet服务的过程:创建一个流服务 socket并将其绑定到端口23上，然后监听该端口。</li>
</ul>
<h3 id="1052-sigpipe"><a class="markdownIt-Anchor" href="#1052-sigpipe"></a> 10.5.2 SIGPIPE</h3>
<p>默认情况下，往一个<u>读端关闭的管道</u>或socket连接中写数据将引发SIGPIPE信号。我们需要在代码中捕获并处理该信号，或者至少忽略它，因为程序接收到SIGPIPE信号的默认行为是结束进程，而我们绝对不希望因为错误的写操作而导致程序退出。引起SIGPIPE信号的写操作将设置errno为EPIPE。</p>
<p>第5章提到，我们可以使用send函数的MSG_NOSIGNAL标志来禁止写操作触发SIGPIPE信号。在这种情况下，我们应该使用send函数反馈的errno值来判断管道或者socket连接的读端是否已经关闭。</p>
<p>此外，我们也可以利用I/O复用系统调用来检测管道【其实就是检测了一个信号】和socket连接的读端是否已经关闭。以poll为例，当管道的读端关闭时，写端文件描述符上的POLLHUP事件将被触发;当socket连接被对方关闭时，socket上的POLLRDHUP事件将被触发。</p>
<h3 id="1053-sigurg"><a class="markdownIt-Anchor" href="#1053-sigurg"></a> 10.5.3 SIGURG</h3>
<p>在Linux环境下，内核通知应用程序带外数据到达主要有两种方法:一种是第9章介绍的I/O复用技术，select等系统调用在接收到带外数据时将返回，并向应用程序报告socket上的异常事件，代码清单9-1给出了一个这方面的例子;另外一种方法就是使用SIGURG信号，如代码清单10-3所示。</p>
<p>代码清单10-3 用SIGURG检测带外数据是否到达</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUF_SIZE 1024</span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> connfd;<br><span class="hljs-comment">/*SIGURG信号的处理函数*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sig_urg</span><span class="hljs-params">( <span class="hljs-keyword">int</span> sig )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> save_errno = errno; <span class="hljs-comment">// 记录旧状态</span><br>    <span class="hljs-comment">// 设置缓冲区处理带外数据</span><br>    <span class="hljs-keyword">char</span> buffer[ BUF_SIZE ];<br>    <span class="hljs-built_in">memset</span>( buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE );<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="hljs-number">-1</span>, MSG_OOB );<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;got %d bytes of oob data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );<br>    errno = save_errno;  <span class="hljs-comment">// 还原旧状态</span><br>&#125;<br><span class="hljs-comment">/*设置信号的处理函数*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addsig</span><span class="hljs-params">( <span class="hljs-keyword">int</span> sig, <span class="hljs-keyword">void</span> ( *sig_handler )( <span class="hljs-keyword">int</span> ) )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sa</span>;</span><br>    <span class="hljs-built_in">memset</span>( &amp;sa, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( sa ) );<br>    sa.sa_handler = sig_handler; <span class="hljs-comment">// 指定信号处理函数（这个是个形式参数）</span><br>    sa.sa_flags |= SA_RESTART;  <span class="hljs-comment">// 设置程序收到信号时，重新调用被该信号终止的系统调用</span><br>    <span class="hljs-built_in">sigfillset</span>( &amp;sa.sa_mask ); <span class="hljs-comment">// 在信号集中设置所有的信号【利用sigaction中的信号掩码】为了给主循环处理 统一事件源</span><br>    <span class="hljs-built_in">assert</span>( <span class="hljs-built_in">sigaction</span>( sig, &amp;sa, <span class="hljs-literal">NULL</span> ) != <span class="hljs-number">-1</span> );  <span class="hljs-comment">// 去捕获信号，处理就是sa配置文件</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 重新设置ip和port</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 创建ipv4的socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 命名socket</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 监听socket</span><br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 创建ipv4 的 socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );<br>    <span class="hljs-comment">// 接收监听到的数据</span><br>    connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );<br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">// 若没有成功接收</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;   <br>        <span class="hljs-comment">// 成功接受了</span><br>        <span class="hljs-comment">// 模拟触发了异常事件</span><br>        <span class="hljs-built_in">addsig</span>( SIGURG, sig_urg );<br>        <span class="hljs-built_in">fcntl</span>( connfd, F_SETOWN, <span class="hljs-built_in">getpid</span>() );<br><br>        <span class="hljs-keyword">char</span> buffer[ BUF_SIZE ];<br>        <span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> )<br>        &#123;   <br>            <span class="hljs-comment">// 开始正常收取TCP连接数据</span><br>            <span class="hljs-built_in">memset</span>( buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE );<br>            ret = <span class="hljs-built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span> );<br>            <span class="hljs-keyword">if</span>( ret &lt;= <span class="hljs-number">0</span> )<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );<br>        &#125;<br><br>        <span class="hljs-built_in">close</span>( connfd );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>读者不妨编译并运行该服务器程序，然后使用代码清单5-6所描述的客户端程序来往该服务器程序发送数据，以观察服务器是如何同时处理普通数据和带外数据的。</p>
<p>至此，我们讨论完了TCP带外数据相关的所有知识。下面帮助读者重新梳理一下。3.8节中我们介绍了TCP带外数据的基本知识，其中探讨了TCP模块是如何发送和接收带外数据的。5.8.1小节描述了如何在应用程序中使用带MSG_OOB标志的send/recv系统调用来发送/接收 带外数据，并给出了相关代码。</p>
<p>9.1.3小节和10.5.3小节分别介绍了检测带外数据是否到达的两种方法:<strong>I/O复用系统调用报告的异常事件</strong>和<strong>SIGURG信号</strong>。但应用程序检测到带外数据到达后，我们还需要进一步判断带外数据在数据流中的具体位置，才能够准确无误地读取带外数据。5.9节介绍的sockatmark系统调用就是专门用于解决这个问题的。它判断一个socket是否处于带外标记，即该socket上下一个将被读取到的数据是否是带外数据。</p>
<h1 id="第11章-定时器"><a class="markdownIt-Anchor" href="#第11章-定时器"></a> 第11章 定时器</h1>
<p>网络程序需要处理的第三类事件是定时事件，比如定期检测一个客户连接的活动状态。服务器程序通常管理着众多定时事件，因此有效地组织这些定时事件，使之能在预期的时间点被触发且不影响服务器的主要逻辑，对于服务器的性能有着至关重要的影响。为此，我们要将每个定时事件分别封装成定时器，并使用某种容器类数据结构，比如链表、排序链表和时间轮，将所有定时器串联起来，以实现对定时事件的统一管理。本章主要讨论的就是两种高效的管理定时器的容器:<strong>时间轮</strong>和<strong>时间堆</strong>。</p>
<p>不过，在讨论如何组织定时器之前，我们先要介绍定时的方法。定时是<u>指在一段时间之后触发某段代码的机制</u>，我们可以在这段代码中依次处理所有到期的定时器。换言之，定时机制是定时器得以被处理的原动力。Linux提供了三种定时方法，它们是:</p>
<ul>
<li>socket选项SO_RCVTIMEO和SO_SNDTIMEO。</li>
<li>SIGALRM信号。</li>
<li>I/O复用系统调用的超时参数。</li>
</ul>
<h2 id="111-socket选项so_rcvtimeo和-so_sndtimeo"><a class="markdownIt-Anchor" href="#111-socket选项so_rcvtimeo和-so_sndtimeo"></a> 11.1 socket选项SO_RCVTIMEO和 SO_SNDTIMEO</h2>
<p>第5章中我们介绍过socket选项SO_RCVTIMEO和 SO_SNDTIMEO，它们分别用来设置socket<u>接收数据超时时间</u>和<u>发送数据超时时间</u>。因此，这两个选项仅对与数据接收和发送相关的socket专用系统调用(socket专用的系统调用指的是5.2~5.11节介绍的那些socket API)有效，这些系统调用包括send、sendmsg、recv、recvmsg、 accept和connect。我们将选项SO_RCVTIMEO和SO_SNDTIMEO对这些系统调用的影响总结于表11-1中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205272125344.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-27 下午9.25.26" /></p>
<p>由表11-1可见，在程序中，我们可以根据系统调用(send、 sendmsg、recv、recvmsg、accept和connect)的返回值以及errno来判断超时时间是否已到，进而决定是否开始处理定时任务。代码清单11-1以connect为例，说明程序中如何使用SO_SNDTIMEO选项来定时。</p>
<p>代码清单11-1 设置connect超时时间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">/*超时连接函数*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">timeout_connect</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip, <span class="hljs-keyword">int</span> port, <span class="hljs-keyword">int</span> time )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 创建IPv4 的 socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-keyword">int</span> sockfd = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sockfd &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">/*通过选项SO_RCVTIMEO和SO_SNDTIMEO所设置的超时时间的类型是timeval，这和select系统调用的超时参数类型相同*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">timeout</span>;</span><br>    timeout.tv_sec = time;<br>    timeout.tv_usec = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">socklen_t</span> len = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( timeout );<br>    <span class="hljs-comment">// 设置返回时间可以返回出是否是超时的宏</span><br>    ret = <span class="hljs-built_in">setsockopt</span>( sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, len );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 连接socket</span><br>    ret = <span class="hljs-built_in">connect</span>( sockfd, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-keyword">if</span> ( ret == <span class="hljs-number">-1</span> )<br>    &#123;<br>        <span class="hljs-comment">/*超时对应的错误号是EINPROGRESS。下面这个条件如果成立，我们就可以处理定时任务了*/</span><br>        <span class="hljs-keyword">if</span>( errno == EINPROGRESS )<br>        &#123;<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;connecting timeout\n&quot;</span> );<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;error occur when connecting to server\n&quot;</span> );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sockfd;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 给ip 和 port</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 启动函数</span><br>    <span class="hljs-keyword">int</span> sockfd = <span class="hljs-built_in">timeout_connect</span>( ip, port, <span class="hljs-number">10</span> );<br>    <span class="hljs-keyword">if</span> ( sockfd &lt; <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>本章的标题叫定时器，这是行业内常用的叫法。实际上，其确切的叫法是<strong>定时器容器</strong>。二者常混谈，本书也没有刻意区分。不过，从本章的第一段话还是能看出二者的区别:定时器容器是<u>容器类数据结构</u>，比如时间轮;定时器则是容器内容纳的一个个对象，它是对定时事件的封装【一种事件与定时器的封装】。</p>
<h2 id="112-sigalrm信号"><a class="markdownIt-Anchor" href="#112-sigalrm信号"></a> 11.2 SIGALRM信号</h2>
<p>第10章提到，由alarm和setitimer函数设置的实时闹钟一旦超时，将触发SIGALRM信号。因此，我们可以利用该信号的信号处理函数来处理定时任务。但是，如果要处理多个定时任务，我们就需要不断地触发SIGALRM信号，并在其信号处理函数中执行到期的任务。一般而 言，SIGALRM信号按照固定的频率生成，即由alarm或setitimer函数设置的定时周期T保持不变。如果某个定时任务的超时时间不是T的整数倍，那么它实际被执行的时间和预期的时间将<strong>略有偏差</strong>。因此定时<u>周期T反映了定时的精度</u>。</p>
<p>本节中我们通过一个实例——<strong>处理非活动连接</strong>，来介绍如何使用SIGALRM信号定时。不过，我们需要先给出一种简单的定时器实现——基于升序链表的定时器，并把它应用到处理非活动连接这个实例中。这样，我们才能观察到SIGALRM信号处理函数是如何处理定时器并执行定时任务的。此外，我们介绍这种定时器也是为了和后面要讨论的高效定时器——时间轮和时间堆做对比。</p>
<h3 id="1121-基于升序链表的定时器"><a class="markdownIt-Anchor" href="#1121-基于升序链表的定时器"></a> 11.2.1 基于升序链表的定时器</h3>
<p>定时器通常至少要包含两个成员:<strong>一个超时时间</strong>(相对时间或者绝对时间)和<strong>一个任务回调函数</strong>。有的时候还可能包含回调函数被执行时需要传入的参数，以及是否重启定时器等信息。如果使用链表作为容器来串联所有的定时器，则每个定时器还要包含<u>指向下一个定时器的指针</u>成员。进一步，如果链表是<strong>双向</strong>的，则每个定时器还需要包含指向前一个定时器的指针成员。代码清单11-2实现了一个简单的升序定时器链表。升序定时器链表将其中的定时器按照超时时间做升序排序。【其实就是节点为定时器的双向链表】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> LST_TIMER </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LST_TIMER </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><br></code></pre></td></tr></table></figure>
<p>代码清单11-2 升序定时器链表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> LST_TIMER</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LST_TIMER</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 64</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">util_timer</span>;</span> <span class="hljs-comment">/*前向声明*/</span><br><span class="hljs-comment">/*用户数据结构:客户端socket地址、socket文件描述符、读缓存和定时器*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">client_data</span></span><br><span class="hljs-class">&#123;</span><br>    sockaddr_in address;<br>    <span class="hljs-keyword">int</span> sockfd;<br>    <span class="hljs-keyword">char</span> buf[ BUFFER_SIZE ];<br>    util_timer* timer;<br>&#125;;<br><span class="hljs-comment">/*定时器类*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">util_timer</span> // 链表节点</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">util_timer</span>() : <span class="hljs-built_in">prev</span>( <span class="hljs-literal">NULL</span> ), <span class="hljs-built_in">next</span>( <span class="hljs-literal">NULL</span> )&#123;&#125;  <span class="hljs-comment">// 构造函数</span><br><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-keyword">time_t</span> expire; <span class="hljs-comment">/*任务的超时时间，这里使用绝对时间*/</span><br>   <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*cb_func)( client_data* ); <span class="hljs-comment">/*任务回调函数【嘻嘻，用的函数指针实现】*/</span><br>   client_data* user_data;  <span class="hljs-comment">/*回调函数处理的客户数据，由定时器的执行者传递给回调函数*/</span><br>   util_timer* prev;  <span class="hljs-comment">/*指向前一个定时器*/</span><br>   util_timer* next;  <span class="hljs-comment">/*指向下一个定时器*/</span><br>&#125;;<br><span class="hljs-comment">/*定时器链表。它是一个升序、双向链表，且带有头结点和尾节点*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">sort_timer_lst</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">sort_timer_lst</span>() : <span class="hljs-built_in">head</span>( <span class="hljs-literal">NULL</span> ), <span class="hljs-built_in">tail</span>( <span class="hljs-literal">NULL</span> ) &#123;&#125;<br>    ~<span class="hljs-built_in">sort_timer_lst</span>() <span class="hljs-comment">/*链表被销毁时，删除其中所有的定时器*/</span><br>    &#123;<br>        util_timer* tmp = head;<br>        <span class="hljs-keyword">while</span>( tmp )<br>        &#123;<br>            head = tmp-&gt;next;<br>            <span class="hljs-keyword">delete</span> tmp;<br>            tmp = head;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*将目标定时器timer添加到链表中*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_timer</span><span class="hljs-params">( util_timer* timer )</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>( !timer )  <span class="hljs-comment">// 如果添加的链表是空的 直接返回</span><br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>( !head )  <span class="hljs-comment">// 初始化头和尾巴指针都指向当前节点</span><br>        &#123;<br>            head = tail = timer;<br>            <span class="hljs-keyword">return</span>; <br>        &#125;<br> <span class="hljs-comment">/*如果目标定时器的超时时间小于当前链表中所有定时器的超时时间，则把该定时器插入链表头部，作为链表新的头节点。否则就需要调用重载函数add_timer(util_timer*timer,util_timer*lst_head)，把它插入链表中合适的位置，以保证链表的升序特性*/</span><br>        <span class="hljs-keyword">if</span>( timer-&gt;expire &lt; head-&gt;expire ) <br>        &#123;<br>            timer-&gt;next = head;<br>            head-&gt;prev = timer;<br>            head = timer;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">add_timer</span>( timer, head );  <span class="hljs-comment">// 从head开始找到一个合适的位置</span><br>    &#125;<br><span class="hljs-comment">/*当某个定时任务发生变化时，调整【对应】的定时器在链表中的位置。这个函数只考虑被调整的定时器的超时时间延长的情况，即该定时器需要往链表的尾部移动*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">adjust_timer</span><span class="hljs-params">( util_timer* timer )</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>( !timer )  <span class="hljs-comment">// 如果输入是空 不做动作</span><br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 设置一个节点指针指向当前的这个下一个</span><br>        util_timer* tmp = timer-&gt;next;<br>   <span class="hljs-comment">/*如果被调整的目标定时器处在链表尾部，或者该定时器新的超时值仍然小于其下一个定时器的超时值，则不用调整*/</span><br>        <span class="hljs-keyword">if</span>( !tmp || ( timer-&gt;expire &lt; tmp-&gt;expire ) )<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">/*如果目标定时器是链表的头节点，则将该定时器从链表中 取出并重新插入链表*/</span><br>        <span class="hljs-keyword">if</span>( timer == head )<br>        &#123;<br>            head = head-&gt;next;<br>            head-&gt;prev = <span class="hljs-literal">NULL</span>;<br>            timer-&gt;next = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-built_in">add_timer</span>( timer, head );<br>        &#125;<br>        <span class="hljs-comment">/*如果目标定时器不是链表的头节点，则将该定时器从链表中取出，然后插入其原来所在位置之后的部分链表中*/</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            timer-&gt;prev-&gt;next = timer-&gt;next;<br>            timer-&gt;next-&gt;prev = timer-&gt;prev;<br>            <span class="hljs-built_in">add_timer</span>( timer, timer-&gt;next );<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*将目标定时器timer从链表中删除*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del_timer</span><span class="hljs-params">( util_timer* timer )</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>( !timer )<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">/*下面这个条件成立表示链表中只有一个定时器，即目标定时器*/</span><br>        <span class="hljs-keyword">if</span>( ( timer == head ) &amp;&amp; ( timer == tail ) )<br>        &#123;<br>            <span class="hljs-keyword">delete</span> timer;<br>            head = <span class="hljs-literal">NULL</span>;<br>            tail = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>      <span class="hljs-comment">/*如果链表中至少有两个定时器，且目标定时器是链表的头结点，则将链表的头结点重置为原头节点的下一个节点，然后删除目标定时器*/</span><br>        <span class="hljs-keyword">if</span>( timer == head )<br>        &#123;<br>            head = head-&gt;next;<br>            head-&gt;prev = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">delete</span> timer;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>      <span class="hljs-comment">/*如果链表中至少有两个定时器，且目标定时器是链表的尾结点，则将链表的尾结点重置为原尾节点的前一个节点，然后删除目标定时器*/</span><br>        <span class="hljs-keyword">if</span>( timer == tail )<br>        &#123;<br>            tail = tail-&gt;prev;<br>            tail-&gt;next = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">delete</span> timer;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">/*如果目标定时器位于链表的中间，则把它前后的定时器串联起来，然后删除目标定时器*/</span><br>        timer-&gt;prev-&gt;next = timer-&gt;next;<br>        timer-&gt;next-&gt;prev = timer-&gt;prev;<br>        <span class="hljs-keyword">delete</span> timer;<br>    &#125;<br>    <span class="hljs-comment">/*SIGALRM信号每次被触发就在其信号处理函数(如果使用统一事件源，则是主函数)中执行一次tick函数，以处理链表上到期的任务*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tick</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>( !head )<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;timer tick\n&quot;</span> );<br>        <span class="hljs-keyword">time_t</span> cur = <span class="hljs-built_in">time</span>( <span class="hljs-literal">NULL</span> ); <span class="hljs-comment">/*获得系统当前的时间*/</span><br>        util_timer* tmp = head;  <br>        <span class="hljs-comment">/*从头结点开始依次处理每个定时器，直到遇到一个尚未到期的定时器，这就是定时器的核心逻辑*/</span><br>        <span class="hljs-keyword">while</span>( tmp )<br>        &#123;<br>        <span class="hljs-comment">/*因为每个定时器都使用绝对时间作为超时值，所以我们可以把定时器的超时值和系统当前时间，比较以判断定时器是否到期*/</span><br>            <span class="hljs-keyword">if</span>( cur &lt; tmp-&gt;expire )  <br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>           <span class="hljs-comment">/*调用定时器的回调函数，以执行定时任务*/</span><br>            tmp-&gt;<span class="hljs-built_in">cb_func</span>( tmp-&gt;user_data );<br>            <span class="hljs-comment">/*执行完定时器中的定时任务之后，就将它从链表中删除，并重置链表头结点*/</span><br>            head = tmp-&gt;next;<br>            <span class="hljs-comment">// 把前面封好</span><br>            <span class="hljs-keyword">if</span>( head )<br>            &#123;<br>                head-&gt;prev = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>            <span class="hljs-keyword">delete</span> tmp;<br>            <span class="hljs-comment">// tmp重新定位到第一个</span><br>            tmp = head;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">/*一个重载的辅助函数，它被公有的add_timer函数和adjust_timer函数调用。该函数表示将目标定时器timer添加到节点lst_head之后的部分链表中*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_timer</span><span class="hljs-params">( util_timer* timer, util_timer* lst_head )</span></span><br><span class="hljs-function">    </span>&#123;<br>        util_timer* prev = lst_head;<br>        util_timer* tmp = prev-&gt;next;<br>      <span class="hljs-comment">/*遍历lst_head节点之后的部分链表，直到找到一个超时时间大于目标定时器的超时时间的节点，并将目标定时器插入该节点之前*/</span><br>        <span class="hljs-keyword">while</span>( tmp )<br>        &#123;<br>            <span class="hljs-keyword">if</span>( timer-&gt;expire &lt; tmp-&gt;expire )<br>            &#123;<br>                prev-&gt;next = timer;<br>                timer-&gt;next = tmp;<br>                tmp-&gt;prev = timer;<br>                timer-&gt;prev = prev;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            prev = tmp;<br>            tmp = tmp-&gt;next;<br>        &#125;<br>      <span class="hljs-comment">/*如果遍历完lst_head节点之后的部分链表，仍未找到超时时间大于目标定时器的超时时间的节点，则将目标定时器插入链表尾部，并把它设置为链表新的尾节点*/</span><br>        <span class="hljs-keyword">if</span>( !tmp )<br>        &#123;<br>            prev-&gt;next = timer;<br>            timer-&gt;prev = prev;<br>            timer-&gt;next = <span class="hljs-literal">NULL</span>;<br>            tail = timer;<br>        &#125;<br>        <br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    util_timer* head;  <span class="hljs-comment">// 定一个头</span><br>    util_timer* tail;  <span class="hljs-comment">// 定一个尾巴</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>为了便于阅读，我们将实现包含在头文件中。sort_timer_lst是一个升序链表。其核心函数tick相当于一个心搏函数，它每隔一段固定的时间就执行一次，以检测并处理到期的任务。判断定时任务到期的依据是定时器的expire值小于当前的系统时间。从执行效率来看，添加定 时器的时间复杂度是O(n)，删除定时器的时间复杂度是O(1)，执行定时任务的时间复杂度是O(1)。</p>
<h3 id="1122-处理非活动连接"><a class="markdownIt-Anchor" href="#1122-处理非活动连接"></a> 11.2.2 处理非活动连接</h3>
<p>现在我们考虑上述升序定时器链表的实际应用——<strong>处理非活动连接</strong>。服务器程序通常要定期处理非活动连接:给客户端<u>发一个重连请求</u>，或者<u>关闭该连接</u>，或者其他。Linux在内核中提供了对连接是否处于活动状态的定期检查机制，我们可以通过socket选项KEEPALIVE来激活它。不过使用这种方式将使得应用程序对连接的管理变得复杂。因此，我们可以考虑在应用层实现类似于KEEPALIVE的机制，以管理 所有长时间处于非活动状态的连接。比如，代码清单11-3利用alarm函数周期性地触发SIGALRM信号，该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务——关闭非活动的连接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;lst_timer.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FD_LIMIT 65535</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TIMESLOT 5</span><br><span class="hljs-comment">// 设置管道</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> pipefd[<span class="hljs-number">2</span>];<br><span class="hljs-comment">/*利用代码清单11-2中的升序链表来管理定时器*/</span><br><span class="hljs-keyword">static</span> sort_timer_lst timer_lst;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> epollfd = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 将文件描述符设置成非阻塞态，并返回文件描述符之前的阻塞态</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">( <span class="hljs-keyword">int</span> fd )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> old_option = <span class="hljs-built_in">fcntl</span>( fd, F_GETFL );<br>    <span class="hljs-keyword">int</span> new_option = old_option | O_NONBLOCK;<br>    <span class="hljs-built_in">fcntl</span>( fd, F_SETFL, new_option );<br>    <span class="hljs-keyword">return</span> old_option;<br>&#125;<br><span class="hljs-comment">/*将文件描述符fd上的EPOLLIN注册到epollfd指示的epoll内核事件表中*/</span><br><span class="hljs-comment">// ET模式</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">( <span class="hljs-keyword">int</span> epollfd, <span class="hljs-keyword">int</span> fd )</span></span><br><span class="hljs-function"></span>&#123;<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN | EPOLLET;<br>    <span class="hljs-built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_ADD, fd, &amp;event );<br>    <span class="hljs-built_in">setnonblocking</span>( fd );<br>&#125;<br><span class="hljs-comment">// sig信号处理函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sig_handler</span><span class="hljs-params">( <span class="hljs-keyword">int</span> sig )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> save_errno = errno;  <span class="hljs-comment">// 记录初始状态</span><br>    <span class="hljs-keyword">int</span> msg = sig;  <span class="hljs-comment">// 记录信号值</span><br>    <span class="hljs-built_in">send</span>( pipefd[<span class="hljs-number">1</span>], ( <span class="hljs-keyword">char</span>* )&amp;msg, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> );  <span class="hljs-comment">// 将信号值写入到管道中</span><br>    errno = save_errno;  <span class="hljs-comment">// 还原初始状态</span><br>&#125;<br><span class="hljs-comment">// 设置捕捉信号以及绑定处理函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addsig</span><span class="hljs-params">( <span class="hljs-keyword">int</span> sig )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">sa</span>;</span><br>    <span class="hljs-built_in">memset</span>( &amp;sa, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( sa ) );<br>    sa.sa_handler = sig_handler;  <span class="hljs-comment">// 绑定处理信号</span><br>    sa.sa_flags |= SA_RESTART; <span class="hljs-comment">// 设置信号收到信号时，重新调用被改信号终止的系统调用</span><br>    <span class="hljs-built_in">sigfillset</span>( &amp;sa.sa_mask ); <span class="hljs-comment">// 在信号集中设置所有的信号，为了交给主循环处理，统一事件源</span><br>    <span class="hljs-built_in">assert</span>( <span class="hljs-built_in">sigaction</span>( sig, &amp;sa, <span class="hljs-literal">NULL</span> ) != <span class="hljs-number">-1</span> ); <span class="hljs-comment">// 捕获信号，按照sa配置文件处理</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">timer_handler</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*定时处理任务，实际上就是调用tick函数*/</span><br>    timer_lst.<span class="hljs-built_in">tick</span>();<br>    <span class="hljs-comment">/*因为一次alarm调用只会引起一次SIGALRM信号，所以我们要重新定时，以不断触发SIGALRM信号*/</span><br>    <span class="hljs-built_in">alarm</span>( TIMESLOT );<br>&#125;<br><span class="hljs-comment">/*定时器回调函数，它删除非活动连接socket上的注册事件，并关闭之*/</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cb_func</span><span class="hljs-params">( client_data* user_data )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_DEL, user_data-&gt;sockfd, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( user_data );<br>    <span class="hljs-built_in">close</span>( user_data-&gt;sockfd );<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;close fd %d\n&quot;</span>, user_data-&gt;sockfd );<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取ip 和 port</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 创建ipv4的socket地址</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-keyword">int</span> listenfd = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( listenfd &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// socket命名</span><br>    ret = <span class="hljs-built_in">bind</span>( listenfd, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 监听socket</span><br>    ret = <span class="hljs-built_in">listen</span>( listenfd, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 创建epoll的事件结构体【epoll事件，和用户数据】数组用来装提取出的就绪事件</span><br>    epoll_event events[ MAX_EVENT_NUMBER ];<br>    <span class="hljs-comment">// 创建大小为5的epoll内核事件表【用来找到就绪的事件，类似一个渔网捞一网】</span><br>    <span class="hljs-keyword">int</span> epollfd = <span class="hljs-built_in">epoll_create</span>( <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( epollfd != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 注册监听事件</span><br>    <span class="hljs-built_in">addfd</span>( epollfd, listenfd );<br>     <span class="hljs-comment">/*使用socketpair创建管道*/</span><br>    ret = <span class="hljs-built_in">socketpair</span>( PF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, pipefd );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 设置管道写为非阻塞</span><br>    <span class="hljs-built_in">setnonblocking</span>( pipefd[<span class="hljs-number">1</span>] );<br>    <span class="hljs-comment">// 将管道读注册</span><br>    <span class="hljs-built_in">addfd</span>( epollfd, pipefd[<span class="hljs-number">0</span>] );<br><br>    <span class="hljs-comment">/*设置信号处理函数*/</span><br>    <span class="hljs-built_in">addsig</span>( SIGALRM );<br>    <span class="hljs-built_in">addsig</span>( SIGTERM );<br>    <span class="hljs-keyword">bool</span> stop_server = <span class="hljs-literal">false</span>;<br>    <br>    client_data* users = <span class="hljs-keyword">new</span> client_data[FD_LIMIT]; <br>    <span class="hljs-keyword">bool</span> timeout = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">alarm</span>( TIMESLOT ); <span class="hljs-comment">/*定时*/</span><br><br>    <span class="hljs-keyword">while</span>( !stop_server )<br>    &#123;<br>        <span class="hljs-comment">// 获取就绪的事件</span><br>        <span class="hljs-keyword">int</span> number = <span class="hljs-built_in">epoll_wait</span>( epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span> );<br>        <span class="hljs-keyword">if</span> ( ( number &lt; <span class="hljs-number">0</span> ) &amp;&amp; ( errno != EINTR ) )<br>        &#123;<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;epoll failure\n&quot;</span> );<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <br>        <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++ )<br>        &#123;<br>            <span class="hljs-keyword">int</span> sockfd = events[i].data.fd;<br>            <span class="hljs-comment">/*处理新到的客户连接*/</span><br>            <span class="hljs-keyword">if</span>( sockfd == listenfd )<br>            &#123;<br>                <span class="hljs-comment">// 创建ipv4的socket地址用来装发送端的ip</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_address</span>;</span><br>                <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client_address );<br>                <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );<br>                <span class="hljs-comment">// 注册连接事件</span><br>                <span class="hljs-built_in">addfd</span>( epollfd, connfd );<br>                <span class="hljs-comment">// 初始化连接用户的信息和对应的socket</span><br>                users[connfd].address = client_address;<br>                users[connfd].sockfd = connfd;<br>                <span class="hljs-comment">/*创建定时器，设置其回调函数与超时时间，然后绑定定时器与用户数据，最后将定时器添加到链表timer_lst中*/</span><br>                util_timer* timer = <span class="hljs-keyword">new</span> util_timer;<br>                timer-&gt;user_data = &amp;users[connfd];<br>                timer-&gt;cb_func = cb_func;<br>                <span class="hljs-keyword">time_t</span> cur = <span class="hljs-built_in">time</span>( <span class="hljs-literal">NULL</span> );<br>                timer-&gt;expire = cur + <span class="hljs-number">3</span> * TIMESLOT;<br>                users[connfd].timer = timer;<br>                timer_lst.<span class="hljs-built_in">add_timer</span>( timer );<br>            &#125;<br>            <span class="hljs-comment">/*处理信号【就绪的读事件】*/</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( ( sockfd == pipefd[<span class="hljs-number">0</span>] ) &amp;&amp; ( events[i].events &amp; EPOLLIN ) )<br>            &#123;<br>                <span class="hljs-keyword">int</span> sig;<br>                <span class="hljs-keyword">char</span> signals[<span class="hljs-number">1024</span>];<br>                <span class="hljs-comment">// 将管道里数据读到signals【因为信号处理函数就是用管道传输当前信号是啥】</span><br>                ret = <span class="hljs-built_in">recv</span>( pipefd[<span class="hljs-number">0</span>], signals, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( signals ), <span class="hljs-number">0</span> );<br>                <span class="hljs-keyword">if</span>( ret == <span class="hljs-number">-1</span> )<br>                &#123;<br>                    <span class="hljs-comment">// handle the error</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( ret == <span class="hljs-number">0</span> )<br>                &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; ++i )<br>                    &#123;<br>                        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>( signals[i] )<br>                        &#123;<br>                            <span class="hljs-keyword">case</span> SIGALRM:<br>                            &#123;<br>   <span class="hljs-comment">/*用timeout变量标记有定时任务需要处理，但不立即处理定时任务。这是因为定时任务的优先级不是很高，我们优先处理其他更重要的任务*/</span><br>                                timeout = <span class="hljs-literal">true</span>;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                            <span class="hljs-keyword">case</span> SIGTERM:<br>                            &#123;<br>                                stop_server = <span class="hljs-literal">true</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">/*处理客户连接上接收到的数据【单纯的读写任务】*/</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(events[i].events &amp; EPOLLIN )<br>            &#123;<br>                <span class="hljs-built_in">memset</span>( users[sockfd].buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE );<br>                <span class="hljs-comment">// 直接将数据存入特定的用户结构体的缓冲区</span><br>                ret = <span class="hljs-built_in">recv</span>( sockfd, users[sockfd].buf, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span> );<br>                <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;get %d bytes of client data %s from %d\n&quot;</span>, ret, users[sockfd].buf, sockfd );<br>                util_timer* timer = users[sockfd].timer;<br>                <span class="hljs-keyword">if</span>( ret &lt; <span class="hljs-number">0</span> )<br>                &#123;<br>                   <span class="hljs-comment">/*如果发生读错误，则关闭连接，并移除其对应的定时器*/</span><br>                    <span class="hljs-keyword">if</span>( errno != EAGAIN )<br>                    &#123;<br>                        <span class="hljs-built_in">cb_func</span>( &amp;users[sockfd] );<br>                        <span class="hljs-keyword">if</span>( timer )<br>                        &#123;<br>                            timer_lst.<span class="hljs-built_in">del_timer</span>( timer );<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( ret == <span class="hljs-number">0</span> )<br>                &#123;<br>                    <span class="hljs-comment">/*如果对方已经关闭连接，则我们也关闭连接，并移除对应的定时器，单独为该用户设置的*/</span><br>                    <span class="hljs-built_in">cb_func</span>( &amp;users[sockfd] );<br>                    <span class="hljs-keyword">if</span>( timer )<br>                    &#123;<br>                        timer_lst.<span class="hljs-built_in">del_timer</span>( timer );<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-comment">/*如果某个客户连接上有数据可读，则我们要调整该连接对应的定时器，以延迟该连接被关闭的时间*/</span><br>                &#123;<br>                    <span class="hljs-comment">//send( sockfd, users[sockfd].buf, BUFFER_SIZE-1, 0 );</span><br>                    <span class="hljs-keyword">if</span>( timer )<br>                    &#123;<br>                        <span class="hljs-keyword">time_t</span> cur = <span class="hljs-built_in">time</span>( <span class="hljs-literal">NULL</span> );<br>                        timer-&gt;expire = cur + <span class="hljs-number">3</span> * TIMESLOT;<br>                        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;adjust timer once\n&quot;</span> );<br>                        timer_lst.<span class="hljs-built_in">adjust_timer</span>( timer );<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// others</span><br>            &#125;<br>        &#125;<br>       <span class="hljs-comment">/*最后处理定时事件，因为I/O事件有更高的优先级。当然，这样做将导致定时任务不能精确地按照预期的时间执行*/</span><br>        <span class="hljs-keyword">if</span>( timeout )<br>        &#123;<br>            <span class="hljs-built_in">timer_handler</span>();<br>            timeout = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 处理完定时事件后就设置false表示没有剩余的定时事件了</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( listenfd );<br>    <span class="hljs-built_in">close</span>( pipefd[<span class="hljs-number">1</span>] );<br>    <span class="hljs-built_in">close</span>( pipefd[<span class="hljs-number">0</span>] );<br>    <span class="hljs-keyword">delete</span> [] users;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="113-io复用系统调用的超时参数"><a class="markdownIt-Anchor" href="#113-io复用系统调用的超时参数"></a> 11.3 I/O复用系统调用的超时参数</h2>
<p>Linux下的3组I/O复用系统调用都带有超时参数，因此它们不仅能统一处理信号和I/O事件，也能统一处理定时事件。但是由于I/O复用系统调用可能在超时时间到期之前就返回(有I/O事件发生)，所以如果我们要利用它们来定时，就需要<u>不断更新定时参数以反映剩余的时间</u>，如代码清单11-4所示。</p>
<p>代码清单11-4 利用I/O复用系统调用定时</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TIMEOUT 5000</span><br><br><span class="hljs-keyword">int</span> timeout = TIMEOUT;<br><span class="hljs-keyword">time_t</span> start = <span class="hljs-built_in">time</span>( <span class="hljs-literal">NULL</span> );<br><span class="hljs-keyword">time_t</span> end = <span class="hljs-built_in">time</span>( <span class="hljs-literal">NULL</span> );<br><span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> )<br>&#123;<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;the timeout is now %d mill-seconds\n&quot;</span>, timeout );<br>    start = <span class="hljs-built_in">time</span>( <span class="hljs-literal">NULL</span> );<br>    <span class="hljs-comment">// 获取就绪事件</span><br>    <span class="hljs-keyword">int</span> number = <span class="hljs-built_in">epoll_wait</span>( epollfd, events, MAX_EVENT_NUMBER, timeout );<br>    <span class="hljs-keyword">if</span>( ( number &lt; <span class="hljs-number">0</span> ) &amp;&amp; ( errno != EINTR ) )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;epoll failure\n&quot;</span> );<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">/*如果epoll_wait成功返回0，则说明超时时间到【也就是I/O结束了】此时便可处理定时任务，并重置定时时间*/</span><br>    <span class="hljs-keyword">if</span>( number == <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-comment">// timeout</span><br>        timeout = TIMEOUT;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    end = <span class="hljs-built_in">time</span>( <span class="hljs-literal">NULL</span> );<br><span class="hljs-comment">/*如果epoll_wait的返回值大于0，则本次epoll_wait调用持续的时间是(end-start)*1000 ms，我们需要将定时时间timeout减去这段时间，以获得下次epoll_wait调用的超时参数*/</span><br>    timeout -= ( end - start ) * <span class="hljs-number">1000</span>;<br><span class="hljs-comment">/*重新计算之后的timeout值有可能等于0，说明本次epoll_wait调用返回时，不仅有文件描述符就绪，而且其超时时间也刚好到达，此时我们也要处理定时任务，并重置定时时间*/</span><br>    <span class="hljs-keyword">if</span>( timeout &lt;= <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-comment">// timeout</span><br>        timeout = TIMEOUT;<br>    &#125;<br>    <span class="hljs-comment">// handle connections</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>也就是epoll_wait这个操作我就给你TIMEOUT的时间长度来用，用过了就休息了。</p>
<h2 id="114-高性能定时器"><a class="markdownIt-Anchor" href="#114-高性能定时器"></a> 11.4 高性能定时器</h2>
<h3 id="1141-时间轮"><a class="markdownIt-Anchor" href="#1141-时间轮"></a> 11.4.1 时间轮</h3>
<p>前文提到，基于排序链表的定时器存在一个问题:<u>添加定时器的效率偏低</u>。下面我们要讨论的时间轮解决了这个问题。一种简单的时间轮如图11-1所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205281724469.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-28 下午5.24.56" /></p>
<p>图11-1所示的时间轮内，(实线)指针指向轮子上的一个槽 (slot)。它以恒定的速度顺时针转动，每转动一步就指向下一个槽 (虚线指针指向的槽)</p>
<ul>
<li>每次转动称为一个滴答(tick)。</li>
<li>一个滴答的时间称为时间轮的槽间隔si(slot interval)，它实际上就是心搏时间。</li>
<li>该时间轮共有N个槽，因此它运转一周的时间是N * si。每个槽指向一条定时器链表，每条链表上的定时器具有相同的特征:<strong>它们的定时时间相差N * si的整数倍</strong>。</li>
</ul>
<p>时间轮正是利用这个关系将定时器散列到不同的链表中。假如现在指针指向槽cs，我们要添加一个定时时间为ti的定时器，则该定时器将被插入槽ts(timer slot)对应的链表中:</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205281745151.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-28 下午5.45.33" /></p>
<p>基于排序链表的定时器使用唯一的一条链表来管理所有定时器，所以插入操作的效率随着定时器数目的增多而降低。而时间轮使用哈希表的思想，将定时器散列到不同的链表上。这样每条链表上的定时器数目都将明显少于原来的排序链表上的定时器数目，插入操作的效率基本不受定时器数目的影响。</p>
<p>很显然，对时间轮而言，要提高定时精度，就要使si值足够小;要提高执行效率，则要求N值足够大。</p>
<p>图11-1描述的是一种简单的时间轮，因为它只有一个轮子。而复杂的时间轮可能有多个轮子，不同的轮子拥有不同的粒度。相邻的两个 轮子，精度高的转一圈，精度低的仅往前移动一槽，就像水表一样。 下面将按照图11-1来编写一个较为简单的时间轮实现代码，如代码清单11-5所示。</p>
<p>代码清单11-5 时间轮</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> TIME_WHEEL_TIMER</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TIME_WHEEL_TIMER</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 64</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">tw_timer</span>;</span><br><span class="hljs-comment">/*绑定socket和定时器*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">client_data</span></span><br><span class="hljs-class">&#123;</span><br>    sockaddr_in address;<br>    <span class="hljs-keyword">int</span> sockfd;<br>    <span class="hljs-keyword">char</span> buf[ BUFFER_SIZE ];<br>    tw_timer* timer;<br>&#125;;<br><span class="hljs-comment">/*定时器类*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">tw_timer</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">tw_timer</span>( <span class="hljs-keyword">int</span> rot, <span class="hljs-keyword">int</span> ts ) <br>    : <span class="hljs-built_in">next</span>( <span class="hljs-literal">NULL</span> ), <span class="hljs-built_in">prev</span>( <span class="hljs-literal">NULL</span> ), <span class="hljs-built_in">rotation</span>( rot ), <span class="hljs-built_in">time_slot</span>( ts )&#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> rotation; <span class="hljs-comment">/*记录定时器在时间轮转多少圈后生效*/</span><br>    <span class="hljs-keyword">int</span> time_slot; <span class="hljs-comment">/*记录定时器属于时间轮上哪个槽(对应的链表，下同)*/</span><br>    <span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (*cb_func)( client_data* ); <span class="hljs-comment">/*定时器回调函数*/</span><br>    client_data* user_data; <span class="hljs-comment">/*客户数据*/</span><br>    tw_timer* next; <span class="hljs-comment">/*指向下一个定时器*/</span><br>    tw_timer* prev; <span class="hljs-comment">/*指向前一个定时器*/</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">time_wheel</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">time_wheel</span>() : <span class="hljs-built_in">cur_slot</span>( <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i )<br>        &#123;<br>            slots[i] = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/*初始化每个槽的头结点*/</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*遍历每个槽，并销毁其中的定时器*/</span><br>    ~<span class="hljs-built_in">time_wheel</span>()<br>    &#123;<br>        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i )<br>        &#123;<br>            tw_timer* tmp = slots[i];<br>            <span class="hljs-keyword">while</span>( tmp )<br>            &#123;<br>                slots[i] = tmp-&gt;next;<br>                <span class="hljs-keyword">delete</span> tmp;<br>                tmp = slots[i];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*根据定时值timeout创建一个定时器，并把它插入合适的槽中*/</span><br>    <span class="hljs-function">tw_timer* <span class="hljs-title">add_timer</span><span class="hljs-params">( <span class="hljs-keyword">int</span> timeout )</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>( timeout &lt; <span class="hljs-number">0</span> )<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> ticks = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/*下面根据待插入定时器的超时值计算它将在时间轮转动多少个滴答后被触发，并将该滴答数存储于变量ticks中[转换了一种新的方式去衡量超市事件】。如果待插入定时器的超时值小于时间轮的槽间隔TI，则将ticks向上折合为1，否则就将ticks向下折合为timeout/TI*/</span><br>        <span class="hljs-keyword">if</span>( timeout &lt; TI )  <br>        &#123;<br>            ticks = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            ticks = timeout / TI;<br>        &#125;<br>        <span class="hljs-comment">/*计算待插入的定时器在时间轮转动多少圈后被触发*/</span><br>        <span class="hljs-keyword">int</span> rotation = ticks / N;<br>        <span class="hljs-comment">/*计算待插入的定时器应该被插入哪个槽中*/</span><br>        <span class="hljs-keyword">int</span> ts = ( cur_slot + ( ticks % N ) ) % N;<br>        <span class="hljs-comment">/*创建新的定时器，它在时间轮转动rotation圈之后被触发，且位于第ts个槽上*/</span><br>        tw_timer* timer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">tw_timer</span>( rotation, ts );<br>      <span class="hljs-comment">/*如果第ts个槽中尚无任何定时器，则把新建的定时器插入其中，并将该定时器设置为该槽的头结点*/</span><br>        <span class="hljs-keyword">if</span>( !slots[ts] )<br>        &#123;<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;add timer, rotation is %d, ts is %d, cur_slot is %d\n&quot;</span>, rotation, ts, cur_slot );<br>            slots[ts] = timer;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">/*否则，将定时器插入第ts个槽中*/</span><br>        &#123;<br>            timer-&gt;next = slots[ts];<br>            slots[ts]-&gt;prev = timer;<br>            slots[ts] = timer;<br>        &#125;<br>        <span class="hljs-keyword">return</span> timer;<br>    &#125;<br>    <span class="hljs-comment">/*删除目标定时器timer*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del_timer</span><span class="hljs-params">( tw_timer* timer )</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>( !timer )<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">/*slots[ts]是目标定时器所在槽的头结点。如果目标定时器就是该头结点，则需要重置第ts个槽的头结点*/</span><br>        <span class="hljs-keyword">int</span> ts = timer-&gt;time_slot;<br>        <span class="hljs-keyword">if</span>( timer == slots[ts] ) <span class="hljs-comment">// 如果是头节点</span><br>        &#123;<br>            slots[ts] = slots[ts]-&gt;next;<br>            <span class="hljs-keyword">if</span>( slots[ts] )<br>            &#123;<br>                slots[ts]-&gt;prev = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>            <span class="hljs-keyword">delete</span> timer;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">// 如果不是</span><br>        &#123;<br>            timer-&gt;prev-&gt;next = timer-&gt;next;<br>            <span class="hljs-keyword">if</span>( timer-&gt;next )<br>            &#123;<br>                timer-&gt;next-&gt;prev = timer-&gt;prev;<br>            &#125;<br>            <span class="hljs-keyword">delete</span> timer;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*TI时间到后，调用该函数，时间轮向前滚动一个槽的间隔*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tick</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        tw_timer* tmp = slots[cur_slot]; <span class="hljs-comment">/*取得时间轮上当前槽的头结点*/</span><br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;current slot is %d\n&quot;</span>, cur_slot );<br>        <span class="hljs-keyword">while</span>( tmp )<br>        &#123;<br>            <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;tick the timer once\n&quot;</span> );<br>            <span class="hljs-comment">/*如果定时器的rotation值大于0，则它在这一轮不起作用[还需要接着转]*/</span><br>            <span class="hljs-keyword">if</span>( tmp-&gt;rotation &gt; <span class="hljs-number">0</span> )<br>            &#123;<br>                tmp-&gt;rotation--;<br>                tmp = tmp-&gt;next;<br>            &#125;<br>            <span class="hljs-comment">/*否则，说明定时器已经到期，于是执行定时任务，然后删除该定时器*/</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tmp-&gt;<span class="hljs-built_in">cb_func</span>( tmp-&gt;user_data );<br>                <span class="hljs-keyword">if</span>( tmp == slots[cur_slot] )  <span class="hljs-comment">// 如果是头节点</span><br>                &#123;<br>                    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;delete header in cur_slot\n&quot;</span> );<br>                    slots[cur_slot] = tmp-&gt;next;<br>                    <span class="hljs-keyword">delete</span> tmp;<br>                    <span class="hljs-keyword">if</span>( slots[cur_slot] )<br>                    &#123;<br>                        slots[cur_slot]-&gt;prev = <span class="hljs-literal">NULL</span>;<br>                    &#125;<br>                    tmp = slots[cur_slot];<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-comment">// 如果是中间节点</span><br>                &#123;<br>                    tmp-&gt;prev-&gt;next = tmp-&gt;next;<br>                    <span class="hljs-keyword">if</span>( tmp-&gt;next )<br>                    &#123;<br>                        tmp-&gt;next-&gt;prev = tmp-&gt;prev;<br>                    &#125;<br>                    tw_timer* tmp2 = tmp-&gt;next;<br>                    <span class="hljs-keyword">delete</span> tmp;<br>                    tmp = tmp2;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*更新时间轮的当前槽，以反映时间轮的转动*/</span><br>        cur_slot = ++cur_slot % N;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">/*时间轮上槽的数目*/</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">60</span>;<br>    <span class="hljs-comment">/*每1 s时间轮转动一次，即槽间隔为1 s*/</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> TI = <span class="hljs-number">1</span>; <br>    <span class="hljs-comment">/*时间轮的槽，其中每个元素指向一个定时器链表，链表无序*/</span><br>    tw_timer* slots[N];<br>    <span class="hljs-comment">/*时间轮的当前槽*/</span><br>    <span class="hljs-keyword">int</span> cur_slot;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>可见，对时间轮而言，添加一个定时器的时间复杂度是O(1)， 删除一个定时器的时间复杂度也是O(1)，执行一个定时器的时间复杂度是O(n)。但实际上执行一个定时器任务的效率要比O(n)好得多，因为时间轮将所有的定时器散列到了不同的链表上。时间轮的槽越多，等价于散列表的入口(entry)越多，从而每条链表上的定时器数量越少。此外，我们的代码仅使用了一个时间轮。当使用多个轮子来实现时间轮时，执行一个定时器任务的时间复杂度将接近O(1)。读者不妨把代码清单11-3稍做修改，用时间轮来代替排序链表，以查看时间轮的工作方式和效率。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/05/21/%E5%85%AB%E8%82%A1%E6%96%87/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">c++及八股文基础知识</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/15/codeTop/">
                        <span class="hidden-mobile">CodeTop</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
