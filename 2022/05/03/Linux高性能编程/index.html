

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="第1章 TCP&#x2F;IP协议族  1.1 TCP&#x2F;IP协议族体系结构以及主要协议   1.1.1 数据链路层 ARP和RARP协议实现了IP地址和机器物理地址(通 常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址) 之间的相互转换  ARP协议（Address Resolve Protocol，地址解析协议） 网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻址一台机器，">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux高性能服务器编程">
<meta property="og:url" content="http://example.com/2022/05/03/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第1章 TCP&#x2F;IP协议族  1.1 TCP&#x2F;IP协议族体系结构以及主要协议   1.1.1 数据链路层 ARP和RARP协议实现了IP地址和机器物理地址(通 常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址) 之间的相互转换  ARP协议（Address Resolve Protocol，地址解析协议） 网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻址一台机器，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071505040.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071505484.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071504810.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052119363.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052118653.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052118513.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052119640.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052120702.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052117137.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052125476.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052126399.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052130947.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052133025.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071553191.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205072139077.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205072159863.png">
<meta property="article:published_time" content="2022-05-02T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-07T14:07:40.452Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071505040.png">
  
  <title>Linux高性能服务器编程 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>PanPan</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/Title%20page/title.jpeg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Linux高性能服务器编程">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-05-03 00:00" pubdate>
        2022年5月3日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      17k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      54 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Linux高性能服务器编程</h1>
            
            <div class="markdown-body">
              <h1 id="第1章-tcpip协议族"><a class="markdownIt-Anchor" href="#第1章-tcpip协议族"></a> 第1章 TCP/IP协议族</h1>
<h2 id="11-tcpip协议族体系结构以及主要协议"><a class="markdownIt-Anchor" href="#11-tcpip协议族体系结构以及主要协议"></a> 1.1 TCP/IP协议族体系结构以及主要协议</h2>
<img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071505040.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-07 下午3.05.28" style="zoom:200%;" />
<h3 id="111-数据链路层"><a class="markdownIt-Anchor" href="#111-数据链路层"></a> 1.1.1 数据链路层</h3>
<p><strong>ARP和RARP协议</strong>实现了IP地址和机器物理地址(通 常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址) 之间的相互转换</p>
<h4 id="arp协议address-resolve-protocol地址解析协议"><a class="markdownIt-Anchor" href="#arp协议address-resolve-protocol地址解析协议"></a> ARP协议（Address Resolve Protocol，地址解析协议）</h4>
<p>网络层使用<strong>IP地址</strong>寻址一台机器，而数据链路层使用<strong>物理地址</strong>寻址一台机器，因此网络层必须先将目标机器的<u>IP地址转化成其物理地址</u>，才能使用数据链路层提供的服务。</p>
<h4 id="rarp协议reverse-address-resolve-protocol逆地址解析协议"><a class="markdownIt-Anchor" href="#rarp协议reverse-address-resolve-protocol逆地址解析协议"></a> RARP协议(Reverse Address Resolve Protocol，逆地址解析协议)</h4>
<p>用于网络上的某些无盘工作站。因为缺乏存储设备，无盘工作站无法记住自己的IP地址，但它们可以利用网卡上的物理地址来向网络管理者(服务器或网络管理软件)查询自身的IP地址。</p>
<p>PS：运行RARP服 务的网络管理者通常存有该网络上所有机器的物理地址到IP地址的映射。</p>
<h3 id="112-网络层"><a class="markdownIt-Anchor" href="#112-网络层"></a> 1.1.2 网络层</h3>
<p>网络层实现数据包的选路和转发。</p>
<p>通信的两台主机一般<u>不是直接相连</u>的，而是通过多个中间节点(路由器)连接的就是选择这些中间节点，以确定两台主机之间的通信路径。同时，网络层对上层协议<u>隐藏了网络拓扑连接</u>的细节，使得在<u>传输层和网络应用程序</u><u>看来，通信的双方是直接相连</u>的。</p>
<h4 id="ip协议internet-protocol因特网协议"><a class="markdownIt-Anchor" href="#ip协议internet-protocol因特网协议"></a> IP协议（Internet Protocol，因特网协议）</h4>
<p>step 1: IP协议<strong>根据数据包的目的IP地址</strong>来决定如何投递它。</p>
<p>step 2: 如果数据包<u>不能直接发送</u>给目标主机，那么IP协议就为它<strong>寻找一个合适的下一跳(next hop)<strong>路由器，并将数据包</strong>交付给该路由器</strong>来转发。</p>
<p>重复step1、2直到最后发送到目的地，或者由于发送失败而丢弃。</p>
<p>PS：IP协议使用逐跳(hop by hop)的方式确定通信路径</p>
<h4 id="icmp协议internet-control-message-protocol-因特网控制报文协议"><a class="markdownIt-Anchor" href="#icmp协议internet-control-message-protocol-因特网控制报文协议"></a> ICMP协议（Internet Control Message Protocol， 因特网控制报文协议）</h4>
<p>它是IP协议的重要补充，主要用于<strong>检测网络连接</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071505484.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-07 下午3.04.44" /></p>
<p>主要分两种：1）用来回应网络错误 2）用来查询网络信息如ping程序</p>
<p>ICMP协议并非严格意义上的网络层协议，因为它使用处于同一层的IP协议提供的服务(一般来说，上层协议使用下层协议提供的服务)。</p>
<h3 id="113-传输层"><a class="markdownIt-Anchor" href="#113-传输层"></a> 1.1.3 传输层</h3>
<p>传输层为两台主机上的应用程序提供<strong>端到端(end to end)<strong>的通信。与网络层使用的逐跳通信方式不同，传输层</strong>只关心通信的起始端和目的端，而不在乎数据包的中转过程</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071504810.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-07 下午3.04.16" /></p>
<p>垂直的实线箭头表示TCP/IP协议族各层之间的<strong>实体通信</strong>，而水平的虚线箭头表示<strong>逻辑通信线路</strong>。该图中还附带描述了<strong>不同物理网络的连接方法</strong>。可见，数据链路层(驱动程序)<strong>封装了物理网络的电气细节</strong>;网络层<strong>封装了网络连接</strong>的细节;传输层则为应用程序<strong>封装了一条端到端的逻辑通信链路</strong>，它负责数据<u>的收发、链路的超时重连</u>等。</p>
<h4 id="tcp协议transmission-control-protocol传输控制协议"><a class="markdownIt-Anchor" href="#tcp协议transmission-control-protocol传输控制协议"></a> TCP协议(Transmission Control Protocol，传输控制协议)</h4>
<p>1、为应用层提供<u>可靠的、面向连接的和基于流(stream)</u>的服务。</p>
<p>2、TCP协议使用<u>超时重传、数据确认</u>等方式来<strong>确保数据包被正确地发送至目的端</strong>，因此TCP服务是<strong>可靠</strong>的。</p>
<p>3、使用TCP协议通信的双方必须<strong>先建立TCP连接</strong>， 并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等。</p>
<p>4、当通信结束时，双方必须关闭连接以释放这些内核数据。</p>
<p>5、TCP服务是基于流的。<strong>基于流的数据没有边界(长度)限制</strong>，它<u>源源不断地从通信的一端流入另一端</u>。</p>
<p>6、发送端可以逐个 字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出。</p>
<h4 id="udp协议user-datagram-protocol用户数据报协议"><a class="markdownIt-Anchor" href="#udp协议user-datagram-protocol用户数据报协议"></a> UDP协议(User Datagram Protocol，用户数据报协议)</h4>
<p>它为应用层提供<u>不可靠、无连接和基于数据报</u>的服务。（与TCP完全相反）</p>
<p>1、<strong>“不可靠”<strong>意味着UDP协议无法保证数据从发送端正确地传送到目的端。如果数据在</strong>中途丢失</strong>，或者目的端通过数据校验<strong>发现数据错误而将其丢弃</strong>，则UDP协议只是<strong>简单地通知应用程序发送失败</strong>。因此，使用UDP协议的应用程序通常要<u>自己处理数据确认、超时重传</u>等逻辑。</p>
<p>2、UDP协议是无连接的，即<strong>通信双方不保持一个长久的联系</strong>，因此应用程序<strong>每次发送数据都要明确指定接收端的地址</strong>(IP地址等信息)。</p>
<p>3、基于数据报的服务，<u>是相对基于流的服务而言的</u>。每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一 次性读出，否则数据将被截断。</p>
<h4 id="sctp协议stream-control-transmission-protocol流控制传输协议"><a class="markdownIt-Anchor" href="#sctp协议stream-control-transmission-protocol流控制传输协议"></a> SCTP协议(Stream Control Transmission Protocol，流控制传输协议)</h4>
<p>是一种相对较新的传输层协议，它是为了在因特网上传输电话信号而设计的。</p>
<h3 id="114-应用层"><a class="markdownIt-Anchor" href="#114-应用层"></a> 1.1.4 应用层</h3>
<p>应用层负责处理应用程序的逻辑。</p>
<p>内核态：<u>数据链路层、网络层和传输层</u>负责处理网络通信细节，这部分必须既稳定又高效，因此它们都在内核空间中实现</p>
<p>用户态：应用层则在用户空间实现，因为它负责处理众多逻辑，比如文件传输、名称查询和网络管理等。</p>
<h4 id="ping应用程序"><a class="markdownIt-Anchor" href="#ping应用程序"></a> ping应用程序</h4>
<p>它利用ICMP报文检测网络连接，是调试网络环境的必备工具。</p>
<h4 id="telnet协议"><a class="markdownIt-Anchor" href="#telnet协议"></a> telnet协议</h4>
<p>它使我们能在本地完成远程任务</p>
<h4 id="ospfopen-shortest-path-first开放最短路径优先协议"><a class="markdownIt-Anchor" href="#ospfopen-shortest-path-first开放最短路径优先协议"></a> OSPF(Open Shortest Path First，开放最短路径优先)协议</h4>
<p>是一种动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由信息。</p>
<h4 id="dnsdomain-name-service域名服务协议"><a class="markdownIt-Anchor" href="#dnsdomain-name-service域名服务协议"></a> DNS(Domain Name Service，域名服务)协议</h4>
<p>提供机器域名到IP地址的转换，我们将在后面简要介绍DNS协议。</p>
<p>应用层协议(或程序)可能跳过传输层直接使用网络层提供的服务，比如ping程序和OSPF协议。应用层协议(或程序)通常既可以使用TCP服务，又可以使用UDP服务，比如DNS协议。我们可以通过/etc/services文件查看所有知名的应用层协议，以及它们都能使用哪些传输层服务。</p>
<h2 id="12-封装"><a class="markdownIt-Anchor" href="#12-封装"></a> 1.2 封装</h2>
<p>上层协议是如何使用下层协议提供的服务的呢?其实这是通过封装(encapsulation)实现的。</p>
<p>应用程序数据在发送到物理网络上之前， 将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加上自己的头部信息(有时还包括尾部信息)，以实现该层的功能， 这个过程就称为封装，如图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052119363.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.19.17" /></p>
<h3 id="121-tcp封装"><a class="markdownIt-Anchor" href="#121-tcp封装"></a> 1.2.1 TCP封装</h3>
<p>经过TCP封装后的数据称为<strong>TCP报文段(TCP message segment)</strong>，或者简称TCP段。</p>
<p>前文提到，TCP协议为通信双方维持一个连接，并且在内核中存储相关数据。这部分数据中的<strong>TCP头部信息</strong>和<strong>TCP内核缓冲区</strong>(发送缓冲区或接收缓冲区)<strong>数据</strong>一起构成了TCP报文段。</p>
<p>封装过程如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052118653.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.18.56" /></p>
<p>当发送端应用程序使用send(或者write)函数向一个TCP连接写入数据过程</p>
<p>1、内核中的TCP模块首先<u>把这些数据复制到与该连接对应的TCP</u>内核发送缓冲区中</p>
<p>2、TCP模块调用IP模块提供的服务，传递的参数包括TCP头部信息和TCP发送缓冲区中的数据，即TCP报文段。</p>
<h3 id="122-udp封装"><a class="markdownIt-Anchor" href="#122-udp封装"></a> 1.2.2 UDP封装</h3>
<p>经过UDP封装后的数据称为<strong>UDP数据报(UDP datagram)</strong>。</p>
<p>UDP 对应用程序数据的封装与TCP类似。不同的是，UDP<strong>无须为应用层数据保存副本</strong>，因为它提供的服务是<strong>不可靠的</strong>。</p>
<p>1、当一个UDP数据报被成功发送之后，UDP内核缓冲区中的该数据报就被丢弃了。</p>
<p>2、如果应用程序检测到该数据报未能被接收端正确接收，并打算<strong>重发</strong>这个数据报，则应用程序需要<u>重新从用户空间将该数据报拷贝到UDP内核发送缓冲区</u>中。</p>
<h3 id="123-ip封装"><a class="markdownIt-Anchor" href="#123-ip封装"></a> 1.2.3 IP封装</h3>
<p>经过IP封装后的数据称为<strong>IP数据报(IP datagram)</strong>。IP数据报也包括<strong>头部信息</strong>和数据部分，其中<u>数据</u>部分就是<u>一个TCP报文段、UDP数据 报或者ICMP报文</u>。</p>
<h3 id="124-数据链路层封装"><a class="markdownIt-Anchor" href="#124-数据链路层封装"></a> 1.2.4 数据链路层封装</h3>
<p>经过数据链路层封装的数据称为<strong>帧(frame)</strong>。传输媒介不同，帧的类型也不同。</p>
<p>比如，<strong>以太网</strong>上传输的是<strong>以太网帧(ethernet frame)</strong>， 而令牌环网络上传输的则是<strong>令牌环帧(token ring frame)</strong>。以以太网帧为例，其封装格式如图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052118513.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午6.16.14" /></p>
<p>以太网帧使用<strong>6字节</strong>的目的物理地址和6字节的源物理地址来表示通信的双方。<strong>4字节</strong>CRC字段对帧的其他部分提供循环冗余校验。</p>
<p><strong>帧的最大传输单元(Max Transmit Unit，MTU)</strong>，即帧<u>最多能携带多少上层协议数据</u>(比如IP数据报)，通常受到网络类型的限制。 图1-6所示的以太网帧的MTU是1500字节。正因为如此，过长的IP数据 报可能需要被分片(fragment)传输。</p>
<p>帧才是最终在物理网络上传送的字节序列。至此，封装过程完成。</p>
<h3 id="13-分用"><a class="markdownIt-Anchor" href="#13-分用"></a> 1.3 分用</h3>
<h3 id="131-分用的流程"><a class="markdownIt-Anchor" href="#131-分用的流程"></a> 1.3.1 分用的流程</h3>
<p>1、当帧到达目的主机时，将沿着协议栈自底向上依次传递。</p>
<p>2、各层协议依次处理帧中本层负责的头部数据，以获取所需的信息。</p>
<p>3、最终将处理后的帧交给目标应用程序。</p>
<p>这个过程称为<strong>分用 (demultiplexing)</strong>，我个人理解就是对于数据报的解析。</p>
<p>分用是依靠头部信息中的类型字段实现的。<u>标准文档RFC 1700</u>定义了所有标识上层协议的类型字段以及每个上层协议对应的数值。如图显示了以太网帧的<strong>分用过程</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052119640.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.19.35" /></p>
<h3 id="132-分用时如何区分协议"><a class="markdownIt-Anchor" href="#132-分用时如何区分协议"></a> 1.3.2 分用时如何区分协议</h3>
<p>因为IP协议、ARP协议和RARP协议都使用帧传输数据，所以帧的 头部需要提供某个字段(具体情况取决于帧的类型)来区分它们。</p>
<p>以以太网帧为例，它使用2字节的类型字段来标识上层协议封装图。 如果主机接收到的以太网帧类型字段的值为0x800，则帧的数据部分 <strong>IP数据报</strong>，以太网驱动程序就将帧交付给IP模块;若类型字段的值为0x806，则帧的数据部分为<strong>ARP</strong>请求或应答报文，以太网驱动程序就将帧交付给<strong>ARP模块</strong>;若类型字段的值为0x835，则帧的数据部分为<strong>RARP</strong>请求或应答报文，以太网驱动程序就将帧交付给<strong>RARP模块</strong>。</p>
<p>简单来说就是根据字节来识别判断什么协议做什么操作。</p>
<p>同样，因为<strong>ICMP协议</strong>、<strong>TCP协议</strong>和<strong>UDP协议</strong>都使用<strong>IP协议</strong>，所以IP数据报的头部采用16位的协议(protocol)字段来区分它们。</p>
<p>TCP报文段和UDP数据报则通过其头部中的16位的端口号(port number)字段来区分上层应用程序。比如DNS协议对应的端口号是53，HTTP协议(Hyper-Text Transfer Protocol，超文本传送协议)对应的端口号是80。所有知名应用层协议使用的端口号都可在/etc/services文件中找到。</p>
<p>帧通过上述分用步骤后，最终将封装前的原始数据送至目标服务 (上图中的ARP服务、RARP服务、ICMP服务或者应用程序)。这样，在顶层目标服务看来，封装和分用似乎没有发生过。<strong>解析交给各一层的东西，直接发送到各自的端口，所以看起来是封装的，端到端的。</strong></p>
<h2 id="14-测试网络"><a class="markdownIt-Anchor" href="#14-测试网络"></a> 1.4 测试网络</h2>
<p><strong>测试网络如下图所示</strong>，其中包括两台主机A和B，以及一个连接到因特网的路由器。如没有特别声明，所有测试硬件指的都是该网络。我们将使用机器名来标识测试机器。</p>
<p>![截屏2022-05-05 下午9.19.45](…/…/…/Library/Application Support/typora-user-images/截屏2022-05-05 下午9.19.45.png)</p>
<p>该测试网络主要用于分析<strong>ARP协议</strong>、<strong>IP协议</strong>、<strong>ICMP协议</strong>、<strong>TCP协议</strong>和<strong>DNS协议</strong>。我们通过抓取该网络上的以太网帧，查看其中的以太网帧头部、IP数据报头部、TCP报文段头部信息，以获取网络通信的细节。【对于路由器，我们仅列出了其LAN网络IP地址(192.168.1.1)，而 忽略了ISP(Internet Service Provider，因特网服务提供商)给它分配的WAN网络IP地址】</p>
<h2 id="15-arp协议工作原理"><a class="markdownIt-Anchor" href="#15-arp协议工作原理"></a> 1.5 ARP协议工作原理</h2>
<p>ARP协议能实现任意<strong>网络层地址</strong>到任意<strong>物理地址</strong>的转换，不过这里仅讨论从<strong>IP地址</strong>到**以太网地址(MAC地址)**的转换。</p>
<h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3>
<p>1、主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。</p>
<p>2、此网络上的其他机器都将收到这个请求，但<strong>只有</strong>被请求的目标机器会<u>回应一个ARP应答</u>，其中<strong>包含自己的物理地址</strong>。</p>
<h3 id="151-以太网arp请求应答报文"><a class="markdownIt-Anchor" href="#151-以太网arp请求应答报文"></a> 1.5.1 以太网ARP请求/应答报文</h3>
<p>以太网ARP请求/应答报文的格式如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052120702.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.20.13" /></p>
<p><strong>硬件类型字段</strong>：定义物理地址的类型，它的值为1表示MAC地址。</p>
<p><strong>协议类型字段</strong>：表示要映射的协议地址类型，它的值为0x800，表示IP地址。</p>
<p><strong>硬件地址长度字段</strong>和<strong>协议地址长度字段</strong>：顾名思义，其单位是字节。对MAC地址来说，其长度为6;对IP(v4)地址来说，其长度为4。</p>
<p><strong>操作字段</strong>：指出4种操作类型：ARP请求(值为1)、ARP应答(值 为2)、RARP请求(值为3)和RARP应答(值为4)。</p>
<p>最后4个字段指定<strong>通信双方的以太网地址</strong>和<strong>IP地址</strong>。</p>
<p>1、发送端填充除目的端以太网地址外的其他3个字段，以构建ARP请求并发送之。</p>
<p>2、接收端发现该请求的目的端IP地址是自己，就把自己的以太网地址填进去。</p>
<p>3、然后交换两个目的端地址和两个发送端地址，以构建ARP应答并返回之(当然，如前所述，操作字段需要设置为2)。</p>
<p>就是一个交互的小过程</p>
<p>由上图可知，ARP请求/应答报文的长度为28字节。如果再加上以太网帧头部和尾部的18字节(见图1-6)，则一个携带ARP请求/应答报文的以太网帧长度为46字节。不过有的实现要求以太网帧数据部分长度至少为46字节(见图1-4)，此时ARP请求/应答报文将增加一些填充字节，以满足这个要求。在这种情况下，一个携带ARP请求/应答报文的以太网帧长度为64字节。</p>
<h3 id="152-arp高速缓存的查看和修改"><a class="markdownIt-Anchor" href="#152-arp高速缓存的查看和修改"></a> 1.5.2 ARP高速缓存的查看和修改</h3>
<p>通常，ARP维护一个高速缓存，其中<strong>包含经常访问(比如网关地址)<strong>或</strong>最近访问的机器的IP地址到物理地址的映射</strong>。这样就<u>避免了重复的ARP请求</u>，提高了发送数据包的速度。</p>
<p>Linux下可以使用arp命令来查看和修改ARP高速缓存。比如， ernest-laptop在某一时刻(注意，ARP高速缓存是动态变化的)的ARP 缓存内容如下(使用<strong>arp -a</strong>命令):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Kongming20</span>(<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>)at <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>[ether]on eth0<br>?(<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>)at <span class="hljs-number">14</span>:e6:e4:<span class="hljs-number">93</span>:<span class="hljs-number">5b</span>:<span class="hljs-number">78</span>[ether]on eth0<br></code></pre></td></tr></table></figure>
<p>第一项描述的是另一台测试机器Kongming20(注意，其IP 地址、MAC地址都与上面的总图描述的一致)。</p>
<p>第二项描述的是路由器。下面两条命令则分别删除和添加一个ARP缓存项。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo arp -d <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>#删除Kongming20对应的ARP缓存项<br>$sudo arp -s <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>#添加Kongming20对应的 ARP缓存项<br></code></pre></td></tr></table></figure>
<h3 id="153-使用tcpdump观察arp通信过程"><a class="markdownIt-Anchor" href="#153-使用tcpdump观察arp通信过程"></a> 1.5.3 使用tcpdump观察ARP通信过程</h3>
<p>为了清楚地了解ARP的运作过程，我们从ernest-laptop上执行telnet 命令登录Kongming20的echo服务(已经开启)，并用tcpdump(详见第 17章)抓取这个过程中两台测试机器之间交换的以太网帧。具体的操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo arp -d <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>#清除ARP缓存中Kongming20对应的项<br>$sudo tcpdump -i eth0-ent<span class="hljs-number">&#x27;</span>(dst <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-keyword">and</span> src <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>) <span class="hljs-built_in"><span class="hljs-keyword">or</span></span><br>(dst <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-keyword">and</span> src <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>)<span class="hljs-string">&#x27;#如无特殊声明，抓包都在机器 ernest-laptop上执行</span><br><span class="hljs-string">$telnet 192.168.1.109 echo#开启另一个终端执行telnet命令 Trying 192.168.1.109...</span><br><span class="hljs-string">Connected to 192.168.1.109.</span><br><span class="hljs-string">Escape character is &#x27;</span>^]<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">^](回车)#输入Ctrl+]并回车 telnet&gt;quit(回车) Connection closed.</span><br></code></pre></td></tr></table></figure>
<p>1、在执行telnet命令之前，应先清除ARP缓存中与Kongming20对应的项，否则ARP通信不被执行，我们也就无法抓取到期望的以太网帧。</p>
<p>2、当执行telnet命令并在两台通信主机之间建立TCP连接后(telnet输 出“Connected to 192.168.1.109”)</p>
<p>3、输入Ctrl+]以调出telnet程序的命令提示符，然后在telnet命令提示符后输入quit，退出telnet客户端程序(因为ARP通信在TCP连接建立之前就已经完成，故我们不关心后续内容)。</p>
<p>4、tcpdump抓取到的众多数据包中，只有最靠前的两个和ARP通信有关系，现在将它们列出(数据包前面的编号是笔者加入的，后同):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.00</span>:<span class="hljs-number">16</span>:d3:<span class="hljs-number">5</span>c:b9:e3&gt;ff:ff:ff:ff:ff:ff,<span class="hljs-function">ethertype <span class="hljs-title">ARP</span><span class="hljs-params">(<span class="hljs-number">0x0806</span>)</span>,length 42:Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>,length <span class="hljs-number">28</span></span><br><span class="hljs-function"><span class="hljs-number">2.08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>&gt;<span class="hljs-number">00</span>:<span class="hljs-number">16</span>:d3:<span class="hljs-number">5</span>c:b9:e3,ethertype ARP(<span class="hljs-number">0x0806</span>),length <span class="hljs-number">60</span>:Reply <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> is-at <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>,length <span class="hljs-number">46</span></span><br></code></pre></td></tr></table></figure>
<p>由tcpdump<u>抓取的数据包</u>本质上是<strong>以太网帧</strong>，我们通过该命令的众多选项来控制帧的过滤(比如用dst和src指定通信的目的端IP地址和源端IP地址)和显示(比如用-e选项开启以太网帧头部信息的显示)。</p>
<p><strong>第一个数据包</strong>中，ARP通信的<strong>源端的物理地址</strong>是00:16:d3:5c:b9:e3(ernest-laptop)，<strong>目的端的物理地址</strong>是ff:ff:ff:ff:ff:ff， 这是以太网的广播地址，用以表示整个LAN。</p>
<p>1、该LAN上的所有机器都会收到并处理这样的帧。</p>
<p>2、数值0x806是以太网帧头部的类型字段的值， 它表示分用的目标是ARP模块。</p>
<p>3、该以太网帧的长度为42字节(实际上是46字节，tcpdump未统计以太网帧尾部4字节的CRC字段)，其中数据部分长度为28字节。</p>
<p>4、“Request”表示这是一个ARP请求，“who-has 192.168.1.109 tell 192.168.1.108”则表示是ernest-laptop要查询Kongming20的IP地址。</p>
<p><strong>第二个数据包</strong>中，ARP通信的<strong>源端的物理地址</strong>是 08:00:27:53:10:67(Kongming20)，<strong>目的端的物理地址</strong>是 00:16:d3:5c:b9:e3(ernest-laptop)。</p>
<p>1、“Reply”表示这是一个ARP应答，“192.168.1.109 is-at 08:00:27:53:10:67”则表示目标机器Kongming20 报告其物理地址。</p>
<p>2、该以太网帧的长度为60字节(实际上是64字节)， 可见它使用了填充字节来满足最小帧长度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052117137.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.16.56" /></p>
<p>1、我们将两次传输的以太网帧按照图1-6所描述的以太网帧封装格式绘制在图的下半部分。</p>
<p>2、ARP请求和应答是从<u>以太网驱动程序发出的，而并非像图中描述的那样从ARP模块直接发送到以太网上</u>，所以我们将它们用虚线表示，这主要是为了体现携带ARP数据的以太网帧和其他以太网帧 (比如携带IP数据报的以太网帧)的区别。</p>
<p>3、路由器也将接收到以太网帧1，因为该<strong>帧是一个广播帧</strong>。不过很显然，<u>路由器并没有回应其中的ARP请求</u>，正如前文讨论的那</p>
<p>样。</p>
<h2 id="16-dns工作原理"><a class="markdownIt-Anchor" href="#16-dns工作原理"></a> 1.6 DNS工作原理</h2>
<p>我们通常使用机器的<u>域名来访问</u>这台机器，而<u>不直接使用其IP</u>地址，比如访问因特网上的各种网站。那么如何将机器的域名转换成IP地址呢?这就需要使用域名查询服务。域名查询服务有很多种实现方式，比如NIS(Network Information Service，网络信息服务)、DNS和本地静态文件等。本节主要讨论DNS。</p>
<h3 id="161-dns查询和应答报文详解"><a class="markdownIt-Anchor" href="#161-dns查询和应答报文详解"></a> 1.6.1 DNS查询和应答报文详解</h3>
<p>DNS是一套分布式的域名服务系统。</p>
<p>每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且是动态更新的。</p>
<p>众多网络客户端程序都使用DNS协议来向DNS服务器查询目标主机的IP地址。</p>
<p>DNS查询和应答报文的格式如图1-11所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052125476.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.25.01" /></p>
<p>16位标识[1]字段用于标记一对<strong>DNS查询</strong>和<strong>应答</strong>，以此<u>区分一个DNS应答是哪个DNS查询的回应</u>。</p>
<p>16位标志字段用于<strong>协商具体的通信方式</strong>和<strong>反馈通信状态</strong>。DNS报文头部的16位标志字段的细节如图1-12所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052126399.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.26.22" /></p>
<p><strong>QR</strong>：查询/应答标志。0表示这是一个查询报文，1表示这是一个应答报文。</p>
<p><strong>opcode</strong>：定义查询和应答的类型。0表示标准查询，1表示反向查询(由IP地址获得主机域名)，2表示请求服务器状态。</p>
<p><strong>AA</strong>：授权应答标志，仅由应答报文使用。1表示域名服务器是授权服务器。</p>
<p><strong>TC</strong>：截断标志，仅当DNS报文使用UDP服务时使用。因为UDP数据报有长度限制，所以过长的DNS报文将被截断。1表示DNS报文超过512字节，并被截断。</p>
<p><strong>RD</strong>：递归查询标志。1表示执行递归查询，即如果目标DNS服务器无法解析某个主机名，则它将向其他DNS服务器继续查询，如此递 归，直到获得结果并把该结果返回给客户端。0表示执行迭代查询，即如果目标DNS服务器无法解析某个主机名，则它将自己知道的其他 DNS服务器的IP地址返回给客户端，以供客户端参考。</p>
<p><strong>RA</strong>：允许递归标志。仅由应答报文使用，1表示DNS服务器支持递归查询。</p>
<p><strong>zero</strong>：这3位未用，必须都设置为0。</p>
<p><strong>rcode</strong>：4位返回码，表示应答的状态。常用值有0(无错误)和3(域名不存在)。</p>
<p>接下来的4个字段则分别指出DNS报文的最后4个字段的资源记录数目。对<strong>查询报文</strong>而言，它一般包含1个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。<strong>应答报文</strong>的应答资源记录数则至少为1，而授权资源记录数和额外资源记录数可为0或非0。</p>
<p>查询问题的格式如图1-13所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052130947.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.30.27" /></p>
<p><strong>查询名</strong>以<u>一定的格式封装了要查询的主机域名</u>。16位查询类型表示如何执行查询操作，常见的类型有如下几种:</p>
<p>类型A：值是1，表示获取目标主机的IP地址。</p>
<p>类型CNAME：值是5，表示获得目标主机的别名。</p>
<p>类型PTR：值是12，表示反向查询。</p>
<p><strong>16位查询类</strong>：通常为1，表示获取因特网地址(IP地址)。</p>
<p>应答字段、授权字段和额外信息字段都使用资源记录(Resource Record，RR)格式。资源记录格式如图1-14所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052133025.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.33.13" /></p>
<p><strong>32位域名</strong>：是该记录中与资源对应的名字，其格式和查询问题中的查询名字段相同。</p>
<p><strong>16位类型</strong>和<strong>16位类</strong>字段：含义也与DNS查询问题的对应字段相同。</p>
<p><strong>32位生存时间</strong>：表示该查询记录结果可被本地客户端程序缓存多长时间，单位是秒。</p>
<p><strong>16位资源数据长度字段和资源数据字段</strong>：的内容取决于类型字段对类型A而言，资源数据是32位的IPv4地址，而资源数据长度则为 4(以字节为单位)。</p>
<p>至此，我们简要地介绍了DNS协议。我们将在后面给出一个DNS通信的具体例子。DNS协议的更多细节请参考其RFC文档(DNS协议 存在诸多RFC文档，每个RFC文档介绍其一个侧面，比如RFC 1035介绍的是域名的实现和规范，RFC 1886则描述DNS协议对IPv6的扩展支 持)。</p>
<h3 id="162-linux下访问dns服务"><a class="markdownIt-Anchor" href="#162-linux下访问dns服务"></a> 1.6.2 Linux下访问DNS服务</h3>
<p>我们要访问DNS服务，就必须先知道DNS服务器的IP地址。Linux 使用/etc/resolv.conf文件来存放DNS服务器的IP地址。机器ernest-laptop上，该文件的内容如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">#Generated by Network Manager<br> nameserver <span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><br> nameserver <span class="hljs-number">124.207</span><span class="hljs-number">.160</span><span class="hljs-number">.106</span><br></code></pre></td></tr></table></figure>
<p>其中的两个IP地址分别是<strong>首选DNS服务器地址</strong>和<strong>备选DNS服务器</strong>地址。</p>
<p>文件中的注释语句“Generated by Network Manager”告诉我们，这<u>两个DNS服务器地址是由网络管理程序写入</u>的。</p>
<p>Linux下一个常用的<strong>访问DNS服务器的客户端程序</strong>是host，比如下面的命令是<u>向首选DNS服务器219.239.26.42查询</u>机器www.baidu.com的IP地址:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">$host -t A www.baidu.com<br>www.baidu.com is an alias <span class="hljs-keyword">for</span> www.a.shifen.com.<br>www.a.shifen.com has address <span class="hljs-number">119.75</span><span class="hljs-number">.217</span><span class="hljs-number">.56</span><br>www.a.shifen.com has address <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><br></code></pre></td></tr></table></figure>
<p>1、host命令的输出告诉我们，机器名www.baidu.com是 www.a.shifen.com.的<strong>别名</strong>（alias），并且该机器名对应两个IP地址。</p>
<p>2、host命令使用<strong>DNS协议</strong>和<strong>DNS服务器通信</strong>，其-t选项<u>告诉DNS协议使用哪种查询类型</u>。</p>
<p>3、我们这里使用的是<strong>A类型</strong>，即<strong>通过机器的域名获得其IP地址</strong>(但实际上返回的资源记录中还包含机器的别名)。</p>
<h3 id="163-使用tcpdump观察dns通信过程"><a class="markdownIt-Anchor" href="#163-使用tcpdump观察dns通信过程"></a> 1.6.3 使用tcpdump观察DNS通信过程</h3>
<p>为了看清楚DNS通信的过程，下面我们将从ernest-laptop上运行<strong>host命令</strong>以查询主机www.baidu.com对应的IP地址，并使用<strong>tcpdump抓取</strong>这一过程中<u>LAN上传输的以太网帧</u>。具体的操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -i eth0 -nt -s <span class="hljs-number">500</span> port domain<br>$host -t A www.baidu.com<br></code></pre></td></tr></table></figure>
<p>这一次执行tcpdump抓包时，我们使用“port domain”来过滤数据包，表示<u>只抓取使用domain(域名)服务的数据包</u>，即DNS查询和应答报文。tcpdump的输出如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34319</span> &gt; <span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><span class="hljs-number">.53</span>: <span class="hljs-number">57428</span>+ A? www.baidu.com. (<span class="hljs-number">31</span>)<br><span class="hljs-number">2.</span>IP <span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><span class="hljs-number">.53</span> &gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34319</span>: <span class="hljs-number">57428</span> <span class="hljs-number">3</span>/<span class="hljs-number">4</span>/<span class="hljs-number">4</span> CNAME www.a.shifen.com.,A <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span>,A <span class="hljs-number">119.75</span><span class="hljs-number">.217</span><span class="hljs-number">.56</span>(<span class="hljs-number">226</span>)<br></code></pre></td></tr></table></figure>
<p>1、这两个数据包开始的“IP”指出，它们后面的内容描述的是<strong>IP数据报</strong>。</p>
<p>2、tcpdump以“<strong>IP地址.端口号</strong>”的形式来描述通信的某一端。</p>
<p>3、以“&gt;”表 示数据传输的方向，“&gt;”前面是<strong>源端</strong>，后面是<strong>目的端</strong>。</p>
<p>4、可见，第一个数据包是测试机器ernest-laptop(IP地址是192.168.1.108)向其首选DNS服务器(IP地址是219.239.26.42)发送的<strong>DNS查询报文</strong>(目标端口53是<strong>DNS服务使用的端口</strong>，这一点我们在前面介绍过)，第二个数据包是<strong>服务器反馈的DNS应答报文</strong>。</p>
<p><strong>第一个数据包中</strong>：</p>
<p>数值57428是<strong>DNS查询报文</strong>的标识值，因此该值也出现在<strong>DNS应答报文</strong>中。“+”表示启用<strong>递归查询标志</strong>。“A?”表示使用<strong>A类型的查询方式</strong>。“<a target="_blank" rel="noopener" href="http://www.baidu.com">www.baidu.com</a>”则是<strong>DNS查询问题中的查询名</strong>。 括号中的数值31是DNS查询报文的长度(以字节为单位)。</p>
<p><strong>第二个数据包中</strong>：</p>
<p>“3/4/4”表示该报文中包含<strong>3个应答资源记录</strong>、<strong>4 个授权资源记录</strong>和<strong>4个额外信息记录</strong>。“CNAME <a target="_blank" rel="noopener" href="http://www.a.shifen.com">www.a.shifen.com</a>.，A 119.75.218.77，A 119.75.217.56”则表示3个应答资源记录的内容。其中<strong>CNAME表示紧随其后的记录是机器的别名</strong>，<strong>A表示紧随其后的记录是IP地址</strong>。该应答报文的长度为226字节。</p>
<p>PS：我们抓包的时候没有开启tcpdump的-X选项(或者-x选 项)。如果使用-X选项，我们将能看到DNS报文的每一个字节，也就 能明白上面31字节的查询报文和226字节的应答报文的具体含义。</p>
<h2 id="17-socket和tcpip协议族的关系"><a class="markdownIt-Anchor" href="#17-socket和tcpip协议族的关系"></a> 1.7 socket和TCP/IP协议族的关系</h2>
<p>由于<u>数据链路层、网络层、传输层</u>协议是在<strong>内核</strong>中实现的。因此<strong>操作系统</strong>需要实现一组系统调用，使得应用程序能够访问这些协议提供的服务。实现这组系统调用的**API(Application Programming Interface，应用程序编程接口)**主要有两套:<strong>socket</strong>和 XTI。<u>XTI现在基本不再使用</u>，所以这里仅讨论socket，如图1-1显示了socket与TCP/IP协议族的关系。</p>
<p>由socket定义的这一组API提供如下两点功能:</p>
<p>1、将应用程序数据从<u>用户缓冲区中复制到TCP/UDP内核发送缓冲区</u>，以<u>交付内核来发送数据</u>(比如图1-5所示的send函数)，或者是<u>从内核TCP/UDP接收缓冲区中复制数据到用户缓冲区</u>，以读取数据。</p>
<p>2、应用程序可以通过它们来<u>修改内核中各层协议的某些头部信息或其他数据结构</u>，从而精细地<u>控制底层通信</u>的行为。比如可以通过setsockopt函数来<u>设置IP数据报在网络上的存活时间</u>。</p>
<p>socket是一套通用网络编程接口，它不但可以访问内核中TCP/IP协议栈，而且可以访问其他网络协议栈(比如X.25协议栈、UNIX本地域协议栈等)。</p>
<h1 id="第2章-ip协议详解"><a class="markdownIt-Anchor" href="#第2章-ip协议详解"></a> 第2章 IP协议详解</h1>
<p>IP协议是TCP/IP协议族的<strong>核心协议</strong>，也是socket网络编程的基础之一。本章从两个方面较为深入地探讨IP协议:</p>
<p><strong>IP头部信息</strong>：IP头部信息出现在每个IP数据报中，用于指定IP通信的源端IP地址、目的端IP地址，指导IP分片和重组，以及指定部分通信行为。</p>
<p><strong>IP数据报的路由和转发</strong>：IP数据报的路由和转发发生在除目标机器之外的所有主机和路由器上。它们决定数据报<u>是否应该转发</u>以及<u>如何转发</u>。</p>
<p>由于32位表示的IP地址即将全部使用完，因此人们开发出了新版本的IP协议，称为IPv6协议，而原来的版本则称为IPv4协议。本章前面部分的讨论都是基于IPv4协议的，只在最后一节简要讨论IPv6协议。</p>
<h2 id="21-ip服务的特点"><a class="markdownIt-Anchor" href="#21-ip服务的特点"></a> 2.1 IP服务的特点</h2>
<p>IP协议是TCP/IP协议族的动力，它为上层协议提供<u>无状态、无连接、不可靠</u>的服务。</p>
<h3 id="无状态stateless"><a class="markdownIt-Anchor" href="#无状态stateless"></a> 无状态(stateless)</h3>
<p><strong>IP通信双方不同步传输数据的状态信息</strong>， 因此所有IP数据报的发送、传输和接收都是<u>相互独立、没有上下文关系</u>的。</p>
<p>这种服务最大的<strong>缺点</strong>是无法处理乱序和重复的IP数据报。比如发送端发送出的第N个IP数据报可能比第N+1个IP数据报后到达接收端，而同一个IP数据报也可能经过不同的路径多次到达接收端。在这两种情况下，接收端的IP模块无法检测到乱序和重复，因为这些IP数据报之间没有任何上下文关系。</p>
<p>接收端的IP模块只要收到了<strong>完整</strong>的IP数据报(如果是IP分片的话，IP模块将先执行重组)，就将其数据部分(TCP报文段、UDP数据报或者ICMP报文)上交给上层协议。那么<strong>从上层协议来看</strong>，这些数据就可能是<u>乱序的、重复</u>的。</p>
<p>面向连接的协议，比如<strong>TCP协议</strong>，则能够自己处理乱序的、重复的报文段，它递交给上层协议的内容绝对是<strong>有序的、正确</strong>的。</p>
<p>虽然IP数据报头部提供了一个<strong>标识</strong>字段(见后文)用以唯一标识一个IP数据报，但它是被用来<strong>处理IP分片和重组</strong>的，而<strong>不是用来指示接收顺序</strong>的。</p>
<p>无状态服务的优点也很明显:<strong>简单、高效</strong>。我们无须为保持通信的状态而分配一些内核资源，也无须每次传输数据时都携带状态信息。在网络协议中，无状态是很常见的，比如<u>UDP协议和HTTP协议都是无状态协议</u>。以HTTP协议为例，一个浏览器的连续两次网页请求之间没有任何关联，它们将被Web服务器独立地处理。</p>
<h3 id="无连接connectionless"><a class="markdownIt-Anchor" href="#无连接connectionless"></a> 无连接(connectionless)</h3>
<p>IP通信双方都<strong>不长久地维持</strong>对方的任何信息。这样，上层协议<strong>每次</strong>发送数据的时候，都必须<strong>明确指定</strong>对方的IP地址。</p>
<p><strong>不可靠</strong></p>
<p>IP协议<strong>不能保证</strong>IP数据报准确地到达接收端，它只是承诺尽最大努力(best effort)。</p>
<p>很多种情况都能导致IP数据报发送失败。比如，某个中转路由器发现IP数据报在网络上存活的时间太长(根据IP数据报头部字段TTL判断，见后文)，那么它将丢弃之，并返回一个ICMP错误消息(超时错误)给发送端。</p>
<p>又比如，接收端发现收到的IP数据报不正确(通过校验机制)，它也将丢弃之，并返回一个ICMP错误消息(IP头部参数错误)给发送端。</p>
<p>无论哪种情况，发送端的IP模块一旦检测到IP数据报发送失败，就通知上层协议发送失败，而不会试图重传。因此，使用IP服务的上层协议(比如TCP协 议)需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。</p>
<h2 id="22-ipv4头部结构"><a class="markdownIt-Anchor" href="#22-ipv4头部结构"></a> 2.2 IPv4头部结构</h2>
<h3 id="221-ipv4头部结构"><a class="markdownIt-Anchor" href="#221-ipv4头部结构"></a> 2.2.1 IPv4头部结构</h3>
<p>IPv4的头部结构如图2-1所示。其长度通常为20字节，除非含有可变长的选项部分。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071553191.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-07 下午3.53.42" /></p>
<p><strong>4位版本号(version)</strong>：指定IP协议的版本。对IPv4来说，其值是4。其他IPv4协议的扩展版本(如SIP协议和PIP协议)，则具有不同的版本号(它们的头部结构也和图2-1不同)。</p>
<p><strong>4位头部长度(header length)</strong>：标识该IP头部有多少个32bit字(4字 节)。因为4位最大能表示15，所以IP头部最长是60字节。</p>
<p><strong>8位服务类型(Type Of Service，TOS)</strong>：包括一个3位的优先权字段 (现在已经被忽略)，4位的TOS字段和1位保留字段(必须置0)。4位的TOS字段分别表示:最小延时，最大吞吐量，最高可靠性和最小费用。其中最多有一个能置为1，应用程序应该根据实际需要来设置它。 比如像ssh和telnet这样的登录程序需要的是最小延时的服务，而文件传输程序ftp则需要最大吞吐量的服务。</p>
<p><strong>16位总长度(total length)</strong>：整个IP数据报的长度，以字节为单位，因此IP数据报的最大长度为65 535(216-1)字节。但由于MTU的限制，长度超过MTU的数据报都将被分片传输，所以实际传输的IP数据报(或分片)的长度都远远没有达到最大值。接下来的3个字段则描述了如何实现分片。</p>
<p><strong>16位标识(identification)</strong>：唯一地标识主机发送的每一个数据报。 其初始值由系统随机生成;每发送一个数据报，其值就<strong>加1</strong>。该值在数 据报分片时被<strong>复制</strong>到每个分片中，因此<u>同一个数据报的所有分片都具有相同</u>的标识值。</p>
<p><strong>3位标志字段</strong>：第一位保留。第二位(Don’t Fragment，DF)表示“禁止分片”。如果设置了这个位，IP模块将不对数据报进行分片。在这种情况下，如果IP数据报长度超过MTU的话，IP模块将丢弃该数据报并返回一个ICMP差错报文。第三位(More Fragment，MF)表示“更多分片”。除了数据报的最后一个分片外，其他分片都要把它置1。</p>
<p><strong>13位分片偏移(fragmentation offset)</strong>：分片相对原始IP数据报开始处(仅指数据部分)的偏移。实际的偏移值是该值左移3位(乘8)后得到的。由于这个原因，除了最后一个IP分片外，每个IP分片的数据部分的长度必须是<strong>8的整数倍</strong>(这样才能保证后面的IP分片拥有一个合适的偏移值)。</p>
<p><strong>8位生存时间(Time To Live，TTL)</strong>：数据报到达目的地之前允许经过的路由器跳数。TTL值被发送端设置(常见的值是64)。数据报在转发过程中每经过一个路由，该值就被路由器减1。当TTL值减为0时，路由器将丢弃数据报，并向源端发送一个ICMP差错报文。TTL值可以 防止数据报陷入路由循环。</p>
<p><strong>8位协议(protocol)</strong>：用来区分上层协议，我们在第1章讨论过。/etc/protocols文件定义了所有上层协议对应的protocol字段的数值。 其中，ICMP是1，TCP是6，UDP是17。/etc/protocols文件是RFC 1700的一个子集。</p>
<p><strong>16位头部校验和(header checksum)</strong>：由发送端填充，接收端对其使用<u>CRC算法以检验IP数据报头部</u>(注意，<strong>仅检验头部</strong>)在传输过程中是否损坏。</p>
<p><strong>32位的源端IP地址和目的端IP地址</strong>：用来标识数据报的发送端和接收端。一般情况下，这两个地址在整个数据报的传递过程中保持不变，而不论它中间经过多少个中转路由器。关于这一点，我们将在第4章进一步讨论。</p>
<p><strong>IPv4最后一个选项字段(option)</strong>：是可变长的可选信息。这部分最多包含40字节，因为IP头部最长是60字节(其中还包含前面讨论的20字节的固定部分)。可用的IP选项包括:</p>
<p>1、记录路由(record route)，告诉数据报途经的所有路由器都将自己的IP地址填入IP头部的选项部分，这样我们就可以跟踪数据报的传递 路径。</p>
<p>2、时间戳(timestamp)，告诉每个路由器都将数据报被转发的时间(或时间与IP地址对)填入IP头部的选项部分，这样就可以测量途经路由之间数据报传输的时间。</p>
<p>3、松散源路由选择(loose source routing)，指定一个路由器IP地址列表，数据报发送过程中必须经过其中所有的路由器。</p>
<p>4、严格源路由选择(strict source routing)，和松散源路由选择类似，不过数据报只能经过被指定的路由器。</p>
<h3 id="222-使用tcpdump观察ipv4头部结构"><a class="markdownIt-Anchor" href="#222-使用tcpdump观察ipv4头部结构"></a> 2.2.2 使用tcpdump观察IPv4头部结构</h3>
<p>为了深入理解IPv4头部中每个字段的含义，我们从测试机器ernest-laptop上<u>执行telnet命令登录本机</u>，并用tcpdump抓取这个过程中telnet客户端程序和telnet服务器程序之间交换的数据包。具体的操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -ntx -i lo #抓取本地回路上的数据包<br>$telnet <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>#开启另一个终端执行telnet命令登录本机 Trying <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>...<br>Connected to <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>.<br>Escape character is<span class="hljs-number">&#x27;</span>^]<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">Ubuntu 9.10</span><br><span class="hljs-string">ernest-laptop login:ernest#输入用户名并回车 Password:#输入密码并回车</span><br></code></pre></td></tr></table></figure>
<p>此时观察tcpdump输出的第一个数据包，其内容如代码清单2-1所示。</p>
<p>代码清单2-1 用tcpdump抓取数据包</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.41621</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[S],seq <span class="hljs-number">3499745539</span>,win <span class="hljs-number">32792</span>,<br>   options[mss <span class="hljs-number">16396</span>,sackOK,TS val <span class="hljs-number">40781017</span> ecr <span class="hljs-number">0</span>,nop,wscale<br><span class="hljs-number">6</span>],length <span class="hljs-number">0</span><br>   <span class="hljs-number">0x0000</span>:<span class="hljs-number">4510</span> <span class="hljs-number">003</span>c a5da <span class="hljs-number">4000</span> <span class="hljs-number">4006</span> <span class="hljs-number">96</span>cf <span class="hljs-number">7f</span>00 <span class="hljs-number">0001</span><br>   <span class="hljs-number">0x0010</span>:<span class="hljs-number">7f</span>00 <span class="hljs-number">0001</span> a295 <span class="hljs-number">0017</span> d099 e103 <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>   <span class="hljs-number">0x0020</span>:a002 <span class="hljs-number">8018</span> fe30 <span class="hljs-number">0000</span> <span class="hljs-number">0204</span> <span class="hljs-number">400</span>c <span class="hljs-number">0402</span> <span class="hljs-number">080</span>a<br></code></pre></td></tr></table></figure>
<p>该数据包描述的是一个<strong>IP数据报</strong>。由于我们是使<u>用telnet登录本机</u>的，所以IP数据报的<strong>源端IP地址</strong>和<strong>目的端IP地址</strong>都是“127.0.0.1”。telnet 服务器程序使用的端口号是23(参见/etc/services文件)，而telnet客户端程序使用临时端口号41621与服务器通信。关于临时端口号，我们将 在第3章讨论。“Flags”、“seq”、“win”和“options”描述的都是TCP头部信息，这也将在第3章讨论。“length”指出该IP数据报所携带的应用程序数据的长度。</p>
<p>这次抓包我们开启了tcpdump的-x选项，使之输出数据包的<strong>二进制码</strong>。此数据包共包含60字节，其中前20字节是IP头部，后40字节是TCP 头部，不包含应用程序数据(length值为0)。现在我们分析IP头部的每个字节，如表2-1所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205072139077.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-07 下午9.39.25" /></p>
<p>由表2-1可见，telnet服务选择<u>使用具有最小延时的服务</u>，并且默认<u>使用的传输层协议是TCP协议</u>(回顾第1章讨论的分用)。这些都符合我们通常的理解。这个IP数据报<u>没有被分片</u>，因为它没有携带任何应用程序数据。接下来我们将<u>抓取并讨论被分片的IP数据报</u>。</p>
<h2 id="23-ip分片"><a class="markdownIt-Anchor" href="#23-ip分片"></a> 2.3 IP分片</h2>
<p>前文曾提到，当IP数据报的长度<u>超过帧的MTU</u>时，它将被<u>分片传输</u>。分片<u>可能发生在发送端</u>，也可能<u>发生在中转路由器</u>上，而且可能在<u>传输过程中被多次</u>分片，但只有在<strong>最终的目标机器上，这些分片才会被内核中的IP模块重新组装</strong>。</p>
<p>IP头部中的如下三个字段给IP的分片和重组提供了足够的信息:数据报标识、标志和片偏移。一个IP数据报的每个分片都具有自己的IP头 部，它们具有相同的标识值，但具有不同的片偏移。并且除了最后一个分片外，其他分片都将设置MF标志。此外，每个分片的IP头部的总长度字段将被设置为该分片的长度。</p>
<p>以太网帧的MTU是1500字节(可以通过ifconfig命令或者netstat命令查看)，因此它携带的IP数据报的数据部分<strong>最多是1480字节</strong>(IP头部占用20字节)。考虑用IP数据报封装一个<strong>长度为1481字节</strong>的<strong>ICMP报文</strong> (包括8字节的ICMP头部，所以其数据部分长度为1473字节)，则该数据报在使用以太网帧传输时<strong>必须被分片</strong>，如图2-2所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205072159863.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-07 下午9.59.01" /></p>
<p>图2-2中，长度为1501字节的IP数据报被拆分成两个IP分片，第一个IP分片长度为1500字节，第二个IP分片的长度为21字节。每个IP分片 都包含自己的IP头部(20字节)，且第一个IP分片的IP头部<strong>设置了MF标志</strong>，而第二个IP分片的IP头部则<strong>没有设置该标志</strong>，因为它<strong>已经是最后 一个分片</strong>了。原始IP数据报中的ICMP头部内容<strong>被完整地复制</strong>到了第一个IP分片中。第二个IP分片<strong>不包含ICMP头部信息</strong>，因为IP模块重组该 ICMP报文的时候<strong>只需要一份ICMP头部</strong>信息，<u>重复传送这个信息没有任何益处</u>。1473字节的ICMP报文数据的前1472字节被IP模块复制到第一个IP分片中，使其总长度为1500字节，从而满足MTU的要求;而多出的最后1字节则被复制到第二个IP分片中。</p>
<p>需要指出的是，<strong>ICMP报文</strong>的<strong>头部长度取决于报文的类型</strong>，其变化范围很大。图2-2以8字节为例，因为后面的例子用到了ping程序，而 ping程序使用的ICMP回显和应答报文的头部长度是8字节。</p>
<p>为了看清楚IP分片的具体过程，考虑从ernest-laptop来ping机器Kongming20，每次传送1473字节的数据(<strong>这是ICMP报文的数据部分</strong>) 以强制引起IP分片，并用tcpdump抓取这一过程中双方交换的数据包。 具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -ntv -i eth0 icmp#只抓取ICMP报文<br>$ping Kongming20 -s <span class="hljs-number">1473</span>#用-s选项指定每次发送<span class="hljs-number">1473</span>字节的数据<br></code></pre></td></tr></table></figure>
<p>下面我们考察tcpdump输出的一个IP数据报的两个分片，其内容如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span><span class="hljs-built_in">IP</span>(tos <span class="hljs-number">0x0</span>,ttl <span class="hljs-number">64</span>,id <span class="hljs-number">61197</span>,offset <span class="hljs-number">0</span>,flags[+],proto <span class="hljs-built_in">ICMP</span>(<span class="hljs-number">1</span>),length <span class="hljs-number">1500</span>)<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.110</span>:ICMP echo request,id <span class="hljs-number">41737</span>,seq <span class="hljs-number">1</span>,length <span class="hljs-number">1480</span><br><span class="hljs-number">2.</span><span class="hljs-built_in">IP</span>(tos <span class="hljs-number">0x0</span>,ttl <span class="hljs-number">64</span>,id <span class="hljs-number">61197</span>,offset <span class="hljs-number">1480</span>,flags[none],proto <span class="hljs-built_in">ICMP</span>(<span class="hljs-number">1</span>),length <span class="hljs-number">21</span>)<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.110</span>:icmp<br></code></pre></td></tr></table></figure>
<p>这两个IP分片的标识值都是61197，说明它们是<strong>同一个IP数据报</strong>的分片。</p>
<p>第一个分片的片偏移值为0，而第二个则是1480。很显然，第二个分片的片<strong>偏移值</strong>实际上也是<strong>第一个分片的ICMP报文的长度</strong>。</p>
<p>第一个 分片设置了MF标志以<strong>表示还有后续分片</strong>，所以tcpdump输出“flags[+]”。</p>
<p>而第二个分片则<strong>没有设置任何标志</strong>，所以tcpdump输出“flags[none]”。</p>
<p>这个两个分片的长度分别为1500字节和21字节，这与图2-2描述的一致。</p>
<p>最后，IP层传递给数据链路层的数据可能是一个<u>完整的IP数据报</u>， 也<u>可能是一个IP分片</u>，它们统称为<strong>IP分组(packet)</strong>。本书如无特殊声 明，<strong>不区分IP数据报和IP分组</strong>。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/15/codeTop/">
                        <span class="hidden-mobile">CodeTop</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
