

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="第1章 TCP&#x2F;IP协议族  1.1 TCP&#x2F;IP协议族体系结构以及主要协议   1.1.1 数据链路层 ARP和RARP协议实现了IP地址和机器物理地址(通 常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址) 之间的相互转换  ARP协议（Address Resolve Protocol，地址解析协议） 网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻址一台机器，">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux高性能服务器编程">
<meta property="og:url" content="http://example.com/2022/05/03/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第1章 TCP&#x2F;IP协议族  1.1 TCP&#x2F;IP协议族体系结构以及主要协议   1.1.1 数据链路层 ARP和RARP协议实现了IP地址和机器物理地址(通 常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址) 之间的相互转换  ARP协议（Address Resolve Protocol，地址解析协议） 网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻址一台机器，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205032144241.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205032157757.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205032205919.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052119363.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052118653.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052118513.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052119640.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052120702.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052117137.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052125476.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052126399.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052130947.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052133025.png">
<meta property="article:published_time" content="2022-05-02T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-06T13:54:31.452Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205032144241.png">
  
  <title>Linux高性能服务器编程 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>PanPan</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/Title%20page/title.jpeg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Linux高性能服务器编程">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-05-03 00:00" pubdate>
        2022年5月3日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      34 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Linux高性能服务器编程</h1>
            
            <div class="markdown-body">
              <h1 id="第1章-tcpip协议族"><a class="markdownIt-Anchor" href="#第1章-tcpip协议族"></a> 第1章 TCP/IP协议族</h1>
<h2 id="11-tcpip协议族体系结构以及主要协议"><a class="markdownIt-Anchor" href="#11-tcpip协议族体系结构以及主要协议"></a> 1.1 TCP/IP协议族体系结构以及主要协议</h2>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205032144241.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-03 下午9.44.36" /></p>
<h3 id="111-数据链路层"><a class="markdownIt-Anchor" href="#111-数据链路层"></a> 1.1.1 数据链路层</h3>
<p><strong>ARP和RARP协议</strong>实现了IP地址和机器物理地址(通 常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址) 之间的相互转换</p>
<h4 id="arp协议address-resolve-protocol地址解析协议"><a class="markdownIt-Anchor" href="#arp协议address-resolve-protocol地址解析协议"></a> ARP协议（Address Resolve Protocol，地址解析协议）</h4>
<p>网络层使用<strong>IP地址</strong>寻址一台机器，而数据链路层使用<strong>物理地址</strong>寻址一台机器，因此网络层必须先将目标机器的<u>IP地址转化成其物理地址</u>，才能使用数据链路层提供的服务。</p>
<h4 id="rarp协议reverse-address-resolve-protocol逆地址解析协议"><a class="markdownIt-Anchor" href="#rarp协议reverse-address-resolve-protocol逆地址解析协议"></a> RARP协议(Reverse Address Resolve Protocol，逆地址解析协议)</h4>
<p>用于网络上的某些无盘工作站。因为缺乏存储设备，无盘工作站无法记住自己的IP地址，但它们可以利用网卡上的物理地址来向网络管理者(服务器或网络管理软件)查询自身的IP地址。</p>
<p>PS：运行RARP服 务的网络管理者通常存有该网络上所有机器的物理地址到IP地址的映射。</p>
<h3 id="112-网络层"><a class="markdownIt-Anchor" href="#112-网络层"></a> 1.1.2 网络层</h3>
<p>网络层实现数据包的选路和转发。</p>
<p>通信的两台主机一般<u>不是直接相连</u>的，而是通过多个中间节点(路由器)连接的就是选择这些中间节点，以确定两台主机之间的通信路径。同时，网络层对上层协议<u>隐藏了网络拓扑连接</u>的细节，使得在<u>传输层和网络应用程序</u><u>看来，通信的双方是直接相连</u>的。</p>
<h4 id="ip协议internet-protocol因特网协议"><a class="markdownIt-Anchor" href="#ip协议internet-protocol因特网协议"></a> IP协议（Internet Protocol，因特网协议）</h4>
<p>step 1: IP协议<strong>根据数据包的目的IP地址</strong>来决定如何投递它。</p>
<p>step 2: 如果数据包<u>不能直接发送</u>给目标主机，那么IP协议就为它<strong>寻找一个合适的下一跳(next hop)<strong>路由器，并将数据包</strong>交付给该路由器</strong>来转发。</p>
<p>重复step1、2直到最后发送到目的地，或者由于发送失败而丢弃。</p>
<p>PS：IP协议使用逐跳(hop by hop)的方式确定通信路径</p>
<h4 id="icmp协议internet-control-message-protocol-因特网控制报文协议"><a class="markdownIt-Anchor" href="#icmp协议internet-control-message-protocol-因特网控制报文协议"></a> ICMP协议（Internet Control Message Protocol， 因特网控制报文协议）</h4>
<p>它是IP协议的重要补充，主要用于<strong>检测网络连接</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205032157757.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-03 下午9.57.17" /></p>
<p>主要分两种：1）用来回应网络错误 2）用来查询网络信息如ping程序</p>
<p>ICMP协议并非严格意义上的网络层协议，因为它使用处于同一层的IP协议提供的服务(一般来说，上层协议使用下层协议提供的服务)。</p>
<h3 id="113-传输层"><a class="markdownIt-Anchor" href="#113-传输层"></a> 1.1.3 传输层</h3>
<p>传输层为两台主机上的应用程序提供<strong>端到端(end to end)<strong>的通信。与网络层使用的逐跳通信方式不同，传输层</strong>只关心通信的起始端和目的端，而不在乎数据包的中转过程</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205032205919.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-03 下午10.05.31" /></p>
<p>垂直的实线箭头表示TCP/IP协议族各层之间的<strong>实体通信</strong>，而水平的虚线箭头表示<strong>逻辑通信线路</strong>。该图中还附带描述了<strong>不同物理网络的连接方法</strong>。可见，数据链路层(驱动程序)<strong>封装了物理网络的电气细节</strong>;网络层<strong>封装了网络连接</strong>的细节;传输层则为应用程序<strong>封装了一条端到端的逻辑通信链路</strong>，它负责数据<u>的收发、链路的超时重连</u>等。</p>
<h4 id="tcp协议transmission-control-protocol传输控制协议"><a class="markdownIt-Anchor" href="#tcp协议transmission-control-protocol传输控制协议"></a> TCP协议(Transmission Control Protocol，传输控制协议)</h4>
<p>1、为应用层提供<u>可靠的、面向连接的和基于流(stream)</u>的服务。</p>
<p>2、TCP协议使用<u>超时重传、数据确认</u>等方式来<strong>确保数据包被正确地发送至目的端</strong>，因此TCP服务是<strong>可靠</strong>的。</p>
<p>3、使用TCP协议通信的双方必须<strong>先建立TCP连接</strong>， 并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等。</p>
<p>4、当通信结束时，双方必须关闭连接以释放这些内核数据。</p>
<p>5、TCP服务是基于流的。<strong>基于流的数据没有边界(长度)限制</strong>，它<u>源源不断地从通信的一端流入另一端</u>。</p>
<p>6、发送端可以逐个 字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出。</p>
<h4 id="udp协议user-datagram-protocol用户数据报协议"><a class="markdownIt-Anchor" href="#udp协议user-datagram-protocol用户数据报协议"></a> UDP协议(User Datagram Protocol，用户数据报协议)</h4>
<p>它为应用层提供<u>不可靠、无连接和基于数据报</u>的服务。（与TCP完全相反）</p>
<p>1、<strong>“不可靠”<strong>意味着UDP协议无法保证数据从发送端正确地传送到目的端。如果数据在</strong>中途丢失</strong>，或者目的端通过数据校验<strong>发现数据错误而将其丢弃</strong>，则UDP协议只是<strong>简单地通知应用程序发送失败</strong>。因此，使用UDP协议的应用程序通常要<u>自己处理数据确认、超时重传</u>等逻辑。</p>
<p>2、UDP协议是无连接的，即<strong>通信双方不保持一个长久的联系</strong>，因此应用程序<strong>每次发送数据都要明确指定接收端的地址</strong>(IP地址等信息)。</p>
<p>3、基于数据报的服务，<u>是相对基于流的服务而言的</u>。每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一 次性读出，否则数据将被截断。</p>
<h4 id="sctp协议stream-control-transmission-protocol流控制传输协议"><a class="markdownIt-Anchor" href="#sctp协议stream-control-transmission-protocol流控制传输协议"></a> SCTP协议(Stream Control Transmission Protocol，流控制传输协议)</h4>
<p>是一种相对较新的传输层协议，它是为了在因特网上传输电话信号而设计的。</p>
<h3 id="114-应用层"><a class="markdownIt-Anchor" href="#114-应用层"></a> 1.1.4 应用层</h3>
<p>应用层负责处理应用程序的逻辑。</p>
<p>内核态：<u>数据链路层、网络层和传输层</u>负责处理网络通信细节，这部分必须既稳定又高效，因此它们都在内核空间中实现</p>
<p>用户态：应用层则在用户空间实现，因为它负责处理众多逻辑，比如文件传输、名称查询和网络管理等。</p>
<h4 id="ping应用程序"><a class="markdownIt-Anchor" href="#ping应用程序"></a> ping应用程序</h4>
<p>它利用ICMP报文检测网络连接，是调试网络环境的必备工具。</p>
<h4 id="telnet协议"><a class="markdownIt-Anchor" href="#telnet协议"></a> telnet协议</h4>
<p>它使我们能在本地完成远程任务</p>
<h4 id="ospfopen-shortest-path-first开放最短路径优先协议"><a class="markdownIt-Anchor" href="#ospfopen-shortest-path-first开放最短路径优先协议"></a> OSPF(Open Shortest Path First，开放最短路径优先)协议</h4>
<p>是一种动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由信息。</p>
<h4 id="dnsdomain-name-service域名服务协议"><a class="markdownIt-Anchor" href="#dnsdomain-name-service域名服务协议"></a> DNS(Domain Name Service，域名服务)协议</h4>
<p>提供机器域名到IP地址的转换，我们将在后面简要介绍DNS协议。</p>
<p>应用层协议(或程序)可能跳过传输层直接使用网络层提供的服务，比如ping程序和OSPF协议。应用层协议(或程序)通常既可以使用TCP服务，又可以使用UDP服务，比如DNS协议。我们可以通过/etc/services文件查看所有知名的应用层协议，以及它们都能使用哪些传输层服务。</p>
<h2 id="12-封装"><a class="markdownIt-Anchor" href="#12-封装"></a> 1.2 封装</h2>
<p>上层协议是如何使用下层协议提供的服务的呢?其实这是通过封装(encapsulation)实现的。</p>
<p>应用程序数据在发送到物理网络上之前， 将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加上自己的头部信息(有时还包括尾部信息)，以实现该层的功能， 这个过程就称为封装，如图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052119363.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.19.17" /></p>
<h3 id="121-tcp封装"><a class="markdownIt-Anchor" href="#121-tcp封装"></a> 1.2.1 TCP封装</h3>
<p>经过TCP封装后的数据称为<strong>TCP报文段(TCP message segment)</strong>，或者简称TCP段。</p>
<p>前文提到，TCP协议为通信双方维持一个连接，并且在内核中存储相关数据。这部分数据中的<strong>TCP头部信息</strong>和<strong>TCP内核缓冲区</strong>(发送缓冲区或接收缓冲区)<strong>数据</strong>一起构成了TCP报文段。</p>
<p>封装过程如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052118653.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.18.56" /></p>
<p>当发送端应用程序使用send(或者write)函数向一个TCP连接写入数据过程</p>
<p>1、内核中的TCP模块首先<u>把这些数据复制到与该连接对应的TCP</u>内核发送缓冲区中</p>
<p>2、TCP模块调用IP模块提供的服务，传递的参数包括TCP头部信息和TCP发送缓冲区中的数据，即TCP报文段。</p>
<h3 id="122-udp封装"><a class="markdownIt-Anchor" href="#122-udp封装"></a> 1.2.2 UDP封装</h3>
<p>经过UDP封装后的数据称为<strong>UDP数据报(UDP datagram)</strong>。</p>
<p>UDP 对应用程序数据的封装与TCP类似。不同的是，UDP<strong>无须为应用层数据保存副本</strong>，因为它提供的服务是<strong>不可靠的</strong>。</p>
<p>1、当一个UDP数据报被成功发送之后，UDP内核缓冲区中的该数据报就被丢弃了。</p>
<p>2、如果应用程序检测到该数据报未能被接收端正确接收，并打算<strong>重发</strong>这个数据报，则应用程序需要<u>重新从用户空间将该数据报拷贝到UDP内核发送缓冲区</u>中。</p>
<h3 id="123-ip封装"><a class="markdownIt-Anchor" href="#123-ip封装"></a> 1.2.3 IP封装</h3>
<p>经过IP封装后的数据称为<strong>IP数据报(IP datagram)</strong>。IP数据报也包括<strong>头部信息</strong>和数据部分，其中<u>数据</u>部分就是<u>一个TCP报文段、UDP数据 报或者ICMP报文</u>。</p>
<h3 id="124-数据链路层封装"><a class="markdownIt-Anchor" href="#124-数据链路层封装"></a> 1.2.4 数据链路层封装</h3>
<p>经过数据链路层封装的数据称为<strong>帧(frame)</strong>。传输媒介不同，帧的类型也不同。</p>
<p>比如，<strong>以太网</strong>上传输的是<strong>以太网帧(ethernet frame)</strong>， 而令牌环网络上传输的则是<strong>令牌环帧(token ring frame)</strong>。以以太网帧为例，其封装格式如图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052118513.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午6.16.14" /></p>
<p>以太网帧使用<strong>6字节</strong>的目的物理地址和6字节的源物理地址来表示通信的双方。<strong>4字节</strong>CRC字段对帧的其他部分提供循环冗余校验。</p>
<p><strong>帧的最大传输单元(Max Transmit Unit，MTU)</strong>，即帧<u>最多能携带多少上层协议数据</u>(比如IP数据报)，通常受到网络类型的限制。 图1-6所示的以太网帧的MTU是1500字节。正因为如此，过长的IP数据 报可能需要被分片(fragment)传输。</p>
<p>帧才是最终在物理网络上传送的字节序列。至此，封装过程完成。</p>
<h3 id="13-分用"><a class="markdownIt-Anchor" href="#13-分用"></a> 1.3 分用</h3>
<h3 id="131-分用的流程"><a class="markdownIt-Anchor" href="#131-分用的流程"></a> 1.3.1 分用的流程</h3>
<p>1、当帧到达目的主机时，将沿着协议栈自底向上依次传递。</p>
<p>2、各层协议依次处理帧中本层负责的头部数据，以获取所需的信息。</p>
<p>3、最终将处理后的帧交给目标应用程序。</p>
<p>这个过程称为<strong>分用 (demultiplexing)</strong>，我个人理解就是对于数据报的解析。</p>
<p>分用是依靠头部信息中的类型字段实现的。<u>标准文档RFC 1700</u>定义了所有标识上层协议的类型字段以及每个上层协议对应的数值。如图显示了以太网帧的<strong>分用过程</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052119640.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.19.35" /></p>
<h3 id="132-分用时如何区分协议"><a class="markdownIt-Anchor" href="#132-分用时如何区分协议"></a> 1.3.2 分用时如何区分协议</h3>
<p>因为IP协议、ARP协议和RARP协议都使用帧传输数据，所以帧的 头部需要提供某个字段(具体情况取决于帧的类型)来区分它们。</p>
<p>以以太网帧为例，它使用2字节的类型字段来标识上层协议封装图。 如果主机接收到的以太网帧类型字段的值为0x800，则帧的数据部分 <strong>IP数据报</strong>，以太网驱动程序就将帧交付给IP模块;若类型字段的值为0x806，则帧的数据部分为<strong>ARP</strong>请求或应答报文，以太网驱动程序就将帧交付给<strong>ARP模块</strong>;若类型字段的值为0x835，则帧的数据部分为<strong>RARP</strong>请求或应答报文，以太网驱动程序就将帧交付给<strong>RARP模块</strong>。</p>
<p>简单来说就是根据字节来识别判断什么协议做什么操作。</p>
<p>同样，因为<strong>ICMP协议</strong>、<strong>TCP协议</strong>和<strong>UDP协议</strong>都使用<strong>IP协议</strong>，所以IP数据报的头部采用16位的协议(protocol)字段来区分它们。</p>
<p>TCP报文段和UDP数据报则通过其头部中的16位的端口号(port number)字段来区分上层应用程序。比如DNS协议对应的端口号是53，HTTP协议(Hyper-Text Transfer Protocol，超文本传送协议)对应的端口号是80。所有知名应用层协议使用的端口号都可在/etc/services文件中找到。</p>
<p>帧通过上述分用步骤后，最终将封装前的原始数据送至目标服务 (上图中的ARP服务、RARP服务、ICMP服务或者应用程序)。这样，在顶层目标服务看来，封装和分用似乎没有发生过。<strong>解析交给各一层的东西，直接发送到各自的端口，所以看起来是封装的，端到端的。</strong></p>
<h2 id="14-测试网络"><a class="markdownIt-Anchor" href="#14-测试网络"></a> 1.4 测试网络</h2>
<p><strong>测试网络如下图所示</strong>，其中包括两台主机A和B，以及一个连接到因特网的路由器。如没有特别声明，所有测试硬件指的都是该网络。我们将使用机器名来标识测试机器。</p>
<p>![截屏2022-05-05 下午9.19.45](…/…/…/Library/Application Support/typora-user-images/截屏2022-05-05 下午9.19.45.png)</p>
<p>该测试网络主要用于分析<strong>ARP协议</strong>、<strong>IP协议</strong>、<strong>ICMP协议</strong>、<strong>TCP协议</strong>和<strong>DNS协议</strong>。我们通过抓取该网络上的以太网帧，查看其中的以太网帧头部、IP数据报头部、TCP报文段头部信息，以获取网络通信的细节。【对于路由器，我们仅列出了其LAN网络IP地址(192.168.1.1)，而 忽略了ISP(Internet Service Provider，因特网服务提供商)给它分配的WAN网络IP地址】</p>
<h2 id="15-arp协议工作原理"><a class="markdownIt-Anchor" href="#15-arp协议工作原理"></a> 1.5 ARP协议工作原理</h2>
<p>ARP协议能实现任意<strong>网络层地址</strong>到任意<strong>物理地址</strong>的转换，不过这里仅讨论从<strong>IP地址</strong>到**以太网地址(MAC地址)**的转换。</p>
<h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3>
<p>1、主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。</p>
<p>2、此网络上的其他机器都将收到这个请求，但<strong>只有</strong>被请求的目标机器会<u>回应一个ARP应答</u>，其中<strong>包含自己的物理地址</strong>。</p>
<h3 id="151-以太网arp请求应答报文"><a class="markdownIt-Anchor" href="#151-以太网arp请求应答报文"></a> 1.5.1 以太网ARP请求/应答报文</h3>
<p>以太网ARP请求/应答报文的格式如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052120702.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.20.13" /></p>
<p><strong>硬件类型字段</strong>：定义物理地址的类型，它的值为1表示MAC地址。</p>
<p><strong>协议类型字段</strong>：表示要映射的协议地址类型，它的值为0x800，表示IP地址。</p>
<p><strong>硬件地址长度字段</strong>和<strong>协议地址长度字段</strong>：顾名思义，其单位是字节。对MAC地址来说，其长度为6;对IP(v4)地址来说，其长度为4。</p>
<p><strong>操作字段</strong>：指出4种操作类型：ARP请求(值为1)、ARP应答(值 为2)、RARP请求(值为3)和RARP应答(值为4)。</p>
<p>最后4个字段指定<strong>通信双方的以太网地址</strong>和<strong>IP地址</strong>。</p>
<p>1、发送端填充除目的端以太网地址外的其他3个字段，以构建ARP请求并发送之。</p>
<p>2、接收端发现该请求的目的端IP地址是自己，就把自己的以太网地址填进去。</p>
<p>3、然后交换两个目的端地址和两个发送端地址，以构建ARP应答并返回之(当然，如前所述，操作字段需要设置为2)。</p>
<p>就是一个交互的小过程</p>
<p>由上图可知，ARP请求/应答报文的长度为28字节。如果再加上以太网帧头部和尾部的18字节(见图1-6)，则一个携带ARP请求/应答报文的以太网帧长度为46字节。不过有的实现要求以太网帧数据部分长度至少为46字节(见图1-4)，此时ARP请求/应答报文将增加一些填充字节，以满足这个要求。在这种情况下，一个携带ARP请求/应答报文的以太网帧长度为64字节。</p>
<h3 id="152-arp高速缓存的查看和修改"><a class="markdownIt-Anchor" href="#152-arp高速缓存的查看和修改"></a> 1.5.2 ARP高速缓存的查看和修改</h3>
<p>通常，ARP维护一个高速缓存，其中<strong>包含经常访问(比如网关地址)<strong>或</strong>最近访问的机器的IP地址到物理地址的映射</strong>。这样就<u>避免了重复的ARP请求</u>，提高了发送数据包的速度。</p>
<p>Linux下可以使用arp命令来查看和修改ARP高速缓存。比如， ernest-laptop在某一时刻(注意，ARP高速缓存是动态变化的)的ARP 缓存内容如下(使用<strong>arp -a</strong>命令):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Kongming20</span>(<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>)at <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>[ether]on eth0<br>?(<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>)at <span class="hljs-number">14</span>:e6:e4:<span class="hljs-number">93</span>:<span class="hljs-number">5b</span>:<span class="hljs-number">78</span>[ether]on eth0<br></code></pre></td></tr></table></figure>
<p>第一项描述的是另一台测试机器Kongming20(注意，其IP 地址、MAC地址都与上面的总图描述的一致)。</p>
<p>第二项描述的是路由器。下面两条命令则分别删除和添加一个ARP缓存项。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo arp -d <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>#删除Kongming20对应的ARP缓存项<br>$sudo arp -s <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>#添加Kongming20对应的 ARP缓存项<br></code></pre></td></tr></table></figure>
<h3 id="153-使用tcpdump观察arp通信过程"><a class="markdownIt-Anchor" href="#153-使用tcpdump观察arp通信过程"></a> 1.5.3 使用tcpdump观察ARP通信过程</h3>
<p>为了清楚地了解ARP的运作过程，我们从ernest-laptop上执行telnet 命令登录Kongming20的echo服务(已经开启)，并用tcpdump(详见第 17章)抓取这个过程中两台测试机器之间交换的以太网帧。具体的操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo arp -d <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>#清除ARP缓存中Kongming20对应的项<br>$sudo tcpdump -i eth0-ent<span class="hljs-number">&#x27;</span>(dst <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-keyword">and</span> src <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>) <span class="hljs-built_in"><span class="hljs-keyword">or</span></span><br>(dst <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-keyword">and</span> src <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>)<span class="hljs-string">&#x27;#如无特殊声明，抓包都在机器 ernest-laptop上执行</span><br><span class="hljs-string">$telnet 192.168.1.109 echo#开启另一个终端执行telnet命令 Trying 192.168.1.109...</span><br><span class="hljs-string">Connected to 192.168.1.109.</span><br><span class="hljs-string">Escape character is &#x27;</span>^]<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">^](回车)#输入Ctrl+]并回车 telnet&gt;quit(回车) Connection closed.</span><br></code></pre></td></tr></table></figure>
<p>1、在执行telnet命令之前，应先清除ARP缓存中与Kongming20对应的项，否则ARP通信不被执行，我们也就无法抓取到期望的以太网帧。</p>
<p>2、当执行telnet命令并在两台通信主机之间建立TCP连接后(telnet输 出“Connected to 192.168.1.109”)</p>
<p>3、输入Ctrl+]以调出telnet程序的命令提示符，然后在telnet命令提示符后输入quit，退出telnet客户端程序(因为ARP通信在TCP连接建立之前就已经完成，故我们不关心后续内容)。</p>
<p>4、tcpdump抓取到的众多数据包中，只有最靠前的两个和ARP通信有关系，现在将它们列出(数据包前面的编号是笔者加入的，后同):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.00</span>:<span class="hljs-number">16</span>:d3:<span class="hljs-number">5</span>c:b9:e3&gt;ff:ff:ff:ff:ff:ff,<span class="hljs-function">ethertype <span class="hljs-title">ARP</span><span class="hljs-params">(<span class="hljs-number">0x0806</span>)</span>,length 42:Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>,length <span class="hljs-number">28</span></span><br><span class="hljs-function"><span class="hljs-number">2.08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>&gt;<span class="hljs-number">00</span>:<span class="hljs-number">16</span>:d3:<span class="hljs-number">5</span>c:b9:e3,ethertype ARP(<span class="hljs-number">0x0806</span>),length <span class="hljs-number">60</span>:Reply <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> is-at <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>,length <span class="hljs-number">46</span></span><br></code></pre></td></tr></table></figure>
<p>由tcpdump<u>抓取的数据包</u>本质上是<strong>以太网帧</strong>，我们通过该命令的众多选项来控制帧的过滤(比如用dst和src指定通信的目的端IP地址和源端IP地址)和显示(比如用-e选项开启以太网帧头部信息的显示)。</p>
<p><strong>第一个数据包</strong>中，ARP通信的<strong>源端的物理地址</strong>是00:16:d3:5c:b9:e3(ernest-laptop)，<strong>目的端的物理地址</strong>是ff:ff:ff:ff:ff:ff， 这是以太网的广播地址，用以表示整个LAN。</p>
<p>1、该LAN上的所有机器都会收到并处理这样的帧。</p>
<p>2、数值0x806是以太网帧头部的类型字段的值， 它表示分用的目标是ARP模块。</p>
<p>3、该以太网帧的长度为42字节(实际上是46字节，tcpdump未统计以太网帧尾部4字节的CRC字段)，其中数据部分长度为28字节。</p>
<p>4、“Request”表示这是一个ARP请求，“who-has 192.168.1.109 tell 192.168.1.108”则表示是ernest-laptop要查询Kongming20的IP地址。</p>
<p><strong>第二个数据包</strong>中，ARP通信的<strong>源端的物理地址</strong>是 08:00:27:53:10:67(Kongming20)，<strong>目的端的物理地址</strong>是 00:16:d3:5c:b9:e3(ernest-laptop)。</p>
<p>1、“Reply”表示这是一个ARP应答，“192.168.1.109 is-at 08:00:27:53:10:67”则表示目标机器Kongming20 报告其物理地址。</p>
<p>2、该以太网帧的长度为60字节(实际上是64字节)， 可见它使用了填充字节来满足最小帧长度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052117137.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.16.56" /></p>
<p>1、我们将两次传输的以太网帧按照图1-6所描述的以太网帧封装格式绘制在图的下半部分。</p>
<p>2、ARP请求和应答是从<u>以太网驱动程序发出的，而并非像图中描述的那样从ARP模块直接发送到以太网上</u>，所以我们将它们用虚线表示，这主要是为了体现携带ARP数据的以太网帧和其他以太网帧 (比如携带IP数据报的以太网帧)的区别。</p>
<p>3、路由器也将接收到以太网帧1，因为该<strong>帧是一个广播帧</strong>。不过很显然，<u>路由器并没有回应其中的ARP请求</u>，正如前文讨论的那</p>
<p>样。</p>
<h2 id="16-dns工作原理"><a class="markdownIt-Anchor" href="#16-dns工作原理"></a> 1.6 DNS工作原理</h2>
<p>我们通常使用机器的<u>域名来访问</u>这台机器，而<u>不直接使用其IP</u>地址，比如访问因特网上的各种网站。那么如何将机器的域名转换成IP地址呢?这就需要使用域名查询服务。域名查询服务有很多种实现方式，比如NIS(Network Information Service，网络信息服务)、DNS和本地静态文件等。本节主要讨论DNS。</p>
<h3 id="161-dns查询和应答报文详解"><a class="markdownIt-Anchor" href="#161-dns查询和应答报文详解"></a> 1.6.1 DNS查询和应答报文详解</h3>
<p>DNS是一套分布式的域名服务系统。</p>
<p>每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且是动态更新的。</p>
<p>众多网络客户端程序都使用DNS协议来向DNS服务器查询目标主机的IP地址。</p>
<p>DNS查询和应答报文的格式如图1-11所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052125476.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.25.01" /></p>
<p>16位标识[1]字段用于标记一对<strong>DNS查询</strong>和<strong>应答</strong>，以此<u>区分一个DNS应答是哪个DNS查询的回应</u>。</p>
<p>16位标志字段用于<strong>协商具体的通信方式</strong>和<strong>反馈通信状态</strong>。DNS报文头部的16位标志字段的细节如图1-12所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052126399.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.26.22" /></p>
<p><strong>QR</strong>：查询/应答标志。0表示这是一个查询报文，1表示这是一个应答报文。</p>
<p><strong>opcode</strong>：定义查询和应答的类型。0表示标准查询，1表示反向查询(由IP地址获得主机域名)，2表示请求服务器状态。</p>
<p><strong>AA</strong>：授权应答标志，仅由应答报文使用。1表示域名服务器是授权服务器。</p>
<p><strong>TC</strong>：截断标志，仅当DNS报文使用UDP服务时使用。因为UDP数据报有长度限制，所以过长的DNS报文将被截断。1表示DNS报文超过512字节，并被截断。</p>
<p><strong>RD</strong>：递归查询标志。1表示执行递归查询，即如果目标DNS服务器无法解析某个主机名，则它将向其他DNS服务器继续查询，如此递 归，直到获得结果并把该结果返回给客户端。0表示执行迭代查询，即如果目标DNS服务器无法解析某个主机名，则它将自己知道的其他 DNS服务器的IP地址返回给客户端，以供客户端参考。</p>
<p><strong>RA</strong>：允许递归标志。仅由应答报文使用，1表示DNS服务器支持递归查询。</p>
<p><strong>zero</strong>：这3位未用，必须都设置为0。</p>
<p><strong>rcode</strong>：4位返回码，表示应答的状态。常用值有0(无错误)和3(域名不存在)。</p>
<p>接下来的4个字段则分别指出DNS报文的最后4个字段的资源记录数目。对<strong>查询报文</strong>而言，它一般包含1个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。<strong>应答报文</strong>的应答资源记录数则至少为1，而授权资源记录数和额外资源记录数可为0或非0。</p>
<p>查询问题的格式如图1-13所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052130947.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.30.27" /></p>
<p><strong>查询名</strong>以<u>一定的格式封装了要查询的主机域名</u>。16位查询类型表示如何执行查询操作，常见的类型有如下几种:</p>
<p>类型A：值是1，表示获取目标主机的IP地址。</p>
<p>类型CNAME：值是5，表示获得目标主机的别名。</p>
<p>类型PTR：值是12，表示反向查询。</p>
<p><strong>16位查询类</strong>：通常为1，表示获取因特网地址(IP地址)。</p>
<p>应答字段、授权字段和额外信息字段都使用资源记录(Resource Record，RR)格式。资源记录格式如图1-14所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052133025.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.33.13" /></p>
<p><strong>32位域名</strong>：是该记录中与资源对应的名字，其格式和查询问题中的查询名字段相同。</p>
<p><strong>16位类型</strong>和<strong>16位类</strong>字段：含义也与DNS查询问题的对应字段相同。</p>
<p><strong>32位生存时间</strong>：表示该查询记录结果可被本地客户端程序缓存多长时间，单位是秒。</p>
<p><strong>16位资源数据长度字段和资源数据字段</strong>：的内容取决于类型字段对类型A而言，资源数据是32位的IPv4地址，而资源数据长度则为 4(以字节为单位)。</p>
<p>至此，我们简要地介绍了DNS协议。我们将在后面给出一个DNS通信的具体例子。DNS协议的更多细节请参考其RFC文档(DNS协议 存在诸多RFC文档，每个RFC文档介绍其一个侧面，比如RFC 1035介绍的是域名的实现和规范，RFC 1886则描述DNS协议对IPv6的扩展支 持)。</p>
<h3 id="162-linux下访问dns服务"><a class="markdownIt-Anchor" href="#162-linux下访问dns服务"></a> 1.6.2 Linux下访问DNS服务</h3>
<p>我们要访问DNS服务，就必须先知道DNS服务器的IP地址。Linux 使用/etc/resolv.conf文件来存放DNS服务器的IP地址。机器ernest-laptop上，该文件的内容如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">#Generated by Network Manager<br> nameserver <span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><br> nameserver <span class="hljs-number">124.207</span><span class="hljs-number">.160</span><span class="hljs-number">.106</span><br></code></pre></td></tr></table></figure>
<p>其中的两个IP地址分别是<strong>首选DNS服务器地址</strong>和<strong>备选DNS服务器</strong>地址。</p>
<p>文件中的注释语句“Generated by Network Manager”告诉我们，这<u>两个DNS服务器地址是由网络管理程序写入</u>的。</p>
<p>Linux下一个常用的<strong>访问DNS服务器的客户端程序</strong>是host，比如下面的命令是<u>向首选DNS服务器219.239.26.42查询</u>机器www.baidu.com的IP地址:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">$host -t A www.baidu.com<br>www.baidu.com is an alias <span class="hljs-keyword">for</span> www.a.shifen.com.<br>www.a.shifen.com has address <span class="hljs-number">119.75</span><span class="hljs-number">.217</span><span class="hljs-number">.56</span><br>www.a.shifen.com has address <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><br></code></pre></td></tr></table></figure>
<p>1、host命令的输出告诉我们，机器名www.baidu.com是 www.a.shifen.com.的<strong>别名</strong>（alias），并且该机器名对应两个IP地址。</p>
<p>2、host命令使用<strong>DNS协议</strong>和<strong>DNS服务器通信</strong>，其-t选项<u>告诉DNS协议使用哪种查询类型</u>。</p>
<p>3、我们这里使用的是<strong>A类型</strong>，即<strong>通过机器的域名获得其IP地址</strong>(但实际上返回的资源记录中还包含机器的别名)。</p>
<h3 id="163-使用tcpdump观察dns通信过程"><a class="markdownIt-Anchor" href="#163-使用tcpdump观察dns通信过程"></a> 1.6.3 使用tcpdump观察DNS通信过程</h3>
<p>为了看清楚DNS通信的过程，下面我们将从ernest-laptop上运行<strong>host命令</strong>以查询主机www.baidu.com对应的IP地址，并使用<strong>tcpdump抓取</strong>这一过程中<u>LAN上传输的以太网帧</u>。具体的操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -i eth0 -nt -s <span class="hljs-number">500</span> port domain<br>$host -t A www.baidu.com<br></code></pre></td></tr></table></figure>
<p>这一次执行tcpdump抓包时，我们使用“port domain”来过滤数据包，表示<u>只抓取使用domain(域名)服务的数据包</u>，即DNS查询和应答报文。tcpdump的输出如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34319</span> &gt; <span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><span class="hljs-number">.53</span>: <span class="hljs-number">57428</span>+ A? www.baidu.com. (<span class="hljs-number">31</span>)<br><span class="hljs-number">2.</span>IP <span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><span class="hljs-number">.53</span> &gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34319</span>: <span class="hljs-number">57428</span> <span class="hljs-number">3</span>/<span class="hljs-number">4</span>/<span class="hljs-number">4</span> CNAME www.a.shifen.com.,A <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span>,A <span class="hljs-number">119.75</span><span class="hljs-number">.217</span><span class="hljs-number">.56</span>(<span class="hljs-number">226</span>)<br></code></pre></td></tr></table></figure>
<p>1、这两个数据包开始的“IP”指出，它们后面的内容描述的是<strong>IP数据报</strong>。</p>
<p>2、tcpdump以“<strong>IP地址.端口号</strong>”的形式来描述通信的某一端。</p>
<p>3、以“&gt;”表 示数据传输的方向，“&gt;”前面是<strong>源端</strong>，后面是<strong>目的端</strong>。</p>
<p>4、可见，第一个数据包是测试机器ernest-laptop(IP地址是192.168.1.108)向其首选DNS服务器(IP地址是219.239.26.42)发送的<strong>DNS查询报文</strong>(目标端口53是<strong>DNS服务使用的端口</strong>，这一点我们在前面介绍过)，第二个数据包是<strong>服务器反馈的DNS应答报文</strong>。</p>
<p><strong>第一个数据包中</strong>：</p>
<p>数值57428是<strong>DNS查询报文</strong>的标识值，因此该值也出现在<strong>DNS应答报文</strong>中。“+”表示启用<strong>递归查询标志</strong>。“A?”表示使用<strong>A类型的查询方式</strong>。“<a target="_blank" rel="noopener" href="http://www.baidu.com">www.baidu.com</a>”则是<strong>DNS查询问题中的查询名</strong>。 括号中的数值31是DNS查询报文的长度(以字节为单位)。</p>
<p><strong>第二个数据包中</strong>：</p>
<p>“3/4/4”表示该报文中包含<strong>3个应答资源记录</strong>、<strong>4 个授权资源记录</strong>和<strong>4个额外信息记录</strong>。“CNAME <a target="_blank" rel="noopener" href="http://www.a.shifen.com">www.a.shifen.com</a>.，A 119.75.218.77，A 119.75.217.56”则表示3个应答资源记录的内容。其中<strong>CNAME表示紧随其后的记录是机器的别名</strong>，<strong>A表示紧随其后的记录是IP地址</strong>。该应答报文的长度为226字节。</p>
<p>PS：我们抓包的时候没有开启tcpdump的-X选项(或者-x选 项)。如果使用-X选项，我们将能看到DNS报文的每一个字节，也就 能明白上面31字节的查询报文和226字节的应答报文的具体含义。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/15/codeTop/">
                        <span class="hidden-mobile">CodeTop</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
