

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <meta name="description" content="第1章 TCP&#x2F;IP协议族  1.1 TCP&#x2F;IP协议族体系结构以及主要协议   1.1.1 数据链路层 ARP和RARP协议实现了IP地址和机器物理地址(通 常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址) 之间的相互转换  ARP协议（Address Resolve Protocol，地址解析协议） 网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻址一台机器，">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux高性能服务器编程">
<meta property="og:url" content="http://example.com/2022/05/03/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第1章 TCP&#x2F;IP协议族  1.1 TCP&#x2F;IP协议族体系结构以及主要协议   1.1.1 数据链路层 ARP和RARP协议实现了IP地址和机器物理地址(通 常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址) 之间的相互转换  ARP协议（Address Resolve Protocol，地址解析协议） 网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻址一台机器，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071505040.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071505484.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071504810.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052119363.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052118653.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052118513.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052119640.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052120702.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052117137.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052125476.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052126399.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052130947.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052133025.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071553191.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205072139077.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205072159863.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205081527791.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205081554166.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091446138.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091501261.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091506319.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091514830.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091554080.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091554401.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091600766.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091629187.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091633489.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091654334.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091740284.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091833324.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205092023605.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205121608151.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205131634108.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142122368.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142127783.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142147580.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142150680.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142153207.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142156591.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142201066.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205161643321.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205161712755.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205161827241.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205162120269.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205162146797.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205172044910.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205181750387.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205172102909.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205172105793.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205182136344.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205182140957.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205182200198.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205192105914.png">
<meta property="article:published_time" content="2022-05-02T16:00:00.000Z">
<meta property="article:modified_time" content="2022-05-19T14:21:30.076Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071505040.png">
  
  <title>Linux高性能服务器编程 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>PanPan</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/Title%20page/title.jpeg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Linux高性能服务器编程">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-05-03 00:00" pubdate>
        2022年5月3日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      94k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      295 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Linux高性能服务器编程</h1>
            
            <div class="markdown-body">
              <h1 id="第1章-tcpip协议族"><a class="markdownIt-Anchor" href="#第1章-tcpip协议族"></a> 第1章 TCP/IP协议族</h1>
<h2 id="11-tcpip协议族体系结构以及主要协议"><a class="markdownIt-Anchor" href="#11-tcpip协议族体系结构以及主要协议"></a> 1.1 TCP/IP协议族体系结构以及主要协议</h2>
<img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071505040.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-07 下午3.05.28" style="zoom:200%;" />
<h3 id="111-数据链路层"><a class="markdownIt-Anchor" href="#111-数据链路层"></a> 1.1.1 数据链路层</h3>
<p><strong>ARP和RARP协议</strong>实现了IP地址和机器物理地址(通 常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址) 之间的相互转换</p>
<h4 id="arp协议address-resolve-protocol地址解析协议"><a class="markdownIt-Anchor" href="#arp协议address-resolve-protocol地址解析协议"></a> ARP协议（Address Resolve Protocol，地址解析协议）</h4>
<p>网络层使用<strong>IP地址</strong>寻址一台机器，而数据链路层使用<strong>物理地址</strong>寻址一台机器，因此网络层必须先将目标机器的<u>IP地址转化成其物理地址</u>，才能使用数据链路层提供的服务。</p>
<h4 id="rarp协议reverse-address-resolve-protocol逆地址解析协议"><a class="markdownIt-Anchor" href="#rarp协议reverse-address-resolve-protocol逆地址解析协议"></a> RARP协议(Reverse Address Resolve Protocol，逆地址解析协议)</h4>
<p>用于网络上的某些无盘工作站。因为缺乏存储设备，无盘工作站无法记住自己的IP地址，但它们可以利用网卡上的物理地址来向网络管理者(服务器或网络管理软件)查询自身的IP地址。</p>
<p>PS：运行RARP服 务的网络管理者通常存有该网络上所有机器的物理地址到IP地址的映射。</p>
<h3 id="112-网络层"><a class="markdownIt-Anchor" href="#112-网络层"></a> 1.1.2 网络层</h3>
<p>网络层实现数据包的选路和转发。</p>
<p>通信的两台主机一般<u>不是直接相连</u>的，而是通过多个中间节点(路由器)连接的就是选择这些中间节点，以确定两台主机之间的通信路径。同时，网络层对上层协议<u>隐藏了网络拓扑连接</u>的细节，使得在<u>传输层和网络应用程序</u><u>看来，通信的双方是直接相连</u>的。</p>
<h4 id="ip协议internet-protocol因特网协议"><a class="markdownIt-Anchor" href="#ip协议internet-protocol因特网协议"></a> IP协议（Internet Protocol，因特网协议）</h4>
<p>step 1: IP协议<strong>根据数据包的目的IP地址</strong>来决定如何投递它。</p>
<p>step 2: 如果数据包<u>不能直接发送</u>给目标主机，那么IP协议就为它<strong>寻找一个合适的下一跳(next hop)<strong>路由器，并将数据包</strong>交付给该路由器</strong>来转发。</p>
<p>重复step1、2直到最后发送到目的地，或者由于发送失败而丢弃。</p>
<p>PS：IP协议使用逐跳(hop by hop)的方式确定通信路径</p>
<h4 id="icmp协议internet-control-message-protocol-因特网控制报文协议"><a class="markdownIt-Anchor" href="#icmp协议internet-control-message-protocol-因特网控制报文协议"></a> ICMP协议（Internet Control Message Protocol， 因特网控制报文协议）</h4>
<p>它是IP协议的重要补充，主要用于<strong>检测网络连接</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071505484.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-07 下午3.04.44" /></p>
<p>主要分两种：1）用来回应网络错误 2）用来查询网络信息如ping程序</p>
<p>ICMP协议并非严格意义上的网络层协议，因为它使用处于同一层的IP协议提供的服务(一般来说，上层协议使用下层协议提供的服务)。</p>
<h3 id="113-传输层"><a class="markdownIt-Anchor" href="#113-传输层"></a> 1.1.3 传输层</h3>
<p>传输层为两台主机上的应用程序提供<strong>端到端(end to end)<strong>的通信。与网络层使用的逐跳通信方式不同，传输层</strong>只关心通信的起始端和目的端，而不在乎数据包的中转过程</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071504810.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-07 下午3.04.16" /></p>
<p>垂直的实线箭头表示TCP/IP协议族各层之间的<strong>实体通信</strong>，而水平的虚线箭头表示<strong>逻辑通信线路</strong>。该图中还附带描述了<strong>不同物理网络的连接方法</strong>。可见，数据链路层(驱动程序)<strong>封装了物理网络的电气细节</strong>;网络层<strong>封装了网络连接</strong>的细节;传输层则为应用程序<strong>封装了一条端到端的逻辑通信链路</strong>，它负责数据<u>的收发、链路的超时重连</u>等。</p>
<h4 id="tcp协议transmission-control-protocol传输控制协议"><a class="markdownIt-Anchor" href="#tcp协议transmission-control-protocol传输控制协议"></a> TCP协议(Transmission Control Protocol，传输控制协议)</h4>
<p>1、为应用层提供<u>可靠的、面向连接的和基于流(stream)</u>的服务。</p>
<p>2、TCP协议使用<u>超时重传、数据确认</u>等方式来<strong>确保数据包被正确地发送至目的端</strong>，因此TCP服务是<strong>可靠</strong>的。</p>
<p>3、使用TCP协议通信的双方必须<strong>先建立TCP连接</strong>， 并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等。</p>
<p>4、当通信结束时，双方必须关闭连接以释放这些内核数据。</p>
<p>5、TCP服务是基于流的。<strong>基于流的数据没有边界(长度)限制</strong>，它<u>源源不断地从通信的一端流入另一端</u>。</p>
<p>6、发送端可以逐个 字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出。</p>
<h4 id="udp协议user-datagram-protocol用户数据报协议"><a class="markdownIt-Anchor" href="#udp协议user-datagram-protocol用户数据报协议"></a> UDP协议(User Datagram Protocol，用户数据报协议)</h4>
<p>它为应用层提供<u>不可靠、无连接和基于数据报</u>的服务。（与TCP完全相反）</p>
<p>1、<strong>“不可靠”<strong>意味着UDP协议无法保证数据从发送端正确地传送到目的端。如果数据在</strong>中途丢失</strong>，或者目的端通过数据校验<strong>发现数据错误而将其丢弃</strong>，则UDP协议只是<strong>简单地通知应用程序发送失败</strong>。因此，使用UDP协议的应用程序通常要<u>自己处理数据确认、超时重传</u>等逻辑。</p>
<p>2、UDP协议是无连接的，即<strong>通信双方不保持一个长久的联系</strong>，因此应用程序<strong>每次发送数据都要明确指定接收端的地址</strong>(IP地址等信息)。</p>
<p>3、基于数据报的服务，<u>是相对基于流的服务而言的</u>。每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其<u>所有内容一次性读出</u>，否则数据将被截断。</p>
<h4 id="sctp协议stream-control-transmission-protocol流控制传输协议"><a class="markdownIt-Anchor" href="#sctp协议stream-control-transmission-protocol流控制传输协议"></a> SCTP协议(Stream Control Transmission Protocol，流控制传输协议)</h4>
<p>是一种相对较新的传输层协议，它是为了在因特网上传输电话信号而设计的。</p>
<h3 id="114-应用层"><a class="markdownIt-Anchor" href="#114-应用层"></a> 1.1.4 应用层</h3>
<p>应用层负责处理应用程序的逻辑。</p>
<p>内核态：<u>数据链路层、网络层和传输层</u>负责处理网络通信细节，这部分必须既稳定又高效，因此它们都在内核空间中实现</p>
<p>用户态：应用层则在用户空间实现，因为它负责处理众多逻辑，比如文件传输、名称查询和网络管理等。</p>
<h4 id="ping应用程序"><a class="markdownIt-Anchor" href="#ping应用程序"></a> ping应用程序</h4>
<p>它利用ICMP报文检测网络连接，是调试网络环境的必备工具。</p>
<h4 id="telnet协议"><a class="markdownIt-Anchor" href="#telnet协议"></a> telnet协议</h4>
<p>它使我们能在本地完成远程任务</p>
<h4 id="ospfopen-shortest-path-first开放最短路径优先协议"><a class="markdownIt-Anchor" href="#ospfopen-shortest-path-first开放最短路径优先协议"></a> OSPF(Open Shortest Path First，开放最短路径优先)协议</h4>
<p>是一种动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由信息。</p>
<h4 id="dnsdomain-name-service域名服务协议"><a class="markdownIt-Anchor" href="#dnsdomain-name-service域名服务协议"></a> DNS(Domain Name Service，域名服务)协议</h4>
<p>提供机器域名到IP地址的转换，我们将在后面简要介绍DNS协议。</p>
<p>应用层协议(或程序)可能跳过传输层直接使用网络层提供的服务，比如ping程序和OSPF协议。应用层协议(或程序)通常既可以使用TCP服务，又可以使用UDP服务，比如DNS协议。我们可以通过/etc/services文件查看所有知名的应用层协议，以及它们都能使用哪些传输层服务。</p>
<h2 id="12-封装"><a class="markdownIt-Anchor" href="#12-封装"></a> 1.2 封装</h2>
<p>上层协议是如何使用下层协议提供的服务的呢?其实这是通过封装(encapsulation)实现的。</p>
<p>应用程序数据在发送到物理网络上之前， 将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加上自己的头部信息(有时还包括尾部信息)，以实现该层的功能， 这个过程就称为封装，如图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052119363.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.19.17" /></p>
<h3 id="121-tcp封装"><a class="markdownIt-Anchor" href="#121-tcp封装"></a> 1.2.1 TCP封装</h3>
<p>经过TCP封装后的数据称为<strong>TCP报文段(TCP message segment)</strong>，或者简称TCP段。</p>
<p>前文提到，TCP协议为通信双方维持一个连接，并且在内核中存储相关数据。这部分数据中的<strong>TCP头部信息</strong>和<strong>TCP内核缓冲区</strong>(发送缓冲区或接收缓冲区)<strong>数据</strong>一起构成了TCP报文段。</p>
<p>封装过程如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052118653.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.18.56" /></p>
<p>当发送端应用程序使用send(或者write)函数向一个TCP连接写入数据过程</p>
<p>1、内核中的TCP模块首先<u>把这些数据复制到与该连接对应的TCP</u>内核发送缓冲区中</p>
<p>2、TCP模块调用IP模块提供的服务，传递的参数包括TCP头部信息和TCP发送缓冲区中的数据，即TCP报文段。</p>
<h3 id="122-udp封装"><a class="markdownIt-Anchor" href="#122-udp封装"></a> 1.2.2 UDP封装</h3>
<p>经过UDP封装后的数据称为<strong>UDP数据报(UDP datagram)</strong>。</p>
<p>UDP 对应用程序数据的封装与TCP类似。不同的是，UDP<strong>无须为应用层数据保存副本</strong>，因为它提供的服务是<strong>不可靠的</strong>。</p>
<p>1、当一个UDP数据报被成功发送之后，UDP内核缓冲区中的该数据报就被丢弃了。</p>
<p>2、如果应用程序检测到该数据报未能被接收端正确接收，并打算<strong>重发</strong>这个数据报，则应用程序需要<u>重新从用户空间将该数据报拷贝到UDP内核发送缓冲区</u>中。</p>
<h3 id="123-ip封装"><a class="markdownIt-Anchor" href="#123-ip封装"></a> 1.2.3 IP封装</h3>
<p>经过IP封装后的数据称为<strong>IP数据报(IP datagram)</strong>。IP数据报也包括<strong>头部信息</strong>和数据部分，其中<u>数据</u>部分就是<u>一个TCP报文段、UDP数据 报或者ICMP报文</u>。</p>
<h3 id="124-数据链路层封装"><a class="markdownIt-Anchor" href="#124-数据链路层封装"></a> 1.2.4 数据链路层封装</h3>
<p>经过数据链路层封装的数据称为<strong>帧(frame)</strong>。传输媒介不同，帧的类型也不同。</p>
<p>比如，<strong>以太网</strong>上传输的是<strong>以太网帧(ethernet frame)</strong>， 而令牌环网络上传输的则是<strong>令牌环帧(token ring frame)</strong>。以以太网帧为例，其封装格式如图所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052118513.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午6.16.14" /></p>
<p>以太网帧使用<strong>6字节</strong>的目的物理地址和6字节的源物理地址来表示通信的双方。<strong>4字节</strong>CRC字段对帧的其他部分提供循环冗余校验。</p>
<p><strong>帧的最大传输单元(Max Transmit Unit，MTU)</strong>，即帧<u>最多能携带多少上层协议数据</u>(比如IP数据报)，通常受到网络类型的限制。 图1-6所示的以太网帧的MTU是1500字节。正因为如此，过长的IP数据 报可能需要被分片(fragment)传输。</p>
<p>帧才是最终在物理网络上传送的字节序列。至此，封装过程完成。</p>
<h3 id="13-分用"><a class="markdownIt-Anchor" href="#13-分用"></a> 1.3 分用</h3>
<h3 id="131-分用的流程"><a class="markdownIt-Anchor" href="#131-分用的流程"></a> 1.3.1 分用的流程</h3>
<p>1、当帧到达目的主机时，将沿着协议栈自底向上依次传递。</p>
<p>2、各层协议依次处理帧中本层负责的头部数据，以获取所需的信息。</p>
<p>3、最终将处理后的帧交给目标应用程序。</p>
<p>这个过程称为<strong>分用 (demultiplexing)</strong>，我个人理解就是对于数据报的解析。</p>
<p>分用是依靠头部信息中的类型字段实现的。<u>标准文档RFC 1700</u>定义了所有标识上层协议的类型字段以及每个上层协议对应的数值。如图显示了以太网帧的<strong>分用过程</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052119640.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.19.35" /></p>
<h3 id="132-分用时如何区分协议"><a class="markdownIt-Anchor" href="#132-分用时如何区分协议"></a> 1.3.2 分用时如何区分协议</h3>
<p>因为IP协议、ARP协议和RARP协议都使用帧传输数据，所以帧的 头部需要提供某个字段(具体情况取决于帧的类型)来区分它们。</p>
<p>以以太网帧为例，它使用2字节的类型字段来标识上层协议封装图。 如果主机接收到的以太网帧类型字段的值为0x800，则帧的数据部分 <strong>IP数据报</strong>，以太网驱动程序就将帧交付给IP模块;若类型字段的值为0x806，则帧的数据部分为<strong>ARP</strong>请求或应答报文，以太网驱动程序就将帧交付给<strong>ARP模块</strong>;若类型字段的值为0x835，则帧的数据部分为<strong>RARP</strong>请求或应答报文，以太网驱动程序就将帧交付给<strong>RARP模块</strong>。</p>
<p>简单来说就是根据字节来识别判断什么协议做什么操作。</p>
<p>同样，因为<strong>ICMP协议</strong>、<strong>TCP协议</strong>和<strong>UDP协议</strong>都使用<strong>IP协议</strong>，所以IP数据报的头部采用16位的协议(protocol)字段来区分它们。</p>
<p>TCP报文段和UDP数据报则通过其头部中的16位的端口号(port number)字段来区分上层应用程序。比如DNS协议对应的端口号是53，HTTP协议(Hyper-Text Transfer Protocol，超文本传送协议)对应的端口号是80。所有知名应用层协议使用的端口号都可在/etc/services文件中找到。</p>
<p>帧通过上述分用步骤后，最终将封装前的原始数据送至目标服务 (上图中的ARP服务、RARP服务、ICMP服务或者应用程序)。这样，在顶层目标服务看来，封装和分用似乎没有发生过。<strong>解析交给各一层的东西，直接发送到各自的端口，所以看起来是封装的，端到端的。</strong></p>
<h2 id="14-测试网络"><a class="markdownIt-Anchor" href="#14-测试网络"></a> 1.4 测试网络</h2>
<p><strong>测试网络如下图所示</strong>，其中包括两台主机A和B，以及一个连接到因特网的路由器。如没有特别声明，所有测试硬件指的都是该网络。我们将使用机器名来标识测试机器。</p>
<p>![截屏2022-05-05 下午9.19.45](…/…/…/Library/Application Support/typora-user-images/截屏2022-05-05 下午9.19.45.png)</p>
<p>该测试网络主要用于分析<strong>ARP协议</strong>、<strong>IP协议</strong>、<strong>ICMP协议</strong>、<strong>TCP协议</strong>和<strong>DNS协议</strong>。我们通过抓取该网络上的以太网帧，查看其中的以太网帧头部、IP数据报头部、TCP报文段头部信息，以获取网络通信的细节。【对于路由器，我们仅列出了其LAN网络IP地址(192.168.1.1)，而 忽略了ISP(Internet Service Provider，因特网服务提供商)给它分配的WAN网络IP地址】</p>
<h2 id="15-arp协议工作原理"><a class="markdownIt-Anchor" href="#15-arp协议工作原理"></a> 1.5 ARP协议工作原理</h2>
<p>ARP协议能实现任意<strong>网络层地址</strong>到任意<strong>物理地址</strong>的转换，不过这里仅讨论从<strong>IP地址</strong>到**以太网地址(MAC地址)**的转换。</p>
<h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3>
<p>1、主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。</p>
<p>2、此网络上的其他机器都将收到这个请求，但<strong>只有</strong>被请求的目标机器会<u>回应一个ARP应答</u>，其中<strong>包含自己的物理地址</strong>。</p>
<h3 id="151-以太网arp请求应答报文"><a class="markdownIt-Anchor" href="#151-以太网arp请求应答报文"></a> 1.5.1 以太网ARP请求/应答报文</h3>
<p>以太网ARP请求/应答报文的格式如图</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052120702.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.20.13" /></p>
<p><strong>硬件类型字段</strong>：定义物理地址的类型，它的值为1表示MAC地址。</p>
<p><strong>协议类型字段</strong>：表示要映射的协议地址类型，它的值为0x800，表示IP地址。</p>
<p><strong>硬件地址长度字段</strong>和<strong>协议地址长度字段</strong>：顾名思义，其单位是字节。对MAC地址来说，其长度为6;对IP(v4)地址来说，其长度为4。</p>
<p><strong>操作字段</strong>：指出4种操作类型：ARP请求(值为1)、ARP应答(值 为2)、RARP请求(值为3)和RARP应答(值为4)。</p>
<p>最后4个字段指定<strong>通信双方的以太网地址</strong>和<strong>IP地址</strong>。</p>
<p>1、发送端填充除目的端以太网地址外的其他3个字段，以构建ARP请求并发送之。</p>
<p>2、接收端发现该请求的目的端IP地址是自己，就把自己的以太网地址填进去。</p>
<p>3、然后交换两个目的端地址和两个发送端地址，以构建ARP应答并返回之(当然，如前所述，操作字段需要设置为2)。</p>
<p>就是一个交互的小过程</p>
<p>由上图可知，ARP请求/应答报文的长度为28字节。如果再加上以太网帧头部和尾部的18字节(见图1-6)，则一个携带ARP请求/应答报文的以太网帧长度为46字节。不过有的实现要求以太网帧数据部分长度至少为46字节(见图1-4)，此时ARP请求/应答报文将增加一些填充字节，以满足这个要求。在这种情况下，一个携带ARP请求/应答报文的以太网帧长度为64字节。</p>
<h3 id="152-arp高速缓存的查看和修改"><a class="markdownIt-Anchor" href="#152-arp高速缓存的查看和修改"></a> 1.5.2 ARP高速缓存的查看和修改</h3>
<p>通常，ARP维护一个高速缓存，其中<strong>包含经常访问(比如网关地址)<strong>或</strong>最近访问的机器的IP地址到物理地址的映射</strong>。这样就<u>避免了重复的ARP请求</u>，提高了发送数据包的速度。</p>
<p>Linux下可以使用arp命令来查看和修改ARP高速缓存。比如， ernest-laptop在某一时刻(注意，ARP高速缓存是动态变化的)的ARP 缓存内容如下(使用<strong>arp -a</strong>命令):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Kongming20</span>(<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>)at <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>[ether]on eth0<br>?(<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>)at <span class="hljs-number">14</span>:e6:e4:<span class="hljs-number">93</span>:<span class="hljs-number">5b</span>:<span class="hljs-number">78</span>[ether]on eth0<br></code></pre></td></tr></table></figure>
<p>第一项描述的是另一台测试机器Kongming20(注意，其IP 地址、MAC地址都与上面的总图描述的一致)。</p>
<p>第二项描述的是路由器。下面两条命令则分别删除和添加一个ARP缓存项。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo arp -d <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>#删除Kongming20对应的ARP缓存项<br>$sudo arp -s <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>#添加Kongming20对应的 ARP缓存项<br></code></pre></td></tr></table></figure>
<h3 id="153-使用tcpdump观察arp通信过程"><a class="markdownIt-Anchor" href="#153-使用tcpdump观察arp通信过程"></a> 1.5.3 使用tcpdump观察ARP通信过程</h3>
<p>为了清楚地了解ARP的运作过程，我们从ernest-laptop上执行telnet 命令登录Kongming20的echo服务(已经开启)，并用tcpdump(详见第 17章)抓取这个过程中两台测试机器之间交换的以太网帧。具体的操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo arp -d <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>#清除ARP缓存中Kongming20对应的项<br>$sudo tcpdump -i eth0-ent<span class="hljs-number">&#x27;</span>(dst <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-keyword">and</span> src <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>) <span class="hljs-built_in"><span class="hljs-keyword">or</span></span><br>(dst <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-keyword">and</span> src <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>)<span class="hljs-string">&#x27;#如无特殊声明，抓包都在机器 ernest-laptop上执行</span><br><span class="hljs-string">$telnet 192.168.1.109 echo#开启另一个终端执行telnet命令 Trying 192.168.1.109...</span><br><span class="hljs-string">Connected to 192.168.1.109.</span><br><span class="hljs-string">Escape character is &#x27;</span>^]<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">^](回车)#输入Ctrl+]并回车 telnet&gt;quit(回车) Connection closed.</span><br></code></pre></td></tr></table></figure>
<p>1、在执行telnet命令之前，应先清除ARP缓存中与Kongming20对应的项，否则ARP通信不被执行，我们也就无法抓取到期望的以太网帧。</p>
<p>2、当执行telnet命令并在两台通信主机之间建立TCP连接后(telnet输 出“Connected to 192.168.1.109”)</p>
<p>3、输入Ctrl+]以调出telnet程序的命令提示符，然后在telnet命令提示符后输入quit，退出telnet客户端程序(因为ARP通信在TCP连接建立之前就已经完成，故我们不关心后续内容)。</p>
<p>4、tcpdump抓取到的众多数据包中，只有最靠前的两个和ARP通信有关系，现在将它们列出(数据包前面的编号是笔者加入的，后同):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.00</span>:<span class="hljs-number">16</span>:d3:<span class="hljs-number">5</span>c:b9:e3&gt;ff:ff:ff:ff:ff:ff,<span class="hljs-function">ethertype <span class="hljs-title">ARP</span><span class="hljs-params">(<span class="hljs-number">0x0806</span>)</span>,length 42:Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>,length <span class="hljs-number">28</span></span><br><span class="hljs-function"><span class="hljs-number">2.08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>&gt;<span class="hljs-number">00</span>:<span class="hljs-number">16</span>:d3:<span class="hljs-number">5</span>c:b9:e3,ethertype ARP(<span class="hljs-number">0x0806</span>),length <span class="hljs-number">60</span>:Reply <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> is-at <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>,length <span class="hljs-number">46</span></span><br></code></pre></td></tr></table></figure>
<p>由tcpdump<u>抓取的数据包</u>本质上是<strong>以太网帧</strong>，我们通过该命令的众多选项来控制帧的过滤(比如用dst和src指定通信的目的端IP地址和源端IP地址)和显示(比如用-e选项开启以太网帧头部信息的显示)。</p>
<p><strong>第一个数据包</strong>中，ARP通信的<strong>源端的物理地址</strong>是00:16:d3:5c:b9:e3(ernest-laptop)，<strong>目的端的物理地址</strong>是ff:ff:ff:ff:ff:ff， 这是以太网的广播地址，用以表示整个LAN。</p>
<p>1、该LAN上的所有机器都会收到并处理这样的帧。</p>
<p>2、数值0x806是以太网帧头部的类型字段的值， 它表示分用的目标是ARP模块。</p>
<p>3、该以太网帧的长度为42字节(实际上是46字节，tcpdump未统计以太网帧尾部4字节的CRC字段)，其中数据部分长度为28字节。</p>
<p>4、“Request”表示这是一个ARP请求，“who-has 192.168.1.109 tell 192.168.1.108”则表示是ernest-laptop要查询Kongming20的IP地址。</p>
<p><strong>第二个数据包</strong>中，ARP通信的<strong>源端的物理地址</strong>是 08:00:27:53:10:67(Kongming20)，<strong>目的端的物理地址</strong>是 00:16:d3:5c:b9:e3(ernest-laptop)。</p>
<p>1、“Reply”表示这是一个ARP应答，“192.168.1.109 is-at 08:00:27:53:10:67”则表示目标机器Kongming20 报告其物理地址。</p>
<p>2、该以太网帧的长度为60字节(实际上是64字节)， 可见它使用了填充字节来满足最小帧长度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052117137.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.16.56" /></p>
<p>1、我们将两次传输的以太网帧按照图1-6所描述的以太网帧封装格式绘制在图的下半部分。</p>
<p>2、ARP请求和应答是从<u>以太网驱动程序发出的，而并非像图中描述的那样从ARP模块直接发送到以太网上</u>，所以我们将它们用虚线表示，这主要是为了体现携带ARP数据的以太网帧和其他以太网帧 (比如携带IP数据报的以太网帧)的区别。</p>
<p>3、路由器也将接收到以太网帧1，因为该<strong>帧是一个广播帧</strong>。不过很显然，<u>路由器并没有回应其中的ARP请求</u>，正如前文讨论的那</p>
<p>样。</p>
<h2 id="16-dns工作原理"><a class="markdownIt-Anchor" href="#16-dns工作原理"></a> 1.6 DNS工作原理</h2>
<p>我们通常使用机器的<u>域名来访问</u>这台机器，而<u>不直接使用其IP</u>地址，比如访问因特网上的各种网站。那么如何将机器的域名转换成IP地址呢?这就需要使用域名查询服务。域名查询服务有很多种实现方式，比如NIS(Network Information Service，网络信息服务)、DNS和本地静态文件等。本节主要讨论DNS。</p>
<h3 id="161-dns查询和应答报文详解"><a class="markdownIt-Anchor" href="#161-dns查询和应答报文详解"></a> 1.6.1 DNS查询和应答报文详解</h3>
<p>DNS是一套分布式的域名服务系统。</p>
<p>每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且是动态更新的。</p>
<p>众多网络客户端程序都使用DNS协议来向DNS服务器查询目标主机的IP地址。</p>
<p>DNS查询和应答报文的格式如图1-11所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052125476.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.25.01" /></p>
<p>16位标识[1]字段用于标记一对<strong>DNS查询</strong>和<strong>应答</strong>，以此<u>区分一个DNS应答是哪个DNS查询的回应</u>。</p>
<p>16位标志字段用于<strong>协商具体的通信方式</strong>和<strong>反馈通信状态</strong>。DNS报文头部的16位标志字段的细节如图1-12所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052126399.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.26.22" /></p>
<p><strong>QR</strong>：查询/应答标志。0表示这是一个查询报文，1表示这是一个应答报文。</p>
<p><strong>opcode</strong>：定义查询和应答的类型。0表示标准查询，1表示反向查询(由IP地址获得主机域名)，2表示请求服务器状态。</p>
<p><strong>AA</strong>：授权应答标志，仅由应答报文使用。1表示域名服务器是授权服务器。</p>
<p><strong>TC</strong>：截断标志，仅当DNS报文使用UDP服务时使用。因为UDP数据报有长度限制，所以过长的DNS报文将被截断。1表示DNS报文超过512字节，并被截断。</p>
<p><strong>RD</strong>：递归查询标志。1表示执行递归查询，即如果目标DNS服务器无法解析某个主机名，则它将向其他DNS服务器继续查询，如此递 归，直到获得结果并把该结果返回给客户端。0表示执行迭代查询，即如果目标DNS服务器无法解析某个主机名，则它将自己知道的其他 DNS服务器的IP地址返回给客户端，以供客户端参考。</p>
<p><strong>RA</strong>：允许递归标志。仅由应答报文使用，1表示DNS服务器支持递归查询。</p>
<p><strong>zero</strong>：这3位未用，必须都设置为0。</p>
<p><strong>rcode</strong>：4位返回码，表示应答的状态。常用值有0(无错误)和3(域名不存在)。</p>
<p>接下来的4个字段则分别指出DNS报文的最后4个字段的资源记录数目。对<strong>查询报文</strong>而言，它一般包含1个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。<strong>应答报文</strong>的应答资源记录数则至少为1，而授权资源记录数和额外资源记录数可为0或非0。</p>
<p>查询问题的格式如图1-13所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052130947.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.30.27" /></p>
<p><strong>查询名</strong>以<u>一定的格式封装了要查询的主机域名</u>。16位查询类型表示如何执行查询操作，常见的类型有如下几种:</p>
<p>类型A：值是1，表示获取目标主机的IP地址。</p>
<p>类型CNAME：值是5，表示获得目标主机的别名。</p>
<p>类型PTR：值是12，表示反向查询。</p>
<p><strong>16位查询类</strong>：通常为1，表示获取因特网地址(IP地址)。</p>
<p>应答字段、授权字段和额外信息字段都使用资源记录(Resource Record，RR)格式。资源记录格式如图1-14所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052133025.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-05 下午9.33.13" /></p>
<p><strong>32位域名</strong>：是该记录中与资源对应的名字，其格式和查询问题中的查询名字段相同。</p>
<p><strong>16位类型</strong>和<strong>16位类</strong>字段：含义也与DNS查询问题的对应字段相同。</p>
<p><strong>32位生存时间</strong>：表示该查询记录结果可被本地客户端程序缓存多长时间，单位是秒。</p>
<p><strong>16位资源数据长度字段和资源数据字段</strong>：的内容取决于类型字段对类型A而言，资源数据是32位的IPv4地址，而资源数据长度则为 4(以字节为单位)。</p>
<p>至此，我们简要地介绍了DNS协议。我们将在后面给出一个DNS通信的具体例子。DNS协议的更多细节请参考其RFC文档(DNS协议 存在诸多RFC文档，每个RFC文档介绍其一个侧面，比如RFC 1035介绍的是域名的实现和规范，RFC 1886则描述DNS协议对IPv6的扩展支 持)。</p>
<h3 id="162-linux下访问dns服务"><a class="markdownIt-Anchor" href="#162-linux下访问dns服务"></a> 1.6.2 Linux下访问DNS服务</h3>
<p>我们要访问DNS服务，就必须先知道DNS服务器的IP地址。Linux 使用/etc/resolv.conf文件来存放DNS服务器的IP地址。机器ernest-laptop上，该文件的内容如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">#Generated by Network Manager<br> nameserver <span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><br> nameserver <span class="hljs-number">124.207</span><span class="hljs-number">.160</span><span class="hljs-number">.106</span><br></code></pre></td></tr></table></figure>
<p>其中的两个IP地址分别是<strong>首选DNS服务器地址</strong>和<strong>备选DNS服务器</strong>地址。</p>
<p>文件中的注释语句“Generated by Network Manager”告诉我们，这<u>两个DNS服务器地址是由网络管理程序写入</u>的。</p>
<p>Linux下一个常用的<strong>访问DNS服务器的客户端程序</strong>是host，比如下面的命令是<u>向首选DNS服务器219.239.26.42查询</u>机器www.baidu.com的IP地址:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">$host -t A www.baidu.com<br>www.baidu.com is an alias <span class="hljs-keyword">for</span> www.a.shifen.com.<br>www.a.shifen.com has address <span class="hljs-number">119.75</span><span class="hljs-number">.217</span><span class="hljs-number">.56</span><br>www.a.shifen.com has address <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><br></code></pre></td></tr></table></figure>
<p>1、host命令的输出告诉我们，机器名www.baidu.com是 www.a.shifen.com.的<strong>别名</strong>（alias），并且该机器名对应两个IP地址。</p>
<p>2、host命令使用<strong>DNS协议</strong>和<strong>DNS服务器通信</strong>，其-t选项<u>告诉DNS协议使用哪种查询类型</u>。</p>
<p>3、我们这里使用的是<strong>A类型</strong>，即<strong>通过机器的域名获得其IP地址</strong>(但实际上返回的资源记录中还包含机器的别名)。</p>
<h3 id="163-使用tcpdump观察dns通信过程"><a class="markdownIt-Anchor" href="#163-使用tcpdump观察dns通信过程"></a> 1.6.3 使用tcpdump观察DNS通信过程</h3>
<p>为了看清楚DNS通信的过程，下面我们将从ernest-laptop上运行<strong>host命令</strong>以查询主机www.baidu.com对应的IP地址，并使用<strong>tcpdump抓取</strong>这一过程中<u>LAN上传输的以太网帧</u>。具体的操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -i eth0 -nt -s <span class="hljs-number">500</span> port domain<br>$host -t A www.baidu.com<br></code></pre></td></tr></table></figure>
<p>这一次执行tcpdump抓包时，我们使用“port domain”来过滤数据包，表示<u>只抓取使用domain(域名)服务的数据包</u>，即DNS查询和应答报文。tcpdump的输出如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34319</span> &gt; <span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><span class="hljs-number">.53</span>: <span class="hljs-number">57428</span>+ A? www.baidu.com. (<span class="hljs-number">31</span>)<br><span class="hljs-number">2.</span>IP <span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><span class="hljs-number">.53</span> &gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34319</span>: <span class="hljs-number">57428</span> <span class="hljs-number">3</span>/<span class="hljs-number">4</span>/<span class="hljs-number">4</span> CNAME www.a.shifen.com.,A <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span>,A <span class="hljs-number">119.75</span><span class="hljs-number">.217</span><span class="hljs-number">.56</span>(<span class="hljs-number">226</span>)<br></code></pre></td></tr></table></figure>
<p>1、这两个数据包开始的“IP”指出，它们后面的内容描述的是<strong>IP数据报</strong>。</p>
<p>2、tcpdump以“<strong>IP地址.端口号</strong>”的形式来描述通信的某一端。</p>
<p>3、以“&gt;”表 示数据传输的方向，“&gt;”前面是<strong>源端</strong>，后面是<strong>目的端</strong>。</p>
<p>4、可见，第一个数据包是测试机器ernest-laptop(IP地址是192.168.1.108)向其首选DNS服务器(IP地址是219.239.26.42)发送的<strong>DNS查询报文</strong>(目标端口53是<strong>DNS服务使用的端口</strong>，这一点我们在前面介绍过)，第二个数据包是<strong>服务器反馈的DNS应答报文</strong>。</p>
<p><strong>第一个数据包中</strong>：</p>
<p>数值57428是<strong>DNS查询报文</strong>的标识值，因此该值也出现在<strong>DNS应答报文</strong>中。“+”表示启用<strong>递归查询标志</strong>。“A?”表示使用<strong>A类型的查询方式</strong>。“<a target="_blank" rel="noopener" href="http://www.baidu.com">www.baidu.com</a>”则是<strong>DNS查询问题中的查询名</strong>。 括号中的数值31是DNS查询报文的长度(以字节为单位)。</p>
<p><strong>第二个数据包中</strong>：</p>
<p>“3/4/4”表示该报文中包含<strong>3个应答资源记录</strong>、<strong>4 个授权资源记录</strong>和<strong>4个额外信息记录</strong>。“CNAME <a target="_blank" rel="noopener" href="http://www.a.shifen.com">www.a.shifen.com</a>.，A 119.75.218.77，A 119.75.217.56”则表示3个应答资源记录的内容。其中<strong>CNAME表示紧随其后的记录是机器的别名</strong>，<strong>A表示紧随其后的记录是IP地址</strong>。该应答报文的长度为226字节。</p>
<p>PS：我们抓包的时候没有开启tcpdump的-X选项(或者-x选 项)。如果使用-X选项，我们将能看到DNS报文的每一个字节，也就 能明白上面31字节的查询报文和226字节的应答报文的具体含义。</p>
<h2 id="17-socket和tcpip协议族的关系"><a class="markdownIt-Anchor" href="#17-socket和tcpip协议族的关系"></a> 1.7 socket和TCP/IP协议族的关系</h2>
<p>由于<u>数据链路层、网络层、传输层</u>协议是在<strong>内核</strong>中实现的。因此<strong>操作系统</strong>需要实现一组系统调用，使得应用程序能够访问这些协议提供的服务。实现这组系统调用的**API(Application Programming Interface，应用程序编程接口)**主要有两套:<strong>socket</strong>和 XTI。<u>XTI现在基本不再使用</u>，所以这里仅讨论socket，如图1-1显示了socket与TCP/IP协议族的关系。</p>
<p>由socket定义的这一组API提供如下两点功能:</p>
<p>1、将应用程序数据从<u>用户缓冲区中复制到TCP/UDP内核发送缓冲区</u>，以<u>交付内核来发送数据</u>(比如图1-5所示的send函数)，或者是<u>从内核TCP/UDP接收缓冲区中复制数据到用户缓冲区</u>，以读取数据。</p>
<p>2、应用程序可以通过它们来<u>修改内核中各层协议的某些头部信息或其他数据结构</u>，从而精细地<u>控制底层通信</u>的行为。比如可以通过setsockopt函数来<u>设置IP数据报在网络上的存活时间</u>。</p>
<p>socket是一套通用网络编程接口，它不但可以访问内核中TCP/IP协议栈，而且可以访问其他网络协议栈(比如X.25协议栈、UNIX本地域协议栈等)。</p>
<h1 id="第2章-ip协议详解"><a class="markdownIt-Anchor" href="#第2章-ip协议详解"></a> 第2章 IP协议详解</h1>
<p>IP协议是TCP/IP协议族的<strong>核心协议</strong>，也是socket网络编程的基础之一。本章从两个方面较为深入地探讨IP协议:</p>
<p><strong>IP头部信息</strong>：IP头部信息出现在每个IP数据报中，用于指定IP通信的源端IP地址、目的端IP地址，指导IP分片和重组，以及指定部分通信行为。</p>
<p><strong>IP数据报的路由和转发</strong>：IP数据报的路由和转发发生在除目标机器之外的所有主机和路由器上。它们决定数据报<u>是否应该转发</u>以及<u>如何转发</u>。</p>
<p>由于32位表示的IP地址即将全部使用完，因此人们开发出了新版本的IP协议，称为IPv6协议，而原来的版本则称为IPv4协议。本章前面部分的讨论都是基于IPv4协议的，只在最后一节简要讨论IPv6协议。</p>
<h2 id="21-ip服务的特点"><a class="markdownIt-Anchor" href="#21-ip服务的特点"></a> 2.1 IP服务的特点</h2>
<p>IP协议是TCP/IP协议族的动力，它为上层协议提供<u>无状态、无连接、不可靠</u>的服务。</p>
<h3 id="无状态stateless"><a class="markdownIt-Anchor" href="#无状态stateless"></a> 无状态(stateless)</h3>
<p><strong>IP通信双方不同步传输数据的状态信息</strong>， 因此所有IP数据报的发送、传输和接收都是<u>相互独立、没有上下文关系</u>的。</p>
<p>这种服务最大的<strong>缺点</strong>是无法处理乱序和重复的IP数据报。比如发送端发送出的第N个IP数据报可能比第N+1个IP数据报后到达接收端，而同一个IP数据报也可能经过不同的路径多次到达接收端。在这两种情况下，接收端的IP模块无法检测到乱序和重复，因为这些IP数据报之间没有任何上下文关系。</p>
<p>接收端的IP模块只要收到了<strong>完整</strong>的IP数据报(如果是IP分片的话，IP模块将先执行重组)，就将其数据部分(TCP报文段、UDP数据报或者ICMP报文)上交给上层协议。那么<strong>从上层协议来看</strong>，这些数据就可能是<u>乱序的、重复</u>的。</p>
<p>面向连接的协议，比如<strong>TCP协议</strong>，则能够自己处理乱序的、重复的报文段，它递交给上层协议的内容绝对是<strong>有序的、正确</strong>的。</p>
<p>虽然IP数据报头部提供了一个<strong>标识</strong>字段(见后文)用以唯一标识一个IP数据报，但它是被用来<strong>处理IP分片和重组</strong>的，而<strong>不是用来指示接收顺序</strong>的。</p>
<p>无状态服务的优点也很明显:<strong>简单、高效</strong>。我们无须为保持通信的状态而分配一些内核资源，也无须每次传输数据时都携带状态信息。在网络协议中，无状态是很常见的，比如<u>UDP协议和HTTP协议都是无状态协议</u>。以HTTP协议为例，一个浏览器的连续两次网页请求之间没有任何关联，它们将被Web服务器独立地处理。</p>
<h3 id="无连接connectionless"><a class="markdownIt-Anchor" href="#无连接connectionless"></a> 无连接(connectionless)</h3>
<p>IP通信双方都<strong>不长久地维持</strong>对方的任何信息。这样，上层协议<strong>每次</strong>发送数据的时候，都必须<strong>明确指定</strong>对方的IP地址。</p>
<h3 id="不可靠"><a class="markdownIt-Anchor" href="#不可靠"></a> 不可靠</h3>
<p>IP协议<strong>不能保证</strong>IP数据报准确地到达接收端，它只是承诺尽最大努力(best effort)。</p>
<p>很多种情况都能导致IP数据报发送失败。比如，某个中转路由器发现IP数据报在网络上存活的时间太长(根据IP数据报头部字段TTL判断，见后文)，那么它将丢弃之，并返回一个ICMP错误消息(超时错误)给发送端。</p>
<p>又比如，接收端发现收到的IP数据报不正确(通过校验机制)，它也将丢弃之，并返回一个ICMP错误消息(IP头部参数错误)给发送端。</p>
<p>无论哪种情况，发送端的IP模块一旦检测到IP数据报发送失败，就通知上层协议发送失败，而不会试图重传。因此，使用IP服务的上层协议(比如TCP协 议)需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。</p>
<h2 id="22-ipv4头部结构"><a class="markdownIt-Anchor" href="#22-ipv4头部结构"></a> 2.2 IPv4头部结构</h2>
<h3 id="221-ipv4头部结构"><a class="markdownIt-Anchor" href="#221-ipv4头部结构"></a> 2.2.1 IPv4头部结构</h3>
<p>IPv4的头部结构如图2-1所示。其长度通常为20字节，除非含有可变长的选项部分。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071553191.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-07 下午3.53.42" /></p>
<p><strong>4位版本号(version)</strong>：指定IP协议的版本。对IPv4来说，其值是4。其他IPv4协议的扩展版本(如SIP协议和PIP协议)，则具有不同的版本号(它们的头部结构也和图2-1不同)。</p>
<p><strong>4位头部长度(header length)</strong>：标识该IP头部有多少个32bit字(4字 节)。因为4位最大能表示15，所以IP头部最长是60字节。</p>
<p><strong>8位服务类型(Type Of Service，TOS)</strong>：包括一个3位的优先权字段 (现在已经被忽略)，4位的TOS字段和1位保留字段(必须置0)。4位的TOS字段分别表示:最小延时，最大吞吐量，最高可靠性和最小费用。其中最多有一个能置为1，应用程序应该根据实际需要来设置它。 比如像ssh和telnet这样的登录程序需要的是最小延时的服务，而文件传输程序ftp则需要最大吞吐量的服务。</p>
<p><strong>16位总长度(total length)</strong>：整个IP数据报的长度，以字节为单位，因此IP数据报的最大长度为65 535(216-1)字节。但由于MTU的限制，长度超过MTU的数据报都将被分片传输，所以实际传输的IP数据报(或分片)的长度都远远没有达到最大值。接下来的3个字段则描述了如何实现分片。</p>
<p><strong>16位标识(identification)</strong>：唯一地标识主机发送的每一个数据报。 其初始值由系统随机生成;每发送一个数据报，其值就<strong>加1</strong>。该值在数 据报分片时被<strong>复制</strong>到每个分片中，因此<u>同一个数据报的所有分片都具有相同</u>的标识值。</p>
<p><strong>3位标志字段</strong>：第一位保留。第二位(Don’t Fragment，DF)表示“禁止分片”。如果设置了这个位，IP模块将不对数据报进行分片。在这种情况下，如果IP数据报长度超过MTU的话，IP模块将丢弃该数据报并返回一个ICMP差错报文。第三位(More Fragment，MF)表示“更多分片”。除了数据报的最后一个分片外，其他分片都要把它置1。</p>
<p><strong>13位分片偏移(fragmentation offset)</strong>：分片相对原始IP数据报开始处(仅指数据部分)的偏移。实际的偏移值是该值左移3位(乘8)后得到的。由于这个原因，除了最后一个IP分片外，每个IP分片的数据部分的长度必须是<strong>8的整数倍</strong>(这样才能保证后面的IP分片拥有一个合适的偏移值)。</p>
<p><strong>8位生存时间(Time To Live，TTL)</strong>：数据报到达目的地之前允许经过的路由器跳数。TTL值被发送端设置(常见的值是64)。数据报在转发过程中每经过一个路由，该值就被路由器减1。当TTL值减为0时，路由器将丢弃数据报，并向源端发送一个ICMP差错报文。TTL值可以 防止数据报陷入路由循环。</p>
<p><strong>8位协议(protocol)</strong>：用来区分上层协议，我们在第1章讨论过。/etc/protocols文件定义了所有上层协议对应的protocol字段的数值。 其中，ICMP是1，TCP是6，UDP是17。/etc/protocols文件是RFC 1700的一个子集。</p>
<p><strong>16位头部校验和(header checksum)</strong>：由发送端填充，接收端对其使用<u>CRC算法以检验IP数据报头部</u>(注意，<strong>仅检验头部</strong>)在传输过程中是否损坏。</p>
<p><strong>32位的源端IP地址和目的端IP地址</strong>：用来标识数据报的发送端和接收端。一般情况下，这两个地址在整个数据报的传递过程中保持不变，而不论它中间经过多少个中转路由器。关于这一点，我们将在第4章进一步讨论。</p>
<p><strong>IPv4最后一个选项字段(option)</strong>：是可变长的可选信息。这部分最多包含40字节，因为IP头部最长是60字节(其中还包含前面讨论的20字节的固定部分)。可用的IP选项包括:</p>
<p>1、记录路由(record route)，告诉数据报途经的所有路由器都将自己的IP地址填入IP头部的选项部分，这样我们就可以跟踪数据报的传递 路径。</p>
<p>2、时间戳(timestamp)，告诉每个路由器都将数据报被转发的时间(或时间与IP地址对)填入IP头部的选项部分，这样就可以测量途经路由之间数据报传输的时间。</p>
<p>3、松散源路由选择(loose source routing)，指定一个路由器IP地址列表，数据报发送过程中必须经过其中所有的路由器。</p>
<p>4、严格源路由选择(strict source routing)，和松散源路由选择类似，不过数据报只能经过被指定的路由器。</p>
<h3 id="222-使用tcpdump观察ipv4头部结构"><a class="markdownIt-Anchor" href="#222-使用tcpdump观察ipv4头部结构"></a> 2.2.2 使用tcpdump观察IPv4头部结构</h3>
<p>为了深入理解IPv4头部中每个字段的含义，我们从测试机器ernest-laptop上<u>执行telnet命令登录本机</u>，并用tcpdump抓取这个过程中telnet客户端程序和telnet服务器程序之间交换的数据包。具体的操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -ntx -i lo #抓取本地回路上的数据包<br>$telnet <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>#开启另一个终端执行telnet命令登录本机 Trying <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>...<br>Connected to <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>.<br>Escape character is<span class="hljs-number">&#x27;</span>^]<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">Ubuntu 9.10</span><br><span class="hljs-string">ernest-laptop login:ernest#输入用户名并回车 Password:#输入密码并回车</span><br></code></pre></td></tr></table></figure>
<p>此时观察tcpdump输出的第一个数据包，其内容如代码清单2-1所示。</p>
<p>代码清单2-1 用tcpdump抓取数据包</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.41621</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[S],seq <span class="hljs-number">3499745539</span>,win <span class="hljs-number">32792</span>,<br>   options[mss <span class="hljs-number">16396</span>,sackOK,TS val <span class="hljs-number">40781017</span> ecr <span class="hljs-number">0</span>,nop,wscale<br><span class="hljs-number">6</span>],length <span class="hljs-number">0</span><br>   <span class="hljs-number">0x0000</span>:<span class="hljs-number">4510</span> <span class="hljs-number">003</span>c a5da <span class="hljs-number">4000</span> <span class="hljs-number">4006</span> <span class="hljs-number">96</span>cf <span class="hljs-number">7f</span>00 <span class="hljs-number">0001</span><br>   <span class="hljs-number">0x0010</span>:<span class="hljs-number">7f</span>00 <span class="hljs-number">0001</span> a295 <span class="hljs-number">0017</span> d099 e103 <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>   <span class="hljs-number">0x0020</span>:a002 <span class="hljs-number">8018</span> fe30 <span class="hljs-number">0000</span> <span class="hljs-number">0204</span> <span class="hljs-number">400</span>c <span class="hljs-number">0402</span> <span class="hljs-number">080</span>a<br></code></pre></td></tr></table></figure>
<p>该数据包描述的是一个<strong>IP数据报</strong>。由于我们是使<u>用telnet登录本机</u>的，所以IP数据报的<strong>源端IP地址</strong>和<strong>目的端IP地址</strong>都是“127.0.0.1”。telnet 服务器程序使用的端口号是23(参见/etc/services文件)，而telnet客户端程序使用临时端口号41621与服务器通信。关于临时端口号，我们将 在第3章讨论。“Flags”、“seq”、“win”和“options”描述的都是TCP头部信息，这也将在第3章讨论。“length”指出该IP数据报所携带的应用程序数据的长度。</p>
<p>这次抓包我们开启了tcpdump的-x选项，使之输出数据包的<strong>二进制码</strong>。此数据包共包含60字节，其中前20字节是IP头部，后40字节是TCP 头部，不包含应用程序数据(length值为0)。现在我们分析IP头部的每个字节，如表2-1所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205072139077.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-07 下午9.39.25" /></p>
<p>由表2-1可见，telnet服务选择<u>使用具有最小延时的服务</u>，并且默认<u>使用的传输层协议是TCP协议</u>(回顾第1章讨论的分用)。这些都符合我们通常的理解。这个IP数据报<u>没有被分片</u>，因为它没有携带任何应用程序数据。接下来我们将<u>抓取并讨论被分片的IP数据报</u>。</p>
<h2 id="23-ip分片"><a class="markdownIt-Anchor" href="#23-ip分片"></a> 2.3 IP分片</h2>
<p>前文曾提到，当IP数据报的长度<u>超过帧的MTU</u>时，它将被<u>分片传输</u>。分片<u>可能发生在发送端</u>，也可能<u>发生在中转路由器</u>上，而且可能在<u>传输过程中被多次</u>分片，但只有在<strong>最终的目标机器上，这些分片才会被内核中的IP模块重新组装</strong>。</p>
<p>IP头部中的如下三个字段给IP的分片和重组提供了足够的信息:数据报标识、标志和片偏移。一个IP数据报的每个分片都具有自己的IP头 部，它们具有相同的标识值，但具有不同的片偏移。并且除了最后一个分片外，其他分片都将设置MF标志。此外，每个分片的IP头部的总长度字段将被设置为该分片的长度。</p>
<p>以太网帧的MTU是1500字节(可以通过ifconfig命令或者netstat命令查看)，因此它携带的IP数据报的数据部分<strong>最多是1480字节</strong>(IP头部占用20字节)。考虑用IP数据报封装一个<strong>长度为1481字节</strong>的<strong>ICMP报文</strong> (包括8字节的ICMP头部，所以其数据部分长度为1473字节)，则该数据报在使用以太网帧传输时<strong>必须被分片</strong>，如图2-2所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205072159863.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-07 下午9.59.01" /></p>
<p>图2-2中，长度为1501字节的IP数据报被拆分成两个IP分片，第一个IP分片长度为1500字节，第二个IP分片的长度为21字节。每个IP分片 都包含自己的IP头部(20字节)，且第一个IP分片的IP头部<strong>设置了MF标志</strong>，而第二个IP分片的IP头部则<strong>没有设置该标志</strong>，因为它<strong>已经是最后 一个分片</strong>了。原始IP数据报中的ICMP头部内容<strong>被完整地复制</strong>到了第一个IP分片中。第二个IP分片<strong>不包含ICMP头部信息</strong>，因为IP模块重组该 ICMP报文的时候<strong>只需要一份ICMP头部</strong>信息，<u>重复传送这个信息没有任何益处</u>。1473字节的ICMP报文数据的前1472字节被IP模块复制到第一个IP分片中，使其总长度为1500字节，从而满足MTU的要求;而多出的最后1字节则被复制到第二个IP分片中。</p>
<p>需要指出的是，<strong>ICMP报文</strong>的<strong>头部长度取决于报文的类型</strong>，其变化范围很大。图2-2以8字节为例，因为后面的例子用到了ping程序，而 ping程序使用的ICMP回显和应答报文的头部长度是8字节。</p>
<p>为了看清楚IP分片的具体过程，考虑从ernest-laptop来ping机器Kongming20，每次传送1473字节的数据(<strong>这是ICMP报文的数据部分</strong>) 以强制引起IP分片，并用tcpdump抓取这一过程中双方交换的数据包。 具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -ntv -i eth0 icmp#只抓取ICMP报文<br>$ping Kongming20 -s <span class="hljs-number">1473</span>#用-s选项指定每次发送<span class="hljs-number">1473</span>字节的数据<br></code></pre></td></tr></table></figure>
<p>下面我们考察tcpdump输出的一个IP数据报的两个分片，其内容如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span><span class="hljs-built_in">IP</span>(tos <span class="hljs-number">0x0</span>,ttl <span class="hljs-number">64</span>,id <span class="hljs-number">61197</span>,offset <span class="hljs-number">0</span>,flags[+],proto <span class="hljs-built_in">ICMP</span>(<span class="hljs-number">1</span>),length <span class="hljs-number">1500</span>)<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.110</span>:ICMP echo request,id <span class="hljs-number">41737</span>,seq <span class="hljs-number">1</span>,length <span class="hljs-number">1480</span><br><span class="hljs-number">2.</span><span class="hljs-built_in">IP</span>(tos <span class="hljs-number">0x0</span>,ttl <span class="hljs-number">64</span>,id <span class="hljs-number">61197</span>,offset <span class="hljs-number">1480</span>,flags[none],proto <span class="hljs-built_in">ICMP</span>(<span class="hljs-number">1</span>),length <span class="hljs-number">21</span>)<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.110</span>:icmp<br></code></pre></td></tr></table></figure>
<p>这两个IP分片的标识值都是61197，说明它们是<strong>同一个IP数据报</strong>的分片。</p>
<p>第一个分片的片偏移值为0，而第二个则是1480。很显然，第二个分片的片<strong>偏移值</strong>实际上也是<strong>第一个分片的ICMP报文的长度</strong>。</p>
<p>第一个 分片设置了MF标志以<strong>表示还有后续分片</strong>，所以tcpdump输出“flags[+]”。</p>
<p>而第二个分片则<strong>没有设置任何标志</strong>，所以tcpdump输出“flags[none]”。</p>
<p>这个两个分片的长度分别为1500字节和21字节，这与图2-2描述的一致。</p>
<p>最后，IP层传递给数据链路层的数据可能是一个<u>完整的IP数据报</u>， 也<u>可能是一个IP分片</u>，它们统称为<strong>IP分组(packet)</strong>。本书如无特殊声 明，<strong>不区分IP数据报和IP分组</strong>。</p>
<h2 id="24-ip路由"><a class="markdownIt-Anchor" href="#24-ip路由"></a> 2.4 IP路由</h2>
<p>IP协议的一个核心任务是<strong>数据报的路由</strong>，即<u>决定发送数据报到目标机器的路径</u>。为了理解IP路由过程，我们先简要分析IP模块的基本工作流程。</p>
<h3 id="241-ip模块工作流程"><a class="markdownIt-Anchor" href="#241-ip模块工作流程"></a> 2.4.1 IP模块工作流程</h3>
<p>IP模块基本工作流程如图2-3所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205081527791.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-08 下午3.26.53" /></p>
<p>我们从右往左来分析图2-3。</p>
<p>1、当IP模块接收到来自数据链路层的IP数据报时，它首先对该数据报的头部做<strong>CRC校验</strong>，确认无误之后就分析其头部的具体信息。</p>
<p>2、如果该IP数据报的头部设置了<strong>源站选路选项</strong>(松散源路由选择或严格源路由选择)，则IP模块<u>调用数据报转发子模块来处理该数据报</u>。</p>
<p>3、如果该IP数据报的头部中目标IP地址是<u>本机的某个IP地址，或者是广播地址，即该数据报是发送给本机</u>的，则IP模块就根据数据报头部 中的协议字段来决定将它<strong>派发给哪个上层应用</strong>(分用)；如果IP模块发现这个数据报不是发送给本机的，则也<strong>调用数据报转发子模块</strong>来处理该数据报。</p>
<p>4、数据报转发子模块将首先检测系统<strong>是否允许转发</strong>，如果不允许，IP模块就将数据报丢弃。如果允许，数据报转发子模块将对该数据报 执行一些操作，然后将它交给IP数据报输出子模块。</p>
<p>5、IP数据报应该发送至哪个下一跳路由(或者目标机器)，以及经过哪个网卡来发送，就是IP路由过程，即图2-3中“计算下一跳路由”子模块。IP模块实现数据报路由的<strong>核心数据结构是路由表</strong>。这个表<u>按照数据报的目标IP地址分类</u>，同一类型的IP数据报将被发往相同的下一跳 路由器(或者目标机器)。</p>
<p>IP输出队列中存放的是<strong>所有等待发送的IP数据报</strong>，其中除了需要转发的IP数据报外，还包括封装了本机上层数据(ICMP报文、TCP报文段和UDP数据报)的IP数据报。图2-3中的虚线箭头显示了路由表更新的过程。这一过程是指通过路由协议或者route命令调整路由表，使之更适应最新的网络拓扑结构，称为<strong>IP路由策略</strong>。</p>
<h3 id="242-路由机制"><a class="markdownIt-Anchor" href="#242-路由机制"></a> 2.4.2 路由机制</h3>
<p>要研究IP路由机制，需要先了解路由表的内容。我们可以使用<strong>route命令</strong>或<strong>netstat命令</strong>查看路由表。在测试机器ernest-laptop上执行 route命令，输出内容如代码清单2-2所示。</p>
<p>代码清单2-2 路由表实例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Kernel IP routing table<br>Destination Gateway Genmask Flags Metric Ref Use Iface<br><span class="hljs-keyword">default</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> UG <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> eth0<br><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>*<span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span> U <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> eth0<br></code></pre></td></tr></table></figure>
<p>该路由表包含两项，每项都包含8个字段，如表2-2所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205081554166.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-08 下午3.54.38" /></p>
<p>1、第一项的目标地址是default，即所谓的默认路由项。该项包含一个“G”标志，说明路由的下一跳目标是<strong>网关</strong>，其地址是192.168.1.1(这是测试网络中路由器的本地IP地址)。</p>
<p>2、另外一个路由项的目标地址是192.168.1.0，它指的是<strong>本地局域网</strong>。该路由项的网关地址为*，说明数据报不需要路由中转，可以直接发送到目标机器。</p>
<p>那么路由表是如何按照IP地址分类的呢?或者说给定数据报的目标IP地址，它将匹配路由表中的哪一项呢?这就是IP的路由机制，分为 3个步骤:</p>
<p>1)查找<strong>路由表</strong>中和<strong>数据报的目标IP地址</strong>完全<strong>匹配</strong>的主机IP地址。 如果找到，就使用该路由项，没找到则转步骤2。</p>
<p>2)查找路由表中和数据报的目标IP地址具有相同<strong>网路ID的网络IP地址</strong>(比如代码清单2-2所示的路由表中的第二项)。如果找到，就使用该路由项;没找到则转步骤3。（这相当于在同一个网关）</p>
<p>3)选择默认路由项，这通常意味着数据报的下一跳路由是网关。</p>
<p>因此，对于测试机器ernest-laptop而言，所有发送到IP地址为192.168.1.*的机器的IP数据报都可以直接发送到目标机器(匹配路由表第二项)，而所有访问因特网的请求都将通过网关来转发(匹配默认路由项)。</p>
<h3 id="243-路由表更新"><a class="markdownIt-Anchor" href="#243-路由表更新"></a> 2.4.3 路由表更新</h3>
<p>路由表必须能够更新，以反映网络连接的变化，这样IP模块才能准确、高效地转发数据报。route命令可以修改路由表。我们看如下几个例子(在机器ernest-laptop上执行):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo route add -host <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> dev eth0<br> $sudo route del -net <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> netmask <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span><br> $sudo route del <span class="hljs-keyword">default</span><br> $sudo route add <span class="hljs-keyword">default</span> gw <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> dev eth0<br></code></pre></td></tr></table></figure>
<p><strong>第1行</strong>表示添加主机192.168.1.109(机器Kongming20)对应的路由项。这样设置之后，所有<u>从ernest-laptop发送到Kongming20</u>的IP数据报 将通过网卡eth0直接发送至目标机器的接收网卡。</p>
<p><strong>第2行</strong>表示删除网络192.168.1.0对应的路由项。这样除了机器Kongming20外，测试机器ernest-laptop将<strong>无法访问该局域网上的任何其他机器</strong>(能访问到Kongming20是由于执行了上一条命令)。</p>
<p><strong>第3行</strong>表示<u>删除默认路由项</u>， 这样做的后果是<u>无法访问因特网</u>。</p>
<p><strong>第4行</strong>表示<u>重新设置默认路由项</u>，不过这次其<u>网关是机器Kongming20</u>(而不是能直接访问因特网的路由器)!</p>
<p>经过上述修改后的路由表如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Kernel IP routing table<br> Destination Gateway Genmask Flags Metric Ref Use Iface<br> Kongming20*<span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.255</span> UH <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> eth0<br> <span class="hljs-keyword">default</span> Kongming20 <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> UG <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> eth0<br></code></pre></td></tr></table></figure>
<p>这个新的路由表中，第一个路由项是<u>主机路由项</u>，所以它被设置了“H”标志。我们设计这样一个路由表的目的是为后文讨论ICMP重定向提供环境。</p>
<p>通过route命令或其他工具手工修改路由表，是静态的路由更新方式。</p>
<p>对于大型的路由器，它们通常通过BGP(Border Gateway Protocol，边际网关协议)、RIP(Routing Information Protocol，路由信息协议)、OSPF等协议来发现路径，并更新自己的路由表。这种更新方式是动态的、自动的。</p>
<h2 id="25-ip转发"><a class="markdownIt-Anchor" href="#25-ip转发"></a> 2.5 IP转发</h2>
<p>前文提到，<strong>不是发送给本机</strong>的IP数据报<u>将由数据报转发子模块来处理</u>。路由器都<strong>能执行数据报的转发操作</strong>，而主机<strong>一般只发送和接收数据报</strong>，这是因为主机上/proc/sys/net/ipv4/ip_forward内核参数默认被设置为0。</p>
<p>我们可以通过修改它<strong>来使能主机的数据报转发功能</strong>(在测试机器Kongming20上以root身份执行):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#echo 1&gt;/proc/sys/net/ipv4/ip_forward</span><br></code></pre></td></tr></table></figure>
<p>对于允许IP数据报转发的系统(主机或路由器)，<strong>数据报转发子模块</strong>将<u>对期望转发的数据报</u>执行如下操作:</p>
<p>1)检查数据报头部的TTL值。如果TTL值已经是0，则丢弃该数据报。</p>
<p>2)查看数据报头部的严格源路由选择选项。如果该选项被设置， 则检测数据报的目标IP地址是否是本机的某个IP地址。如果不是，则发送一个ICMP源站选路失败报文给发送端。</p>
<p>3)如果有必要，则给源端发送一个ICMP<strong>重定向</strong>报文，以<u>告诉它一个更合理的下一跳</u>路由器。（优化路径）</p>
<p>4)将TTL值减1。</p>
<p>5)处理IP头部选项。</p>
<p>6)如果有必要，则执行IP分片操作。</p>
<h2 id="26-重定向"><a class="markdownIt-Anchor" href="#26-重定向"></a> 2.6 重定向</h2>
<p>图2-3显示了<u>ICMP重定向报文也能用于更新路由表</u>，因此本节我们简要讨论ICMP重定向。</p>
<h3 id="261-icmp重定向报文"><a class="markdownIt-Anchor" href="#261-icmp重定向报文"></a> 2.6.1 ICMP重定向报文</h3>
<p>ICMP重定向报文格式如图2-4所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091446138.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午2.46.34" /></p>
<p>我们在1.1节讨论过ICMP报文头部的3个固定字段:8位类型、8位代码和16位校验和。ICMP重定向报文的类型值是5，代码字段有4个可选值，用来区分不同的重定向类型。本书仅讨论<strong>主机重定向</strong>，其代码值为1。</p>
<p>ICMP重定向报文的数据部分含义很明确，它给接收方提供了如下两个信息:</p>
<p>1、引起重定向的IP数据报(即图2-4中的原始IP数据报)的源端IP地址。</p>
<p>2、应该使用的路由器的IP地址。</p>
<p>接收主机根据这两个信息就可以断定引起重定向的IP数据报<u>应该使用哪个路由器来转发</u>，并且以此来更新路由表(通常是<strong>更新路由表缓冲</strong>，而不是直接更改路由表)。</p>
<p>/proc/sys/net/ipv4/conf/all/send_redirects内核参数指定<u>是否允许发送ICMP重定向报文</u>，而/proc/sys/net/ipv4/conf/all/accept_redirects内核参数则指定<u>是否允许接收ICMP重定向</u>报文。一般来说，<strong>主机只能接收</strong>ICMP重定向报文，而<strong>路由器只能发送</strong>ICMP重定向报文。</p>
<h3 id="262-主机重定向实例"><a class="markdownIt-Anchor" href="#262-主机重定向实例"></a> 2.6.2 主机重定向实例</h3>
<p>2.4.3节中，我们把机器ernest-laptop的<strong>网关</strong>设置成了机器Kongming20，2.5节中我们又使能了Kongming20的<strong>数据报转发</strong>功能，因此机器ernest-laptop将通过Kongming20来访问因特网，比如在ernest- laptop上执行如下ping命令:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">	 $ping www.baidu.com<br>   PING www.a.shifen.<span class="hljs-built_in">com</span>(<span class="hljs-number">119.75</span><span class="hljs-number">.217</span><span class="hljs-number">.56</span>)<span class="hljs-number">56</span>(<span class="hljs-number">84</span>)bytes of data.<br>   <span class="hljs-function">From <span class="hljs-title">Kongming20</span><span class="hljs-params">(<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>)</span>:icmp_seq=</span><span class="hljs-number">1</span> <span class="hljs-function">Redirect <span class="hljs-title">Host</span><span class="hljs-params">(New</span></span><br><span class="hljs-params"><span class="hljs-function">nexthop:<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>)</span></span><br><span class="hljs-function">   64 bytes from 119.75.217.56:icmp_seq=</span><span class="hljs-number">1</span> ttl=<span class="hljs-number">54</span> time=<span class="hljs-number">6.78</span> ms<br>   ---www.a.shifen.com ping statistics---<br>   <span class="hljs-number">1</span> packets transmitted,<span class="hljs-number">1</span> received,<span class="hljs-number">0</span>%packet loss,time <span class="hljs-number">0</span>ms<br>   rtt min/avg/max/mdev=<span class="hljs-number">6.789</span>/<span class="hljs-number">6.789</span>/<span class="hljs-number">6.789</span>/<span class="hljs-number">0.000</span> ms<br></code></pre></td></tr></table></figure>
<p>从ping命令的输出来看，Kongming20给ernest-laptop发送了一个 ICMP重定向报文，告诉它请通过192.168.1.1来访问目标机器，因为这对ernest-laptop来说是更合理的路由方式。当主机ernest-laptop收到这样的ICMP重定向报文后，它将更新其路由表缓冲(使用命令route-Cn查看)，并使用新的路由方式来发送后续数据报。上面讨论的重定向过程可用图2-5来总结。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091501261.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午3.01.26" /></p>
<p>PS: 相当于告诉你这条路不好使，告诉你一条更好的路线</p>
<h2 id="27-ipv6头部结构"><a class="markdownIt-Anchor" href="#27-ipv6头部结构"></a> 2.7 IPv6头部结构</h2>
<p>Pv6协议是网络层技术发展的必然趋势。它<strong>不仅解决了IPv4地址不够用</strong>的问题，还做了很大的改进。比如，<strong>增加了多播和流</strong>的功能，为网络上多媒体内容的质量提供精细的控制;引入自动配置功能，使得局域网管理更方便;<strong>增加了专门的网络安全功能</strong>等。本节简要地讨论 IPv6头部结构，它的更多细节请参考其标准文档RFC 2460。</p>
<h3 id="271-ipv6固定头部结构"><a class="markdownIt-Anchor" href="#271-ipv6固定头部结构"></a> 2.7.1 IPv6固定头部结构</h3>
<p>IPv6头部由40字节的固定头部和可变长的扩展头部组成。图2-6所示是IPv6的固定头部结构。<img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091506319.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午3.06.55" /></p>
<p><strong>4位版本号(version)</strong>：指定IP协议的版本。对IPv6来说，其值是6。 8位通信类型(traffic class)指示数据流通信类型或优先级，和IPv4中的TOS类似。</p>
<p><strong>20位流标签(flow label)</strong>：是IPv6新增加的字段，用于某些对连接的服务质量有特殊要求的通信，比如音频或视频等实时数据传输。</p>
<p><strong>16位净荷长度(payload length)</strong>：指的是IPv6扩展头部和应用程序数 据长度之和，不包括固定头部长度。</p>
<p><strong>8位下一个包头(next header)</strong>：指出紧跟IPv6固定头部后的包头类 型，如扩展头(如果有的话)或某个上层协议头(比如TCP，UDP或 ICMP)。它类似于IPv4头部中的协议字段，且相同的取值有相同的含 义。</p>
<p><strong>8位跳数限制(hop limit)<strong>和</strong>IPv4中的TTL</strong>含义相同。</p>
<p><strong>IPv6用128位(16字节)</strong>:来表示IP地址，使得IP地址的总量达到了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>128</mn></msup></mrow><annotation encoding="application/x-tex">2^{128}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>个。所以有人说，“IPv6使得地球上的每粒沙子都有一个IP地址”。</p>
<p><strong>32位表示的IPv4地址</strong>一般用点分十进制来表示，而<strong>IPv6地址</strong>则用十六进制字符串表示，比如“FE80:0000:0000:0000:2234:5678:0000:0012”。可见，<strong>IPv6地址</strong>用“:”分割成8组，每组包含2字节。但这种表示方法过于麻烦，通常可以使用所谓的<strong>零压缩法</strong>来将其简写，也就是<strong>省略连续的、全零</strong>的组。 比如，上面的例子使用零压缩法可表示为“FE80::2234:5678:0000:0012”。不过零压缩法对一个IPv6地址<strong>只能使用一次</strong>，比如上面的例子中，字节组“5678”后面的全零组就不能再省略，否则我们就<u>无法计算每个“::”之间省略了多少个</u>全零组。</p>
<h3 id="272-ipv6扩展头部"><a class="markdownIt-Anchor" href="#272-ipv6扩展头部"></a> 2.7.2 IPv6扩展头部</h3>
<p>可变长的扩展头部使得IPv6能支持更多的选项，并且很便于将来的扩展需要。它的长度可以是0，表示<strong>数据报没使用任何扩展头部</strong>。一个数据报可以包含<strong>多个</strong>扩展头部，每个扩展头部的<u>类型由前一个头部</u> (固定头部或扩展头部)中的<u>下一个报头字段</u>指定。目前可以使用的m扩展头部如表2-3所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091514830.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午3.14.02" /></p>
<p><strong>注意</strong> <u>IPv6协议并不是IPv4协议的简单扩展</u>，而是完全<strong>独立</strong>的协议。用以太网帧封装的IPv6数据报和IPv4数据报具有不同的类型值。</p>
<p>第1章提到，<strong>IPv4数据报</strong>的以太网帧封装类型值是0x800，而<strong>IPv6数据报</strong>的以太网帧封装类型值是0x86dd(见RFC 2464)。</p>
<h1 id="第3章-tcp协议详解"><a class="markdownIt-Anchor" href="#第3章-tcp协议详解"></a> 第3章 TCP协议详解</h1>
<p>TCP协议是TCP/IP协议族中另一个重要的协议。和IP协议相比， TCP协议<u>更靠近应用层</u>，因此在应用程序中具有<strong>更强的可操作性</strong>。一些 重要的socket选项都和TCP协议相关。</p>
<p>本章从如下四方面来讨论TCP协议:</p>
<p><strong>TCP头部信息</strong>:TCP头部信息出现在每个TCP报文段中，用于指定通信的源端端口号、目的端端口号，管理TCP连接，控制两个方向的数据流。</p>
<p><strong>TCP状态转移过程</strong>:TCP连接的任意一端都是一个状态机。在 TCP连接从建立到断开的整个过程中，连接两端的状态机将经历不同的状态变迁。理解TCP状态转移对于调试网络应用程序将有很大的帮助。</p>
<p><strong>TCP数据流</strong>:通过分析TCP数据流，我们就可以从网络应用程序外部来了解应用层协议和通信双方交换的应用程序数据。这一部分将讨论两种类型的TCP数据流:<u>交互数据流</u>和<u>成块数据流</u>。TCP数据流中有一种特殊的数据，称为<u>紧急数据</u>，我们也将简单讨论之。</p>
<p><strong>TCP数据流的控制</strong>:为了保证可靠传输和提高网络通信质量，内核需要对TCP数据流进行控制。这一部分讨论TCP数据流控制的两个方面:<u>超时重传</u>和<u>拥塞控制</u>。</p>
<p>不过在详细讨论TCP协议之前，我们先简单介绍一下TCP服务的特点，以及它和UDP服务的区别。</p>
<h2 id="31-tcp服务的特点"><a class="markdownIt-Anchor" href="#31-tcp服务的特点"></a> 3.1 TCP服务的特点</h2>
<p><strong>传输层协议</strong>主要有两个:<strong>TCP协议</strong>和<strong>UDP协议</strong>。TCP协议相对于UDP协议的特点是:面向连接、字节流和可靠传输。</p>
<p>使用TCP协议通信的双方必须<u>先建立连接</u>，然后才能开始数据的读写。双方都必须为该<u>连接分配必要的内核</u>资源，以管理连接的状态和连接上数据的传输。TCP连接是<strong>全双工</strong>的，即<u>双方的数据读写可以通过一个连接进行</u>。完成数据交换之后，通信双方都<u>必须断开</u>连接以释放 系统资源。</p>
<p>TCP协议的这种连接是<strong>一对一</strong>的，所以基于<strong>广播</strong>和<strong>多播</strong>(目标是多个主机地址)的应用程序<strong>不能使用</strong>TCP服务。而无连接协议<u>UDP则非常适合于广播和多播</u>。</p>
<p>我们在1.1节中简单介绍过<strong>字节流服务</strong>和<strong>数据报服务</strong>的区别。这种区别对应到实际编程中，则体现为通信双方<u>是否必须执行相同次数的 读、写操作</u>(当然，这只是表现形式)。</p>
<p>当发送端应用程序连续执行多次写操作时，TCP模块先将这些数据放入<strong>TCP发送缓冲区</strong>中。当TCP模块<strong>真正开始发送</strong>数据时，发送缓冲区中这些等待发送的数据可能被<strong>封装成一个或多个TCP报文</strong>段发出。因此，TCP模块发送出的<u>TCP报文段的个数和应用程序执行的写操作次数之间没有固定的数量关系</u>。(<u>因为是两个阶段的，所以他可以读和写不用同步</u>)</p>
<p>当接收端收到一个或多个TCP报文段后，TCP模块将它们携带的应用程序数据<u>按照TCP报文段的序号</u>(见后文)依次放入TCP接收缓冲区 中，并<u>通知应用程序读取</u>数据。接收端应用程序可以一次性将TCP接收缓冲区中的数据<u>全部读出，也可以分多次读取</u>，这取决于用户指定的应用程序读缓冲区的大小。因此，应用程序执行的读操作次数和TCP模块接收到的TCP报文段个数之间也没有固定的数量关系。（跟上面一样也是有缓冲区，所以是两个阶段）</p>
<p>综上所述，<strong>发送端执行的写操作次数和接收端执行的读操作次数之间没有任何数量关系</strong>，这就是<strong>字节流</strong>的概念:应用程序对数据的发送和接收是没有边界限制的。UDP则不然。发送端应用程序每执行一次写操作，UDP模块就将其封装成一个UDP数据报并发送之。接收端必须及时针对每一个UDP数据报执行读操作(通过recvfrom系统调用)，否则就会丢包(这经常发生在较慢的服务器上)。并且，如果用户没有指定足够的应用程序缓冲区来读取UDP数据，则UDP数据将被截断。（<u>UDP属于是一一对应的发送</u>）</p>
<p>图3-1和图3-2显示了TCP字节流服务和UDP数据报服务的上述区别。两图中省略了传输层以下的通信细节。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091554080.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午3.54.17" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091554401.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午3.54.30" /></p>
<p>TCP传输是<strong>可靠的</strong>。</p>
<p>1、TCP协议采用发送应答机制，即发送端发送的每个TCP报文段都必须得到接收方的应答，才认为这个TCP报文段传输成功。</p>
<p>2、TCP协议采用超时重传机制，发送端在发送出一个 TCP报文段之后启动定时器，如果在定时时间内未收到应答，它将重发该报文段。3、因为TCP报文段最终是以IP数据报发送的，而IP数据报到达接收端<strong>可能乱序、重复</strong>，所以TCP协议还会对接收到的TCP报文段<strong>重排、整理，再交付</strong>给应用层。</p>
<p><u>UDP协议则和IP协议一样，提供不可靠服务</u>。它们都需要上层协议来处理数据确认和超时重传。</p>
<h2 id="32-tcp头部结构"><a class="markdownIt-Anchor" href="#32-tcp头部结构"></a> 3.2 TCP头部结构</h2>
<p>TCP头部信息出现在每个TCP报文段中，用于指定通信的源端端口，目的端端口，管理TCP连接等，本节详细介绍TCP的头部结构，包括固定头部结构和头部选项。</p>
<h3 id="321-tcp固定头部结构"><a class="markdownIt-Anchor" href="#321-tcp固定头部结构"></a> 3.2.1 TCP固定头部结构</h3>
<p>TCP头部结构如图3-3所示，其中的诸多字段为管理TCP连接和控制数据流提供了足够的信息。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091600766.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午4.00.34" /></p>
<p><strong>16位端口号(port number)</strong>:告知主机该报文段是来自哪里(源端口)以及传给哪个上层协议或应用程序(目的端口)的。进行TCP通信时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号。1.3节中提到过，所有知名服务使用的端口号都定义在/etc/services文件中。</p>
<p><strong>32位序号(sequence number)</strong>:一次TCP通信(从TCP连接建立到断开)过程中某一个传输方向上的字节流的每个字节的编号。假设主机A和主机B进行TCP通信，A发送给B的第一个TCP报文段中，序号值被系统初始化为某个随机值ISN(Initial Sequence Number，初始序号 值)。那么在该传输方向上(从A到B)，后续的TCP报文段中序号值<u>将被系统设置成ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移</u>。例如，某个TCP报文段传送的数据是字节流中的第1025~2048字节，那么该报文段的序号值就是ISN+1025。另外一个传输方向 (从B到A)的TCP报文段的序号值也具有相同的含义。</p>
<p><strong>32位确认号(acknowledgement number)</strong>:用作对<u>另一方发送来的TCP报文段的响应</u>。其值是收到的TCP报文段的序号值加1。假设主机 A和主机B进行TCP通信，那么A发送出的TCP报文段不仅携带自己的序号，而且包含对B发送来的TCP报文段的确认号。反之，B发送出的 TCP报文段也同时携带自己的序号和对A发送来的报文段的确认号。</p>
<p><strong>4位头部长度(header length)</strong>:标识该TCP头部有多少个32bit字 (4字节)。因为4位最大能表示15，所以TCP头部最长是60字节。</p>
<p><strong>6位标志位</strong>包含如下几项:</p>
<p>1、URG标志，表示紧急指针(urgent pointer)是否有效。</p>
<p>2、ACK标志，表示确认号是否有效。我们称携带ACK标志的TCP报文段为确认报文段。</p>
<p>3、PSH标志，提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间(如果应用程序不将接收到的数据读走，它们就会一直停留在TCP接收缓冲区中)。</p>
<p>4、RST标志，表示要求对方重新建立连接。我们称携带RST标志的TCP报文段为复位报文段。</p>
<p>5、SYN标志，表示请求建立一个连接。我们称携带SYN标志的TCP报文段为同步报文段。</p>
<p>6、FIN标志，表示通知对方本端要关闭连接了。我们称携带FIN标志的TCP报文段为结束报文段。</p>
<p><strong>16位窗口大小(window size)</strong>:是<u>TCP流量控制</u>的一个手段。这里说的窗口，指的是接收通告窗口(Receiver Window，RWND)。它告诉对方本端的<u>TCP接收缓冲区还能容纳多少字节</u>的数据，这样对方就可以控制发送数据的速度。</p>
<p><strong>16位校验和(TCP checksum)</strong>:由发送端填充，接收端对TCP报 文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这 个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一 个重要保障。</p>
<p><strong>16位紧急指针(urgent pointer)</strong>:是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是<u>紧急指针相对当前序号的偏移</u>，不妨称之为紧急偏移。TCP的紧急指针是<u>发送端向接收端发送紧急数据</u>的方法。我们将在后面讨论TCP紧急数据。</p>
<h3 id="322-tcp头部选项"><a class="markdownIt-Anchor" href="#322-tcp头部选项"></a> 3.2.2 TCP头部选项</h3>
<p>TCP头部的最后一个选项字段(options)是<u>可变长的可选</u>信息。这部分最多包含40字节，因为TCP头部最长是60字节(其中还包含前面讨论的20字节的固定部分)。典型的TCP头部选项结构如图3-4所示。<img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091629187.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午4.29.12" /></p>
<p>选项的第一个字段kind说明选项的类型。有的TCP选项没有后面两个字段，仅包含1字节的kind字段。第二个字段length(如果有的话)指定该选项的总长度，该长度包括kind字段和length字段占据的2字节。第三个字段info(如果有的话)是选项的具体信息。常见的TCP选项有7 种，如图3-5所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091633489.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午4.33.50" /></p>
<p>kind=0是选项表结束选项。</p>
<p>kind=1是空操作(nop)选项，没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍。</p>
<p>kind=2是最大报文段长度选项。TCP连接初始化时，通信双方使用 该选项来协商最大报文段长度(Max Segment Size，MSS)。TCP模块 通常将MSS设置为(MTU-40)字节(减掉的这40字节包括20字节的 TCP头部和20字节的IP头部)。这样携带TCP报文段的IP数据报的长度就不会超过MTU(假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况)，从而避免本机发生IP分片。对以太网而言，MSS值是1460(1500-40)字节。</p>
<p>kind=3是窗口扩大因子选项。TCP连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子。在TCP的头部中，接收通告窗口 大小是用16位表示的，故最大为65535字节，但实际上TCP模块允许的接收通告窗口大小远不止这个数(为了提高TCP通信的吞吐量)。窗口扩大因子解决了这个问题。假设TCP头部中的接收通告窗口大小是N， 窗口扩大因子(移位数)是M，那么TCP报文段的实际接收通告窗口大小是N乘2M，或者说N左移M位。注意，M的取值范围是0~14。我们可以通过修改/proc/sys/net/ipv4/tcp_window_scaling内核变量来启用或关闭窗口扩大因子选项。</p>
<p>和MSS选项一样，窗口扩大因子选项只能出现在同步报文段中， 否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该TCP报文段的实际接收通告窗口大小。当连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了。关于窗口扩大因子选项的细节，可参考标准文档RFC 1323。</p>
<p>kind=4是选择性确认(Selective Acknowledgment，SACK)选项。 TCP通信时，如果某个TCP报文段丢失，则TCP模块会重传最后被确认 的TCP报文段后续的所有报文段，这样<u>原先已经正确传输的TCP报文段也可能重复发送，从而降低了TCP性能</u>。SACK技术正是为改善这种情况而产生的，它使TCP模块只重新发送丢失的TCP报文段，不用发送所有未被确认的TCP报文段。选择性确认选项用在连接初始化时，表示是否支持SACK技术。我们可以通过修改/proc/sys/net/ipv4/tcp_sack内核变量来启用或关闭选择性确认选项。</p>
<p>kind=5是SACK实际工作的选项。该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。每个块边沿(edge of block)参数包含一个4字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数(块左边沿和块右边沿)之间的数据是没有收到的。因为一个块信息占用8字节，所以TCP头部选项中实际上最多可以包含4个这样的不连续数据块(考虑选项类型和长度占用的2字节)。</p>
<p>kind=8是时间戳选项。该选项提供了较为准确的计算通信双方之间的回路时间(Round Trip Time，RTT)的方法，从而为TCP流量控制提供重要信息。我们可以通过修改/proc/sys/net/ipv4/tcp_timestamps内核变量来启用或关闭时间戳选项。</p>
<h3 id="323-使用tcpdump观察tcp头部信息"><a class="markdownIt-Anchor" href="#323-使用tcpdump观察tcp头部信息"></a> 3.2.3 使用tcpdump观察TCP头部信息</h3>
<p>在2.3节中，我们利用tcpdump抓取了一个数据包并分析了其中的IP头部信息，本节分析其中与TCP协议相关的部分(后面的分析中，我们 将所有<u>tcpdump抓取到的数据包都称为TCP报文段</u>，因为TCP报文段既是数据包的主要内容，也是我们主要讨论的对象)。为了方便阅读， 先将该TCP报文段的内容复制于代码清单3-1中。</p>
<p>代码清单3-1 用tcpdump抓取数据包</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.41621</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[S],seq <span class="hljs-number">3499745539</span>,win <span class="hljs-number">32792</span>,options[mss <span class="hljs-number">16396</span>,sackOK,TS val <span class="hljs-number">40781017</span> ecr <span class="hljs-number">0</span>,nop,wscale <span class="hljs-number">6</span>],length <span class="hljs-number">0</span><br><span class="hljs-number">0x0000</span>:<span class="hljs-number">4510</span> <span class="hljs-number">003</span>c a5da <span class="hljs-number">4000</span> <span class="hljs-number">4006</span> <span class="hljs-number">96</span>cf <span class="hljs-number">7f</span>00 <span class="hljs-number">0001</span><br><span class="hljs-number">0x0010</span>:<span class="hljs-number">7f</span>00 <span class="hljs-number">0001</span> a295 <span class="hljs-number">0017</span> d099 e103 <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0x0020</span>:a002 <span class="hljs-number">8018</span> fe30 <span class="hljs-number">0000</span> <span class="hljs-number">0204</span> <span class="hljs-number">400</span>c <span class="hljs-number">0402</span> <span class="hljs-number">080</span>a<br><span class="hljs-number">0x0030</span>:<span class="hljs-number">026</span>e <span class="hljs-number">44</span>d9 <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0103</span> <span class="hljs-number">0306</span><br></code></pre></td></tr></table></figure>
<p><strong>tcpdump输出Flags[S]</strong>，表示该TCP报文段包含SYN标志，因此它是一个<strong>同步报文段</strong>。如果TCP报文段包含其他标志，则tcpdump也会将该<strong>标志的首字母</strong>显示在“Flags”后的方括号中。</p>
<p><strong>seq是序号值</strong>。因为该同步报文段是从127.0.0.1.41621(客户端IP地址和端口号)到127.0.0.1.23(服务器IP地址和端口号)这个传输方向上的第一个TCP报文段，所以这个序号值也就是此次通信过程中该传输方向的<strong>ISN值</strong>。并且，因为这是整个通信过程中的第一个TCP报文段， 所以它没有针对对方发送来的TCP报文段的确认值(尚未收到任何对方发送来的TCP报文段)。</p>
<p><strong>win是接收通告窗口的大小</strong>。因为这是一个同步报文段，所以win值反映的是实际的接收通告窗口大小。</p>
<p><strong>options是TCP选项</strong>，其具体内容列在方括号中。<strong>mss</strong>是发送端(客户端)通告的最大报文段长度。通过ifconfig命令查看回路接口的MTU为16436字节，因此可以预想到TCP报文段的MSS为16396(16436-40) 字节。<strong>sackOK</strong>表示发送端支持并同意使用SACK选项。<strong>TS val</strong>是发送端的时间戳。<strong>ecr</strong>是时间戳回显应答。因为这是一次TCP通信的第一个 TCP报文段，所以它针对对方的时间戳的应答为0(尚未收到对方的时 间戳)。紧接着的<strong>nop</strong>是一个空操作选项。<strong>wscale</strong>指出发送端使用的窗口扩大因子为6。</p>
<p>接下来我们分析tcpdump输出的字节码中TCP头部对应的信息，它从第21字节开始，如表3-1所示。第一列的16进制没用，就是代表行号。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091654334.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午4.54.28" /></p>
<p>从表3-1中可见，TCP报文段头部的二进制码和tcpdump输出的TCP报文段描述信息完全对应。在后面的tcpdump输出中，我们将省略大部 分TCP头部信息，仅显示序号、确认号、窗口大小以及标志位等与主题相关的字段。</p>
<h2 id="33-tcp连接的建立和关闭"><a class="markdownIt-Anchor" href="#33-tcp连接的建立和关闭"></a> 3.3 TCP连接的建立和关闭</h2>
<p>本节我们讨论建立和关闭TCP连接的过程。</p>
<h3 id="331-使用tcpdump观察tcp连接的建立和关闭"><a class="markdownIt-Anchor" href="#331-使用tcpdump观察tcp连接的建立和关闭"></a> 3.3.1 使用tcpdump观察TCP连接的建立和关闭</h3>
<p>首先从ernest-laptop上<u>执行telnet命令登录Kongming20的80端口</u>，然后抓取这一过程中<u>客户端和服务器交换的TCP报文段</u>。具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -i eth0 -nt<span class="hljs-number">&#x27;</span>(src <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-keyword">and</span> dst <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>)<span class="hljs-built_in"><span class="hljs-keyword">or</span></span>(src <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-keyword">and</span> dst <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>)&#x27;<br>$telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">80</span> Trying <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>... Connected to <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>. Escape character is<span class="hljs-number">&#x27;</span>^]<span class="hljs-string">&#x27;. ^](回车)#输入ctrl+]并回车 telnet&gt;quit(回车) Connection closed.</span><br></code></pre></td></tr></table></figure>
<p>当执行telnet命令并在两台通信主机之间建立TCP连接后(telnet输出“Connected to 192.168.1.109”)，输入Ctrl+]以调出telnet程序的命令提 示符，然后在telnet命令提示符后输入quit以退出telnet客户端程序，从而结束TCP连接。整个过程中(从连接建立到结束)，tcpdump输出的 内容如代码清单3-2所示。</p>
<p><strong>代码清单3-2 建立和关闭TCP连接的过程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>:Flags[S],seq <span class="hljs-number">535734930</span>,win <span class="hljs-number">5840</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>:Flags[S.],seq <span class="hljs-number">2159701207</span>,ack <span class="hljs-number">535734931</span>,win <span class="hljs-number">5792</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">1</span>,win <span class="hljs-number">92</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>:Flags[F.],seq <span class="hljs-number">1</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">92</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>:Flags[.],ack <span class="hljs-number">2</span>,win <span class="hljs-number">91</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">6.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>:Flags[F.],seq <span class="hljs-number">1</span>,ack <span class="hljs-number">2</span>,win <span class="hljs-number">91</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">7.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">2</span>,win <span class="hljs-number">92</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>因为整个过程并<strong>没有发生应用层数据的交换</strong>，所以TCP报文段的数据部分的<strong>长度(length)总是0</strong>。为了更清楚地表示建立和关闭TCP连接 的整个过程，我们将tcpdump输出的内容绘制成图3-6所示的时序图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091740284.png" srcset="/img/loading.gif" lazyload alt="" /></p>
<h4 id="tcp三次握手tcp连接"><a class="markdownIt-Anchor" href="#tcp三次握手tcp连接"></a> TCP三次握手（TCP连接）</h4>
<p><strong>第1个TCP报文段</strong>包含SYN标志，因此它是一个<u>同步报文段</u>，即ernest-laptop(客户端)向Kongming20(服务器)发起连接请求。同时，该同步报文段包含一个ISN值为535734930的序号。</p>
<p><strong>第2个TCP报文段</strong>也是<u>同步报文段</u>，表示Kongming20同意与ernest-laptop建立连接。同时它发送自己的ISN值为2159701207的序号，并<u>对第1个同步报文段进行确认</u>。确认值是535734931，即第1个同步报文段的序号值加1。</p>
<p>前文说过，序号值是<u>用来标识TCP数据流中的每一字节</u>的。但<u>同步报文段比较特殊</u>，即使它并没有携带任何应用程序数据，它也要占用一个序号值。</p>
<p><strong>第3个TCP报文段</strong>是ernest-laptop对第2个同步报文段的确认。至此，TCP连接就建立起来了。建立TCP连接的这3个步骤被称为<strong>TCP三次握手。</strong></p>
<p>从第3个TCP报文段开始，tcpdump输出的序号值和确认值都是<u>相对初始ISN值的偏移</u>。当然，我们可以开启tcpdump的-S选项来选择打印 序号的绝对值。</p>
<h4 id="tcp四次握手tcp断开连接"><a class="markdownIt-Anchor" href="#tcp四次握手tcp断开连接"></a> TCP四次握手（TCP断开连接）</h4>
<p>后面4个TCP报文段是关闭连接的过程。</p>
<p><strong>第4个TCP报文段</strong>包含FIN标志，因此它是一个结束报文段，即ernest-laptop要求关闭连接。结束报文段和同步报文段一样，也要占用一个序号值。</p>
<p><strong>Kongming20用TCP报文段5</strong>来确认该结束报文段。紧接着Kongming20发送自己的结束报文段6，ernest-laptop则用TCP报文段7给予确认。实际上，仅用于确认目的的确认报文段5是<u>可以省略</u>的，因为<strong>结束报文段6也携带了该确认信息</strong>。确认报文段5是否出现在连接断开的过程中，取决于TCP的延迟确认特性。延迟确认将在后面讨论。</p>
<p>在连接的关闭过程中，因为ernest-laptop先发送结束报文段(telnet客户端程序主动退出)，故称<strong>ernest-laptop执行主动关闭</strong>，而称 <strong>Kongming20执行被动关闭</strong>。</p>
<p>一般而言，TCP连接是由客户端发起，并通过三次握手建立(特殊情况是所谓同时打开[1])的。TCP连接的关闭过程相对复杂一些。可能是客户端执行主动关闭，比如前面的例子;也可能是服务器执行主动关闭，比如服务器程序被中断而强制关闭连接;还可能是同时关闭(和同时打开一样，非常少见)。</p>
<h3 id="332-半关闭状态"><a class="markdownIt-Anchor" href="#332-半关闭状态"></a> 3.3.2 半关闭状态</h3>
<p>TCP连接是<strong>全双工</strong>的，所以<strong>它允许两个方向的数据传输被独立关闭</strong>。换言之，通信的一端可以发送结束报文段给对方，告诉它本端已经完成了数据的发送，但允许继续接收来自对方的数据，直到对方也发送结束报文段以关闭连接。TCP连接的这种状态称为<strong>半关闭(half close)状态</strong>，如图3-7所示。（一方结束了，等待另一方也结束的状态叫半关闭）</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091833324.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午6.33.29" /></p>
<p>请注意，在图3-7中，服务器和客户端应用程序判断对方<u>是否已经关闭连接</u>的方法是:<u>read系统调用返回0</u>(收到结束报文段)。当然， Linux还提供其他检测连接是否被对方关闭的方法，这将在后续章节讨论。</p>
<p>socket网络编程接口通过shutdown函数提供了对半关闭的支持，我们将在后续章节讨论它。这里强调一下，虽然我们介绍了<strong>半关闭状态</strong>，但是使用半关闭的应用程序很少见。</p>
<h3 id="333-连接超时"><a class="markdownIt-Anchor" href="#333-连接超时"></a> 3.3.3 连接超时</h3>
<p>前面我们讨论的是很快建立连接的情况。如果客户端访问一个距离它<strong>很远</strong>的服务器，或者由于网络繁忙，导致服务器对于客户端发送出的同步报文段没有应答，此时客户端程序将产生什么样的行为呢? 显然，对于提供可靠服务的TCP来说，它必然是先进行重连(可能执行多次)，如果重连仍然无效，则通知应用程序连接超时。</p>
<p>为了观察连接超时，我们模拟一个繁忙的服务器环境，在ernest-laptop上执行下面的操作:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo iptables -F<br>$sudo iptables -I INPUT -p tcp --syn -i eth0 -j DROP<br></code></pre></td></tr></table></figure>
<p>iptable命令用于<strong>过滤数据包</strong>，这里我们利用它来<u>丢弃所有接收到的连接请求</u>(丢弃所有同步报文段，这样客户端就无法得到任何确认报文段)。</p>
<p>接下来从Kongming20上执行telnet命令登录到ernest-laptop，并用tcpdump抓取这个过程中双方交换的TCP报文段。具体操作如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -n -i eth0 port <span class="hljs-number">23</span>#仅抓取telnet客户端和服务器交换的数据包<br>$date; telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>; date#在telnet命令前后都执行date命令，以计算超时时间<br>Mon Jun <span class="hljs-number">11</span> <span class="hljs-number">21</span>:<span class="hljs-number">23</span>:<span class="hljs-number">35</span> CST <span class="hljs-number">2012</span><br>Trying <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>...<br>telnet:connect to address <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:Connection timed out<br>Mon Jun <span class="hljs-number">11</span> <span class="hljs-number">21</span>:<span class="hljs-number">24</span>:<span class="hljs-number">38</span> CST <span class="hljs-number">2012</span><br></code></pre></td></tr></table></figure>
<p>从两次date命令的输出来看，Kongming20建立TCP连接的超时时间是63s。本次tcpdump的输出如代码清单3-3所示。</p>
<p>代码清单3-3 TCP超时重连</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.21</span>:<span class="hljs-number">23</span>:<span class="hljs-number">35.612136</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.39385</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.telnet:Flags[S],seq <span class="hljs-number">1355982096</span>，length <span class="hljs-number">0</span><br><span class="hljs-number">2.21</span>:<span class="hljs-number">23</span>:<span class="hljs-number">36.613146</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.39385</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.telnet:Flags[S],seq <span class="hljs-number">1355982096</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">3.21</span>:<span class="hljs-number">23</span>:<span class="hljs-number">38.617279</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.39385</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.telnet:Flags[S],seq <span class="hljs-number">1355982096</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.21</span>:<span class="hljs-number">23</span>:<span class="hljs-number">42.625140</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.39385</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.telnet:Flags[S],seq <span class="hljs-number">1355982096</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">5.21</span>:<span class="hljs-number">23</span>:<span class="hljs-number">50.641344</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.39385</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.telnet:Flags[S],seq <span class="hljs-number">1355982096</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">6.21</span>:<span class="hljs-number">24</span>:<span class="hljs-number">06.673331</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.39385</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.telnet:Flags[S],seq <span class="hljs-number">1355982096</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>这次抓包我们保留了tcpdump输出的时间戳(不使用其-t选项)，以便推理Linux的超时重连策略。</p>
<p>我们一共抓取到6个TCP报文段，它们都是<strong>同步报文段</strong>，并且具有<strong>相同的序号值</strong>，这说明后面5个同步报文段都是<u>超时重连报文段</u>。观察 这些TCP报文段被发送的时间间隔，它们分别为1s、2s、4s、8s和16s(由于定时器精度的问题，这些时间间隔都有一定偏差)，可以推断最后一个TCP报文段的超时时间是32s(63s-16s-8s-4s-2s-1s)。因此，TCP模块一共执行了5次重连操作，这是由/proc/sys/net/ipv4/tcp_syn_retries内核变量所定义的。<strong>每次重连的超时时间都增加一倍</strong>。在5次重连均失败的情况下，TCP模块放弃连接并通知应用程序。</p>
<p>在应用程序中，我们可以修改连接超时时间，具体方法将在本书后续章节中进行介绍。</p>
<h2 id="34-tcp状态转移"><a class="markdownIt-Anchor" href="#34-tcp状态转移"></a> 3.4 TCP状态转移</h2>
<p>TCP连接的<u>任意一端在任一时刻都处于某种状态</u>，当前状态可以通过netstat命令(见第17章)查看。本节我们要讨论的是TCP连接从建立到关闭的整个过程中通信两端状态的变化。图3-8是完整的状态转移图，它描绘了所有的TCP状态以及可能的状态转换。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205092023605.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-09 下午8.23.24" /></p>
<p>图3-8中的<strong>粗虚线</strong>表示<strong>典型的服务器端连接的状态转移</strong>;<strong>粗实线</strong>表示<strong>典型的客户端连接的状态转移</strong>。<strong>CLOSED</strong>是一个<strong>假想的起始点</strong>，并不是一个实际的状态。</p>
<h3 id="341-tcp状态转移总图"><a class="markdownIt-Anchor" href="#341-tcp状态转移总图"></a> 3.4.1 TCP状态转移总图</h3>
<p>我们先讨论服务器的典型状态转移过程，此时我们说的<u>连接状态都是指该连接的服务器端的状态</u>。</p>
<p>1、服务器通过listen系统调用(见第5章)进入<strong>LISTEN状态</strong>，<u>被动等待客户端连接</u>，因此执行的是所谓的被动打开。</p>
<p>2、服务器一旦监听到某个连接请求(收到同步报文段)，就将该连接放入内核等待队列中，并向客户端发送带SYN标志的确认报文段。此时该连接处于SYN_RCVD状态。</p>
<p>3、如果服务器成功地接收到客户端发送回的确认报文段，则该连接转移到ESTABLISHED状态。<strong>ESTABLISHED状态</strong>是<strong>连接双方能够进行双向数据传输的状态</strong>。</p>
<p>4、当客户端主动关闭连接时(通过close或shutdown系统调用向服务器发送结束报文段)，服务器通过返回确认报文段使连接进入<strong>CLOSE_WAIT</strong>状态。这个状态的含义很明确:<u>等待服务器应用程序关闭连接</u>。通常，<u>服务器检测到客户端关闭连接后，也会立即给客户端发送一个结束报文段来关闭连接</u>。这将使连接转移到<strong>LAST_ACK</strong>状态，以等待客户端对结束报文段的最后一次确认。一旦确认完成，连 接就彻底关闭了。</p>
<p>下面讨论客户端的典型状态转移过程，此时我们说的<strong>连接状态</strong>都是指<strong>该连接的客户端的状态</strong>。</p>
<p>客户端通过connect系统调用(见第5章)<u>主动与服务器建立连接</u>。 connect系统调用首先给服务器发送一个同步报文段，使连接转移到 SYN_SENT状态。此后，connect系统调用可能因为如下两个原因失败返回:</p>
<p>1、如果connect连接的目标端口不存在(未被任何进程监听)，或者该端口仍被处于TIME_WAIT状态的连接所占用(见后文)，则服务器将给客户端发送一个复位报文段，connect调用失败。</p>
<p>2、如果目标端口存在，但connect在超时时间内<u>未收到服务器的确认报文段</u>，则connect调用失败。</p>
<p>connect调用失败将使连接立即返回到初始的<strong>CLOSED状态</strong>。如果客户端成功收到服务器的同步报文段和确认，则connect调用成功返 回，连接转移至ESTABLISHED状态。</p>
<p>当客户端执行主动关闭时，它将向服务器发送一个结束报文段， 同时连接进入FIN_WAIT_1状态。若此时客户端收到服务器专门用于确认目的的确认报文段(比如图3-6中的TCP报文段5)，则连接转移至FIN_WAIT_2状态。当客户端处于FIN_WAIT_2状态时，服务器处于 CLOSE_WAIT状态，这一对状态是可能发生半关闭的状态。此时如果服务器也关闭连接(发送结束报文段)，则客户端将给予确认并进入 TIME_WAIT状态。关于TIME_WAIT状态的含义，我们将在下一节讨论。</p>
<p>图3-8还给出了客户端从FIN_WAIT_1状态直接进入TIME_WAIT状态的一条线路(不经过FIN_WAIT_2状态)，前提是处于<strong>FIN_WAIT_1状态的服务器直接收到带确认信息的结束报文段</strong>(而不是先收到确认报文段，再收到结束报文段)。这种情况对应于图3-6中的服务器不发送TCP报文段5。</p>
<p>前面说过，处于FIN_WAIT_2状态的客户端需要等待服务器发送结束报文段，才能转移至TIME_WAIT状态，否则它将一直停留在这个状 态。如果不是为了在半关闭状态下继续接收数据，<u>连接长时间地停留在FIN_WAIT_2状态并无益处</u>。（属于一个工作一个不工作）连接停留在FIN_WAIT_2状态的情况可能发生在**:客户端执行半关闭<strong>后，未等服务器关闭连接就强行退出了。此时客户端连接由内核来接管，可称之为孤儿连接(和孤儿进程类似)。</strong>（相当于找了个保姆替你看着）<strong>Linux为了防止孤儿连接长时间存留在内核中，定义了两个内核变量:/proc/sys/net/ipv4/tcp_max_orphans 和/proc/sys/net/ipv4/tcp_fin_timeout。前者指定内核能接管的</strong>孤儿连接数目**，后者指定孤儿连接在内核中<strong>生存的时间</strong>。</p>
<p>至此，我们简单地讨论了服务器和客户端程序的典型TCP状态转移路线。对应于图3-6所示的TCP连接的建立与断开过程，客户端和服务 器的状态转移如图3-9所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205121608151.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-12 下午4.08.47" /></p>
<p>图3-8<u>还描绘了其他非典型的TCP状态转移路线</u>，比如同时关闭与同时打开，本书不予讨论。</p>
<h3 id="342-time_wait状态"><a class="markdownIt-Anchor" href="#342-time_wait状态"></a> 3.4.2 TIME_WAIT状态</h3>
<p>从图3-9来看，客户端连接在收到服务器的结束报文段(TCP报文段6)之后，并没有直接进入CLOSED状态[1]，而是转移到TIME_WAIT状态。在这个状态，<u>客户端连接要等待一段长为2MSL(Maximum Segment Life，报文段最大生存时间)的时间</u>，才能完全关闭。MSL是 TCP报文段在网络中的最大生存时间，标准文档RFC 1122的建议值是2 min。</p>
<h4 id="time_wait状态存在的原因有两点"><a class="markdownIt-Anchor" href="#time_wait状态存在的原因有两点"></a> TIME_WAIT状态存在的原因有两点:</h4>
<p>1、可靠地终止TCP连接。</p>
<p>2、保证让迟来的TCP报文段有足够的时间被识别并丢弃。</p>
<p>第一个原因很好理解。假设图3-9中用于确认服务器结束报文段6的TCP报文段7丢失，那么服务器将重发结束报文段。因此客户端需要停 留在某个状态以处理重复收到的结束报文段(即向服务器发送确认报文段)。否则，客户端将以复位报文段来回应服务器，服务器则认为这是一个错误，因为它期望的是一个像TCP报文段7那样的确认报文段。</p>
<p>在Linux系统上，<strong>一个TCP端口不能被同时打开多次</strong>(两次及以上)。当一个TCP连接处于TIME_WAIT状态时，我们将无法立即使用该连接占用着的端口来建立一个新连接。反过来思考，如果不存在TIME_WAIT状态，则应用程序能够立即建立一个和刚关闭的连接相似的连接(这里说的相似，是指它们具有相同的IP地址和端口号)。这个新的、和原来相似的连接被称为<strong>原来的连接的化身(incarnation)</strong>。 新的化身可能接收到属于原来的连接的、携带应用程序数据的TCP报文段(迟到的报文段)，这显然是不应该发生的。这就是TIME_WAIT状态存在的第二个原因。</p>
<p>另外，因为TCP报文段的<strong>最大生存时间是MSL</strong>，所以<u>坚持2MSL时间的TIME_WAIT状态能够确保网络上两个传输方向上尚未被接收到的、迟到的TCP报文段都已经消失(被中转路由器丢弃)</u>。因此，一个连接的新的化身可以在2MSL时间之后安全地建立，而绝对不会接收到属于原来连接的应用程序数据，<strong>这就是TIME_WAIT状态要持续2MSL时间</strong>的原因。</p>
<p>有时候我们希望<u>避免TIME_WAIT状态</u>，因为当程序退出后，我们希望能够立即重启它。但由于处在TIME_WAIT状态的连接还占用着端 口，程序将无法启动(直到2MSL超时时间结束)。</p>
<h4 id="考虑一个例子"><a class="markdownIt-Anchor" href="#考虑一个例子"></a> 考虑一个例子:</h4>
<p>在测试机器ernest-laptop上以客户端方式运行nc(用于创建网络连接的工具，见第17章)命令，登录本机的Web服务，且明确指定客户端使用12345端口与服务器通信。然后从终端输入Ctrl+C终止客户端程序，接着又立即重启nc程序，以完全相同的方式再次连接本机的Web服务。具体操作如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">$nc-p <span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-number">80</span><br>ctrl+C#中断客户端程序<br>$nc-p <span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-number">80</span>#重启客户端程序，重新建立连接<br>nc:bind failed:Address already in use#输出显示连接失败，因为<span class="hljs-number">12345</span>端口<br>仍被占用<br>$netstat-nat#用netstat命令查看连接状态<br>Proto Recv-Q Send-Q Local Address Foreign Address State tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">80</span> TIME_WAIT<br></code></pre></td></tr></table></figure>
<p>这里我们使用netstat命令查看连接的状态。其输出显示，客户端程序被中断后，连接进入TIME_WAIT状态，12345端口仍被占用，所以 客户端重启失败。</p>
<p>对客户端程序来说，我们通常不用担心上面描述的重启问题。因为客户端<u>一般使用系统自动分配的临时端口号来建立连接</u>，而由于随机性，临时端口号一般和程序上一次使用的端口号(还处于TIME_WAIT状态的那个连接使用的端口号)不同，所以客户端程序一般可以立即重启。上面的例子仅仅是为了说明问题，我们强制客户端使用12345端口，这才导致立即重启客户端程序失败。</p>
<p>但如果是服务器主动关闭连接后异常终止，则因为它总是使用同一个知名服务端口号，所以连接的TIME_WAIT状态将导致它不能立即 重启。不过，我们可以通过socket选项SO_REUSEADDR来强制进程立 即使用处于TIME_WAIT状态的连接占用的端口，这将在第5章讨论。</p>
<h2 id="35-复位报文段"><a class="markdownIt-Anchor" href="#35-复位报文段"></a> 3.5 复位报文段</h2>
<p>在某些特殊条件下，<u>TCP连接的一端会向另一端发送携带RST标志的报文段，即复位报文段</u>，以通知对方关闭连接或重新建立连接。 本节讨论产生复位报文段的3种情况。</p>
<h3 id="351-访问不存在的端口"><a class="markdownIt-Anchor" href="#351-访问不存在的端口"></a> 3.5.1 访问不存在的端口</h3>
<p>3.4.1小节提到，当客户端程序访问一个不存在的端口时，目标主机将给它发送一个复位报文段。考虑从Kongming20上执行telnet命令登 录ernest-laptop上一个不存在的54321端口，并用tcpdump抓取该过程中两台主机交换的TCP报文段。具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -nt -i eth0 port <span class="hljs-number">54321</span>#仅抓取发送至和来自<span class="hljs-number">54321</span>端口的TCP报文段<br> $telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-number">54321</span><br> Trying <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>...<br> telnet:connect to address <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:Connection refused<br></code></pre></td></tr></table></figure>
<p>telnet程序的输出显示连接被<strong>拒绝</strong>了，因为这个端口<strong>不存在</strong>。 tcpdump抓取到的TCP报文段内容如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.42001</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.54321</span>:Flags[S],seq <span class="hljs-number">21621375</span>,win <span class="hljs-number">14600</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.54321</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.42001</span>:Flags[R.],seq <span class="hljs-number">0</span>,ack <span class="hljs-number">21621376</span>,win <span class="hljs-number">0</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>由此可见，ernest-laptop针对Kongming20的连接请求(同步报文段)回应了一个复位报文段(tcpdump输出R标志)。因为复位报文段的接收通告窗口大小为0，所以可以预见:收到复位报文段的一端应该关闭连接或者重新连接，而不能回应这个复位报文段。</p>
<p>实际上，当客户端程序向服务器的某个端口发起连接，而该端口仍被处于TIME_WAIT状态的连接所占用时，客户端程序也将收到复位报文段。</p>
<h3 id="352-异常终止连接"><a class="markdownIt-Anchor" href="#352-异常终止连接"></a> 3.5.2 异常终止连接</h3>
<p>前面讨论的连接终止方式都是正常的终止方式:数据交换完成之后，一方给另一方发送结束报文段。TCP提供了异常终止一个连接的方法，即给对方发送一个复位报文段。一旦发送了复位报文段，发送端所有排队等待发送的数据都将被丢弃。</p>
<p>应用程序可以使用socket选项SO_LINGER来发送复位报文段，以异常终止一个连接。我们将在第5章讨论SO_LINGER选项。</p>
<h3 id="353-处理半打开连接"><a class="markdownIt-Anchor" href="#353-处理半打开连接"></a> 3.5.3 处理半打开连接</h3>
<p>考虑下面的情况:服务器(或客户端)关闭或者异常终止了连接，而对方没有接收到结束报文段(比如发生了网络故障)，此时，客户端(或服务器)还维持着原来的连接，而服务器(或客户端)即使重启，也已经没有该连接的任何信息了。我们将这种状态称为<strong>半打开状态</strong>，处于这种状态的连接称为半打开连接。如果客户端(或服务器)往处于半打开状态的连接写入数据，则对方将回应一个复位报文段。（属于是客户单方面苦等）</p>
<p>举例来说，我们在Kongming20上使用nc命令模拟一个服务器程序，使之监听12345端口，然后从ernest-laptop运行telnet命令登录到该 端口上，接着拔掉ernest-laptop的网线，并在Kongming20上中断服务器程序。显然，此时ernest-laptop上运行的telnet客户端程序维持着一个半打开连接。然后接上ernest-laptop的网线，并从客户端程序往半打开连接写入1字节的数据“a”。同时，运行tcpdump程序抓取整个过程中telnet客户端和nc服务器交换的TCP报文段。具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">$nc -l <span class="hljs-number">12345</span>#在Kongming20上运行服务器程序<br>$sudo tcpdump -nt -i eth0 port <span class="hljs-number">12345</span><br>$telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">12345</span>#在ernest-laptop上运行客户端程序 Trying <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>...<br>Connected to <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>.<br>Escape character is<span class="hljs-number">&#x27;</span>^]<span class="hljs-string">&#x27;.#此时断开ernest-laptop的网线，并重启服务器 a(回车)#向半打开连接输入字符a</span><br><span class="hljs-string">Connection closed by foreign host.</span><br></code></pre></td></tr></table></figure>
<p>telnet的输出显示，连接被服务器关闭了。tcpdump抓取到的TCP 报文段内容如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.55100</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.12345</span>:Flags[S],seq <span class="hljs-number">3093809365</span>,length <span class="hljs-number">0</span>      <br><span class="hljs-number">2.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.55100</span>:Flags[S.],seq <span class="hljs-number">1495337791</span>,ack <span class="hljs-number">3093809366</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.55100</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.12345</span>:Flags[.],ack <span class="hljs-number">1</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.55100</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.12345</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">4</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">3</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.55100</span>:Flags[R],seq <span class="hljs-number">1495337792</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>该输出内容中，前3个TCP报文段是正常建立TCP连接的3次握手的过程。</p>
<p>第4个TCP报文段由客户端发送给服务器，它携带了3字节的应用程序数据，这3字节依次是:字母“a”、回车符“\r”和换行符“\n”。 不过因为服务器程序已经被中断，所以Kongming20对客户端发送的数据回应了一个复位报文段5。</p>
<h2 id="36-tcp交互数据流"><a class="markdownIt-Anchor" href="#36-tcp交互数据流"></a> 3.6 TCP交互数据流</h2>
<p>前面讨论了TCP连接及其状态，从本节开始我们讨论通过TCP连接交换的应用程序数据。TCP报文段所携带的应用程序数据按照长度分为两种:<strong>交互数据</strong>和<strong>成块数据</strong>。交互数据仅包含<u>很少</u>的字节。使用交互数据的应用程序(或协议)对实时性要求高，比如telnet、ssh等。 成块数据的长度则通常为TCP报文段允许的最大数据长度。使用成块数据的应用程序(或协议)对传输效率要求高，比如ftp。本节我们讨论交互数据流。</p>
<p>考虑如下情况:在ernest-laptop上执行telnet命令登录到本机，然后在shell命令提示符后执行ls命令，同时用tcpdump抓取这一过程中telnet 客户端和telnet服务器交换的TCP报文段。具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">$tcpdump -nt -i lo port <span class="hljs-number">23</span><br>$telnet <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>Trying <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>...<br>Connected to <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>.<br>Escape character is<span class="hljs-number">&#x27;</span>^]<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">Ubuntu 9.10</span><br><span class="hljs-string">ernest-laptop login:ernest(回车)#输入用户名并回车 Password:(回车)#输入密码并回车 ernest@ernest-laptop:~$ls(回车)</span><br></code></pre></td></tr></table></figure>
<p>上述过程将引起客户端和服务器交换很多TCP报文段。下面我们仅列出我们感兴趣的、执行ls命令产生的tcpdump输出，如代码清单3-4所示。</p>
<p>代码清单3-4 TCP交互数据流</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[P.],seq <span class="hljs-number">1408334812</span>:<span class="hljs-number">1408334813</span>,ack <span class="hljs-number">1415955507</span>,win <span class="hljs-number">613</span>,length <span class="hljs-number">1</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">2</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">512</span>,length <span class="hljs-number">1</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[.],ack <span class="hljs-number">2</span>,win <span class="hljs-number">613</span>,length<br><span class="hljs-number">0</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">2</span>,ack <span class="hljs-number">2</span>,win<br><span class="hljs-number">613</span>,length <span class="hljs-number">1</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>:Flags[P.],seq <span class="hljs-number">2</span>:<span class="hljs-number">3</span>,ack <span class="hljs-number">2</span>,win<br><span class="hljs-number">512</span>,length <span class="hljs-number">1</span><br><span class="hljs-number">6.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[.],ack <span class="hljs-number">3</span>,win <span class="hljs-number">613</span>,length<br><span class="hljs-number">0</span><br><span class="hljs-number">7.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[P.],seq <span class="hljs-number">2</span>:<span class="hljs-number">4</span>,ack <span class="hljs-number">3</span>,win<br><span class="hljs-number">613</span>,length <span class="hljs-number">2</span><br><span class="hljs-number">8.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>:Flags[P.],seq <span class="hljs-number">3</span>:<span class="hljs-number">176</span>,ack <span class="hljs-number">4</span>,win<br><span class="hljs-number">512</span>,length <span class="hljs-number">173</span><br><span class="hljs-number">9.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[.],ack <span class="hljs-number">176</span>,win<br><span class="hljs-number">630</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">10.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>:Flags[P.],seq <span class="hljs-number">176</span>:<span class="hljs-number">228</span>,ack<br><span class="hljs-number">4</span>,win <span class="hljs-number">512</span>,length <span class="hljs-number">52</span><br><span class="hljs-number">11.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[.],ack <span class="hljs-number">228</span>,win<br><span class="hljs-number">630</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p><strong>TCP报文段1</strong>由客户端发送给服务器，它携带1个字节的应用程序数据，即字母“l”。</p>
<p><strong>TCP报文段2</strong>是服务器对<u>TCP报文段1</u>的确认，同时回显字母“l”。</p>
<p><strong>TCP报文段3</strong>是客户端对<u>TCP报文段2</u>的确认。</p>
<p><strong>第4~6个TCP报文段</strong>是针对字母“s”的上述过程。</p>
<p><strong>TCP报文段7</strong>传送的2字节数据分别是:客户端键入的回车符和流结束符(EOF，本例中是0x00)。</p>
<p><strong>TCP报文段8</strong>携带服务器返回的客户<u>查询的目录的内容</u>(ls命令的输出)，包括该目录下文件的文件名及其显示控制参数。</p>
<p><strong>TCP报文段9</strong>是客户端对TCP报文段8的确认。</p>
<p><strong>TCP报文段10</strong>携带的也是服务器返回给客户端的数据，包括一个回车符、一个换行符、客户端登录用户的PS1环境变量(第一级命令提示符)。</p>
<p><strong>TCP报文段11</strong>是客户端对TCP报文段10的确认。</p>
<p>在上述过程中，客户端针对服务器返回的数据所发送的确认报文段(TCP报文段6、9和11)都不携带任何应用程序数据(长度为0)， 而服务器每次<u>发送的确认报文段</u>(TCP报文段2、5、8和10)<u>都包含它需要发送的应用程序数据</u>。服务器的这种处理方式称为<strong>延迟确认</strong>，即<u>它不马上确认上次收到的数据，而是在一段延迟时间后查看本端是否有数据需要发送</u>，如果有，则和确认信息一起发出。因为服务器对客户请求处理得很快，所以它发送确认报文段的时候总是有数据一起发送。<strong>延迟确认</strong>可以<strong>减少发送TCP报文段的数</strong>量。而<u>由于用户的输入速度明显慢于客户端程序的处理速度，所以客户端的确认报文段总是不携带任何应用程序数据</u>。前文曾提到，在TCP连接的建立和断开过程中，也可能发生延迟确认。</p>
<p>上例是在本地回路运行的结果，在局域网中也能得到基本相同的结果，但在广域网就未必如此了。广域网上的交互数据流可能经受很大的延迟，并且，携带交互数据的微小TCP报文段数量一般很多(一个按键输入就导致一个TCP报文段)，这些因素都可能导致拥塞发生。解决该问题的一个简单有效的方法是使用Nagle算法。</p>
<p>Nagle算法要求<u>一个TCP连接的通信双方在任意时刻都最多只能发送一个未被确认的TCP报文段</u>，在该TCP报文段的确认到达之前不能发送其他TCP报文段。另一方面，发送方在等待确认的同时收集本端需要发送的微量数据，并在确认到来时以一个TCP报文段将它们全部发出。这样就极大地减少了网络上的微小TCP报文段的数量。该算法的另一个优点在于其自适应性:<u>确认到达得越快，数据也就发送得越 快</u>。</p>
<h2 id="37-tcp成块数据流"><a class="markdownIt-Anchor" href="#37-tcp成块数据流"></a> 3.7 TCP成块数据流</h2>
<p>下面考虑用FTP协议传输一个大文件。在ernest-laptop上启动一个vsftpd服务器程序(升级的、安全版的ftp服务器程序)，并执行ftp命令登录该服务器上，然后在ftp命令提示符后输入get命令，从服务器下载一个几百兆的大文件。同时用tcpdump抓取这一个过程中ftp客户端和vsftpd服务器交换的TCP报文段。具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -nt -i eth0 port <span class="hljs-number">20</span><span class="hljs-meta">#vsftpd服务器程序使用端口号20 $ftp 127.0.0.1</span><br>Connected to <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>.<br><span class="hljs-number">220</span>(vsFTPd <span class="hljs-number">2.3</span><span class="hljs-number">.0</span>) <span class="hljs-built_in">Name</span>(<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:ernest):<span class="hljs-built_in">ernest</span>(回车)#输入用户名并回车<br><span class="hljs-number">331</span> Please specify the password. Password:(回车)#输入密码并回车<br><span class="hljs-number">230</span> Login successful.<br>Remote system type is UNIX.<br>Using binary mode to transfer files. ftp&gt;<span class="hljs-function">get <span class="hljs-title">bigfile</span><span class="hljs-params">(回车)</span>#获取大文件bigfile</span><br></code></pre></td></tr></table></figure>
<p>代码清单3-5 是该过程的部分tcpdump输出。</p>
<p>代码清单3-5 TCP成块数据流</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205783041</span>:<span class="hljs-number">205799425</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205799425</span>:<span class="hljs-number">205815809</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205815809</span>:<span class="hljs-number">205832193</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[P.],seq <span class="hljs-number">205832193</span>:<span class="hljs-number">205848577</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205848577</span>:<span class="hljs-number">205864961</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">6.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205864961</span>:<span class="hljs-number">205881345</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">7.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205881345</span>:<span class="hljs-number">205897729</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">8.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[P.],seq <span class="hljs-number">205897729</span>:<span class="hljs-number">205914113</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">9.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205914113</span>:<span class="hljs-number">205930497</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">10.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205930497</span>:<span class="hljs-number">205946881</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">11.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205946881</span>:<span class="hljs-number">205963265</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">12.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[P.],seq <span class="hljs-number">205963265</span>:<span class="hljs-number">205979649</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">13.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205979649</span>:<span class="hljs-number">205996033</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">14.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205996033</span>:<span class="hljs-number">206012417</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">15.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">206012417</span>:<span class="hljs-number">206028801</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">16.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[P.],seq <span class="hljs-number">206028801</span>:<span class="hljs-number">206045185</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">17.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>:Flags[.],ack <span class="hljs-number">205815809</span>,win <span class="hljs-number">30084</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">18.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>:Flags[.],ack <span class="hljs-number">206045185</span>,win <span class="hljs-number">27317</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>注意，客户端发送的最后两个TCP报文段17和18，它们分别是对TCP报文段2和16的确认(从序号值和确认值来判断)。由此可见，当传输大量大块数据的时候，<strong>发送方</strong>会<strong>连续发送多个TCP报文段</strong>，<strong>接收方</strong>可以<strong>一次确认所有这些报文段</strong>。</p>
<p>那么发送方在收到上一次确认后，能<u>连续发送多少个TCP报文</u>段呢?这是由接收通告<u>窗口(还需要考虑拥塞窗口，见后文)的大小决定</u>的。</p>
<p><strong>TCP报文段17</strong>说明客户端还能接收30 084×64字节(本例中窗口扩大因子为6)，即1 925 376字节的数据。</p>
<p>而在<strong>TCP报文段18</strong>中，接收通告窗口大小为1 748 288字节，即客户端能接收的数据量变小了。这表明客户端的TCP接收缓冲区有更多的数据未被应用程序读取而停留在其中，这些数据都来自TCP报文段3 ~16中的一部分。</p>
<p>服务器收到TCP报文段18后，它至少(因为接收通告窗口可能扩大)还能连续发送的未被确认的报文段数量是1 748 288/16 384个，即106个(但一般不会连续发送这么多)。其中，16 384是成块数据的长度(见TCP报文段1~16的length值)，很显然它小于但接近MSS规定的16 396字节。</p>
<p>另外一个值得注意的地方是，服务器每发送4个TCP报文段就传送一个PSH标志(tcpdump输出标志P)给客户端，以通知客户端的应用程序尽快读取数据。不过这对服务器来说显然不是必需的，因为它知道客户端的TCP接收缓冲区中还有空闲空间(接收通告窗口大小不为0)。</p>
<p>下面我们修改系统的TCP接收缓冲区和TCP发送缓冲区的大小 (如何修改将在第16章介绍)，使之都为4096字节，然后重启vsftpd服务器，并再次执行上述操作。此次tcpdump的部分输出如代码清单3-6 所示。</p>
<p>代码清单3-6 修改TCP接收和发送缓冲区大小后的TCP成块数据流</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.45227</span>:Flags[.],seq <span class="hljs-number">5195777</span>:<span class="hljs-number">5197313</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">3072</span>,length <span class="hljs-number">1536</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.45227</span>:Flags[.],seq <span class="hljs-number">5197313</span>:<span class="hljs-number">5198849</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">3072</span>,length <span class="hljs-number">1536</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.45227</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>:Flags[.],ack <span class="hljs-number">5198849</span>,win <span class="hljs-number">3072</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.45227</span>:Flags[P.],seq <span class="hljs-number">5198849</span>:<span class="hljs-number">5200385</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">3072</span>,length <span class="hljs-number">1536</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.45227</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>:Flags[.],ack <span class="hljs-number">5200385</span>,win <span class="hljs-number">3072</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>从同步报文段(未在代码清单3-6中列出)得知在这次通信过程中，客户端和服务器的窗口扩大因子都为0，因而客户端和服务器每次通告的窗口大小都是3072字节(没超过4096字节，预料之中)。因为每个成块数据的长度为1536字节，所以服务器在收到上一个TCP报文段的确认之前最多还能再发送1个TCP报文段，这正是TCP报文段1~3描述的情形。</p>
<h2 id="38-带外数据"><a class="markdownIt-Anchor" href="#38-带外数据"></a> 3.8 带外数据</h2>
<p>有些传输层协议具有带外(Out Of Band，OOB)数据的概念，用于<u>迅速通告对方本端发生的重要事件</u>。因此，带外数据比普通数据 (也称为带内数据)有<strong>更高的优先级</strong>，它应该总是立即被发送，而不论发送缓冲区中是否有排队等待发送的普通数据。带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接中。实际应用中，带外数据的使用很少见，已知的仅有telnet、ftp等远程非活跃程序。</p>
<p>UDP没有实现带外数据传输，TCP也没有真正的带外数据。不过TCP利用其头部中的紧急指针标志和紧急指针两个字段，给应用程序提供了一种紧急方式。TCP的紧急方式利用传输普通数据的连接来传输紧急数据。这种紧急数据的含义和带外数据类似，因此后文也将<u>TCP紧急数据称为带外数据</u>。</p>
<h3 id="381tcp发送带外数据的过程"><a class="markdownIt-Anchor" href="#381tcp发送带外数据的过程"></a> 3.8.1TCP发送带外数据的过程</h3>
<p>假设一个进程已经往某个TCP连接的发送缓冲区中写入了N字节的普通数据，并等待其发送。在数据被发送前，该进程又向这个连接写入了3字节的带外数据“abc”。此时，待发送的TCP报文段的头部将被设置URG标志，并且紧急指针被设置为指向最后一个带外数据的下一字节(进一步减去当前TCP报文段的序号值得到其头部中的紧急偏移值)，如图3-10所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205131634108.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-13 下午4.34.33" /></p>
<p>由图3-10可见，发送端一次发送的多字节的带外数据中只有最后一字节被当作带外数据(字母c)，而其他数据(字母a和b)被当成了普通数据。如果TCP模块以多个TCP报文段来发送图3-10所示TCP发送缓冲区中的内容，则每个TCP报文段都将设置URG标志，并且它们的紧 急指针指向同一个位置(数据流中带外数据的下一个位置)，但<u>只有一个TCP报文段真正携带带外数据</u>。</p>
<p>现在考虑TCP接收带外数据的过程。TCP接收端只有在接收到紧急指针标志时才检查紧急指针，然后根据紧急指针所指的位置确定带外数据的位置，并将它读入一个特殊的缓存中。这个缓存只有1字节，称为<u>带外缓存</u>。<strong>如果上层应用程序没有及时将带外数据从带外缓存中读 出，则后续的带外数据(如果有的话)将覆盖它</strong>。</p>
<p>前面讨论的带外数据的接收过程是TCP模块接收带外数据的默认方式。如果我们给TCP连接设置了SO_OOBINLINE选项，则带外数据将 和普通数据一样被TCP模块存放在TCP接收缓冲区中。此时应用程序需要像读取普通数据一样来读取带外数据。那么这种情况下如何区分带外数据和普通数据呢?显然，紧急指针可以用来指出带外数据的位置，socket编程接口也提供了系统调用来识别带外数据(见第5章)。</p>
<p>至此，我们讨论了TCP模块发送和接收带外数据的过程。至于内核如何通知应用程序带外数据的到来，以及应用程序如何发送和接收带外数据，将在后续章节讨论。</p>
<h2 id="39-tcp超时重传"><a class="markdownIt-Anchor" href="#39-tcp超时重传"></a> 3.9 TCP超时重传</h2>
<p>在3.6节~3.8节中，我们讲述了TCP在正常网络情况下的数据流。 从本节开始，我们讨论异常网络状况下(开始出现超时或丢包)，TCP如何控制数据传输以保证其承诺的可靠服务。</p>
<p>TCP服务必须能够重传超时时间内未收到确认的TCP报文段。为此，TCP模块为每个TCP报文段都维护一个重传定时器，该定时器在TCP报文段第一次被发送时启动。如果超时时间内未收到接收方的应答，TCP模块将重传TCP报文段并重置定时器。至于下次重传的超时时间如何选择，以及最多执行多少次重传，就是TCP的重传策略。我们通过实例来研究Linux下TCP的超时重传策略。</p>
<p>在ernest-laptop上启动iperf服务器程序，然后从Kongming20上执行telnet命令登录该服务器程序。接下来，从telnet客户端发送一些数据 (此处是“1234”)给服务器，然后断开服务器的网线并再次从客户端发送一些数据给服务器(此处是“12”)。同时，用tcpdump抓取这一过程中客户端和服务器交换的TCP报文段。具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump-n-i eth0 port <span class="hljs-number">5001</span> $iperf-s#在ernest-laptop上执行<br>$telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-number">5001</span>#在Kongming20上执行 Trying <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>...<br>Connected to <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.<br>Escape character is<span class="hljs-number">&#x27;</span>^]<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">1234#发送完之后断开服务器网线</span><br><span class="hljs-string">12</span><br><span class="hljs-string">Connection closed by foreign host</span><br></code></pre></td></tr></table></figure>
<p>iperf是一个测量网络状况的工具，-s选项表示将其作为服务器运行。iperf默认监听5001端口，并丢弃该端口上接收到的所有数据，相当于一个discard服务器。上述操作过程的部分tcpdump输出如代码清单3-7所示。</p>
<p>代码清单3-7 TCP超时重传</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">57.580341</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[S],seq <span class="hljs-number">2381272950</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">2.18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">57.580477</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>:Flags[S.],seq <span class="hljs-number">466032301</span>,ack <span class="hljs-number">2381272951</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">3.18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">57.580498</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[.],ack <span class="hljs-number">1</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">59.866019</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">7</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">6</span><br><span class="hljs-number">5.18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">59.866165</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>:Flags[.],ack <span class="hljs-number">7</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">6.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">25.028933</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">7</span>:<span class="hljs-number">11</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">4</span><br><span class="hljs-number">7.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">25.230034</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">7</span>:<span class="hljs-number">11</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">4</span><br><span class="hljs-number">8.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">25.639407</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">7</span>:<span class="hljs-number">11</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">4</span><br><span class="hljs-number">9.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">26.455942</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">7</span>:<span class="hljs-number">11</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">4</span><br><span class="hljs-number">10.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">28.092425</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">7</span>:<span class="hljs-number">11</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">4</span><br><span class="hljs-number">11.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">31.362473</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">7</span>:<span class="hljs-number">11</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">4</span><br><span class="hljs-number">12.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">33.100888</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">13.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">34.098156</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">14.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">35.100887</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">15.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">37.902034</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">16.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">38.903126</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">17.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">39.901421</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">18.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">44.440049</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">19.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">45.438840</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">20.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">46.439932</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">21.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">50.976710</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">22.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">51.974134</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">23.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">52.973939</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br></code></pre></td></tr></table></figure>
<p><strong>TCP报文段1~3</strong>是<strong>三次握手建立连接</strong>的过程。</p>
<p><strong>TCP报文段4~5</strong>是客户端发送数据“1234”(应用程序数据长度为6，包括回车、换行两个字符，后同)及服务器确认的过程。</p>
<p><strong>TCP报文段6</strong>是客户端第一次发送数据“12”的过程。因为服务器的网线被断开，所以客户端无法收到TCP报文段6的确认报文段。此后，客户端对TCP报文段6执行了5次重传，它们是TCP报文段7~11，这可以从每个TCP报文段的序号得知。</p>
<p>此后，<strong>数据包12~23</strong>都是ARP模块的输出内容，即Kongming20查询ernest-laptop的MAC地址。</p>
<p>我们保留了tcpdump输出的时间戳，以便推理TCP的超时重传策略。观察TCP报文段6~11被发送的时间间隔，它们分别为0.2 s、0.4 s、0.8 s、1.6 s和3.2 s。由此可见，TCP一共执行5次重传，每次重传超时时间都增加一倍(因此，和TCP超时重连的策略相似)。</p>
<p>在5次重传均失败的情况下，底层的IP和ARP开始接管，直到telnet客户端放弃连接为止。</p>
<p>Linux有两个重要的内核参数与TCP超时重传相关:/proc/sys/net/ipv4/tcp_retries1和/proc/sys/net/ipv4/tcp_retries2。前者指定在底层IP接管之前TCP最少执行的重传次数，默认值是3。后者指定连接放弃前TCP最多可以执行的重传次数，默认值是15(一般对应 13~30 min)。在我们的实例中，TCP超时重传发生了5次，连接坚持的时间是15 min(可以用date命令来测量)。</p>
<p>虽然超时会导致TCP报文段重传，但TCP报文段的重传可以发生在超时之前，即快速重传，这将在下一节中讨论。</p>
<h2 id="310-拥塞控制"><a class="markdownIt-Anchor" href="#310-拥塞控制"></a> 3.10 拥塞控制</h2>
<h3 id="3101-拥塞控制概述"><a class="markdownIt-Anchor" href="#3101-拥塞控制概述"></a> 3.10.1 拥塞控制概述</h3>
<p>TCP模块还有一个重要的任务，就是<u>提高网络利用率，降低丢包率</u>，并<u>保证网络资源对每条数据流的公平性</u>。这就是所谓的<strong>拥塞控制</strong>。</p>
<p>TCP拥塞控制的标准文档是RFC 5681，其中详细介绍了拥塞控制的四个部分:<strong>慢启动(slow start)</strong>、<strong>拥塞避免(congestion avoidance)</strong>、<strong>快速重传(fast retransmit)<strong>和</strong>快速恢复(fast recovery)</strong>。拥塞控制算法在Linux下有多种实现，比如<strong>reno算法</strong>、 <strong>vegas算法</strong>和<strong>cubic算法</strong>等。它们或者部分或者全部实现了上述四个部分。/proc/sys/net/ipv4/tcp_congestion_control文件指示机器当前所使用的拥塞控制算法。</p>
<p>拥塞控制的最终受控变量是发送端向网络一次连续写入(收到其中第一个数据的确认之前)的数据量，我们称为SWND(Send Window，发送窗口[1])。不过，发送端最终以TCP报文段来发送数据，所以SWND限定了发送端能连续发送的TCP报文段数量。这些**TCP报文段的最大长度(仅指数据部分)**称为SMSS(Sender Maximum Segment Size，发送者最大段大小)，其值一般等于MSS。</p>
<p>发送端需要合理地选择SWND的大小。如果<strong>SWND太小</strong>，会引起明显的<strong>网络延迟</strong>;反之，如果<strong>SWND太大</strong>，则容易导致<strong>网络拥塞</strong>。前文提到，接收方可通过其接收通告窗口(RWND)来控制发送端的SWND。但这显然不够，所以发送端引入了一个称为拥塞窗口(Congestion Window，CWND)的状态变量。实际的SWND值是RWND和CWND中的较小者。图3-11显示了拥塞控制的输入和输出(可见，它是一个闭环反馈控制)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142122368.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-14 下午9.22.16" /></p>
<h3 id="3102-慢启动和拥塞避免"><a class="markdownIt-Anchor" href="#3102-慢启动和拥塞避免"></a> 3.10.2 慢启动和拥塞避免</h3>
<p>TCP连接建立好之后，CWND将被设置成初始值IW(Initial Window)，其大小为2~4个SMSS。但新的Linux内核提高了该初始值，以减小传输滞后。此时发送端最多能发送IW字节的数据。此后发送端每收到接收端的一个确认，其CWND就按照式(3-1)增加:</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142127783.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-14 下午9.27.56" /></p>
<p>其中N是此次确认中包含的之前未被确认的字节数。这样一来， CWND将按照指数形式扩大，这就是所谓的慢启动。慢启动算法的理由是，TCP模块刚开始发送数据时并不知道网络的实际情况，需要用一种<u>试探的方式</u>平滑地增加CWND的大小。</p>
<p>但是如果不施加其他手段，慢启动必然使得CWND很快膨胀(可见慢启动其实不慢)并最终导致网络拥塞。因此TCP拥塞控制中定义了另一个重要的状态变量:慢启动门限(slow start threshold size， ssthresh)。当CWND的大小超过该值时，TCP拥塞控制将进入拥塞避免阶段。</p>
<p>拥塞避免算法使得CWND按照线性方式增加，从而减缓其扩大。 RFC 5681中提到了如下两种实现方式:</p>
<p>1、每个RTT时间内按照式(3-1)计算新的CWND，而不论该RTT时间内发送端收到多少个确认。</p>
<p>2、每收到一个对新数据的确认报文段，就按照式(3-2)来更新CWND。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142147580.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-14 下午9.47.31" /></p>
<p>图3-12粗略地描述了慢启动和拥塞避免发生的时机和区别。该图中，我们以SMSS为单位来显示CWND(实际上它是以字节为单位的)，以次数为单位来显示RTT，这只是为了方便讨论问题。此外，我们假设当前的ssthresh是16SMSS大小(当然，实际的ssthresh显然远不止这么大)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142150680.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-14 下午9.50.06" /></p>
<p>以上我们讨论了发送端在未检测到拥塞时所采用的积极避免拥塞的方法。接下来介绍拥塞发生时(可能发生在慢启动阶段或者拥塞避免阶段)拥塞控制的行为。不过我们先要搞清楚发送端是如何判断拥塞已经发生的。发送端<strong>判断拥塞发生</strong>的依据有如下两个:</p>
<p>1、传输超时，或者说TCP重传定时器溢出。</p>
<p>2、接收到重复的确认报文段。</p>
<p>拥塞控制对这两种情况有不同的处理方式。对第一种情况仍然使用慢启动和拥塞避免。对第二种情况则使用快速重传和快速恢复(如果是真的发生拥塞的话)，这种情况将在后面讨论。注意，第二种情况如果发生在重传定时器溢出之后，则也被拥塞控制当成第一种情况来对待。</p>
<p>如果发送端检测到拥塞发生是由于传输超时，即上述第一种情况，那么它将执行重传并做如下调整:</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142153207.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-14 下午9.53.26" /></p>
<p>其中FlightSize是<strong>已经发送但未收到确认的字节数</strong>。这样调整之后，CWMD将小于SMSS，那么也必然小于新的慢启动门限值ssthresh(因为根据式(3-3)，它一定不小于SMSS的2倍)，故而拥塞控制再次进入慢启动阶段。</p>
<h3 id="3103-快速重传和快速恢复"><a class="markdownIt-Anchor" href="#3103-快速重传和快速恢复"></a> 3.10.3 快速重传和快速恢复</h3>
<p>在很多情况下，发送端都可能接收到重复的确认报文段，比如TCP报文段丢失，或者接收端收到乱序TCP报文段并重排之等。拥塞控制算 法需要判断当收到重复的确认报文段时，网络是否真的发生了拥塞，或者说TCP报文段是否真的丢失了。具体做法是:发送端如果连续收到 3个重复的确认报文段，就认为是拥塞发生了。然后它启用快速重传和快速恢复算法来处理拥塞，过程如下:</p>
<p>1)当收到第3个重复的确认报文段时，按照式(3-3)计算ssthresh，然后立即重传丢失的报文段，并按照式(3-4)设置CWND。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142156591.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-14 下午9.56.04" /></p>
<p>2)每次收到1个重复的确认时，设置CWND=CWND+SMSS。此时发送端可以发送新的TCP报文段(如果新的CWND允许的话)。【扩大窗口，快速重传】</p>
<p>3)当收到新数据的确认时，设置CWND=ssthresh(ssthresh是新的慢启动门限值，由第一步计算得到)。【如果能收到说明没问题，重新确定阈值，快速恢复】</p>
<p>快速重传和快速恢复完成之后，拥塞控制将<u>恢复到拥塞避免阶段</u>，这一点由第3步操作可得知。</p>
<h1 id="第4章-tcpip通信案例访问internet上的web服务器"><a class="markdownIt-Anchor" href="#第4章-tcpip通信案例访问internet上的web服务器"></a> 第4章 TCP/IP通信案例:访问Internet上的Web服务器</h1>
<p>在第1章中，我们简单地讨论了TCP/IP协议族各层的功能和部分协议，以及它们之间是如何协作完成网络通信的。在第2章和第3章中， 我们详细地探讨了IP协议和TCP协议。本章，我们分析一个完整的 TCP/IP通信的实例——访问Internet上的Web服务器，通过该实例把这些知识串联起来。选择使用Web服务器展开讨论的理由是:</p>
<p>1、Internet上的Web服务器随处都可以获得，我们通过浏览器访问任何一个网站都是在与Web服务器通信。</p>
<p>2、本书后续章节将编写简单的Web服务器程序，因此先学习其工作原理是有好处的。</p>
<p>Web客户端和服务器之间使用<strong>HTTP协议通信</strong>。HTTP协议的内容相当广泛，涵盖了网络应用层协议需要考虑的诸多方面。因此，学习 HTTP协议对应用层协议设计将大有裨益。</p>
<h2 id="41-实例总图"><a class="markdownIt-Anchor" href="#41-实例总图"></a> 4.1 实例总图</h2>
<p>我们按照如下方法来部署通信实例:在Kongming20上运行wget客户端程序，在ernest-laptop上运行squid代理服务器程序。客户端通过代 理服务器的中转，获取Internet上的主机www.baidu.com的首页文档 index.html，如图4-1所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142201066.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-14 下午10.01.32" /></p>
<p>由图4-1可见，wget客户端程序和代理服务器之间，以及代理服务器与Web服务器之间都是使用HTTP协议通信的。HTTP协议是一种应用 层协议，它默认使用的传输层协议是TCP协议。我们将在后文中简单讨论HTTP协议。</p>
<p>为了将ernest-laptop设置为Kongming20的<strong>HTTP代理服务器</strong>，我们需要在Kongming20上设置环境变量http_proxy:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">$<span class="hljs-keyword">export</span> http_proxy=<span class="hljs-string">&quot;ernest-laptop:3128&quot;</span>#在Kongming20上执行<br></code></pre></td></tr></table></figure>
<p>其中，3128是squid服务器默认使用的端口号(可以通过lsof命令查看服务器程序监听的端口号，见第17章)。设置好环境变量之后， Kongming20访问任何Internet上的Web服务器时，其HTTP请求都将首先发送至ernest-laptop的3128端口。</p>
<p>squid代理服务器接收到wget客户端的HTTP请求之后，将简单地修改这个请求，然后把它发送给最终的目标Web服务器。既然代理服务器 访问的是Internet上的机器，可以预见它发送的IP数据报都将经过路由器的中转，这一点也体现在图4-1中了。</p>
<h2 id="42-部署代理服务器"><a class="markdownIt-Anchor" href="#42-部署代理服务器"></a> 4.2 部署代理服务器</h2>
<p>由于通信实例中使用了HTTP代理服务器(squid程序)，所以先简单介绍一下HTTP代理服务器的工作原理，以及如何部署squid代理服务 器。</p>
<h3 id="421-http代理服务器的工作原理"><a class="markdownIt-Anchor" href="#421-http代理服务器的工作原理"></a> 4.2.1 HTTP代理服务器的工作原理</h3>
<p>在HTTP通信链上，客户端和目标服务器之间通常存在某些中转代理服务器，它们提供对目标资源的中转访问。一个HTTP请求可能被多 个代理服务器转发，<u>后面的服务器称为前面服务器的上游服务器</u>。代理服务器按照其使用方式和作用，分为<strong>正向代理服务器</strong>、<strong>反向代理服务器</strong>和<strong>透明代理服务器</strong>。</p>
<h4 id="正向代理"><a class="markdownIt-Anchor" href="#正向代理"></a> 正向代理</h4>
<p>要求客户端自己设置代理服务器的地址。<u>客户的每次请求都将直接发送到该代理服务器，并由代理服务器来请求目标资源</u>。 比如处于防火墙内的局域网机器要访问Internet，或者要访问一些被屏蔽掉的国外网站，就需要使用正向代理服务器。</p>
<h4 id="反向代理"><a class="markdownIt-Anchor" href="#反向代理"></a> 反向代理</h4>
<p>则被设置在服务器端，因而客户端无须进行任何设置。 反向代理是<u>指用代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从内部服务器上得到的结果返回给客户端</u>。</p>
<p>这种情况下，代理服务器对外就表现为一个真实的服务器。各大网站通常分区域设置了多个代理服务器，所以在不同的地方ping同一个域名可能得到不同的IP地址，因为这些IP地址实际上是代理服务器的IP地址。图4-2显示了正向代理服务器和反向代理服务器在HTTP通信链上的逻辑位置。</p>
<p>图4-2中，正向代理服务器和客户端主机处于同一个逻辑网络中。 该逻辑网络可以是一个本地LAN，也可以是一个更大的网络。反向代理服务器和真正的Web服务器也位于同一个逻辑网络中，这通常由提供网站的公司来配置和管理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205161643321.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-16 下午4.43.52" /></p>
<p>透明代理只能设置在网关上。用户访问Internet的数据报必然都经过网关，如果在网关上设置代理，则该代理对用户来说显然是透明的。透明代理可以看作正向代理的一种特殊情况。</p>
<p>代理服务器通常还提供缓存目标资源的功能(可选)，这样用户下次访问同一资源时速度将很快。优秀的开源软件squid、varnish都是提供了缓存能力的代理服务器软件，其中squid支持所有代理方式，而varnish仅能用作反向代理。</p>
<h3 id="422-部署squid代理服务器"><a class="markdownIt-Anchor" href="#422-部署squid代理服务器"></a> 4.2.2 部署squid代理服务器</h3>
<p>现在我们在ernest-laptop上部署squid代理服务器。这个过程很简单，只需修改squid服务器的配置文件/etc/squid3/squid.conf，在其中加 入如下两行代码(需要root权限，且应该加在合适的位置，详情可参考其他类似条目的设置):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">acl localnet src <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span><br> http_access allow localnet<br></code></pre></td></tr></table></figure>
<p>这两行代码的含义是:允许网络192.168.1.0上的所有机器通过该代理服务器来访问Web服务器。其中，“192.168.1.0/24”是CIDR(Classless Inter-Domain Routing，无类域间路由)风格的IP地址表示方法:“/”前的部分指定网络的IP地址，“/”后的部分则指定子网掩码中“1”的位数。 对IPv4而言，上述表示等价于“192.168.1.0/255.255.255.0”(IP地址/子网掩码)。</p>
<p>我们通过上面的两行代码简单地配置了squid的访问控制。但实际应用中，squid提供更多、更安全的配置，比如用户验证等。</p>
<p>接下来在ernest-laptop上执行如下命令，以重启squid服务器:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo service squid3 restart<br>*Restarting Squid HTTP Proxy <span class="hljs-number">3.0</span> squid3[OK]<br></code></pre></td></tr></table></figure>
<p>service是一个脚本程序(/usr/sbin/service)，它为/etc/init.d/目录下的众多服务器程序(比如httpd、vsftpd、sshd和mysqld等)的启动 (start)、停止(stop)和重启(restart)等动作提供了一个统一的管理。现在，Linux程序员已经越来越偏向于使用service脚本来管理服务器程序了。</p>
<h2 id="43-使用tcpdump抓取传输数据包"><a class="markdownIt-Anchor" href="#43-使用tcpdump抓取传输数据包"></a> 4.3 使用tcpdump抓取传输数据包</h2>
<p>在执行wget命令前，我们首先应删除ernest-laptop的ARP高速缓存中路由器对应的项，以便观察TCP/IP通信过程中ARP协议何时起作 用。然后，使用tcpdump命令抓取整个通信过程中传输的数据包。完整的操作过程如代码清单4-1所示。</p>
<p>代码清单4-1 使用wget抓取网页</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo arp-d <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br>$sudo tcpdump -s <span class="hljs-number">2000</span> -i eth0 -ntX <span class="hljs-string">&#x27;(src 192.168.1.108)or(dst 192.168.1.108)or(arp)&#x27;</span><br>$wget --header=<span class="hljs-string">&quot;Connection:close&quot;</span> http:<span class="hljs-comment">//www.baidu.com/index.html</span><br>-<span class="hljs-number">-2012</span><span class="hljs-number">-07</span><span class="hljs-number">-03</span> <span class="hljs-number">00</span>:<span class="hljs-number">51</span>:<span class="hljs-number">12</span> --http:<span class="hljs-comment">//www.baidu.com/index.html</span><br>Resolving ernest-laptop..<span class="hljs-number">.192</span><span class="hljs-number">.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><br>Connecting to ernest-laptop|<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>|:<span class="hljs-number">3128.</span>..connected.<br>Proxy request sent,awaiting response..<span class="hljs-number">.200</span> OK<br>Length:<span class="hljs-number">8024</span>(<span class="hljs-number">7.8</span>K)[text/html]<br>Saving to:“index.html” <br><span class="hljs-number">100</span>%[=======================&gt;]<span class="hljs-number">8</span>,<span class="hljs-number">024</span>--.-K/s in <span class="hljs-number">0.001</span>s <span class="hljs-number">2012</span><span class="hljs-number">-07</span><span class="hljs-number">-03</span> <span class="hljs-number">00</span>:<span class="hljs-number">51</span>:<span class="hljs-number">12</span>(<span class="hljs-number">8.76</span> MB/s)-“index.html”              saved[<span class="hljs-number">8024</span>/<span class="hljs-number">8024</span>]<br></code></pre></td></tr></table></figure>
<p>wget命令的输出显示，HTTP请求确实是先被送至代理服务器的3128端口，并且代理服务器正确地返回了文件index.html的内容。</p>
<p>这次通信的完整tcpdump输出内容如代码清单4-2所示。</p>
<p>代码清单4-2 访问Internet上的Web服务器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[S],seq <span class="hljs-number">227192137</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[S.],seq <span class="hljs-number">1084588508</span>,ack <span class="hljs-number">227192138</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">1</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">137</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">136</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[.],ack <span class="hljs-number">137</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">6.</span>ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>,length <span class="hljs-number">28</span> <br><span class="hljs-number">7.</span>ARP,Reply <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> is-at <span class="hljs-number">14</span>:e6:e4:<span class="hljs-number">93</span>:<span class="hljs-number">5b</span>:<span class="hljs-number">78</span>,length <span class="hljs-number">46</span> <br><span class="hljs-number">8.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.46149</span>&gt;<span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><span class="hljs-number">.53</span>:<span class="hljs-number">59410</span>+A? www.baidu.com.(<span class="hljs-number">31</span>)<br><span class="hljs-number">9.</span>IP <span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><span class="hljs-number">.53</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.46149</span>:<span class="hljs-number">59410</span> <span class="hljs-number">3</span>/<span class="hljs-number">4</span>/<span class="hljs-number">0</span> CNAME www.a.shifen.com.,A <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span>,A <span class="hljs-number">119.75</span><span class="hljs-number">.217</span><span class="hljs-number">.56</span>(<span class="hljs-number">162</span>) <br><span class="hljs-number">10.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[S],seq <span class="hljs-number">1084002207</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">11.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[S.],seq <span class="hljs-number">4261071806</span>,ack <span class="hljs-number">1084002208</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">12.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">1</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">13.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">226</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">225</span><br><span class="hljs-number">14.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[.],ack <span class="hljs-number">226</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">15.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">380</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">379</span><br><span class="hljs-number">16.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">380</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">17.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[.],seq <span class="hljs-number">380</span>:<span class="hljs-number">1820</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">1440</span><br><span class="hljs-number">18.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">1820</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">19.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[.],seq <span class="hljs-number">1820</span>:<span class="hljs-number">3260</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">1440</span><br><span class="hljs-number">20.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">3260</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">21.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[P.],seq <span class="hljs-number">3260</span>:<span class="hljs-number">4700</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">1440</span><br><span class="hljs-number">22.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">4700</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">23.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[.],seq <span class="hljs-number">1</span>:<span class="hljs-number">1449</span>,ack <span class="hljs-number">137</span>,length <span class="hljs-number">1448</span><br><span class="hljs-number">24.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[P.],seq <span class="hljs-number">1449</span>:<span class="hljs-number">2166</span>,ack <span class="hljs-number">137</span>,length <span class="hljs-number">717</span><br><span class="hljs-number">25.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[.],seq <span class="hljs-number">2166</span>:<span class="hljs-number">3614</span>,ack <span class="hljs-number">137</span>,length <span class="hljs-number">1448</span><br><span class="hljs-number">26.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[.],seq <span class="hljs-number">4700</span>:<span class="hljs-number">6140</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">1440</span><br><span class="hljs-number">27.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">6140</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">28.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[.],seq <span class="hljs-number">6140</span>:<span class="hljs-number">7580</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">1440</span><br><span class="hljs-number">29.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">7580</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">30.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[FP.],seq <span class="hljs-number">7580</span>:<span class="hljs-number">8404</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">824</span><br><span class="hljs-number">31.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[F.],seq <span class="hljs-number">226</span>,ack <span class="hljs-number">8405</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">32.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">1449</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">33.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[.],seq <span class="hljs-number">3614</span>:<span class="hljs-number">6510</span>,ack <span class="hljs-number">137</span>,length <span class="hljs-number">2896</span><br><span class="hljs-number">34.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">2166</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">35.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[.],seq <span class="hljs-number">6510</span>:<span class="hljs-number">7958</span>,ack <span class="hljs-number">137</span>,length <span class="hljs-number">1448</span><br><span class="hljs-number">36.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[FP.],seq <span class="hljs-number">7958</span>:<span class="hljs-number">8523</span>,ack <span class="hljs-number">137</span>,length <span class="hljs-number">565</span><br><span class="hljs-number">37.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">3614</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">38.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">5062</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">39.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">6510</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">40.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">7958</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">41.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[.],ack <span class="hljs-number">227</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">42.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[F.],seq <span class="hljs-number">137</span>,ack <span class="hljs-number">8524</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">43.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[.],ack <span class="hljs-number">138</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>我们一共抓取了43个数据包。与前面章节的讨论不同，这些数据包不是一对客户端和服务器之间交换的内容，而是两对客户端和服务器(wget客户端和代理服务器，以及代理服务器和目标Web服务器) 之间通信的全部内容。所以，tcpdump的输出把这两组通信的内容交织在一起。但为了讨论问题的方便，我们将这43个数据包按照其逻辑关系分为如下4个部分:</p>
<p>1、代理服务器访问DNS服务器以查询域名www.baidu.com对应的IP地址，包括数据包8、9。</p>
<p>2、代理服务器查询路由器MAC地址的ARP请求和应答，包括数据包6、7。</p>
<p>3、wget客户端(192.168.1.109)和代理服务器(192.168.1.108)之间的HTTP通信，包括数据包1<sub>5、23</sub>25、32~40、42和43。</p>
<p>4、代理服务器和Web服务器(119.75.218.77)之间的HTTP通信， 包括数据包10<sub>22、26</sub>31和41。</p>
<p>下面我们将依次讨论前3个部分，第4个部分与第3个部分的内容基本相似，不再赘述。</p>
<h2 id="44-访问dns服务器"><a class="markdownIt-Anchor" href="#44-访问dns服务器"></a> 4.4 访问DNS服务器</h2>
<p>数据包8、9表示代理服务器ernest-laptop向DNS服务器(219.239.26.42，首选DNS服务器的IP地址，见1.6.2节)查询域名www.baidu.com对应的IP地址，并得到了回复。该回复包括一个主机别名(<a target="_blank" rel="noopener" href="http://www.a.shifen.com">www.a.shifen.com</a>)和两个IP地址(119.75.218.77和 119.75.217.56)。代理服务器执行DNS查询的完整过程如图4-3所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205161712755.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-16 下午5.12.04" /></p>
<p>squid程序通过读取/etc/resolv.conf文件获得DNS服务器的IP地址 (见1.6.2节)，然后将控制权传递给内核中的UDP模块。</p>
<p>UDP模块将DNS查询报文封装成UDP数据报，同时把源端口号和目标端口号加入UDP数据报头部，然后UDP模块调用IP服务。IP模块则将UDP数据报封装成IP数据报，并把源端IP地址(192.168.1.108)和DNS服务器的IP地址加入IP数据报头部。</p>
<p>接下来，IP模块查询路由表以决定如何发送该IP数据报。根据路由策略，目标IP地址(219.239.26.42)仅能匹配路由表中的默认路由项，因此该IP数据报先被发送至路由器(IP地址为192.168.1.1)，然后通过路由器来转发。</p>
<p>因为ernest-laptop的ARP缓存中没有与路由器对应的缓存项(我们手动将其删除了)，所以ernest-laptop需要发起一个ARP广播以查询路由器的IP地址，而这正是数据包6描述的内容。</p>
<p>路由器则通过ARP应答告诉ernest-laptop自己的MAC地址是14:e6:e4:93:5b:78，如数据包7所示。</p>
<p>最终，以太网驱动程序将IP数据报封装成以太网帧发送给路由器。</p>
<p>此后，代理服务器再次发送数据到Internet时将不再需要ARP查询，因为ernest-laptop的ARP高速缓存中已经记录了路由器的IP地址和MAC地址的映射关系。</p>
<p>需要指出的是，虽然IP数据报是先发送到路由器，再由它转发给目标主机，但是其头部的目标IP地址却是最终的目标主机(DNS服务器)的IP地址，而不是中转路由器的IP地址(192.168.1.1)。这说明， <u>IP头部的源端IP地址和目的端IP地址在转发过程中是始终不变</u>的(一种例外是源路由选择)。但<u>帧头部的源端物理地址和目的端物理地址在转发过程中则是一直在变化</u>的。</p>
<h2 id="45-本地名称查询"><a class="markdownIt-Anchor" href="#45-本地名称查询"></a> 4.5 本地名称查询</h2>
<p>一般来说，通过域名来访问Internet上的某台主机时，需要使用DNS服务来获取该主机的IP地址。但如果我们通过主机名来访问本地局域网上的机器，则可通过本地的静态文件来获得该机器的IP地址。</p>
<p>Linux将目标主机名及其对应的IP地址存储在/etc/hosts配置文件中。当需要查询某个主机名对应的IP地址时，程序将首先检查这个文件。Kongming20上/etc/hosts文件的内容如下(笔者手动修改过):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> localhost<br><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> Kongming20<br><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> ernest-laptop<br></code></pre></td></tr></table></figure>
<p>其中第一项指出本地回路地址127.0.0.1的名称是localhost，第二项和第三项则分别描述了Kongming20和ernest-laptop的IP地址及对应的主机名。</p>
<p>代码清单4-1中，wget命令输出“Resolving ernest- laptop…192.168.1.108”，即它成功地解析了主机名ernest-laptop对应的IP地址，原因如下:当wget访问某个Web服务器时，它先读取环境变量http_proxy。如果该环境变量被设置，并且我们没有阻止wget使用代理服务，则wget将通过http_proxy指定的代理服务器来访问Web服务。</p>
<p>但http_proxy环境变量中包含主机名ernest-laptop，因此wget将首先读取/etc/hosts配置文件，试图通过它来解析主机名ernest-laptop对应的IP地址。其结果正如wget的输出所示，解析成功。</p>
<p>如果程序在/etc/hosts文件中<strong>未找到</strong>目标机器名对应的IP地址，它将求助于DNS服务。</p>
<p>用户可以通过修改/etc/host.conf文件来自定义系统解析主机名的方法和顺序(一般是先访问本地文件/etc/hosts，再访问DNS服务)， Kongming20上的该文件内容如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">order hosts,bind<br>multi on<br></code></pre></td></tr></table></figure>
<p>其中第一行表示优先使用/etc/hosts文件来解析主机名(hosts)， 失败后再使用DNS服务(bind)。第二行表示如果/etc/hosts文件中一个主机名对应多个IP地址，那么解析的结果就包含多个IP地址。/etc/host.conf文件通常仅包含这两行，但它支持更多选项，具体使用请参考其man手册。</p>
<p>标准文档RFC 1123指出，网络上的主机都应该实现一个简单的本地名称查询服务。</p>
<h2 id="46-http通信"><a class="markdownIt-Anchor" href="#46-http通信"></a> 4.6 HTTP通信</h2>
<p>为了方便讨论，我们将wget客户端和代理服务器之间的通信过程画成图4-4所示的TCP时序图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205161827241.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-16 下午6.26.57" /></p>
<p>首先应该注意的是，TCP连接从建立到关闭的过程中，客户端仅给服务器发送了一个HTTP请求(即TCP报文段4)，该请求的长度为136 字节(见代码清单4-2中TCP报文段4的length值)。代理服务器则用6个TCP报文段(23、24、25、33、35和36)给客户端返回了总长度为8522 字节(这可以从对方的最后一个确认报文段42的确认值计算得到，考虑同步报文段和结束报文段各占用一个序号)的HTTP应答。客户端使 用了7个TCP报文段(32、34、37、38、39、40和42)来确认这8522字节的HTTP应答数据。</p>
<p>下面我们简单分析一下这136字节的HTTP请求和8522字节的HTTP应答的部分主要内容(开启tcpdump的-X选项来查看)。</p>
<h3 id="461-http请求"><a class="markdownIt-Anchor" href="#461-http请求"></a> 4.6.1 HTTP请求</h3>
<p>HTTP请求的部分内容如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">GET http:<span class="hljs-comment">//www.baidu.com/index.html HTTP/1.0</span><br>User-Agent:Wget/<span class="hljs-number">1.12</span>(linux-gnu)<br>Host:www.baidu.com<br>Connection:close<br></code></pre></td></tr></table></figure>
<p>第1行是请求行。其中“GET”是请求方法，表示客户端以只读的方式来申请资源。常见的HTTP请求方法有9种，如表4-1所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205162120269.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-16 下午9.20.40" /></p>
<p>这些方法中，HEAD、GET、OPTIONS和TRACE被视为安全的方法，因为它们只是从服务器获得资源或信息，而不对服务器进行任何修改。而POST、PUT、DELETE和PATCH则影响服务器上的资源。</p>
<p>另一方面，GET、HEAD、OPTIONS、TRACE、PUT和DELETE等请求方法被认为是等幂的(idempotent)，即<u>多次连续的、重复的请求和只发送一次该请求具有完全相同</u>的效果。而<strong>POST方法则不同</strong>，<u>连续多次发送同样一个请求可能进一步影响服务器上</u>的资源。</p>
<p>值得一提的是，Linux上提供了几个命令:HEAD、GET和POST。其含义基本与HTTP协议中的同名请求方法相同。它们适合用来快速测试Web服务器。</p>
<p>“<a target="_blank" rel="noopener" href="http://www.baidu.com/index.html%E2%80%9D%E6%98%AF%E7%9B%AE%E6%A0%87%E8%B5%84%E6%BA%90%E7%9A%84URL%E3%80%82%E5%85%B6%E4%B8%AD%E2%80%9Chttp%E2%80%9D%E6%98%AF%E6%89%80%E8%B0%93%E7%9A%84scheme%EF%BC%8C%E8%A1%A8%E7%A4%BA">http://www.baidu.com/index.html”是目标资源的URL。其中“http”是所谓的scheme，表示</a><strong>获取目标资源需要使用的应用层协议</strong>。</p>
<p>其他常见的scheme还有ftp、rtsp和file等。“<a target="_blank" rel="noopener" href="http://www.baidu.com">www.baidu.com</a>”指定资源所在的目标主机。“index.html”指定资源文件的名称，这里指的是服务器根目录(站点的根目录，而不是服务器的文件系统根目录“/”)中的索引文件。</p>
<p>“HTTP/1. 0”表示客户端(wget程序)使用的HTTP的版本号是1.0。 目前的主流HTTP版本是1.1。</p>
<p>HTTP请求内容中的第2~4行都是HTTP请求的头部字段。一个HTTP请求可以包含多个头部字段。一个头部字段用一行表示，包含字段名称、冒号、空格和字段的值。HTTP请求中的头部字段可按任意顺序排列。</p>
<p>“User-Agent:Wget/1.12(linux-gnu)”表示客户端使用的程序是wget。</p>
<p>“Host:www.baidu.com”<a target="_blank" rel="noopener" href="http://xn--www-g88d49x1m3amsb25b822e81ekv2c.baidu.com">表示目标主机名是www.baidu.com</a>。HTTP协议规定HTTP请求中<strong>必须包含</strong>的头部字段就是目标主机名。</p>
<h4 id="短连接"><a class="markdownIt-Anchor" href="#短连接"></a> 短连接</h4>
<p>“Connection:close”是我们执行wget命令时传入的(见代码清单4-1)，用以告诉服务器处理完这个HTTP请求之后就关闭连接。在旧的HTTP协议中，Web客户端和Web服务器之间的一个TCP连接只能为一个HTTP请求服务。当处理完客户的一个HTTP请求之后，Web服务器就 (主动)将TCP连接关闭了。此后，同一客户如果要再发送一个HTTP请求的话，必须与服务器建立一个新的TCP连接。也就是说，同一个客户的多个连续的HTTP请求不能共用同一个TCP连接，这称为短连接。</p>
<h4 id="长连接"><a class="markdownIt-Anchor" href="#长连接"></a> 长连接</h4>
<p>与之相反，是指多个请求可以使用同一个TCP连接。长连接在编程上稍微复杂一些，但性能上却有很大提高:它极大地减少了网络上为建立TCP连接导致的负荷，同时对每次请求而言缩减了处理时间。 HTTP请求和应答中的“Connection”头部字段就是专门用于告诉对方一个请求完成之后该如何处理连接的，比如立即关闭连接(该头部字段的值为“close”)或者保持一段时间以等待后续请求(该头部字段的值为“keep-alive”)。当用浏览器访问一个网页时，读者不妨使用netstat命令来查看浏览器和Web服务器之间的连接是否是长连接，以及该连接维持了多长时间。</p>
<p>在所有头部字段之后，HTTP请求必须包含一个空行，以标识头部字段的结束。请求行和每个头部字段都必须以<CR><LF>结束(回车符和换行符);而空行则必须只包含一个<CR><LF>，不能有其他字符，甚至是空白字符。</p>
<p>在空行之后，HTTP请求可以包含可选的消息体。如果消息体非空，则HTTP请求的头部字段中必须包含描述该消息体长度的字段“Content-Length”。我们的实例只是获取目标服务器上的资源，所以没有消息体。</p>
<h3 id="462-http应答"><a class="markdownIt-Anchor" href="#462-http应答"></a> 4.6.2 HTTP应答</h3>
<p>HTTP应答的部分内容如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">	 HTTP/<span class="hljs-number">1.0</span> <span class="hljs-number">200</span> OK<br>   Server:BWS/<span class="hljs-number">1.0</span><br>   Content-Length:<span class="hljs-number">8024</span><br>   Content-Type:text/html;charset=gbk<br>   Set-<br>Cookie:BAIDUID=A5B6C72D68CF639CE8896FD79A03FBD8:FG=<span class="hljs-number">1</span>;expires=Wed,<span class="hljs-number">04</span>-<br>Jul<span class="hljs-number">-42</span> <span class="hljs-number">00</span>:<span class="hljs-number">10</span>:<span class="hljs-number">47</span> GMT;path=/;domain=.baidu.com<br>   Via:<span class="hljs-number">1.0</span> <span class="hljs-built_in">localhost</span>(squid/<span class="hljs-number">3.0</span> STABLE18)<br></code></pre></td></tr></table></figure>
<p>第一行是状态行。“HTTP/1.0”是服务器使用的HTTP协议的版本号。通常，服务器需要使用和客户端相同的HTTP协议版本。“200 OK”是状态码和状态信息。常见的状态码和状态信息及其含义如表4-2 所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205162146797.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-16 下午9.46.49" /></p>
<p><strong>第2~7行</strong>是HTTP应答的头部字段。其表示方法与HTTP请求中的头部字段相同。</p>
<p>**“Server:BWS/1. 0”**表示目标Web服务器程序的名字是BWS(Baidu Web Server)。</p>
<p>**“Content-Length:8024”**表示目标文档的长度为8024字节。这个值和wget输出的文档长度一致。</p>
<p>**“Content-Type:text/html;charset=gbk”**表示目标文档的MIME类型。 其中“text”是主文档类型，“html”是子文档类型。“text/html”表示目标文档index.html是text类型中的html文档。“charset”是text文档类型的一个参数，用于指定文档的字符编码。</p>
<p>**“Set-Cookie:BAIDUID=A5B6C72D68CF639CE8896FD79A03FBD8:FG=1;expi res=Wed,04-Jul-42 00:10:47 GMT;path=/;domain=. <a target="_blank" rel="noopener" href="http://baidu.com">baidu.com</a>”<strong>表示服务器传送一个Cookie给客户端。其中，</strong>“BAIDUID”<strong>指定Cookie的名字，</strong>“expires”<strong>指定Cookie的生存时间，</strong>“domain”<strong>和</strong>“path”**指定该Cookie生效的域名和路径。下面我们简单分析一下Cookie的作用。</p>
<p>第2章中曾提到，HTTP协议是一种<strong>无状态</strong>的协议，即每个HTTP请求之间没有任何上下文关系。如果服务器处理后续HTTP请求时需要用到前面的HTTP请求的相关信息，客户端必须重传这些信息。这样就<u>导致HTTP请求必须传输更多</u>的数据。</p>
<p>在交互式Web应用程序兴起之后，HTTP协议的这种无状态特性就显得不适应了，因为交互程序<u>通常要承上启下</u>。因此，我们要<u>使用额外的手段来保持HTTP连接状态，常见的解决方法就是Cookie</u>。Cookie是服务器发送给客户端的特殊信息(通过HTTP应答的头部字段“Set- Cookie”)，客户端每次向服务器发送请求的时候都需要带上这些信息 (通过HTTP请求的头部字段“Cookie”)。这样服务器就可以区分不同 的客户了。<strong>基于浏览器的自动登录就是用Cookie实现的</strong>。</p>
<p>**“Via:1. 0 localhost(squid/3.0 STABLE18)”**表示HTTP应答在返回过程中经历过的所有代理服务器的地址和名称。这里的localhost实际上指的是“192.168.1.108”。这个头部字段的功能有点类似于IP协议的记录路由功能。</p>
<p>在所有头部字段之后，HTTP应答必须包含一个空行，以标识头部字段的结束。状态行和每个头部字段都必须以<CR><LF>结束;而空行则必须只包含一个<CR><LF>，不能有其他字符，甚至是空白字符。</p>
<p>空行之后是被请求文档index.html的内容(当然，我们并不关心它)，其长度是8024字节。</p>
<h2 id="47-实例总结"><a class="markdownIt-Anchor" href="#47-实例总结"></a> 4.7 实例总结</h2>
<p>至此，我们成功地访问了Internet上的Web服务器，通过该实例，我们分析了TCP/IP协议族各层的部分协议:应用层的HTTP和DNS、传输层的TCP和UDP、网络层的IP、数据链路层的ARP，以及它们之间是如何协作来完成网络通信的。我们的分析方法是使用tcpdump抓包， 然后观察各层协议的头部内容以推断其工作原理。在后续章节中，我们还将多次使用这种方法来分析问题。</p>
<h1 id="第5章-linux网络编程基础api"><a class="markdownIt-Anchor" href="#第5章-linux网络编程基础api"></a> 第5章 Linux网络编程基础API</h1>
<p>本章是承前启后的一章。它探讨Linux网络编程基础API与内核中TCP/IP协议族之间的关系，并为后续章节提供编程基础。我们将从如下3个方面讨论Linux网络API:</p>
<p><strong>socket地址API</strong></p>
<p>socket最开始的含义是一个IP地址和端口对(ip，port)。它唯一地表示了使用TCP通信的一端。本书称其为socket地址。</p>
<p><strong>socket基础API</strong></p>
<p>socket的主要API都定义在sys/socket.h头文件中，包括创建socket、命名socket、监听socket、接受连接、发起连接、读写数据、获取地址信息、检测带外标记，以及读取和设置socket选项。</p>
<p><strong>网络信息API</strong></p>
<p>Linux提供了一套网络信息API，以实现主机名和IP地址之间的转换，以及服务名称和端口号之间的转换。这些API都定义在netdb.h头文件中，我们将讨论其中几个主要的函数。</p>
<h2 id="51-socket地址api"><a class="markdownIt-Anchor" href="#51-socket地址api"></a> 5.1 socket地址API</h2>
<p>要学习socket地址API，先要理解<strong>主机字节序</strong>和<strong>网络字节序</strong>。</p>
<h3 id="511-主机字节序和网络字节序"><a class="markdownIt-Anchor" href="#511-主机字节序和网络字节序"></a> 5.1.1 主机字节序和网络字节序</h3>
<p>现代CPU的累加器一次都能装载(至少)4字节(这里考虑32位机，下同)，即一个整数。那么这4字节在内存中排列的顺序将影响它被累加器装载成的整数的值。这就是字节序问题。字节序分为<strong>大端字节序(big endian)<strong>和</strong>小端字节序(little endian)</strong>。大端字节序是指<u>一个整数的高位字节(23~31bit)存储在内存的低地址处</u>，<u>低位字节(0 ~7 bit)存储在内存的高地址处</u>。小端字节序则是指<u>整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处</u>。代码清单5-1可用于检查机器的字节序。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205172044910.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-17 下午8.44.34" /></p>
<p>代码清单5-1 判断机器字节序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">byteorder</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">	&#123;</span><br>		<span class="hljs-keyword">short</span> value;<br>		<span class="hljs-keyword">char</span> union_bytes[ <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( <span class="hljs-keyword">short</span> ) ];<br>	&#125; test;<br>	test.value = <span class="hljs-number">0x0102</span>; <span class="hljs-comment">// 用一个共用体来表示一个16进制的数，通过两种方式来表示结果</span><br>	<span class="hljs-keyword">if</span> (  ( test.union_bytes[ <span class="hljs-number">0</span> ] == <span class="hljs-number">1</span> ) &amp;&amp; ( test.union_bytes[ <span class="hljs-number">1</span> ] == <span class="hljs-number">2</span> ) )<br>	&#123;<br>		<span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;big endian\n&quot;</span> ); <span class="hljs-comment">// 判断低位是不是小的高位是不是大的</span><br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( ( test.union_bytes[ <span class="hljs-number">0</span> ] == <span class="hljs-number">2</span> ) &amp;&amp; ( test.union_bytes[ <span class="hljs-number">1</span> ] == <span class="hljs-number">1</span> ) )<br>	&#123;<br>		<span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;little endian\n&quot;</span> ); <span class="hljs-comment">// 判断低位是不是大的高位是不是小的</span><br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;unknown...\n&quot;</span> );<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现代PC大多采用小端字节序，因此小端字节序又被称为<strong>主机字节序</strong>。</p>
<p>当格式化的数据(比如32bit整型数和16bit短整型数)在两台使用不同字节序的主机之间直接传递时，接收端必然错误地解释之。解决问题的方法是:发送端总是把要发送的数据<u>转化成大端字节序数据后再发送</u>，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端<u>可以根据自身采用的字节序决定是否对接收到的数据进行转换</u>(小端机转换，大端机不转换)。因此大端字节序也称为<strong>网络字节序</strong>，它给所有接收数据的主机提供了一个正确解释收到的格式化数据的保证。</p>
<p>需要指出的是，即使是同一台机器上的两个进程(比如一个由C语言编写，另一个由JAVA编写)通信，也要考虑字节序的问题(JAVA虚拟机采用大端字节序)。</p>
<p>Linux提供了如下4个函数来完成<u>主机字节序和网络字节序之间的转换</u>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">htonl</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> hostlong)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> <span class="hljs-title">htons</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> hostshort)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ntohl</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> netlong)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ntohs</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> netshort)</span></span>;<br></code></pre></td></tr></table></figure>
<p>它们的含义很明确，比如htonl表示“host to network long”，即将长整型(32 bit)的主机字节序数据转化为网络字节序数据。这4个函数中，长整型函数通常<u>用来转换IP地址</u>，短整型函数用来<u>转换端口号</u>(当然不限于此。任何格式化的数据通过网络传输时，都应该使用这些函数来转换字节序)。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205181750387.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-18 下午5.49.36" /></p>
<h3 id="512-通用socket地址"><a class="markdownIt-Anchor" href="#512-通用socket地址"></a> 5.1.2 通用socket地址</h3>
<p>socket网络编程接口中表示<strong>socket地址</strong>的是结构体sockaddr，其定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/socket.h&gt;</span> </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">sa_family_t</span> sa_family; <br>  <span class="hljs-keyword">char</span> sa_data[<span class="hljs-number">14</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>sa_family成员</strong>是**地址族类型(sa_family_t)**的变量。地址族类型通常与协议族类型对应。常见的协议族(protocol family，也称domain， 见后文)和对应的地址族如表5-1所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205172102909.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-17 下午9.02.11" /></p>
<p>宏PF_ *和AF_ *都定义在bits/socket.h头文件中，且后者与前者有完全相同的值，所以二者通常混用。</p>
<p><strong>sa_data成员</strong>用于存放socket地址值。但是，不同的协议族的地址值具有不同的含义和长度，如表5-2所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205172105793.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-17 下午9.05.36" /></p>
<p>由表5-2可见，14字节的sa_data根本无法完全容纳多数协议族的地址值。因此，Linux定义了下面这个新的通用socket地址结构体:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/socket.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">sa_family_t</span> sa_family;<br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> __ss_align; <br>	<span class="hljs-keyword">char</span> __ss_padding[<span class="hljs-number">128</span> - <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(__ss_align)];  <span class="hljs-comment">// 为什么是128 - sizeof是因为保证二三元素的大小一定是128个字节</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个结构体不仅提供了足够大的空间用于存放地址值，而且是<strong>内存对齐</strong>的(这是__ss_align成员的作用)。</p>
<p>内存对齐相关的知识：<a target="_blank" rel="noopener" href="https://blog.csdn.net/feng__shuai/article/details/115768166">https://blog.csdn.net/feng__shuai/article/details/115768166</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/suoyudong/article/details/88366235?utm_medium=distribute.pc_relevant.none-task-blog-2">https://blog.csdn.net/suoyudong/article/details/88366235?utm_medium=distribute.pc_relevant.none-task-blog-2</a><sub>default</sub>baidujs_baidulandingword~default-0-88366235-blog-115768166.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=1</p>
<p>这部分说白了就是，当你的变量大小没办法一次性全部读取出来的话，会造成地址的浪费，不如直接补齐这部分都是你的。</p>
<h3 id="513-专用socket地址"><a class="markdownIt-Anchor" href="#513-专用socket地址"></a> 5.1.3 专用socket地址</h3>
<p>上面这两个通用socket地址结构体显然很不好用，比如设置与获取IP地址和端口号就需要执行烦琐的位操作。所以Linux为各个协议族提 供了专门的socket地址结构体。</p>
<p><strong>UNIX本地域协议族</strong>使用如下专用socket地址结构体:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/un.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">sa_family_t</span> sin_family;<span class="hljs-comment">/*地址族:AF_UNIX*/</span> <br>	<span class="hljs-keyword">char</span> sun_path[<span class="hljs-number">108</span>];<span class="hljs-comment">/*文件路径名*/</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>TCP/IP协议族有sockaddr_in和sockaddr_in6两个专用socket地址结构体，它们分别用于IPv4和IPv6:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">sa_family_t</span> sin_family;<span class="hljs-comment">/*地址族:AF_INET*/</span><br>	<span class="hljs-keyword">u_int16_t</span> sin_port;<span class="hljs-comment">/*端口号，要用网络字节序表示*/</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span><span class="hljs-comment">/*IPv4地址结构体，见下面*/</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">u_int32_t</span> s_addr;<span class="hljs-comment">/*IPv4地址，要用网络字节序表示*/</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in6</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">sa_family_t</span> sin6_family;<span class="hljs-comment">/*地址族:AF_INET6*/</span><br>	<span class="hljs-keyword">u_int16_t</span> sin6_port;<span class="hljs-comment">/*端口号，要用网络字节序表示*/</span> <br>  <span class="hljs-keyword">u_int32_t</span> sin6_flowinfo;<span class="hljs-comment">/*流信息，应设置为0*/</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> <span class="hljs-title">sin6_addr</span>;</span><span class="hljs-comment">/*IPv6地址结构体，见下面*/</span> <br>  <span class="hljs-keyword">u_int32_t</span> sin6_scope_id;<span class="hljs-comment">/*scope ID，尚处于实验阶段*/</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> sa_addr[<span class="hljs-number">16</span>];<span class="hljs-comment">/*IPv6地址，要用网络字节序表示*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这两个专用socket地址结构体各字段的含义都很明确，我们只在右边稍加注释。</p>
<p>所有专用socket地址(以及sockaddr_storage)类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr(强制转换即可)，因为<u>所有socket编程接口使用的地址参数</u>的类型都是<strong>sockaddr</strong>。</p>
<h3 id="514-ip地址转换函数"><a class="markdownIt-Anchor" href="#514-ip地址转换函数"></a> 5.1.4 IP地址转换函数</h3>
<p>通常，人们习惯用可读性好的字符串来表示IP地址，比如用点分十进制字符串表示IPv4地址，以及用十六进制字符串表示IPv6地址。但编程中我们需要先把它们转化为整数(二进制数)方能使用。</p>
<p>而记录日志时则相反，我们要把整数表示的IP地址转化为可读的字符串。下面3个函数可用于用<u>点分十进制</u>字符串表示的<strong>IPv4地址</strong>和<strong>用网络字节序</strong>整数表示的IPv4地址之间的转换:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">in_addr_t</span> <span class="hljs-title">inet_addr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*strptr)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inet_aton</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*cp, struct in_addr*inp)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">char</span>*<span class="hljs-title">inet_ntoa</span><span class="hljs-params">(struct in_addr in)</span></span>;<br></code></pre></td></tr></table></figure>
<p>inet_addr函数将用<u>点分十进制字符串</u>表示的IPv4地址转化为用<u>网络字节序整数</u>表示的IPv4地址。它失败时返回INADDR_NONE。</p>
<p>inet_aton函数完成和inet_addr同样的功能，但是将转化结果存储于 参数inp指向的地址结构中。它成功时返回1，失败则返回0。</p>
<p>inet_ntoa函数将用<u>网络字节序整数</u>表示的IPv4地址转化为<u>用点分十进制字符串</u>表示的IPv4地址。但需要注意的是，该函数内部用一个静 态变量存储转化结果，函数的返回值指向该静态内存，因此inet_ntoa是<strong>不可重入</strong>的。代码清单5-2揭示了其不可重入性。</p>
<p>代码清单5-2 不可重入的inet_ntoa函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">char</span>* szValue1 = <span class="hljs-built_in">inet_ntoa</span>(“<span class="hljs-number">1.2</span><span class="hljs-number">.3</span><span class="hljs-number">.4</span>”);<br><span class="hljs-keyword">char</span>* szValue2 = <span class="hljs-built_in">inet_ntoa</span>(“<span class="hljs-number">10.194</span><span class="hljs-number">.71</span><span class="hljs-number">.60</span>”);<br><span class="hljs-built_in">printf</span>(“address <span class="hljs-number">1</span>:%s\n”, szValue1);<br><span class="hljs-built_in">printf</span>(“address <span class="hljs-number">2</span>:%s\n”, szValue2);<br></code></pre></td></tr></table></figure>
<p>运行这段代码，得到的结果是: （说明了他们指向的是同一片区域，不可以用作并发执行）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">address1:<span class="hljs-number">10.194</span><span class="hljs-number">.71</span><span class="hljs-number">.60</span><br>address2:<span class="hljs-number">10.194</span><span class="hljs-number">.71</span><span class="hljs-number">.60</span><br></code></pre></td></tr></table></figure>
<p>下面这对更新的函数也能完成和前面3个函数同样的功能，并且它们同时适用于IPv4地址和IPv6地址:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inet_pton</span><span class="hljs-params">(<span class="hljs-keyword">int</span> af, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* src, <span class="hljs-keyword">void</span>* dst)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">inet_ntop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> af, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* src, <span class="hljs-keyword">char</span>* dst, <span class="hljs-keyword">socklen_t</span> cnt)</span></span>;<br></code></pre></td></tr></table></figure>
<p>inet_pton函数将用字符串表示的IP地址src(用点分十进制字符串表示的IPv4地址或用十六进制字符串表示的IPv6地址)转换成用网络字节序整数表示的IP地址，并把转换结果存储于<strong>dst指向的内存</strong>中。其中，af参数<u>指定地址族</u>，可以是AF_INET或者AF_INET6。inet_pton成功时返回1，失败则返回0并设置errno[1]。</p>
<p>inet_ntop函数进行相反的转换，前三个参数的含义与inet_pton的参数相同，最后一个参数cnt指定目标存储单元的大小。下面的两个宏能 帮助我们指定这个大小(分别用于IPv4和IPv6):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netinet/in.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INET_ADDRSTRLEN 16 </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INET6_ADDRSTRLEN 46</span><br></code></pre></td></tr></table></figure>
<p>inet_ntop成功时返回目标存储单元的地址，失败则返回NULL并设置errno。</p>
<p>[1]Linux提供众多errno以表示各种错误。如非特殊情况，本书将不一一指出各函数可能反馈的errno值。</p>
<h2 id="52-创建socket"><a class="markdownIt-Anchor" href="#52-创建socket"></a> 5.2 创建socket</h2>
<h3 id="用netstat命令显示套接字内容这个贯通全文"><a class="markdownIt-Anchor" href="#用netstat命令显示套接字内容这个贯通全文"></a> 用netstat命令显示套接字内容这个贯通全文</h3>
<p>UNIX/Linux的一个哲学是:<strong>所有东西都是文件</strong>。socket也不例外，它就是可读、可写、可控制、可关闭的文件描述符。下面的socket系统调用可创建一个socket:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> domain,<span class="hljs-keyword">int</span> type,<span class="hljs-keyword">int</span> protocol)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>domain参数</strong></p>
<p>告诉系统<u>使用哪个底层协议族</u>。对TCP/IP协议族而言，该参数应该设置为<strong>PF_INET</strong>(Protocol Family of Internet，用于IPv4)或<strong>PF_INET6</strong>(用于IPv6);对于UNIX本地域协议族而言，该参数应该设置为PF_UNIX。关于socket系统调用支持的所有协议族， 请读者自己参考其man手册。</p>
<p><strong>type参数</strong></p>
<p>指定服务类型。服务类型主要有<strong>SOCK_STREAM</strong>服务(流服务)和<strong>SOCK_UGRAM</strong>(数据报)服务。对TCP/IP协议族而言，其值取SOCK_STREAM表示传输层使用TCP协议，取SOCK_DGRAM表示传输层使用UDP协议。</p>
<p>值得指出的是，自Linux内核版本2.6.17起，type参数可以<u>接受上述服务类型与下面两个重要的标志相与</u>的值:SOCK_NONBLOCK和SOCK_CLOEXEC。它们分别表示将新创建的socket设为非阻塞的，以及用fork调用创建子进程时在子进程中关闭该socket。在内核版本 2.6.17之前的Linux中，文件描述符的这两个属性都需要使用额外的系统调用(比如fcntl)来设置。</p>
<p><strong>protocol参数</strong></p>
<p>是在前两个参数构成的协议集合下，再选择一个具体的协议。不过这个值通常都是唯一的(前两个参数已经完全决定了它的值)。几乎在所有情况下，我们都应该把它设置为0，表示使用默认协议。</p>
<p>socket系统调用成功时返回一个socket文件描述符，失败则返回-1并设置errno。</p>
<h2 id="53-命名socket"><a class="markdownIt-Anchor" href="#53-命名socket"></a> 5.3 命名socket</h2>
<p>创建socket时，我们给它指定了地址族，但是并未指定使用该地址族中的哪个具体<strong>socket地址</strong>。<u>将一个socket与socket地址绑定</u>称为给<strong>socket命名</strong>。在服务器程序中，我们通常要命名socket，因为只有命名后客户端才能知道该如何连接它。客户端则通常不需要命名socket，而是采用匿名方式，即使用操作系统自动分配的socket地址。命名socket的系统调用是bind，其定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">const</span> struct sockaddr* my_addr,<span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure>
<p>bind将<u>my_addr所指的socket地址</u>分配给未命名的<strong>sockfd文件描述符</strong>。</p>
<p><strong>addrlen参数</strong>指出该<strong>socket地址的长度</strong>。</p>
<p>bind成功时返回0，失败则返回-1并设置errno。其中两种常见的errno是EACCES和EADDRINUSE，它们的含义分别是:</p>
<p><strong>EACCES</strong></p>
<p>被绑定的地址是受保护的地址，仅超级用户能够访问。比如普通用户将socket绑定到知名服务端口(端口号为0~1023) 上时，bind将返回EACCES错误。</p>
<p><strong>EADDRINUSE</strong></p>
<p>被绑定的地址正在使用中。比如将socket绑定到一个处于TIME_WAIT状态的socket地址。</p>
<h2 id="54-监听socket"><a class="markdownIt-Anchor" href="#54-监听socket"></a> 5.4 监听socket</h2>
<p>socket被命名之后，还不能马上接受客户连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户连接:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">int</span> backlog)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>sockfd参数</strong>指定被监听的socket。</p>
<p><strong>backlog参数</strong>提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客户连接，客户端也将收到ECONNREFUSED错误信息。在内核版本2.2 之前的Linux中，backlog参数是指所有处于半连接状态 (SYN_RCVD)和完全连接状态(ESTABLISHED)的socket的上限。 但自内核版本2.2之后，它只表示处于完全连接状态的socket的上限，处于半连接状态的socket的上限则由/proc/sys/net/ipv4/tcp_max_syn_backlog内核参数定义。backlog参数的典型值是5。</p>
<p>listen成功时返回0，失败则返回-1并设置errno。</p>
<p>下面我们编写一个<strong>服务器程序</strong>，如代码清单5-3所示，以研究 backlog参数对listen系统调用的实际影响。</p>
<p>代码清单5-3 backlog参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> stop = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">/*SIGTERM信号的处理函数，触发时结束主程序中的循环*/</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle_term</span><span class="hljs-params">( <span class="hljs-keyword">int</span> sig )</span></span><br><span class="hljs-function"></span>&#123;<br>    stop = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span> <span class="hljs-comment">// argv[] : IP地址、端口号和backlog值</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">signal</span>( SIGTERM, handle_term );<br><br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">3</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number backlog\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) ); <span class="hljs-comment">// 0代表的是文件名字</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>]; <span class="hljs-comment">// IP地址</span><br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] ); <span class="hljs-comment">// 端口号</span><br>    <span class="hljs-keyword">int</span> backlog = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">3</span>] ); <span class="hljs-comment">// backlog值</span><br><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> ); <span class="hljs-comment">// 创立TCP写一个socket</span><br>    <span class="hljs-comment">// socket系统调用成功时返回一个socket文件描述符，失败则返回-1并设置errno。</span><br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">/*创建一个IPv4 socket地址 用于接收监听的ip*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;  <span class="hljs-comment">// 地址族 ： AF_INET</span><br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr ); <span class="hljs-comment">// 将IPv4地址转换成网络字节序整数表示的IP地址</span><br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );  <span class="hljs-comment">// 端口号，用网络字节序表示</span><br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );  <span class="hljs-comment">// 给sock套接字赋予地址</span><br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><br>    ret = <span class="hljs-built_in">listen</span>( sock, backlog );  <span class="hljs-comment">// 来监听这个套接字 backlog来确定可以监听队列的最大长度，再多就不听了</span><br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">/*循环等待连接，直到有SIGTERM信号将它中断*/</span><br>    <span class="hljs-keyword">while</span> ( ! stop )<br>    &#123;<br>        <span class="hljs-built_in">sleep</span>( <span class="hljs-number">1</span> );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-comment">/*关闭socket，见后文*/</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该服务器程序(名为testlisten)接收3个参数:IP地址、端口号和backlog值。我们在Kongming20上运行该服务器程序，并在ernest-laptop上多次执行telnet命令来连接该服务器程序。同时，每使用telnet命令建立一个连接，就执行一次netstat命令来查看服务器上连接的状态。具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">$./testlisten <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">12345</span> <span class="hljs-number">5</span>#监听<span class="hljs-number">12345</span>端口，给backlog传递典 型值<span class="hljs-number">5</span><br>$telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">12345</span>#多次执行之 <br>$netstat-nt|grep <span class="hljs-number">12345</span>#多次执行之<br></code></pre></td></tr></table></figure>
<p>代码清单5-4是netstat命令某次输出的内容，它显示了这一时刻listen监听队列的内容。</p>
<p>代码清单5-4 listen监听队列的内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">Proto Recv-Q Send-Q Local Address Foreign Address Statetcp<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2240</span> SYN_RECV<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2228</span> SYN_RECV[<span class="hljs-number">1</span>]<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2230</span> SYN_RECV<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2238</span> SYN_RECV<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2236</span> SYN_RECV<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2217</span> ESTABLISHED<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2226</span> ESTABLISHED<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2224</span> ESTABLISHED<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2212</span> ESTABLISHED<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2220</span> ESTABLISHED<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2222</span> ESTABLISHED<br></code></pre></td></tr></table></figure>
<p>可见，在监听队列中，处于ESTABLISHED状态的连接只有6个 (backlog值加1)，其他的连接都处于SYN_RCVD状态。我们改变服务器程序的第3个参数并重新运行之，能发现同样的规律，即完整连接最多有(backlog+1)个。在不同的系统上，运行结果会有些差别，不过监听队列中完整连接的上限通常比backlog值略大。</p>
<h2 id="55-接受连接"><a class="markdownIt-Anchor" href="#55-接受连接"></a> 5.5 接受连接</h2>
<p>下面的系统调用从listen监听队列中接受一个连接:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,struct sockaddr*addr,<span class="hljs-keyword">socklen_t</span>*addrlen)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>sockfd参数</strong>是执行过listen系统调用的<strong>监听socket</strong>[1]。</p>
<p><strong>addr参数</strong>用来获取被接受连接的<strong>远端socket地址</strong>，该socket地址的长度由addrlen参数指出。</p>
<p>accept成功时返回一个<strong>新的连接socket</strong>，该socket唯一地<u>标识了被接受的这个连接</u>，服务器可通过读写该socket来与被接受连接对应的客户端通信。accept失败时返回-1并设置errno。</p>
<p>现在考虑如下情况:如果监听队列中处于ESTABLISHED状态的连接对应的客户端出现网络异常(比如掉线)，或者提前退出，那么服务器对这个连接执行的accept调用是否成功?我们编写一个简单的服务器程序来测试之，如代码清单5-5所示。</p>
<p>代码清单5-5 接受一个异常的连接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>		<span class="hljs-comment">/*创建一个IPv4 socket地址 用于接收得到的ip地址*/</span> <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );  <span class="hljs-comment">// 创建一个socket对象 用来准备接收处理过后结果</span><br>    <span class="hljs-comment">// sock本身是文件描述符可以找到对应的套接字</span><br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) ); <span class="hljs-comment">// sock接收</span><br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 以上就是监听ip : port ret socket为获取的那个对象</span><br>    <span class="hljs-comment">/*暂停20秒以等待客户端连接和相关操作(掉线或者退出)完成*/</span><br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-comment">/*创建一个IPv4 socket地址 用于接收得到的ip地址*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );  <br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength ); <span class="hljs-comment">// 接收接受套接字的结果</span><br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )  <br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">/*接受连接成功则打印出客户端的IP地址和端口号*/</span><br>    &#123; <br>        <span class="hljs-keyword">char</span> remote[INET_ADDRSTRLEN ];<br>        <span class="hljs-comment">// 获取对应的连接成功套接字信息</span><br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;connected with ip: %s and port: %d\n&quot;</span>, <br>            <span class="hljs-built_in">inet_ntop</span>( AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN ), <span class="hljs-built_in">ntohs</span>( client.sin_port ) );<br>        <span class="hljs-built_in">close</span>( connfd );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们在Kongming20上运行该服务器程序(名为testaccept)，并在ernest-laptop上执行telnet命令来连接该服务器程序。具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$./testaccept <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">54321</span>#监听<span class="hljs-number">54321</span>端口 <br>$ telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">54321</span><br></code></pre></td></tr></table></figure>
<p>启动telnet客户端程序后，立即断开该客户端的网络连接(建立和断开连接的过程要在服务器启动后20秒内完成)。结果发现accept调用能够正常返回，服务器输出如下:</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">connected</span> with ip:<span class="hljs-number">192.168.1.108</span> and port:<span class="hljs-number">38545</span><br></code></pre></td></tr></table></figure>
<p>接着，在服务器上运行netstat命令以查看accept返回的连接socket的状态:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$netstat -nt|grep <span class="hljs-number">54321</span><br>tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">54321</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">38545</span> ESTABLISHED<br></code></pre></td></tr></table></figure>
<p>netstat命令的输出说明，accept调用对于客户端网络断开毫不知情。下面我们重新执行上述过程，不过这次不断开客户端网络连接，而是在建立连接后立即退出客户端程序。这次accept调用同样正常返回，服务器输出如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">connected with ip:<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-keyword">and</span> port:<span class="hljs-number">52070</span><br></code></pre></td></tr></table></figure>
<p>再次在服务器上运行netstat命令:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$netstat -nt|grep <span class="hljs-number">54321</span><br>tcp <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">54321</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">52070</span> CLOSE_WAIT<br></code></pre></td></tr></table></figure>
<p>由此可见，accept只是从<u>监听队列中取出连接</u>，而不论连接处于何种状态(如上面的ESTABLISHED状态和CLOSE_WAIT状态)，更不关心任何网络状况的变化。</p>
<h2 id="56-发起连接"><a class="markdownIt-Anchor" href="#56-发起连接"></a> 5.6 发起连接</h2>
<p>如果说服务器通过listen调用来<u>被动接受连接</u>，那么客户端需要通过如下系统调用来<u>主动与服务器建立连接</u>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">const</span> struct sockaddr*serv_addr,<span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>sockfd参数</strong>由socket系统调用返回一个socket。</p>
<p><strong>serv_addr参数</strong>是服务器监听的socket地址，<strong>addrlen参数</strong>则指定这个地址的长度。</p>
<p>connect成功时返回0。一旦成功建立连接，sockfd就唯一地标识了这个连接，客户端就可以通过读写sockfd来与服务器通信。connect失 败则返回-1并设置errno。其中两种常见的errno是ECONNREFUSED和 ETIMEDOUT，它们的含义如下:</p>
<p>1、ECONNREFUSED，目标端口不存在，连接被拒绝。我们在 3.5.1小节讨论过这种情况。</p>
<p>2、ETIMEDOUT，连接超时。我们在3.3.3小节讨论过这种情况。</p>
<h2 id="57-关闭连接"><a class="markdownIt-Anchor" href="#57-关闭连接"></a> 5.7 关闭连接</h2>
<p>关闭一个连接实际上就是关闭该连接对应的socket，这可以通过如下关闭普通文件描述符的系统调用来完成:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<br></code></pre></td></tr></table></figure>
<p>fd参数是待关闭的socket。不过，close系统调用并非<u>总是立即关闭一个连接，而是将fd的引用计数减1</u>。只有当fd的引用计数为0时，才真 正关闭连接。多进程程序中，一次fork系统调用默认将使父进程中打开的socket的引用计数加1，因此我们必须在父进程和子进程中都对该socket执行close调用才能将连接关闭。</p>
<p>如果无论如何都要立即终止连接(而不是将socket的引用计数减1)，可以使用如下的shutdown系统调用(相对于close来说，它是专门为网络编程设计的):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shutdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">int</span> howto)</span></span>;<br></code></pre></td></tr></table></figure>
<p>sockfd参数是待关闭的socket。<strong>howto参数</strong>决定了shutdown的行为， 它可取表5-3中的某个值。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205182136344.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-18 下午9.36.47" /></p>
<p>由此可见，shutdown能够分别关闭socket上的读或写，或者都关闭。而close在关闭连接时只能将socket上的读和写同时关闭。</p>
<p>shutdown成功时返回0，失败则返回-1并设置errno。</p>
<h2 id="58-数据读写"><a class="markdownIt-Anchor" href="#58-数据读写"></a> 5.8 数据读写</h2>
<h3 id="581-tcp数据读写"><a class="markdownIt-Anchor" href="#581-tcp数据读写"></a> 5.8.1 TCP数据读写</h3>
<p>对文件的读写操作read和write同样适用于socket。但是socket编程接口提供了几个专门用于socket数据读写的系统调用，它们增加了对数据读写的控制。其中用于<strong>TCP流数据读写</strong>的系统调用是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">void</span>*buf,<span class="hljs-keyword">size_t</span> len,<span class="hljs-keyword">int</span> flags)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*buf,<span class="hljs-keyword">size_t</span> len,<span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>recv</strong>读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小，flags参数的含义见后文，通常设置为0即可。recv成功时返回 实际读取到的数据的长度，它可能小于我们期望的长度len。因此我们可能要多次调用recv，才能读取到完整的数据。<u>recv可能返回0，这意味着通信对方已经关闭连接</u>了。recv出错时返回-1并设置errno。</p>
<p><strong>send</strong>往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。send成功时返回实际写入的数据的长度，失败则返回-1并设置 errno。</p>
<p>flags参数为数据收发提供了额外的控制，它可以取表5-4所示选项中的一个或几个的逻辑或。</p>
<p>由于socket连接是<strong>全双工</strong>的，这里的“读端”是针对通信对方而言的</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205182140957.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-18 下午9.40.39" /></p>
<p>我们举例来说明如何使用这些选项。MSG_OOB选项给应用程序<u>提供了发送和接收带外数据的方法</u>，如代码清单5-6和代码清单5-7所示。</p>
<p>代码清单5-6 发送带外数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 创建IPv4 地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;server_address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( server_address ) );<br>    server_address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;server_address.sin_addr );<br>    server_address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 建立套接字</span><br>    <span class="hljs-keyword">int</span> sockfd = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sockfd &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">connect</span>( sockfd, ( struct sockaddr* )&amp;server_address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( server_address ) ) &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">// 建立连接套接字并判断是否链接</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;connection failed\n&quot;</span> );<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;send oob data out\n&quot;</span> );<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* oob_data = <span class="hljs-string">&quot;abc&quot;</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* normal_data = <span class="hljs-string">&quot;123&quot;</span>;<br>        <span class="hljs-comment">// 发送套接字</span><br>        <span class="hljs-built_in">send</span>( sockfd, normal_data, <span class="hljs-built_in">strlen</span>( normal_data ), <span class="hljs-number">0</span> );<br>        <span class="hljs-built_in">send</span>( sockfd, oob_data, <span class="hljs-built_in">strlen</span>( oob_data ), MSG_OOB );<br>        <span class="hljs-built_in">send</span>( sockfd, normal_data, <span class="hljs-built_in">strlen</span>( normal_data ), <span class="hljs-number">0</span> );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sockfd );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码清单5-7 接收带外数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUF_SIZE 1024</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 建立监听套接字</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>     <br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// ipv4地址设置</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );<br>    <span class="hljs-comment">// 接受连接（从监听套接字里提取接结果）</span><br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );<br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">char</span> buffer[ BUF_SIZE ];<br>        <span class="hljs-comment">// 接受套接字 ret存储字节数，buffer存储结果</span><br>        <span class="hljs-built_in">memset</span>( buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE );<br>        ret = <span class="hljs-built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span> );<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );<br><br>        <span class="hljs-built_in">memset</span>( buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE );<br>        ret = <span class="hljs-built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="hljs-number">-1</span>, MSG_OOB );<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;got %d bytes of oob data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );<br><br>        <span class="hljs-built_in">memset</span>( buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE );<br>        ret = <span class="hljs-built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span> );<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );<br><br>        <span class="hljs-built_in">close</span>( connfd );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们先在Kongming20上启动代码清单5-7所示的服务器程序(名为testoobrecv)，然后从ernest-laptop上执行代码清单5-6所示的客户端程序(名为testoobsend)来向服务器发送带外数据。同时用tcpdump抓取这一过程中客户端和服务器交换的TCP报文段。具体操作如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">$./testoobrecv <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">54321</span>#在Kongming20上执行服务器程序，监听 <span class="hljs-number">54321</span>端口<br>$./testoobsend <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">54321</span>#在ernest-laptop上执行客户端程序 <br>$sudo tcpdump-ntx -i eth0 port <span class="hljs-number">54321</span><br></code></pre></td></tr></table></figure>
<p>服务器程序的输出如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">got <span class="hljs-number">5</span> bytes of normal data<span class="hljs-number">&#x27;123</span>ab<span class="hljs-number">&#x27;</span><br>got <span class="hljs-number">1</span> bytes of oob data<span class="hljs-number">&#x27;</span>c<span class="hljs-number">&#x27;</span><br>got <span class="hljs-number">3</span> bytes of normal data<span class="hljs-number">&#x27;123&#x27;</span><br></code></pre></td></tr></table></figure>
<p>由此可见，客户端发送给服务器的3字节的带外数据“abc”中，<strong>仅有</strong>最后一个字符“c”被服务器当成真正的带外数据接收(<strong>正如3.8节</strong>讨论的 那样)。并且，<strong>服务器对正常数据的接收将被带外数据截断</strong>，即前一部分正常数据“123ab”和后续的正常数据“123”是不能被一个recv调用全部读出的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205182200198.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-18 下午10.00.09" /></p>
<p>tcpdump的输出内容中，和带外数据相关的是代码清单5-8所示的TCP报文段。</p>
<p>代码清单5-8 <u>含带外数据</u>的TCP报文段</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60460</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.54321</span>:Flags[P.U],seq <span class="hljs-number">4</span>:<span class="hljs-number">7</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">92</span>,urg <span class="hljs-number">3</span>,options[nop,nop,TS val <span class="hljs-number">102794322</span> ecr <span class="hljs-number">154703423</span>],length <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p>这里我们第一次看到tcpdump输出<strong>标志U</strong>，这表示该TCP报文段的头部被设置了紧急标志。**“urg 3”**是紧急偏移值，它指出带外数据在字节流中的位置的下一字节位置是7【说明当前最后一个位置是6】(3+4，其中4是该TCP报文段的序号值相对初始序号值的偏移)。因此，带外数据是字节流中的第6字节， 即字符“c”。</p>
<p>值得一提的是，flags参数只对send和recv的当前调用生效，而后面我们将看到如何通过setsockopt系统调用永久性地修改socket的某些属 性。</p>
<h3 id="582-udp数据读写"><a class="markdownIt-Anchor" href="#582-udp数据读写"></a> 5.8.2 UDP数据读写</h3>
<p>socket编程接口中用于UDP数据报读写的系统调用是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recvfrom</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">void</span>*buf,<span class="hljs-keyword">size_t</span> len,<span class="hljs-keyword">int</span> flags,struct sockaddr*src_addr,<span class="hljs-keyword">socklen_t</span>*addrlen)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendto</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*buf,<span class="hljs-keyword">size_t</span> len,<span class="hljs-keyword">int</span> flags,<span class="hljs-keyword">const</span> struct sockaddr*dest_addr,<span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>recvfrom</strong>读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小。因为UDP通信<strong>没有连接</strong>的概念【像tcp就有连接套接字和监听套接字提供一个平台让数据互通，但udp都是一个对一个的没法按照流发送】，所以我们<u>每次读取数据都 需要获取发送端的socket地址</u>，即参数src_addr所指的内容，addrlen参数则指定该地址的长度。</p>
<p><strong>sendto</strong>往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。dest_addr参数指定接收端的socket地址，addrlen参数则指定该地址的长度。</p>
<p>这两个系统调用的flags参数以及返回值的含义均与send/recv系统调用的flags参数及返回值相同。</p>
<p>值得一提的是，recvfrom/sendto系统调用<u>也可以用于面向连接 (STREAM)的socket的数据读写</u>，只需要把最后两个参数都设置为 NULL以忽略发送端/接收端的socket地址(因为我们已经和对方建立了连接，所以已经知道其socket地址了)。</p>
<h3 id="583-通用数据读写函数"><a class="markdownIt-Anchor" href="#583-通用数据读写函数"></a> 5.8.3 通用数据读写函数</h3>
<p>socket编程接口还提供了一对通用的数据读写系统调用。它们不仅能用于TCP流数据，也能用于UDP数据报:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recvmsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,struct msghdr*msg,<span class="hljs-keyword">int</span> flags)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendmsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,struct msghdr*msg,<span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure>
<p>sockfd参数指定<strong>被操作的目标socket</strong>。msg参数是msghdr结构体类型的指针，msghdr结构体的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msghdr</span> &#123;</span><br>      <span class="hljs-keyword">void</span>*msg_name;<span class="hljs-comment">/*socket地址*/</span><br>      <span class="hljs-keyword">socklen_t</span> msg_namelen;<span class="hljs-comment">/*socket地址的长度*/</span><br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span>*<span class="hljs-title">msg_iov</span>;</span><span class="hljs-comment">/*分散的内存块，见后文*/</span><br>      <span class="hljs-keyword">int</span> msg_iovlen;<span class="hljs-comment">/*分散内存块的数量*/</span><br>      <span class="hljs-keyword">void</span>*msg_control;<span class="hljs-comment">/*指向辅助数据的起始位置*/</span><br>      <span class="hljs-keyword">socklen_t</span> msg_controllen;<span class="hljs-comment">/*辅助数据的大小*/</span><br>      <span class="hljs-keyword">int</span> msg_flags;<span class="hljs-comment">/*复制函数中的flags参数，并在调用过程中更新*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure>
<p>msg_name成员指向一个socket地址结构变量。它指定通信对方的socket地址。对于<strong>面向连接的TCP协议</strong>，该成员没有意义，必须被设置 为NULL。这是因为对数据流socket而言，对方的地址已经知道。 msg_namelen成员则指定了msg_name所指socket地址的长度。</p>
<p>msg_iov成员是iovec结构体类型的指针，iovec结构体的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span></span><br><span class="hljs-class">&#123;</span><br>	<span class="hljs-keyword">void</span>*iov_base;<span class="hljs-comment">/*内存起始地址*/</span> <br>  <span class="hljs-keyword">size_t</span> iov_len;<span class="hljs-comment">/*这块内存的长度*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure>
<p>由上可见，iovec结构体封装了一块内存的起始位置和长度。 msg_iovlen指定这样的iovec结构对象有多少个。对于<strong>recvmsg</strong>而言，数据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长度则由<u>msg_iov指向的数组指定</u>，这称为<strong>分散读</strong>(scatter read);对于 <strong>sendmsg</strong>而言，msg_iovlen块分散内存中的数据将被一并发送，这称为<strong>集中写</strong>(gather write)。</p>
<p>msg_control和msg_controllen成员用于辅助数据的传送。我们不详细讨论它们，仅在第13章介绍如何使用它们来实现在进程间传递文件 描述符。</p>
<p>msg_flags成员无须设定，它会复制recvmsg/sendmsg的flags参数的内容以影响数据读写过程。recvmsg还会在调用结束前，将某些更新后的标志设置到msg_flags中。</p>
<p>recvmsg/sendmsg的flags参数以及返回值的含义均与send/recv的flags 参数及返回值相同。</p>
<h2 id="59-带外标记"><a class="markdownIt-Anchor" href="#59-带外标记"></a> 5.9 带外标记</h2>
<p>代码清单5-7演示了TCP带外数据的接收方法。但在实际应用中，我们通常无法预期带外数据何时到来。好在Linux内核检测到TCP紧急标志时，将通知应用程序有带外数据需要接收。内核通知应用程序带外数据到达的两种常见方式是:<strong>I/O复用产生的异常事件</strong>和<strong>SIGURG信 号</strong>。但是，即使应用程序得到了有带外数据需要接收的通知，还需要知道带外数据在数据流中的具体位置，才能准确接收带外数据。这一 点可通过如下系统调用实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sockatmark</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd)</span></span>;<br></code></pre></td></tr></table></figure>
<p>sockatmark判断<u>sockfd是否处于带外标记</u>，即下一个被读取到的数据是否是带外数据。如果是，sockatmark返回1，此时我们就可以利用 带MSG_OOB标志的recv调用来接收带外数据。如果不是，则 sockatmark返回0。</p>
<h2 id="510-地址信息函数"><a class="markdownIt-Anchor" href="#510-地址信息函数"></a> 5.10 地址信息函数</h2>
<p>在某些情况下，我们想知道一个<u>连接socket的本端socket地址</u>，以及<u>远端的socket地址</u>。下面这两个函数正是用于解决这个问题:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsockname</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,struct sockaddr* address,<span class="hljs-keyword">socklen_t</span>* address_len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getpeername</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,struct sockaddr* address,<span class="hljs-keyword">socklen_t</span>* address_len)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>getsockname</strong>获取<u>sockfd对应的本端socket地址</u>，并将其存储于address参数指定的内存中，该socket地址的长度则存储于address_len参数指向的变量中。如果实际socket地址的长度大于address所指内存区的大小，那么该socket地址将被截断。getsockname成功时返回0，失败返回-1并设置errno。</p>
<p><strong>getpeername</strong>获取<u>sockfd对应的远端socket地址</u>，其参数及返回值的含义与getsockname的参数及返回值相同。</p>
<h2 id="511-socket选项"><a class="markdownIt-Anchor" href="#511-socket选项"></a> 5.11 socket选项</h2>
<p>如果说fcntl系统调用是控制文件描述符属性的通用POSIX方法，那么下面两个系统调用则是专门用来<u><strong>读取</strong>和<strong>设置</strong>socket文件描述符属性</u>的 方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsockopt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">int</span> level,<span class="hljs-keyword">int</span> option_name,<span class="hljs-keyword">void</span>* option_value,<span class="hljs-keyword">socklen_t</span>* <span class="hljs-keyword">restrict</span> option_len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">int</span> level,<span class="hljs-keyword">int</span> option_name,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* option_value,<span class="hljs-keyword">socklen_t</span> option_len)</span></span>;<br></code></pre></td></tr></table></figure>
<p><strong>sockfd参数</strong></p>
<p>指定被操作的目标socket。</p>
<p><strong>level参数</strong></p>
<p>指定要操作哪个协议的选项(即属性)，比如IPv4、IPv6、TCP等。</p>
<p><strong>option_name参数</strong></p>
<p>则指定选项的名字。我们在表5-5中列举了socket通信中几个比较常用的socket选项。</p>
<p><strong>option_value和option_len参数</strong></p>
<p>分别是被操作选项的值和长度。不同的选项具有不同类型的值，如表5-5中“数据类型”一列所示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205192105914.png" srcset="/img/loading.gif" lazyload alt="截屏2022-05-19 下午9.05.38" /></p>
<p>getsockopt和setsockopt这两个函数成功时返回0，失败时返回-1并设置errno。</p>
<p>值得指出的是，对服务器而言，有部分socket选项只能在调用listen系统调用前针对监听socket[1]设置才有效。这是因为连接socket只能由accept调用返回，而accept从listen监听队列中接受的连接至少已经完成了TCP三次握手的前两个步骤(因为listen监听队列中的连接至少已进入SYN_RCVD状态，参见图3-8和代码清单5-4)，这说明服务器已经往被接受连接上发送出了TCP同步报文段。但有的socket选项却应该在TCP同步报文段中设置，比如TCP最大报文段选项(回忆3.2.2小节，该选项只能由同步报文段来发送)。对这种情况，Linux给开发人员提供的解决方案是:对监听socket设置这些socket选项，那么accept返回的连接socket将自动继承这些选项。这些socket选项包括:SO_DEBUG、 SO_DONTROUTE、SO_KEEPALIVE、SO_LINGER、 SO_OOBINLINE、SO_RCVBUF、SO_RCVLOWAT、SO_SNDBUF、 SO_SNDLOWAT、TCP_MAXSEG和TCP_NODELAY。而对客户端而言，这些<u>socket选项则应该在调用connect函数之前设置，因为connect调用成功返回之后，TCP三次握手已完成</u>。</p>
<p>下面我们详细讨论部分重要的socket选项。</p>
<h3 id="5111-so_reuseaddr选项"><a class="markdownIt-Anchor" href="#5111-so_reuseaddr选项"></a> 5.11.1 SO_REUSEADDR选项</h3>
<p>我们在3.4.2小节讨论过TCP连接的TIME_WAIT状态，并提到服务器程序可以通过设置socket选项SO_REUSEADDR来<u>强制使用被处于 TIME_WAIT状态的连接占用的socket地址</u>。具体实现方法如代码清单5-9所示。</p>
<p>代码清单5-9 重用本地地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 书中代码</span><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-keyword">int</span> reuse = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">setsockopt</span>( sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( reuse ) ); <span class="hljs-comment">// 给代码赋予重用功能</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>		<span class="hljs-comment">// 书中代码</span><br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );<br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );<br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">char</span> remote[INET_ADDRSTRLEN ];<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;connected with ip: %s and port: %d\n&quot;</span>, <br>        <span class="hljs-built_in">inet_ntop</span>( AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN ), <span class="hljs-built_in">ntohs</span>( client.sin_port ) );<br>        <span class="hljs-built_in">close</span>( connfd );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>经过setsockopt的设置之后，即使sock处于TIME_WAIT状态，与之绑定的socket地址也可以立即被重用。此外，我们也可以通过修改内核参数/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket，从而使得TCP连接根本就不进入TIME_WAIT状态，进而允许应用程序立即重用本地的socket地址。</p>
<h3 id="5112-so_rcvbuf和so_sndbuf选项"><a class="markdownIt-Anchor" href="#5112-so_rcvbuf和so_sndbuf选项"></a> 5.11.2 SO_RCVBUF和SO_SNDBUF选项</h3>
<p><strong>SO_RCVBUF</strong>和<strong>SO_SNDBUF</strong>选项分别表示<strong>TCP接收缓冲区</strong>和<strong>发送缓冲区</strong>的大小。不过，当我们用setsockopt来设置TCP的接收缓冲区和 发送缓冲区的大小时，<u>系统都会将其值加倍，并且不得小于某个最小值</u>。TCP接收缓冲区的最小值是256字节，而发送缓冲区的最小值是 2048字节(不过，不同的系统可能有不同的默认最小值)。系统这样做的目的，主要是确保一个TCP连接拥有足够的空闲缓冲区来处理拥塞 (比如快速重传算法就期望TCP接收缓冲区能至少容纳4个大小为SMSS的TCP报文段)。此外，我们可以直接修改内核参数/proc/sys/net/ipv4/tcp_rmem和/proc/sys/net/ipv4/tcp_wmem来强制TCP 接收缓冲区和发送缓冲区的大小没有最小值限制。我们将在第16章讨论这两个内核参数。</p>
<p>下面我们编写一对客户端和服务器程序，如代码清单5-10和代码清单5-11所示，它们分别修改TCP发送缓冲区和接收缓冲区的大小。</p>
<p>代码清单5-10 修改TCP发送缓冲区的客户端程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 512</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">3</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number send_bufer_size\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;server_address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( server_address ) );<br>    server_address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;server_address.sin_addr );<br>    server_address.sin_port = <span class="hljs-built_in">htons</span>( port );<br><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br><br>    <span class="hljs-keyword">int</span> sendbuf = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">3</span>] );<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( sendbuf );<br>    <span class="hljs-comment">/*先设置TCP发送缓冲区的大小，然后立即读取之*/</span><br>    <span class="hljs-built_in">setsockopt</span>( sock, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( sendbuf ) );  <span class="hljs-comment">// 设置socket tcp发送缓冲区</span><br>    <span class="hljs-built_in">getsockopt</span>( sock, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, ( <span class="hljs-keyword">socklen_t</span>* )&amp;len ); <span class="hljs-comment">// 查看socket tcp发送缓冲区</span><br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;the tcp send buffer size after setting is %d\n&quot;</span>, sendbuf );<br><br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">connect</span>( sock, ( struct sockaddr* )&amp;server_address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( server_address ) ) != <span class="hljs-number">-1</span> ) <span class="hljs-comment">// 连接socket</span><br>    &#123;<br>        <span class="hljs-keyword">char</span> buffer[ BUFFER_SIZE ];<br>        <span class="hljs-built_in">memset</span>( buffer, <span class="hljs-string">&#x27;a&#x27;</span>, BUFFER_SIZE );<br>        <span class="hljs-built_in">send</span>( sock, buffer, BUFFER_SIZE, <span class="hljs-number">0</span> ); <span class="hljs-comment">// 发送socket</span><br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码清单5-11 修改TCP接收缓冲区的服务器程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 1024</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">3</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number receive_buffer_size\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-keyword">int</span> recvbuf = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">3</span>] );<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( recvbuf );<br>    <span class="hljs-comment">/*先设置TCP接收缓冲区的大小，然后立即读取之*/</span><br>    <span class="hljs-built_in">setsockopt</span>( sock, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( recvbuf ) );<br>    <span class="hljs-built_in">getsockopt</span>( sock, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, ( <span class="hljs-keyword">socklen_t</span>* )&amp;len );<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;the receive buffer size after settting is %d\n&quot;</span>, recvbuf );<br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) ); <span class="hljs-comment">// 命名socket 相当于给对应端口安排一个人</span><br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> ); <span class="hljs-comment">// 监听</span><br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );<br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength ); <span class="hljs-comment">// accept监听结果</span><br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 如果监听到结果开始接收</span><br>    &#123;<br>        <span class="hljs-keyword">char</span> buffer[ BUFFER_SIZE ];<br>        <span class="hljs-built_in">memset</span>( buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE );<br>        <span class="hljs-keyword">while</span>( <span class="hljs-built_in">recv</span>( connfd, buffer, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span> ) &gt; <span class="hljs-number">0</span> )&#123;&#125;<br>        <span class="hljs-built_in">close</span>( connfd );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们在ernest-laptop上运行代码清单5-11所示的服务器程序(名为set_recv_buffer)，然后在Kongming20上运行代码清单5-10所示的客户 端程序(名为set_send_buffer)来向服务器发送512字节的数据，然后用 tcpdump抓取这一过程中双方交换的TCP报文段。具体操作过程如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">$./set_recv_buffer <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-number">12345</span> <span class="hljs-number">50</span> #将TCP接收缓冲区的大小设置为 <span class="hljs-number">50</span>字节<br> the tcp receive buffer size after settting is <span class="hljs-number">256</span><br>$./set_send_buffer <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-number">12345</span> <span class="hljs-number">2000</span> #将TCP发送缓冲区的大小设置为 <span class="hljs-number">2000</span>字节<br> the tcp send buffer size after setting is <span class="hljs-number">4000</span><br>$tcpdump -nt -i eth0 port <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure>
<p>从服务器的输出来看，系统允许的TCP接收缓冲区最小为256字节。当我们设置TCP接收缓冲区的大小为50字节时，系统将<strong>忽略</strong>我们的设置。从客户端的输出来看，我们设置的<strong>TCP发送缓冲区的大小被系统增加了一倍</strong>。这两种情况和我们前面讨论的一致。下面是此次TCP通信的tcpdump输出:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[S],seq <span class="hljs-number">1425875256</span>,win <span class="hljs-number">14600</span>,options[mss <span class="hljs-number">1460</span>,sackOK,TS val <span class="hljs-number">7782289</span> ecr <span class="hljs-number">0</span>,nop,wscale <span class="hljs-number">4</span>],length <span class="hljs-number">0</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>:Flags[S.],seq <span class="hljs-number">3109725840</span>,ack <span class="hljs-number">1425875257</span>,win <span class="hljs-number">192</span>,options[mss <span class="hljs-number">1460</span>,sackOK,TS val <span class="hljs-number">126229160</span> ecr <span class="hljs-number">7782289</span>,nop,wscale <span class="hljs-number">6</span>],length <span class="hljs-number">0</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[.],ack <span class="hljs-number">1</span>,win <span class="hljs-number">913</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">193</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">913</span>,length <span class="hljs-number">192</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>:Flags[.],ack <span class="hljs-number">193</span>,win <span class="hljs-number">0</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">6.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>:Flags[.],ack <span class="hljs-number">193</span>,win <span class="hljs-number">3</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">7.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[P.],seq <span class="hljs-number">193</span>:<span class="hljs-number">385</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">913</span>,length <span class="hljs-number">192</span><br><span class="hljs-number">8.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>:Flags[.],ack <span class="hljs-number">385</span>,win <span class="hljs-number">3</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">9.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[P.],seq <span class="hljs-number">385</span>:<span class="hljs-number">513</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">913</span>,length <span class="hljs-number">128</span><br><span class="hljs-number">10.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>:Flags[.],ack <span class="hljs-number">513</span>,win <span class="hljs-number">3</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">11.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[F.],seq <span class="hljs-number">513</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">913</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">12.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>:Flags[F.],seq <span class="hljs-number">1</span>,ack <span class="hljs-number">514</span>,win <span class="hljs-number">3</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">13.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[.],ack <span class="hljs-number">2</span>,win <span class="hljs-number">913</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>首先注意<strong>第2个TCP报文段</strong>，它指出服务器的接收通告窗口大小为192字节。该值小于256字节，显然是在情理之中。同时，该同步报文段还指出服务器采用的窗口扩大因子是6【将窗口大小乘以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">2^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>】。所以服务器后续发送的大部分TCP报文段(6、8、10和12)的实际接收通告窗口大小都是3×26字节，即192字节。因此客户端每次最多给服务器发送192字节的数据。 客户端一共给服务器发送了512字节的数据，这些数据必须至少被分为3个TCP报文段(4、7和9)来发送。</p>
<p>有意思的是<strong>TCP报文段5和6</strong>。当服务器收到客户端发送过来的第一批数据(TCP报文段4)时，它立即用TCP报文段5给予了确认，但该确认报文段的接收通告窗口的大小为0。这说明<u>TCP模块发送该确认报文段时，应用程序还没来得及将数据从TCP接收缓冲中读出</u>。所以此时客户端是不能发送数据给服务器的，直到服务器发送一个重复的确认报文段(TCP报文段6)来扩大其接收通告窗口。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/15/codeTop/">
                        <span class="hidden-mobile">CodeTop</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
