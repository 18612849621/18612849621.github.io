<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>秋招复盘</title>
    <link href="/2022/05/21/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E7%9B%98/"/>
    <url>/2022/05/21/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h1 id="美团"><a class="markdownIt-Anchor" href="#美团"></a> 美团</h1><h2 id="暑期offer笔试"><a class="markdownIt-Anchor" href="#暑期offer笔试"></a> 暑期offer笔试</h2><h3 id="第一题"><a class="markdownIt-Anchor" href="#第一题"></a> 第一题</h3><p>一组数，将他们按照两位两位分开然后相加，之后反复到小于等于99，如果个数是奇数，就把第一领出来。</p><blockquote><p>input:</p><p>123456</p><p>output:</p><p>102</p><p>3</p></blockquote><p>按照分治的方法进行处理，如果是奇数的话，那我就把第一位除去变成偶数再分治再加回来，这样时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><h4 id="第二题"><a class="markdownIt-Anchor" href="#第二题"></a> 第二题</h4><p>线程锁，记住一个线程可以抢占多个锁，然后锁按照队列排序，先进先出。</p><h3 id="第三题"><a class="markdownIt-Anchor" href="#第三题"></a> 第三题</h3><p>已知给我们一个长度为n数组，求去除一个或n个数时，能够组成多少个等差数列。</p><blockquote><p>input：</p><p>4</p><p>1 2 3 4</p><p>output:</p><p>13</p></blockquote><p>当时脑子抽了，没有做出来。不过现在我想到可以用dfs遍历状态图来做，并且可以一直判断状态图是否符合要求进行剪枝。</p><h4 id="第四题"><a class="markdownIt-Anchor" href="#第四题"></a> 第四题</h4><p>输入为n， m 然后一个数组，目的是让你求出把n个数分组求和到m个组里，让其每个组取最小值，最后输出m个组的最大值。</p><blockquote><p>input:</p><p>4 2</p><p>2 4 7 8</p><p>output:</p><p>11</p></blockquote><p>因为是一天没有考虑到24小时的问题，所以我就达到了55%。方法就是创建一个数组，先给这些课程排序，然后倒序插入到m个组里，如果到头了就折返这样可以保证每个组尽量是平均，一个大的可以配一个小的（不过我感觉这个肯定不是正确解法，不然不至于才55%）</p><p>呜呜 人生第一次笔试就这么结束了，美团👋，提前批追回来！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>TinyWebServer</title>
    <link href="/2022/05/21/TinyWebServer/"/>
    <url>/2022/05/21/TinyWebServer/</url>
    
    <content type="html"><![CDATA[<h1 id="线程同步机制封装类"><a class="markdownIt-Anchor" href="#线程同步机制封装类"></a> 线程同步机制封装类</h1><h2 id="一-基础知识"><a class="markdownIt-Anchor" href="#一-基础知识"></a> 一、基础知识</h2><h3 id="rall"><a class="markdownIt-Anchor" href="#rall"></a> RAll</h3><ul><li>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”.</li></ul><ul><li><p>在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，<u>将资源和对象的生命周期绑定</u></p></li><li><p>RAII的核心思想是<u>将资源或者状态与对象的生命周期绑定</u>，通过C++的语言机制，实现资源和状态的安全管理,<strong>智能指针</strong>是RAII最好的例子</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux高性能服务器编程</title>
    <link href="/2022/05/03/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/05/03/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-tcpip协议族"><a class="markdownIt-Anchor" href="#第1章-tcpip协议族"></a> 第1章 TCP/IP协议族</h1><h2 id="11-tcpip协议族体系结构以及主要协议"><a class="markdownIt-Anchor" href="#11-tcpip协议族体系结构以及主要协议"></a> 1.1 TCP/IP协议族体系结构以及主要协议</h2><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071505040.png" alt="截屏2022-05-07 下午3.05.28" style="zoom:200%;" /><h3 id="111-数据链路层"><a class="markdownIt-Anchor" href="#111-数据链路层"></a> 1.1.1 数据链路层</h3><p><strong>ARP和RARP协议</strong>实现了IP地址和机器物理地址(通 常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址) 之间的相互转换</p><h4 id="arp协议address-resolve-protocol地址解析协议"><a class="markdownIt-Anchor" href="#arp协议address-resolve-protocol地址解析协议"></a> ARP协议（Address Resolve Protocol，地址解析协议）</h4><p>网络层使用<strong>IP地址</strong>寻址一台机器，而数据链路层使用<strong>物理地址</strong>寻址一台机器，因此网络层必须先将目标机器的<u>IP地址转化成其物理地址</u>，才能使用数据链路层提供的服务。</p><h4 id="rarp协议reverse-address-resolve-protocol逆地址解析协议"><a class="markdownIt-Anchor" href="#rarp协议reverse-address-resolve-protocol逆地址解析协议"></a> RARP协议(Reverse Address Resolve Protocol，逆地址解析协议)</h4><p>用于网络上的某些无盘工作站。因为缺乏存储设备，无盘工作站无法记住自己的IP地址，但它们可以利用网卡上的物理地址来向网络管理者(服务器或网络管理软件)查询自身的IP地址。</p><p>PS：运行RARP服 务的网络管理者通常存有该网络上所有机器的物理地址到IP地址的映射。</p><h3 id="112-网络层"><a class="markdownIt-Anchor" href="#112-网络层"></a> 1.1.2 网络层</h3><p>网络层实现数据包的选路和转发。</p><p>通信的两台主机一般<u>不是直接相连</u>的，而是通过多个中间节点(路由器)连接的就是选择这些中间节点，以确定两台主机之间的通信路径。同时，网络层对上层协议<u>隐藏了网络拓扑连接</u>的细节，使得在<u>传输层和网络应用程序</u><u>看来，通信的双方是直接相连</u>的。</p><h4 id="ip协议internet-protocol因特网协议"><a class="markdownIt-Anchor" href="#ip协议internet-protocol因特网协议"></a> IP协议（Internet Protocol，因特网协议）</h4><p>step 1: IP协议<strong>根据数据包的目的IP地址</strong>来决定如何投递它。</p><p>step 2: 如果数据包<u>不能直接发送</u>给目标主机，那么IP协议就为它<strong>寻找一个合适的下一跳(next hop)<strong>路由器，并将数据包</strong>交付给该路由器</strong>来转发。</p><p>重复step1、2直到最后发送到目的地，或者由于发送失败而丢弃。</p><p>PS：IP协议使用逐跳(hop by hop)的方式确定通信路径</p><h4 id="icmp协议internet-control-message-protocol-因特网控制报文协议"><a class="markdownIt-Anchor" href="#icmp协议internet-control-message-protocol-因特网控制报文协议"></a> ICMP协议（Internet Control Message Protocol， 因特网控制报文协议）</h4><p>它是IP协议的重要补充，主要用于<strong>检测网络连接</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071505484.png" alt="截屏2022-05-07 下午3.04.44" /></p><p>主要分两种：1）用来回应网络错误 2）用来查询网络信息如ping程序</p><p>ICMP协议并非严格意义上的网络层协议，因为它使用处于同一层的IP协议提供的服务(一般来说，上层协议使用下层协议提供的服务)。</p><h3 id="113-传输层"><a class="markdownIt-Anchor" href="#113-传输层"></a> 1.1.3 传输层</h3><p>传输层为两台主机上的应用程序提供<strong>端到端(end to end)<strong>的通信。与网络层使用的逐跳通信方式不同，传输层</strong>只关心通信的起始端和目的端，而不在乎数据包的中转过程</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071504810.png" alt="截屏2022-05-07 下午3.04.16" /></p><p>垂直的实线箭头表示TCP/IP协议族各层之间的<strong>实体通信</strong>，而水平的虚线箭头表示<strong>逻辑通信线路</strong>。该图中还附带描述了<strong>不同物理网络的连接方法</strong>。可见，数据链路层(驱动程序)<strong>封装了物理网络的电气细节</strong>;网络层<strong>封装了网络连接</strong>的细节;传输层则为应用程序<strong>封装了一条端到端的逻辑通信链路</strong>，它负责数据<u>的收发、链路的超时重连</u>等。</p><h4 id="tcp协议transmission-control-protocol传输控制协议"><a class="markdownIt-Anchor" href="#tcp协议transmission-control-protocol传输控制协议"></a> TCP协议(Transmission Control Protocol，传输控制协议)</h4><p>1、为应用层提供<u>可靠的、面向连接的和基于流(stream)</u>的服务。</p><p>2、TCP协议使用<u>超时重传、数据确认</u>等方式来<strong>确保数据包被正确地发送至目的端</strong>，因此TCP服务是<strong>可靠</strong>的。</p><p>3、使用TCP协议通信的双方必须<strong>先建立TCP连接</strong>， 并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等。</p><p>4、当通信结束时，双方必须关闭连接以释放这些内核数据。</p><p>5、TCP服务是基于流的。<strong>基于流的数据没有边界(长度)限制</strong>，它<u>源源不断地从通信的一端流入另一端</u>。</p><p>6、发送端可以逐个 字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出。</p><h4 id="udp协议user-datagram-protocol用户数据报协议"><a class="markdownIt-Anchor" href="#udp协议user-datagram-protocol用户数据报协议"></a> UDP协议(User Datagram Protocol，用户数据报协议)</h4><p>它为应用层提供<u>不可靠、无连接和基于数据报</u>的服务。（与TCP完全相反）</p><p>1、<strong>“不可靠”<strong>意味着UDP协议无法保证数据从发送端正确地传送到目的端。如果数据在</strong>中途丢失</strong>，或者目的端通过数据校验<strong>发现数据错误而将其丢弃</strong>，则UDP协议只是<strong>简单地通知应用程序发送失败</strong>。因此，使用UDP协议的应用程序通常要<u>自己处理数据确认、超时重传</u>等逻辑。</p><p>2、UDP协议是无连接的，即<strong>通信双方不保持一个长久的联系</strong>，因此应用程序<strong>每次发送数据都要明确指定接收端的地址</strong>(IP地址等信息)。</p><p>3、基于数据报的服务，<u>是相对基于流的服务而言的</u>。每个UDP数据报都有一个长度，接收端必须以该长度为最小单位将其<u>所有内容一次性读出</u>，否则数据将被截断。</p><h4 id="sctp协议stream-control-transmission-protocol流控制传输协议"><a class="markdownIt-Anchor" href="#sctp协议stream-control-transmission-protocol流控制传输协议"></a> SCTP协议(Stream Control Transmission Protocol，流控制传输协议)</h4><p>是一种相对较新的传输层协议，它是为了在因特网上传输电话信号而设计的。</p><h3 id="114-应用层"><a class="markdownIt-Anchor" href="#114-应用层"></a> 1.1.4 应用层</h3><p>应用层负责处理应用程序的逻辑。</p><p>内核态：<u>数据链路层、网络层和传输层</u>负责处理网络通信细节，这部分必须既稳定又高效，因此它们都在内核空间中实现</p><p>用户态：应用层则在用户空间实现，因为它负责处理众多逻辑，比如文件传输、名称查询和网络管理等。</p><h4 id="ping应用程序"><a class="markdownIt-Anchor" href="#ping应用程序"></a> ping应用程序</h4><p>它利用ICMP报文检测网络连接，是调试网络环境的必备工具。</p><h4 id="telnet协议"><a class="markdownIt-Anchor" href="#telnet协议"></a> telnet协议</h4><p>它使我们能在本地完成远程任务</p><h4 id="ospfopen-shortest-path-first开放最短路径优先协议"><a class="markdownIt-Anchor" href="#ospfopen-shortest-path-first开放最短路径优先协议"></a> OSPF(Open Shortest Path First，开放最短路径优先)协议</h4><p>是一种动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由信息。</p><h4 id="dnsdomain-name-service域名服务协议"><a class="markdownIt-Anchor" href="#dnsdomain-name-service域名服务协议"></a> DNS(Domain Name Service，域名服务)协议</h4><p>提供机器域名到IP地址的转换，我们将在后面简要介绍DNS协议。</p><p>应用层协议(或程序)可能跳过传输层直接使用网络层提供的服务，比如ping程序和OSPF协议。应用层协议(或程序)通常既可以使用TCP服务，又可以使用UDP服务，比如DNS协议。我们可以通过/etc/services文件查看所有知名的应用层协议，以及它们都能使用哪些传输层服务。</p><h2 id="12-封装"><a class="markdownIt-Anchor" href="#12-封装"></a> 1.2 封装</h2><p>上层协议是如何使用下层协议提供的服务的呢?其实这是通过封装(encapsulation)实现的。</p><p>应用程序数据在发送到物理网络上之前， 将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加上自己的头部信息(有时还包括尾部信息)，以实现该层的功能， 这个过程就称为封装，如图。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052119363.png" alt="截屏2022-05-05 下午9.19.17" /></p><h3 id="121-tcp封装"><a class="markdownIt-Anchor" href="#121-tcp封装"></a> 1.2.1 TCP封装</h3><p>经过TCP封装后的数据称为<strong>TCP报文段(TCP message segment)</strong>，或者简称TCP段。</p><p>前文提到，TCP协议为通信双方维持一个连接，并且在内核中存储相关数据。这部分数据中的<strong>TCP头部信息</strong>和<strong>TCP内核缓冲区</strong>(发送缓冲区或接收缓冲区)<strong>数据</strong>一起构成了TCP报文段。</p><p>封装过程如图</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052118653.png" alt="截屏2022-05-05 下午9.18.56" /></p><p>当发送端应用程序使用send(或者write)函数向一个TCP连接写入数据过程</p><p>1、内核中的TCP模块首先<u>把这些数据复制到与该连接对应的TCP</u>内核发送缓冲区中</p><p>2、TCP模块调用IP模块提供的服务，传递的参数包括TCP头部信息和TCP发送缓冲区中的数据，即TCP报文段。</p><h3 id="122-udp封装"><a class="markdownIt-Anchor" href="#122-udp封装"></a> 1.2.2 UDP封装</h3><p>经过UDP封装后的数据称为<strong>UDP数据报(UDP datagram)</strong>。</p><p>UDP 对应用程序数据的封装与TCP类似。不同的是，UDP<strong>无须为应用层数据保存副本</strong>，因为它提供的服务是<strong>不可靠的</strong>。</p><p>1、当一个UDP数据报被成功发送之后，UDP内核缓冲区中的该数据报就被丢弃了。</p><p>2、如果应用程序检测到该数据报未能被接收端正确接收，并打算<strong>重发</strong>这个数据报，则应用程序需要<u>重新从用户空间将该数据报拷贝到UDP内核发送缓冲区</u>中。</p><h3 id="123-ip封装"><a class="markdownIt-Anchor" href="#123-ip封装"></a> 1.2.3 IP封装</h3><p>经过IP封装后的数据称为<strong>IP数据报(IP datagram)</strong>。IP数据报也包括<strong>头部信息</strong>和数据部分，其中<u>数据</u>部分就是<u>一个TCP报文段、UDP数据 报或者ICMP报文</u>。</p><h3 id="124-数据链路层封装"><a class="markdownIt-Anchor" href="#124-数据链路层封装"></a> 1.2.4 数据链路层封装</h3><p>经过数据链路层封装的数据称为<strong>帧(frame)</strong>。传输媒介不同，帧的类型也不同。</p><p>比如，<strong>以太网</strong>上传输的是<strong>以太网帧(ethernet frame)</strong>， 而令牌环网络上传输的则是<strong>令牌环帧(token ring frame)</strong>。以以太网帧为例，其封装格式如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052118513.png" alt="截屏2022-05-05 下午6.16.14" /></p><p>以太网帧使用<strong>6字节</strong>的目的物理地址和6字节的源物理地址来表示通信的双方。<strong>4字节</strong>CRC字段对帧的其他部分提供循环冗余校验。</p><p><strong>帧的最大传输单元(Max Transmit Unit，MTU)</strong>，即帧<u>最多能携带多少上层协议数据</u>(比如IP数据报)，通常受到网络类型的限制。 图1-6所示的以太网帧的MTU是1500字节。正因为如此，过长的IP数据 报可能需要被分片(fragment)传输。</p><p>帧才是最终在物理网络上传送的字节序列。至此，封装过程完成。</p><h3 id="13-分用"><a class="markdownIt-Anchor" href="#13-分用"></a> 1.3 分用</h3><h3 id="131-分用的流程"><a class="markdownIt-Anchor" href="#131-分用的流程"></a> 1.3.1 分用的流程</h3><p>1、当帧到达目的主机时，将沿着协议栈自底向上依次传递。</p><p>2、各层协议依次处理帧中本层负责的头部数据，以获取所需的信息。</p><p>3、最终将处理后的帧交给目标应用程序。</p><p>这个过程称为<strong>分用 (demultiplexing)</strong>，我个人理解就是对于数据报的解析。</p><p>分用是依靠头部信息中的类型字段实现的。<u>标准文档RFC 1700</u>定义了所有标识上层协议的类型字段以及每个上层协议对应的数值。如图显示了以太网帧的<strong>分用过程</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052119640.png" alt="截屏2022-05-05 下午9.19.35" /></p><h3 id="132-分用时如何区分协议"><a class="markdownIt-Anchor" href="#132-分用时如何区分协议"></a> 1.3.2 分用时如何区分协议</h3><p>因为IP协议、ARP协议和RARP协议都使用帧传输数据，所以帧的 头部需要提供某个字段(具体情况取决于帧的类型)来区分它们。</p><p>以以太网帧为例，它使用2字节的类型字段来标识上层协议封装图。 如果主机接收到的以太网帧类型字段的值为0x800，则帧的数据部分 <strong>IP数据报</strong>，以太网驱动程序就将帧交付给IP模块;若类型字段的值为0x806，则帧的数据部分为<strong>ARP</strong>请求或应答报文，以太网驱动程序就将帧交付给<strong>ARP模块</strong>;若类型字段的值为0x835，则帧的数据部分为<strong>RARP</strong>请求或应答报文，以太网驱动程序就将帧交付给<strong>RARP模块</strong>。</p><p>简单来说就是根据字节来识别判断什么协议做什么操作。</p><p>同样，因为<strong>ICMP协议</strong>、<strong>TCP协议</strong>和<strong>UDP协议</strong>都使用<strong>IP协议</strong>，所以IP数据报的头部采用16位的协议(protocol)字段来区分它们。</p><p>TCP报文段和UDP数据报则通过其头部中的16位的端口号(port number)字段来区分上层应用程序。比如DNS协议对应的端口号是53，HTTP协议(Hyper-Text Transfer Protocol，超文本传送协议)对应的端口号是80。所有知名应用层协议使用的端口号都可在/etc/services文件中找到。</p><p>帧通过上述分用步骤后，最终将封装前的原始数据送至目标服务 (上图中的ARP服务、RARP服务、ICMP服务或者应用程序)。这样，在顶层目标服务看来，封装和分用似乎没有发生过。<strong>解析交给各一层的东西，直接发送到各自的端口，所以看起来是封装的，端到端的。</strong></p><h2 id="14-测试网络"><a class="markdownIt-Anchor" href="#14-测试网络"></a> 1.4 测试网络</h2><p><strong>测试网络如下图所示</strong>，其中包括两台主机A和B，以及一个连接到因特网的路由器。如没有特别声明，所有测试硬件指的都是该网络。我们将使用机器名来标识测试机器。</p><p>![截屏2022-05-05 下午9.19.45](…/…/…/Library/Application Support/typora-user-images/截屏2022-05-05 下午9.19.45.png)</p><p>该测试网络主要用于分析<strong>ARP协议</strong>、<strong>IP协议</strong>、<strong>ICMP协议</strong>、<strong>TCP协议</strong>和<strong>DNS协议</strong>。我们通过抓取该网络上的以太网帧，查看其中的以太网帧头部、IP数据报头部、TCP报文段头部信息，以获取网络通信的细节。【对于路由器，我们仅列出了其LAN网络IP地址(192.168.1.1)，而 忽略了ISP(Internet Service Provider，因特网服务提供商)给它分配的WAN网络IP地址】</p><h2 id="15-arp协议工作原理"><a class="markdownIt-Anchor" href="#15-arp协议工作原理"></a> 1.5 ARP协议工作原理</h2><p>ARP协议能实现任意<strong>网络层地址</strong>到任意<strong>物理地址</strong>的转换，不过这里仅讨论从<strong>IP地址</strong>到**以太网地址(MAC地址)**的转换。</p><h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3><p>1、主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。</p><p>2、此网络上的其他机器都将收到这个请求，但<strong>只有</strong>被请求的目标机器会<u>回应一个ARP应答</u>，其中<strong>包含自己的物理地址</strong>。</p><h3 id="151-以太网arp请求应答报文"><a class="markdownIt-Anchor" href="#151-以太网arp请求应答报文"></a> 1.5.1 以太网ARP请求/应答报文</h3><p>以太网ARP请求/应答报文的格式如图</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052120702.png" alt="截屏2022-05-05 下午9.20.13" /></p><p><strong>硬件类型字段</strong>：定义物理地址的类型，它的值为1表示MAC地址。</p><p><strong>协议类型字段</strong>：表示要映射的协议地址类型，它的值为0x800，表示IP地址。</p><p><strong>硬件地址长度字段</strong>和<strong>协议地址长度字段</strong>：顾名思义，其单位是字节。对MAC地址来说，其长度为6;对IP(v4)地址来说，其长度为4。</p><p><strong>操作字段</strong>：指出4种操作类型：ARP请求(值为1)、ARP应答(值 为2)、RARP请求(值为3)和RARP应答(值为4)。</p><p>最后4个字段指定<strong>通信双方的以太网地址</strong>和<strong>IP地址</strong>。</p><p>1、发送端填充除目的端以太网地址外的其他3个字段，以构建ARP请求并发送之。</p><p>2、接收端发现该请求的目的端IP地址是自己，就把自己的以太网地址填进去。</p><p>3、然后交换两个目的端地址和两个发送端地址，以构建ARP应答并返回之(当然，如前所述，操作字段需要设置为2)。</p><p>就是一个交互的小过程</p><p>由上图可知，ARP请求/应答报文的长度为28字节。如果再加上以太网帧头部和尾部的18字节(见图1-6)，则一个携带ARP请求/应答报文的以太网帧长度为46字节。不过有的实现要求以太网帧数据部分长度至少为46字节(见图1-4)，此时ARP请求/应答报文将增加一些填充字节，以满足这个要求。在这种情况下，一个携带ARP请求/应答报文的以太网帧长度为64字节。</p><h3 id="152-arp高速缓存的查看和修改"><a class="markdownIt-Anchor" href="#152-arp高速缓存的查看和修改"></a> 1.5.2 ARP高速缓存的查看和修改</h3><p>通常，ARP维护一个高速缓存，其中<strong>包含经常访问(比如网关地址)<strong>或</strong>最近访问的机器的IP地址到物理地址的映射</strong>。这样就<u>避免了重复的ARP请求</u>，提高了发送数据包的速度。</p><p>Linux下可以使用arp命令来查看和修改ARP高速缓存。比如， ernest-laptop在某一时刻(注意，ARP高速缓存是动态变化的)的ARP 缓存内容如下(使用<strong>arp -a</strong>命令):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Kongming20</span>(<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>)at <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>[ether]on eth0<br>?(<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>)at <span class="hljs-number">14</span>:e6:e4:<span class="hljs-number">93</span>:<span class="hljs-number">5b</span>:<span class="hljs-number">78</span>[ether]on eth0<br></code></pre></td></tr></table></figure><p>第一项描述的是另一台测试机器Kongming20(注意，其IP 地址、MAC地址都与上面的总图描述的一致)。</p><p>第二项描述的是路由器。下面两条命令则分别删除和添加一个ARP缓存项。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo arp -d <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>#删除Kongming20对应的ARP缓存项<br>$sudo arp -s <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>#添加Kongming20对应的 ARP缓存项<br></code></pre></td></tr></table></figure><h3 id="153-使用tcpdump观察arp通信过程"><a class="markdownIt-Anchor" href="#153-使用tcpdump观察arp通信过程"></a> 1.5.3 使用tcpdump观察ARP通信过程</h3><p>为了清楚地了解ARP的运作过程，我们从ernest-laptop上执行telnet 命令登录Kongming20的echo服务(已经开启)，并用tcpdump(详见第 17章)抓取这个过程中两台测试机器之间交换的以太网帧。具体的操作过程如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo arp -d <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>#清除ARP缓存中Kongming20对应的项<br>$sudo tcpdump -i eth0-ent<span class="hljs-number">&#x27;</span>(dst <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-keyword">and</span> src <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>) <span class="hljs-built_in"><span class="hljs-keyword">or</span></span><br>(dst <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-keyword">and</span> src <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>)<span class="hljs-string">&#x27;#如无特殊声明，抓包都在机器 ernest-laptop上执行</span><br><span class="hljs-string">$telnet 192.168.1.109 echo#开启另一个终端执行telnet命令 Trying 192.168.1.109...</span><br><span class="hljs-string">Connected to 192.168.1.109.</span><br><span class="hljs-string">Escape character is &#x27;</span>^]<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">^](回车)#输入Ctrl+]并回车 telnet&gt;quit(回车) Connection closed.</span><br></code></pre></td></tr></table></figure><p>1、在执行telnet命令之前，应先清除ARP缓存中与Kongming20对应的项，否则ARP通信不被执行，我们也就无法抓取到期望的以太网帧。</p><p>2、当执行telnet命令并在两台通信主机之间建立TCP连接后(telnet输 出“Connected to 192.168.1.109”)</p><p>3、输入Ctrl+]以调出telnet程序的命令提示符，然后在telnet命令提示符后输入quit，退出telnet客户端程序(因为ARP通信在TCP连接建立之前就已经完成，故我们不关心后续内容)。</p><p>4、tcpdump抓取到的众多数据包中，只有最靠前的两个和ARP通信有关系，现在将它们列出(数据包前面的编号是笔者加入的，后同):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.00</span>:<span class="hljs-number">16</span>:d3:<span class="hljs-number">5</span>c:b9:e3&gt;ff:ff:ff:ff:ff:ff,<span class="hljs-function">ethertype <span class="hljs-title">ARP</span><span class="hljs-params">(<span class="hljs-number">0x0806</span>)</span>,length 42:Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>,length <span class="hljs-number">28</span></span><br><span class="hljs-function"><span class="hljs-number">2.08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>&gt;<span class="hljs-number">00</span>:<span class="hljs-number">16</span>:d3:<span class="hljs-number">5</span>c:b9:e3,ethertype ARP(<span class="hljs-number">0x0806</span>),length <span class="hljs-number">60</span>:Reply <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> is-at <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">27</span>:<span class="hljs-number">53</span>:<span class="hljs-number">10</span>:<span class="hljs-number">67</span>,length <span class="hljs-number">46</span></span><br></code></pre></td></tr></table></figure><p>由tcpdump<u>抓取的数据包</u>本质上是<strong>以太网帧</strong>，我们通过该命令的众多选项来控制帧的过滤(比如用dst和src指定通信的目的端IP地址和源端IP地址)和显示(比如用-e选项开启以太网帧头部信息的显示)。</p><p><strong>第一个数据包</strong>中，ARP通信的<strong>源端的物理地址</strong>是00:16:d3:5c:b9:e3(ernest-laptop)，<strong>目的端的物理地址</strong>是ff:ff:ff:ff:ff:ff， 这是以太网的广播地址，用以表示整个LAN。</p><p>1、该LAN上的所有机器都会收到并处理这样的帧。</p><p>2、数值0x806是以太网帧头部的类型字段的值， 它表示分用的目标是ARP模块。</p><p>3、该以太网帧的长度为42字节(实际上是46字节，tcpdump未统计以太网帧尾部4字节的CRC字段)，其中数据部分长度为28字节。</p><p>4、“Request”表示这是一个ARP请求，“who-has 192.168.1.109 tell 192.168.1.108”则表示是ernest-laptop要查询Kongming20的IP地址。</p><p><strong>第二个数据包</strong>中，ARP通信的<strong>源端的物理地址</strong>是 08:00:27:53:10:67(Kongming20)，<strong>目的端的物理地址</strong>是 00:16:d3:5c:b9:e3(ernest-laptop)。</p><p>1、“Reply”表示这是一个ARP应答，“192.168.1.109 is-at 08:00:27:53:10:67”则表示目标机器Kongming20 报告其物理地址。</p><p>2、该以太网帧的长度为60字节(实际上是64字节)， 可见它使用了填充字节来满足最小帧长度。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052117137.png" alt="截屏2022-05-05 下午9.16.56" /></p><p>1、我们将两次传输的以太网帧按照图1-6所描述的以太网帧封装格式绘制在图的下半部分。</p><p>2、ARP请求和应答是从<u>以太网驱动程序发出的，而并非像图中描述的那样从ARP模块直接发送到以太网上</u>，所以我们将它们用虚线表示，这主要是为了体现携带ARP数据的以太网帧和其他以太网帧 (比如携带IP数据报的以太网帧)的区别。</p><p>3、路由器也将接收到以太网帧1，因为该<strong>帧是一个广播帧</strong>。不过很显然，<u>路由器并没有回应其中的ARP请求</u>，正如前文讨论的那</p><p>样。</p><h2 id="16-dns工作原理"><a class="markdownIt-Anchor" href="#16-dns工作原理"></a> 1.6 DNS工作原理</h2><p>我们通常使用机器的<u>域名来访问</u>这台机器，而<u>不直接使用其IP</u>地址，比如访问因特网上的各种网站。那么如何将机器的域名转换成IP地址呢?这就需要使用域名查询服务。域名查询服务有很多种实现方式，比如NIS(Network Information Service，网络信息服务)、DNS和本地静态文件等。本节主要讨论DNS。</p><h3 id="161-dns查询和应答报文详解"><a class="markdownIt-Anchor" href="#161-dns查询和应答报文详解"></a> 1.6.1 DNS查询和应答报文详解</h3><p>DNS是一套分布式的域名服务系统。</p><p>每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且是动态更新的。</p><p>众多网络客户端程序都使用DNS协议来向DNS服务器查询目标主机的IP地址。</p><p>DNS查询和应答报文的格式如图1-11所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052125476.png" alt="截屏2022-05-05 下午9.25.01" /></p><p>16位标识[1]字段用于标记一对<strong>DNS查询</strong>和<strong>应答</strong>，以此<u>区分一个DNS应答是哪个DNS查询的回应</u>。</p><p>16位标志字段用于<strong>协商具体的通信方式</strong>和<strong>反馈通信状态</strong>。DNS报文头部的16位标志字段的细节如图1-12所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052126399.png" alt="截屏2022-05-05 下午9.26.22" /></p><p><strong>QR</strong>：查询/应答标志。0表示这是一个查询报文，1表示这是一个应答报文。</p><p><strong>opcode</strong>：定义查询和应答的类型。0表示标准查询，1表示反向查询(由IP地址获得主机域名)，2表示请求服务器状态。</p><p><strong>AA</strong>：授权应答标志，仅由应答报文使用。1表示域名服务器是授权服务器。</p><p><strong>TC</strong>：截断标志，仅当DNS报文使用UDP服务时使用。因为UDP数据报有长度限制，所以过长的DNS报文将被截断。1表示DNS报文超过512字节，并被截断。</p><p><strong>RD</strong>：递归查询标志。1表示执行递归查询，即如果目标DNS服务器无法解析某个主机名，则它将向其他DNS服务器继续查询，如此递 归，直到获得结果并把该结果返回给客户端。0表示执行迭代查询，即如果目标DNS服务器无法解析某个主机名，则它将自己知道的其他 DNS服务器的IP地址返回给客户端，以供客户端参考。</p><p><strong>RA</strong>：允许递归标志。仅由应答报文使用，1表示DNS服务器支持递归查询。</p><p><strong>zero</strong>：这3位未用，必须都设置为0。</p><p><strong>rcode</strong>：4位返回码，表示应答的状态。常用值有0(无错误)和3(域名不存在)。</p><p>接下来的4个字段则分别指出DNS报文的最后4个字段的资源记录数目。对<strong>查询报文</strong>而言，它一般包含1个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。<strong>应答报文</strong>的应答资源记录数则至少为1，而授权资源记录数和额外资源记录数可为0或非0。</p><p>查询问题的格式如图1-13所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052130947.png" alt="截屏2022-05-05 下午9.30.27" /></p><p><strong>查询名</strong>以<u>一定的格式封装了要查询的主机域名</u>。16位查询类型表示如何执行查询操作，常见的类型有如下几种:</p><p>类型A：值是1，表示获取目标主机的IP地址。</p><p>类型CNAME：值是5，表示获得目标主机的别名。</p><p>类型PTR：值是12，表示反向查询。</p><p><strong>16位查询类</strong>：通常为1，表示获取因特网地址(IP地址)。</p><p>应答字段、授权字段和额外信息字段都使用资源记录(Resource Record，RR)格式。资源记录格式如图1-14所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205052133025.png" alt="截屏2022-05-05 下午9.33.13" /></p><p><strong>32位域名</strong>：是该记录中与资源对应的名字，其格式和查询问题中的查询名字段相同。</p><p><strong>16位类型</strong>和<strong>16位类</strong>字段：含义也与DNS查询问题的对应字段相同。</p><p><strong>32位生存时间</strong>：表示该查询记录结果可被本地客户端程序缓存多长时间，单位是秒。</p><p><strong>16位资源数据长度字段和资源数据字段</strong>：的内容取决于类型字段对类型A而言，资源数据是32位的IPv4地址，而资源数据长度则为 4(以字节为单位)。</p><p>至此，我们简要地介绍了DNS协议。我们将在后面给出一个DNS通信的具体例子。DNS协议的更多细节请参考其RFC文档(DNS协议 存在诸多RFC文档，每个RFC文档介绍其一个侧面，比如RFC 1035介绍的是域名的实现和规范，RFC 1886则描述DNS协议对IPv6的扩展支 持)。</p><h3 id="162-linux下访问dns服务"><a class="markdownIt-Anchor" href="#162-linux下访问dns服务"></a> 1.6.2 Linux下访问DNS服务</h3><p>我们要访问DNS服务，就必须先知道DNS服务器的IP地址。Linux 使用/etc/resolv.conf文件来存放DNS服务器的IP地址。机器ernest-laptop上，该文件的内容如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">#Generated by Network Manager<br> nameserver <span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><br> nameserver <span class="hljs-number">124.207</span><span class="hljs-number">.160</span><span class="hljs-number">.106</span><br></code></pre></td></tr></table></figure><p>其中的两个IP地址分别是<strong>首选DNS服务器地址</strong>和<strong>备选DNS服务器</strong>地址。</p><p>文件中的注释语句“Generated by Network Manager”告诉我们，这<u>两个DNS服务器地址是由网络管理程序写入</u>的。</p><p>Linux下一个常用的<strong>访问DNS服务器的客户端程序</strong>是host，比如下面的命令是<u>向首选DNS服务器219.239.26.42查询</u>机器www.baidu.com的IP地址:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">$host -t A www.baidu.com<br>www.baidu.com is an alias <span class="hljs-keyword">for</span> www.a.shifen.com.<br>www.a.shifen.com has address <span class="hljs-number">119.75</span><span class="hljs-number">.217</span><span class="hljs-number">.56</span><br>www.a.shifen.com has address <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><br></code></pre></td></tr></table></figure><p>1、host命令的输出告诉我们，机器名www.baidu.com是 www.a.shifen.com.的<strong>别名</strong>（alias），并且该机器名对应两个IP地址。</p><p>2、host命令使用<strong>DNS协议</strong>和<strong>DNS服务器通信</strong>，其-t选项<u>告诉DNS协议使用哪种查询类型</u>。</p><p>3、我们这里使用的是<strong>A类型</strong>，即<strong>通过机器的域名获得其IP地址</strong>(但实际上返回的资源记录中还包含机器的别名)。</p><h3 id="163-使用tcpdump观察dns通信过程"><a class="markdownIt-Anchor" href="#163-使用tcpdump观察dns通信过程"></a> 1.6.3 使用tcpdump观察DNS通信过程</h3><p>为了看清楚DNS通信的过程，下面我们将从ernest-laptop上运行<strong>host命令</strong>以查询主机www.baidu.com对应的IP地址，并使用<strong>tcpdump抓取</strong>这一过程中<u>LAN上传输的以太网帧</u>。具体的操作过程如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -i eth0 -nt -s <span class="hljs-number">500</span> port domain<br>$host -t A www.baidu.com<br></code></pre></td></tr></table></figure><p>这一次执行tcpdump抓包时，我们使用“port domain”来过滤数据包，表示<u>只抓取使用domain(域名)服务的数据包</u>，即DNS查询和应答报文。tcpdump的输出如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34319</span> &gt; <span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><span class="hljs-number">.53</span>: <span class="hljs-number">57428</span>+ A? www.baidu.com. (<span class="hljs-number">31</span>)<br><span class="hljs-number">2.</span>IP <span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><span class="hljs-number">.53</span> &gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34319</span>: <span class="hljs-number">57428</span> <span class="hljs-number">3</span>/<span class="hljs-number">4</span>/<span class="hljs-number">4</span> CNAME www.a.shifen.com.,A <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span>,A <span class="hljs-number">119.75</span><span class="hljs-number">.217</span><span class="hljs-number">.56</span>(<span class="hljs-number">226</span>)<br></code></pre></td></tr></table></figure><p>1、这两个数据包开始的“IP”指出，它们后面的内容描述的是<strong>IP数据报</strong>。</p><p>2、tcpdump以“<strong>IP地址.端口号</strong>”的形式来描述通信的某一端。</p><p>3、以“&gt;”表 示数据传输的方向，“&gt;”前面是<strong>源端</strong>，后面是<strong>目的端</strong>。</p><p>4、可见，第一个数据包是测试机器ernest-laptop(IP地址是192.168.1.108)向其首选DNS服务器(IP地址是219.239.26.42)发送的<strong>DNS查询报文</strong>(目标端口53是<strong>DNS服务使用的端口</strong>，这一点我们在前面介绍过)，第二个数据包是<strong>服务器反馈的DNS应答报文</strong>。</p><p><strong>第一个数据包中</strong>：</p><p>数值57428是<strong>DNS查询报文</strong>的标识值，因此该值也出现在<strong>DNS应答报文</strong>中。“+”表示启用<strong>递归查询标志</strong>。“A?”表示使用<strong>A类型的查询方式</strong>。“<a href="http://www.baidu.com">www.baidu.com</a>”则是<strong>DNS查询问题中的查询名</strong>。 括号中的数值31是DNS查询报文的长度(以字节为单位)。</p><p><strong>第二个数据包中</strong>：</p><p>“3/4/4”表示该报文中包含<strong>3个应答资源记录</strong>、<strong>4 个授权资源记录</strong>和<strong>4个额外信息记录</strong>。“CNAME <a href="http://www.a.shifen.com">www.a.shifen.com</a>.，A 119.75.218.77，A 119.75.217.56”则表示3个应答资源记录的内容。其中<strong>CNAME表示紧随其后的记录是机器的别名</strong>，<strong>A表示紧随其后的记录是IP地址</strong>。该应答报文的长度为226字节。</p><p>PS：我们抓包的时候没有开启tcpdump的-X选项(或者-x选 项)。如果使用-X选项，我们将能看到DNS报文的每一个字节，也就 能明白上面31字节的查询报文和226字节的应答报文的具体含义。</p><h2 id="17-socket和tcpip协议族的关系"><a class="markdownIt-Anchor" href="#17-socket和tcpip协议族的关系"></a> 1.7 socket和TCP/IP协议族的关系</h2><p>由于<u>数据链路层、网络层、传输层</u>协议是在<strong>内核</strong>中实现的。因此<strong>操作系统</strong>需要实现一组系统调用，使得应用程序能够访问这些协议提供的服务。实现这组系统调用的**API(Application Programming Interface，应用程序编程接口)**主要有两套:<strong>socket</strong>和 XTI。<u>XTI现在基本不再使用</u>，所以这里仅讨论socket，如图1-1显示了socket与TCP/IP协议族的关系。</p><p>由socket定义的这一组API提供如下两点功能:</p><p>1、将应用程序数据从<u>用户缓冲区中复制到TCP/UDP内核发送缓冲区</u>，以<u>交付内核来发送数据</u>(比如图1-5所示的send函数)，或者是<u>从内核TCP/UDP接收缓冲区中复制数据到用户缓冲区</u>，以读取数据。</p><p>2、应用程序可以通过它们来<u>修改内核中各层协议的某些头部信息或其他数据结构</u>，从而精细地<u>控制底层通信</u>的行为。比如可以通过setsockopt函数来<u>设置IP数据报在网络上的存活时间</u>。</p><p>socket是一套通用网络编程接口，它不但可以访问内核中TCP/IP协议栈，而且可以访问其他网络协议栈(比如X.25协议栈、UNIX本地域协议栈等)。</p><h1 id="第2章-ip协议详解"><a class="markdownIt-Anchor" href="#第2章-ip协议详解"></a> 第2章 IP协议详解</h1><p>IP协议是TCP/IP协议族的<strong>核心协议</strong>，也是socket网络编程的基础之一。本章从两个方面较为深入地探讨IP协议:</p><p><strong>IP头部信息</strong>：IP头部信息出现在每个IP数据报中，用于指定IP通信的源端IP地址、目的端IP地址，指导IP分片和重组，以及指定部分通信行为。</p><p><strong>IP数据报的路由和转发</strong>：IP数据报的路由和转发发生在除目标机器之外的所有主机和路由器上。它们决定数据报<u>是否应该转发</u>以及<u>如何转发</u>。</p><p>由于32位表示的IP地址即将全部使用完，因此人们开发出了新版本的IP协议，称为IPv6协议，而原来的版本则称为IPv4协议。本章前面部分的讨论都是基于IPv4协议的，只在最后一节简要讨论IPv6协议。</p><h2 id="21-ip服务的特点"><a class="markdownIt-Anchor" href="#21-ip服务的特点"></a> 2.1 IP服务的特点</h2><p>IP协议是TCP/IP协议族的动力，它为上层协议提供<u>无状态、无连接、不可靠</u>的服务。</p><h3 id="无状态stateless"><a class="markdownIt-Anchor" href="#无状态stateless"></a> 无状态(stateless)</h3><p><strong>IP通信双方不同步传输数据的状态信息</strong>， 因此所有IP数据报的发送、传输和接收都是<u>相互独立、没有上下文关系</u>的。</p><p>这种服务最大的<strong>缺点</strong>是无法处理乱序和重复的IP数据报。比如发送端发送出的第N个IP数据报可能比第N+1个IP数据报后到达接收端，而同一个IP数据报也可能经过不同的路径多次到达接收端。在这两种情况下，接收端的IP模块无法检测到乱序和重复，因为这些IP数据报之间没有任何上下文关系。</p><p>接收端的IP模块只要收到了<strong>完整</strong>的IP数据报(如果是IP分片的话，IP模块将先执行重组)，就将其数据部分(TCP报文段、UDP数据报或者ICMP报文)上交给上层协议。那么<strong>从上层协议来看</strong>，这些数据就可能是<u>乱序的、重复</u>的。</p><p>面向连接的协议，比如<strong>TCP协议</strong>，则能够自己处理乱序的、重复的报文段，它递交给上层协议的内容绝对是<strong>有序的、正确</strong>的。</p><p>虽然IP数据报头部提供了一个<strong>标识</strong>字段(见后文)用以唯一标识一个IP数据报，但它是被用来<strong>处理IP分片和重组</strong>的，而<strong>不是用来指示接收顺序</strong>的。</p><p>无状态服务的优点也很明显:<strong>简单、高效</strong>。我们无须为保持通信的状态而分配一些内核资源，也无须每次传输数据时都携带状态信息。在网络协议中，无状态是很常见的，比如<u>UDP协议和HTTP协议都是无状态协议</u>。以HTTP协议为例，一个浏览器的连续两次网页请求之间没有任何关联，它们将被Web服务器独立地处理。</p><h3 id="无连接connectionless"><a class="markdownIt-Anchor" href="#无连接connectionless"></a> 无连接(connectionless)</h3><p>IP通信双方都<strong>不长久地维持</strong>对方的任何信息。这样，上层协议<strong>每次</strong>发送数据的时候，都必须<strong>明确指定</strong>对方的IP地址。</p><h3 id="不可靠"><a class="markdownIt-Anchor" href="#不可靠"></a> 不可靠</h3><p>IP协议<strong>不能保证</strong>IP数据报准确地到达接收端，它只是承诺尽最大努力(best effort)。</p><p>很多种情况都能导致IP数据报发送失败。比如，某个中转路由器发现IP数据报在网络上存活的时间太长(根据IP数据报头部字段TTL判断，见后文)，那么它将丢弃之，并返回一个ICMP错误消息(超时错误)给发送端。</p><p>又比如，接收端发现收到的IP数据报不正确(通过校验机制)，它也将丢弃之，并返回一个ICMP错误消息(IP头部参数错误)给发送端。</p><p>无论哪种情况，发送端的IP模块一旦检测到IP数据报发送失败，就通知上层协议发送失败，而不会试图重传。因此，使用IP服务的上层协议(比如TCP协 议)需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。</p><h2 id="22-ipv4头部结构"><a class="markdownIt-Anchor" href="#22-ipv4头部结构"></a> 2.2 IPv4头部结构</h2><h3 id="221-ipv4头部结构"><a class="markdownIt-Anchor" href="#221-ipv4头部结构"></a> 2.2.1 IPv4头部结构</h3><p>IPv4的头部结构如图2-1所示。其长度通常为20字节，除非含有可变长的选项部分。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205071553191.png" alt="截屏2022-05-07 下午3.53.42" /></p><p><strong>4位版本号(version)</strong>：指定IP协议的版本。对IPv4来说，其值是4。其他IPv4协议的扩展版本(如SIP协议和PIP协议)，则具有不同的版本号(它们的头部结构也和图2-1不同)。</p><p><strong>4位头部长度(header length)</strong>：标识该IP头部有多少个32bit字(4字 节)。因为4位最大能表示15，所以IP头部最长是60字节。</p><p><strong>8位服务类型(Type Of Service，TOS)</strong>：包括一个3位的优先权字段 (现在已经被忽略)，4位的TOS字段和1位保留字段(必须置0)。4位的TOS字段分别表示:最小延时，最大吞吐量，最高可靠性和最小费用。其中最多有一个能置为1，应用程序应该根据实际需要来设置它。 比如像ssh和telnet这样的登录程序需要的是最小延时的服务，而文件传输程序ftp则需要最大吞吐量的服务。</p><p><strong>16位总长度(total length)</strong>：整个IP数据报的长度，以字节为单位，因此IP数据报的最大长度为65 535(216-1)字节。但由于MTU的限制，长度超过MTU的数据报都将被分片传输，所以实际传输的IP数据报(或分片)的长度都远远没有达到最大值。接下来的3个字段则描述了如何实现分片。</p><p><strong>16位标识(identification)</strong>：唯一地标识主机发送的每一个数据报。 其初始值由系统随机生成;每发送一个数据报，其值就<strong>加1</strong>。该值在数 据报分片时被<strong>复制</strong>到每个分片中，因此<u>同一个数据报的所有分片都具有相同</u>的标识值。</p><p><strong>3位标志字段</strong>：第一位保留。第二位(Don’t Fragment，DF)表示“禁止分片”。如果设置了这个位，IP模块将不对数据报进行分片。在这种情况下，如果IP数据报长度超过MTU的话，IP模块将丢弃该数据报并返回一个ICMP差错报文。第三位(More Fragment，MF)表示“更多分片”。除了数据报的最后一个分片外，其他分片都要把它置1。</p><p><strong>13位分片偏移(fragmentation offset)</strong>：分片相对原始IP数据报开始处(仅指数据部分)的偏移。实际的偏移值是该值左移3位(乘8)后得到的。由于这个原因，除了最后一个IP分片外，每个IP分片的数据部分的长度必须是<strong>8的整数倍</strong>(这样才能保证后面的IP分片拥有一个合适的偏移值)。</p><p><strong>8位生存时间(Time To Live，TTL)</strong>：数据报到达目的地之前允许经过的路由器跳数。TTL值被发送端设置(常见的值是64)。数据报在转发过程中每经过一个路由，该值就被路由器减1。当TTL值减为0时，路由器将丢弃数据报，并向源端发送一个ICMP差错报文。TTL值可以 防止数据报陷入路由循环。</p><p><strong>8位协议(protocol)</strong>：用来区分上层协议，我们在第1章讨论过。/etc/protocols文件定义了所有上层协议对应的protocol字段的数值。 其中，ICMP是1，TCP是6，UDP是17。/etc/protocols文件是RFC 1700的一个子集。</p><p><strong>16位头部校验和(header checksum)</strong>：由发送端填充，接收端对其使用<u>CRC算法以检验IP数据报头部</u>(注意，<strong>仅检验头部</strong>)在传输过程中是否损坏。</p><p><strong>32位的源端IP地址和目的端IP地址</strong>：用来标识数据报的发送端和接收端。一般情况下，这两个地址在整个数据报的传递过程中保持不变，而不论它中间经过多少个中转路由器。关于这一点，我们将在第4章进一步讨论。</p><p><strong>IPv4最后一个选项字段(option)</strong>：是可变长的可选信息。这部分最多包含40字节，因为IP头部最长是60字节(其中还包含前面讨论的20字节的固定部分)。可用的IP选项包括:</p><p>1、记录路由(record route)，告诉数据报途经的所有路由器都将自己的IP地址填入IP头部的选项部分，这样我们就可以跟踪数据报的传递 路径。</p><p>2、时间戳(timestamp)，告诉每个路由器都将数据报被转发的时间(或时间与IP地址对)填入IP头部的选项部分，这样就可以测量途经路由之间数据报传输的时间。</p><p>3、松散源路由选择(loose source routing)，指定一个路由器IP地址列表，数据报发送过程中必须经过其中所有的路由器。</p><p>4、严格源路由选择(strict source routing)，和松散源路由选择类似，不过数据报只能经过被指定的路由器。</p><h3 id="222-使用tcpdump观察ipv4头部结构"><a class="markdownIt-Anchor" href="#222-使用tcpdump观察ipv4头部结构"></a> 2.2.2 使用tcpdump观察IPv4头部结构</h3><p>为了深入理解IPv4头部中每个字段的含义，我们从测试机器ernest-laptop上<u>执行telnet命令登录本机</u>，并用tcpdump抓取这个过程中telnet客户端程序和telnet服务器程序之间交换的数据包。具体的操作过程如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -ntx -i lo #抓取本地回路上的数据包<br>$telnet <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>#开启另一个终端执行telnet命令登录本机 Trying <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>...<br>Connected to <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>.<br>Escape character is<span class="hljs-number">&#x27;</span>^]<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">Ubuntu 9.10</span><br><span class="hljs-string">ernest-laptop login:ernest#输入用户名并回车 Password:#输入密码并回车</span><br></code></pre></td></tr></table></figure><p>此时观察tcpdump输出的第一个数据包，其内容如代码清单2-1所示。</p><p>代码清单2-1 用tcpdump抓取数据包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.41621</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[S],seq <span class="hljs-number">3499745539</span>,win <span class="hljs-number">32792</span>,<br>   options[mss <span class="hljs-number">16396</span>,sackOK,TS val <span class="hljs-number">40781017</span> ecr <span class="hljs-number">0</span>,nop,wscale<br><span class="hljs-number">6</span>],length <span class="hljs-number">0</span><br>   <span class="hljs-number">0x0000</span>:<span class="hljs-number">4510</span> <span class="hljs-number">003</span>c a5da <span class="hljs-number">4000</span> <span class="hljs-number">4006</span> <span class="hljs-number">96</span>cf <span class="hljs-number">7f</span>00 <span class="hljs-number">0001</span><br>   <span class="hljs-number">0x0010</span>:<span class="hljs-number">7f</span>00 <span class="hljs-number">0001</span> a295 <span class="hljs-number">0017</span> d099 e103 <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br>   <span class="hljs-number">0x0020</span>:a002 <span class="hljs-number">8018</span> fe30 <span class="hljs-number">0000</span> <span class="hljs-number">0204</span> <span class="hljs-number">400</span>c <span class="hljs-number">0402</span> <span class="hljs-number">080</span>a<br></code></pre></td></tr></table></figure><p>该数据包描述的是一个<strong>IP数据报</strong>。由于我们是使<u>用telnet登录本机</u>的，所以IP数据报的<strong>源端IP地址</strong>和<strong>目的端IP地址</strong>都是“127.0.0.1”。telnet 服务器程序使用的端口号是23(参见/etc/services文件)，而telnet客户端程序使用临时端口号41621与服务器通信。关于临时端口号，我们将 在第3章讨论。“Flags”、“seq”、“win”和“options”描述的都是TCP头部信息，这也将在第3章讨论。“length”指出该IP数据报所携带的应用程序数据的长度。</p><p>这次抓包我们开启了tcpdump的-x选项，使之输出数据包的<strong>二进制码</strong>。此数据包共包含60字节，其中前20字节是IP头部，后40字节是TCP 头部，不包含应用程序数据(length值为0)。现在我们分析IP头部的每个字节，如表2-1所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205072139077.png" alt="截屏2022-05-07 下午9.39.25" /></p><p>由表2-1可见，telnet服务选择<u>使用具有最小延时的服务</u>，并且默认<u>使用的传输层协议是TCP协议</u>(回顾第1章讨论的分用)。这些都符合我们通常的理解。这个IP数据报<u>没有被分片</u>，因为它没有携带任何应用程序数据。接下来我们将<u>抓取并讨论被分片的IP数据报</u>。</p><h2 id="23-ip分片"><a class="markdownIt-Anchor" href="#23-ip分片"></a> 2.3 IP分片</h2><p>前文曾提到，当IP数据报的长度<u>超过帧的MTU</u>时，它将被<u>分片传输</u>。分片<u>可能发生在发送端</u>，也可能<u>发生在中转路由器</u>上，而且可能在<u>传输过程中被多次</u>分片，但只有在<strong>最终的目标机器上，这些分片才会被内核中的IP模块重新组装</strong>。</p><p>IP头部中的如下三个字段给IP的分片和重组提供了足够的信息:数据报标识、标志和片偏移。一个IP数据报的每个分片都具有自己的IP头 部，它们具有相同的标识值，但具有不同的片偏移。并且除了最后一个分片外，其他分片都将设置MF标志。此外，每个分片的IP头部的总长度字段将被设置为该分片的长度。</p><p>以太网帧的MTU是1500字节(可以通过ifconfig命令或者netstat命令查看)，因此它携带的IP数据报的数据部分<strong>最多是1480字节</strong>(IP头部占用20字节)。考虑用IP数据报封装一个<strong>长度为1481字节</strong>的<strong>ICMP报文</strong> (包括8字节的ICMP头部，所以其数据部分长度为1473字节)，则该数据报在使用以太网帧传输时<strong>必须被分片</strong>，如图2-2所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205072159863.png" alt="截屏2022-05-07 下午9.59.01" /></p><p>图2-2中，长度为1501字节的IP数据报被拆分成两个IP分片，第一个IP分片长度为1500字节，第二个IP分片的长度为21字节。每个IP分片 都包含自己的IP头部(20字节)，且第一个IP分片的IP头部<strong>设置了MF标志</strong>，而第二个IP分片的IP头部则<strong>没有设置该标志</strong>，因为它<strong>已经是最后 一个分片</strong>了。原始IP数据报中的ICMP头部内容<strong>被完整地复制</strong>到了第一个IP分片中。第二个IP分片<strong>不包含ICMP头部信息</strong>，因为IP模块重组该 ICMP报文的时候<strong>只需要一份ICMP头部</strong>信息，<u>重复传送这个信息没有任何益处</u>。1473字节的ICMP报文数据的前1472字节被IP模块复制到第一个IP分片中，使其总长度为1500字节，从而满足MTU的要求;而多出的最后1字节则被复制到第二个IP分片中。</p><p>需要指出的是，<strong>ICMP报文</strong>的<strong>头部长度取决于报文的类型</strong>，其变化范围很大。图2-2以8字节为例，因为后面的例子用到了ping程序，而 ping程序使用的ICMP回显和应答报文的头部长度是8字节。</p><p>为了看清楚IP分片的具体过程，考虑从ernest-laptop来ping机器Kongming20，每次传送1473字节的数据(<strong>这是ICMP报文的数据部分</strong>) 以强制引起IP分片，并用tcpdump抓取这一过程中双方交换的数据包。 具体操作过程如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -ntv -i eth0 icmp#只抓取ICMP报文<br>$ping Kongming20 -s <span class="hljs-number">1473</span>#用-s选项指定每次发送<span class="hljs-number">1473</span>字节的数据<br></code></pre></td></tr></table></figure><p>下面我们考察tcpdump输出的一个IP数据报的两个分片，其内容如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span><span class="hljs-built_in">IP</span>(tos <span class="hljs-number">0x0</span>,ttl <span class="hljs-number">64</span>,id <span class="hljs-number">61197</span>,offset <span class="hljs-number">0</span>,flags[+],proto <span class="hljs-built_in">ICMP</span>(<span class="hljs-number">1</span>),length <span class="hljs-number">1500</span>)<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.110</span>:ICMP echo request,id <span class="hljs-number">41737</span>,seq <span class="hljs-number">1</span>,length <span class="hljs-number">1480</span><br><span class="hljs-number">2.</span><span class="hljs-built_in">IP</span>(tos <span class="hljs-number">0x0</span>,ttl <span class="hljs-number">64</span>,id <span class="hljs-number">61197</span>,offset <span class="hljs-number">1480</span>,flags[none],proto <span class="hljs-built_in">ICMP</span>(<span class="hljs-number">1</span>),length <span class="hljs-number">21</span>)<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.110</span>:icmp<br></code></pre></td></tr></table></figure><p>这两个IP分片的标识值都是61197，说明它们是<strong>同一个IP数据报</strong>的分片。</p><p>第一个分片的片偏移值为0，而第二个则是1480。很显然，第二个分片的片<strong>偏移值</strong>实际上也是<strong>第一个分片的ICMP报文的长度</strong>。</p><p>第一个 分片设置了MF标志以<strong>表示还有后续分片</strong>，所以tcpdump输出“flags[+]”。</p><p>而第二个分片则<strong>没有设置任何标志</strong>，所以tcpdump输出“flags[none]”。</p><p>这个两个分片的长度分别为1500字节和21字节，这与图2-2描述的一致。</p><p>最后，IP层传递给数据链路层的数据可能是一个<u>完整的IP数据报</u>， 也<u>可能是一个IP分片</u>，它们统称为<strong>IP分组(packet)</strong>。本书如无特殊声 明，<strong>不区分IP数据报和IP分组</strong>。</p><h2 id="24-ip路由"><a class="markdownIt-Anchor" href="#24-ip路由"></a> 2.4 IP路由</h2><p>IP协议的一个核心任务是<strong>数据报的路由</strong>，即<u>决定发送数据报到目标机器的路径</u>。为了理解IP路由过程，我们先简要分析IP模块的基本工作流程。</p><h3 id="241-ip模块工作流程"><a class="markdownIt-Anchor" href="#241-ip模块工作流程"></a> 2.4.1 IP模块工作流程</h3><p>IP模块基本工作流程如图2-3所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205081527791.png" alt="截屏2022-05-08 下午3.26.53" /></p><p>我们从右往左来分析图2-3。</p><p>1、当IP模块接收到来自数据链路层的IP数据报时，它首先对该数据报的头部做<strong>CRC校验</strong>，确认无误之后就分析其头部的具体信息。</p><p>2、如果该IP数据报的头部设置了<strong>源站选路选项</strong>(松散源路由选择或严格源路由选择)，则IP模块<u>调用数据报转发子模块来处理该数据报</u>。</p><p>3、如果该IP数据报的头部中目标IP地址是<u>本机的某个IP地址，或者是广播地址，即该数据报是发送给本机</u>的，则IP模块就根据数据报头部 中的协议字段来决定将它<strong>派发给哪个上层应用</strong>(分用)；如果IP模块发现这个数据报不是发送给本机的，则也<strong>调用数据报转发子模块</strong>来处理该数据报。</p><p>4、数据报转发子模块将首先检测系统<strong>是否允许转发</strong>，如果不允许，IP模块就将数据报丢弃。如果允许，数据报转发子模块将对该数据报 执行一些操作，然后将它交给IP数据报输出子模块。</p><p>5、IP数据报应该发送至哪个下一跳路由(或者目标机器)，以及经过哪个网卡来发送，就是IP路由过程，即图2-3中“计算下一跳路由”子模块。IP模块实现数据报路由的<strong>核心数据结构是路由表</strong>。这个表<u>按照数据报的目标IP地址分类</u>，同一类型的IP数据报将被发往相同的下一跳 路由器(或者目标机器)。</p><p>IP输出队列中存放的是<strong>所有等待发送的IP数据报</strong>，其中除了需要转发的IP数据报外，还包括封装了本机上层数据(ICMP报文、TCP报文段和UDP数据报)的IP数据报。图2-3中的虚线箭头显示了路由表更新的过程。这一过程是指通过路由协议或者route命令调整路由表，使之更适应最新的网络拓扑结构，称为<strong>IP路由策略</strong>。</p><h3 id="242-路由机制"><a class="markdownIt-Anchor" href="#242-路由机制"></a> 2.4.2 路由机制</h3><p>要研究IP路由机制，需要先了解路由表的内容。我们可以使用<strong>route命令</strong>或<strong>netstat命令</strong>查看路由表。在测试机器ernest-laptop上执行 route命令，输出内容如代码清单2-2所示。</p><p>代码清单2-2 路由表实例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Kernel IP routing table<br>Destination Gateway Genmask Flags Metric Ref Use Iface<br><span class="hljs-keyword">default</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> UG <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> eth0<br><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>*<span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span> U <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> eth0<br></code></pre></td></tr></table></figure><p>该路由表包含两项，每项都包含8个字段，如表2-2所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205081554166.png" alt="截屏2022-05-08 下午3.54.38" /></p><p>1、第一项的目标地址是default，即所谓的默认路由项。该项包含一个“G”标志，说明路由的下一跳目标是<strong>网关</strong>，其地址是192.168.1.1(这是测试网络中路由器的本地IP地址)。</p><p>2、另外一个路由项的目标地址是192.168.1.0，它指的是<strong>本地局域网</strong>。该路由项的网关地址为*，说明数据报不需要路由中转，可以直接发送到目标机器。</p><p>那么路由表是如何按照IP地址分类的呢?或者说给定数据报的目标IP地址，它将匹配路由表中的哪一项呢?这就是IP的路由机制，分为 3个步骤:</p><p>1)查找<strong>路由表</strong>中和<strong>数据报的目标IP地址</strong>完全<strong>匹配</strong>的主机IP地址。 如果找到，就使用该路由项，没找到则转步骤2。</p><p>2)查找路由表中和数据报的目标IP地址具有相同<strong>网路ID的网络IP地址</strong>(比如代码清单2-2所示的路由表中的第二项)。如果找到，就使用该路由项;没找到则转步骤3。（这相当于在同一个网关）</p><p>3)选择默认路由项，这通常意味着数据报的下一跳路由是网关。</p><p>因此，对于测试机器ernest-laptop而言，所有发送到IP地址为192.168.1.*的机器的IP数据报都可以直接发送到目标机器(匹配路由表第二项)，而所有访问因特网的请求都将通过网关来转发(匹配默认路由项)。</p><h3 id="243-路由表更新"><a class="markdownIt-Anchor" href="#243-路由表更新"></a> 2.4.3 路由表更新</h3><p>路由表必须能够更新，以反映网络连接的变化，这样IP模块才能准确、高效地转发数据报。route命令可以修改路由表。我们看如下几个例子(在机器ernest-laptop上执行):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo route add -host <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> dev eth0<br> $sudo route del -net <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span> netmask <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span><br> $sudo route del <span class="hljs-keyword">default</span><br> $sudo route add <span class="hljs-keyword">default</span> gw <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> dev eth0<br></code></pre></td></tr></table></figure><p><strong>第1行</strong>表示添加主机192.168.1.109(机器Kongming20)对应的路由项。这样设置之后，所有<u>从ernest-laptop发送到Kongming20</u>的IP数据报 将通过网卡eth0直接发送至目标机器的接收网卡。</p><p><strong>第2行</strong>表示删除网络192.168.1.0对应的路由项。这样除了机器Kongming20外，测试机器ernest-laptop将<strong>无法访问该局域网上的任何其他机器</strong>(能访问到Kongming20是由于执行了上一条命令)。</p><p><strong>第3行</strong>表示<u>删除默认路由项</u>， 这样做的后果是<u>无法访问因特网</u>。</p><p><strong>第4行</strong>表示<u>重新设置默认路由项</u>，不过这次其<u>网关是机器Kongming20</u>(而不是能直接访问因特网的路由器)!</p><p>经过上述修改后的路由表如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Kernel IP routing table<br> Destination Gateway Genmask Flags Metric Ref Use Iface<br> Kongming20*<span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.255</span> UH <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> eth0<br> <span class="hljs-keyword">default</span> Kongming20 <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span> UG <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> eth0<br></code></pre></td></tr></table></figure><p>这个新的路由表中，第一个路由项是<u>主机路由项</u>，所以它被设置了“H”标志。我们设计这样一个路由表的目的是为后文讨论ICMP重定向提供环境。</p><p>通过route命令或其他工具手工修改路由表，是静态的路由更新方式。</p><p>对于大型的路由器，它们通常通过BGP(Border Gateway Protocol，边际网关协议)、RIP(Routing Information Protocol，路由信息协议)、OSPF等协议来发现路径，并更新自己的路由表。这种更新方式是动态的、自动的。</p><h2 id="25-ip转发"><a class="markdownIt-Anchor" href="#25-ip转发"></a> 2.5 IP转发</h2><p>前文提到，<strong>不是发送给本机</strong>的IP数据报<u>将由数据报转发子模块来处理</u>。路由器都<strong>能执行数据报的转发操作</strong>，而主机<strong>一般只发送和接收数据报</strong>，这是因为主机上/proc/sys/net/ipv4/ip_forward内核参数默认被设置为0。</p><p>我们可以通过修改它<strong>来使能主机的数据报转发功能</strong>(在测试机器Kongming20上以root身份执行):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#echo 1&gt;/proc/sys/net/ipv4/ip_forward</span><br></code></pre></td></tr></table></figure><p>对于允许IP数据报转发的系统(主机或路由器)，<strong>数据报转发子模块</strong>将<u>对期望转发的数据报</u>执行如下操作:</p><p>1)检查数据报头部的TTL值。如果TTL值已经是0，则丢弃该数据报。</p><p>2)查看数据报头部的严格源路由选择选项。如果该选项被设置， 则检测数据报的目标IP地址是否是本机的某个IP地址。如果不是，则发送一个ICMP源站选路失败报文给发送端。</p><p>3)如果有必要，则给源端发送一个ICMP<strong>重定向</strong>报文，以<u>告诉它一个更合理的下一跳</u>路由器。（优化路径）</p><p>4)将TTL值减1。</p><p>5)处理IP头部选项。</p><p>6)如果有必要，则执行IP分片操作。</p><h2 id="26-重定向"><a class="markdownIt-Anchor" href="#26-重定向"></a> 2.6 重定向</h2><p>图2-3显示了<u>ICMP重定向报文也能用于更新路由表</u>，因此本节我们简要讨论ICMP重定向。</p><h3 id="261-icmp重定向报文"><a class="markdownIt-Anchor" href="#261-icmp重定向报文"></a> 2.6.1 ICMP重定向报文</h3><p>ICMP重定向报文格式如图2-4所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091446138.png" alt="截屏2022-05-09 下午2.46.34" /></p><p>我们在1.1节讨论过ICMP报文头部的3个固定字段:8位类型、8位代码和16位校验和。ICMP重定向报文的类型值是5，代码字段有4个可选值，用来区分不同的重定向类型。本书仅讨论<strong>主机重定向</strong>，其代码值为1。</p><p>ICMP重定向报文的数据部分含义很明确，它给接收方提供了如下两个信息:</p><p>1、引起重定向的IP数据报(即图2-4中的原始IP数据报)的源端IP地址。</p><p>2、应该使用的路由器的IP地址。</p><p>接收主机根据这两个信息就可以断定引起重定向的IP数据报<u>应该使用哪个路由器来转发</u>，并且以此来更新路由表(通常是<strong>更新路由表缓冲</strong>，而不是直接更改路由表)。</p><p>/proc/sys/net/ipv4/conf/all/send_redirects内核参数指定<u>是否允许发送ICMP重定向报文</u>，而/proc/sys/net/ipv4/conf/all/accept_redirects内核参数则指定<u>是否允许接收ICMP重定向</u>报文。一般来说，<strong>主机只能接收</strong>ICMP重定向报文，而<strong>路由器只能发送</strong>ICMP重定向报文。</p><h3 id="262-主机重定向实例"><a class="markdownIt-Anchor" href="#262-主机重定向实例"></a> 2.6.2 主机重定向实例</h3><p>2.4.3节中，我们把机器ernest-laptop的<strong>网关</strong>设置成了机器Kongming20，2.5节中我们又使能了Kongming20的<strong>数据报转发</strong>功能，因此机器ernest-laptop将通过Kongming20来访问因特网，比如在ernest- laptop上执行如下ping命令:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"> $ping www.baidu.com<br>   PING www.a.shifen.<span class="hljs-built_in">com</span>(<span class="hljs-number">119.75</span><span class="hljs-number">.217</span><span class="hljs-number">.56</span>)<span class="hljs-number">56</span>(<span class="hljs-number">84</span>)bytes of data.<br>   <span class="hljs-function">From <span class="hljs-title">Kongming20</span><span class="hljs-params">(<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>)</span>:icmp_seq=</span><span class="hljs-number">1</span> <span class="hljs-function">Redirect <span class="hljs-title">Host</span><span class="hljs-params">(New</span></span><br><span class="hljs-params"><span class="hljs-function">nexthop:<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>)</span></span><br><span class="hljs-function">   64 bytes from 119.75.217.56:icmp_seq=</span><span class="hljs-number">1</span> ttl=<span class="hljs-number">54</span> time=<span class="hljs-number">6.78</span> ms<br>   ---www.a.shifen.com ping statistics---<br>   <span class="hljs-number">1</span> packets transmitted,<span class="hljs-number">1</span> received,<span class="hljs-number">0</span>%packet loss,time <span class="hljs-number">0</span>ms<br>   rtt min/avg/max/mdev=<span class="hljs-number">6.789</span>/<span class="hljs-number">6.789</span>/<span class="hljs-number">6.789</span>/<span class="hljs-number">0.000</span> ms<br></code></pre></td></tr></table></figure><p>从ping命令的输出来看，Kongming20给ernest-laptop发送了一个 ICMP重定向报文，告诉它请通过192.168.1.1来访问目标机器，因为这对ernest-laptop来说是更合理的路由方式。当主机ernest-laptop收到这样的ICMP重定向报文后，它将更新其路由表缓冲(使用命令route-Cn查看)，并使用新的路由方式来发送后续数据报。上面讨论的重定向过程可用图2-5来总结。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091501261.png" alt="截屏2022-05-09 下午3.01.26" /></p><p>PS: 相当于告诉你这条路不好使，告诉你一条更好的路线</p><h2 id="27-ipv6头部结构"><a class="markdownIt-Anchor" href="#27-ipv6头部结构"></a> 2.7 IPv6头部结构</h2><p>Pv6协议是网络层技术发展的必然趋势。它<strong>不仅解决了IPv4地址不够用</strong>的问题，还做了很大的改进。比如，<strong>增加了多播和流</strong>的功能，为网络上多媒体内容的质量提供精细的控制;引入自动配置功能，使得局域网管理更方便;<strong>增加了专门的网络安全功能</strong>等。本节简要地讨论 IPv6头部结构，它的更多细节请参考其标准文档RFC 2460。</p><h3 id="271-ipv6固定头部结构"><a class="markdownIt-Anchor" href="#271-ipv6固定头部结构"></a> 2.7.1 IPv6固定头部结构</h3><p>IPv6头部由40字节的固定头部和可变长的扩展头部组成。图2-6所示是IPv6的固定头部结构。<img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091506319.png" alt="截屏2022-05-09 下午3.06.55" /></p><p><strong>4位版本号(version)</strong>：指定IP协议的版本。对IPv6来说，其值是6。 8位通信类型(traffic class)指示数据流通信类型或优先级，和IPv4中的TOS类似。</p><p><strong>20位流标签(flow label)</strong>：是IPv6新增加的字段，用于某些对连接的服务质量有特殊要求的通信，比如音频或视频等实时数据传输。</p><p><strong>16位净荷长度(payload length)</strong>：指的是IPv6扩展头部和应用程序数 据长度之和，不包括固定头部长度。</p><p><strong>8位下一个包头(next header)</strong>：指出紧跟IPv6固定头部后的包头类 型，如扩展头(如果有的话)或某个上层协议头(比如TCP，UDP或 ICMP)。它类似于IPv4头部中的协议字段，且相同的取值有相同的含 义。</p><p><strong>8位跳数限制(hop limit)<strong>和</strong>IPv4中的TTL</strong>含义相同。</p><p><strong>IPv6用128位(16字节)</strong>:来表示IP地址，使得IP地址的总量达到了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>128</mn></msup></mrow><annotation encoding="application/x-tex">2^{128}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>个。所以有人说，“IPv6使得地球上的每粒沙子都有一个IP地址”。</p><p><strong>32位表示的IPv4地址</strong>一般用点分十进制来表示，而<strong>IPv6地址</strong>则用十六进制字符串表示，比如“FE80:0000:0000:0000:2234:5678:0000:0012”。可见，<strong>IPv6地址</strong>用“:”分割成8组，每组包含2字节。但这种表示方法过于麻烦，通常可以使用所谓的<strong>零压缩法</strong>来将其简写，也就是<strong>省略连续的、全零</strong>的组。 比如，上面的例子使用零压缩法可表示为“FE80::2234:5678:0000:0012”。不过零压缩法对一个IPv6地址<strong>只能使用一次</strong>，比如上面的例子中，字节组“5678”后面的全零组就不能再省略，否则我们就<u>无法计算每个“::”之间省略了多少个</u>全零组。</p><h3 id="272-ipv6扩展头部"><a class="markdownIt-Anchor" href="#272-ipv6扩展头部"></a> 2.7.2 IPv6扩展头部</h3><p>可变长的扩展头部使得IPv6能支持更多的选项，并且很便于将来的扩展需要。它的长度可以是0，表示<strong>数据报没使用任何扩展头部</strong>。一个数据报可以包含<strong>多个</strong>扩展头部，每个扩展头部的<u>类型由前一个头部</u> (固定头部或扩展头部)中的<u>下一个报头字段</u>指定。目前可以使用的m扩展头部如表2-3所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091514830.png" alt="截屏2022-05-09 下午3.14.02" /></p><p><strong>注意</strong> <u>IPv6协议并不是IPv4协议的简单扩展</u>，而是完全<strong>独立</strong>的协议。用以太网帧封装的IPv6数据报和IPv4数据报具有不同的类型值。</p><p>第1章提到，<strong>IPv4数据报</strong>的以太网帧封装类型值是0x800，而<strong>IPv6数据报</strong>的以太网帧封装类型值是0x86dd(见RFC 2464)。</p><h1 id="第3章-tcp协议详解"><a class="markdownIt-Anchor" href="#第3章-tcp协议详解"></a> 第3章 TCP协议详解</h1><p>TCP协议是TCP/IP协议族中另一个重要的协议。和IP协议相比， TCP协议<u>更靠近应用层</u>，因此在应用程序中具有<strong>更强的可操作性</strong>。一些 重要的socket选项都和TCP协议相关。</p><p>本章从如下四方面来讨论TCP协议:</p><p><strong>TCP头部信息</strong>:TCP头部信息出现在每个TCP报文段中，用于指定通信的源端端口号、目的端端口号，管理TCP连接，控制两个方向的数据流。</p><p><strong>TCP状态转移过程</strong>:TCP连接的任意一端都是一个状态机。在 TCP连接从建立到断开的整个过程中，连接两端的状态机将经历不同的状态变迁。理解TCP状态转移对于调试网络应用程序将有很大的帮助。</p><p><strong>TCP数据流</strong>:通过分析TCP数据流，我们就可以从网络应用程序外部来了解应用层协议和通信双方交换的应用程序数据。这一部分将讨论两种类型的TCP数据流:<u>交互数据流</u>和<u>成块数据流</u>。TCP数据流中有一种特殊的数据，称为<u>紧急数据</u>，我们也将简单讨论之。</p><p><strong>TCP数据流的控制</strong>:为了保证可靠传输和提高网络通信质量，内核需要对TCP数据流进行控制。这一部分讨论TCP数据流控制的两个方面:<u>超时重传</u>和<u>拥塞控制</u>。</p><p>不过在详细讨论TCP协议之前，我们先简单介绍一下TCP服务的特点，以及它和UDP服务的区别。</p><h2 id="31-tcp服务的特点"><a class="markdownIt-Anchor" href="#31-tcp服务的特点"></a> 3.1 TCP服务的特点</h2><p><strong>传输层协议</strong>主要有两个:<strong>TCP协议</strong>和<strong>UDP协议</strong>。TCP协议相对于UDP协议的特点是:面向连接、字节流和可靠传输。</p><p>使用TCP协议通信的双方必须<u>先建立连接</u>，然后才能开始数据的读写。双方都必须为该<u>连接分配必要的内核</u>资源，以管理连接的状态和连接上数据的传输。TCP连接是<strong>全双工</strong>的，即<u>双方的数据读写可以通过一个连接进行</u>。完成数据交换之后，通信双方都<u>必须断开</u>连接以释放 系统资源。</p><p>TCP协议的这种连接是<strong>一对一</strong>的，所以基于<strong>广播</strong>和<strong>多播</strong>(目标是多个主机地址)的应用程序<strong>不能使用</strong>TCP服务。而无连接协议<u>UDP则非常适合于广播和多播</u>。</p><p>我们在1.1节中简单介绍过<strong>字节流服务</strong>和<strong>数据报服务</strong>的区别。这种区别对应到实际编程中，则体现为通信双方<u>是否必须执行相同次数的 读、写操作</u>(当然，这只是表现形式)。</p><p>当发送端应用程序连续执行多次写操作时，TCP模块先将这些数据放入<strong>TCP发送缓冲区</strong>中。当TCP模块<strong>真正开始发送</strong>数据时，发送缓冲区中这些等待发送的数据可能被<strong>封装成一个或多个TCP报文</strong>段发出。因此，TCP模块发送出的<u>TCP报文段的个数和应用程序执行的写操作次数之间没有固定的数量关系</u>。(<u>因为是两个阶段的，所以他可以读和写不用同步</u>)</p><p>当接收端收到一个或多个TCP报文段后，TCP模块将它们携带的应用程序数据<u>按照TCP报文段的序号</u>(见后文)依次放入TCP接收缓冲区 中，并<u>通知应用程序读取</u>数据。接收端应用程序可以一次性将TCP接收缓冲区中的数据<u>全部读出，也可以分多次读取</u>，这取决于用户指定的应用程序读缓冲区的大小。因此，应用程序执行的读操作次数和TCP模块接收到的TCP报文段个数之间也没有固定的数量关系。（跟上面一样也是有缓冲区，所以是两个阶段）</p><p>综上所述，<strong>发送端执行的写操作次数和接收端执行的读操作次数之间没有任何数量关系</strong>，这就是<strong>字节流</strong>的概念:应用程序对数据的发送和接收是没有边界限制的。UDP则不然。发送端应用程序每执行一次写操作，UDP模块就将其封装成一个UDP数据报并发送之。接收端必须及时针对每一个UDP数据报执行读操作(通过recvfrom系统调用)，否则就会丢包(这经常发生在较慢的服务器上)。并且，如果用户没有指定足够的应用程序缓冲区来读取UDP数据，则UDP数据将被截断。（<u>UDP属于是一一对应的发送</u>）</p><p>图3-1和图3-2显示了TCP字节流服务和UDP数据报服务的上述区别。两图中省略了传输层以下的通信细节。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091554080.png" alt="截屏2022-05-09 下午3.54.17" /></p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091554401.png" alt="截屏2022-05-09 下午3.54.30" /></p><p>TCP传输是<strong>可靠的</strong>。</p><p>1、TCP协议采用发送应答机制，即发送端发送的每个TCP报文段都必须得到接收方的应答，才认为这个TCP报文段传输成功。</p><p>2、TCP协议采用超时重传机制，发送端在发送出一个 TCP报文段之后启动定时器，如果在定时时间内未收到应答，它将重发该报文段。3、因为TCP报文段最终是以IP数据报发送的，而IP数据报到达接收端<strong>可能乱序、重复</strong>，所以TCP协议还会对接收到的TCP报文段<strong>重排、整理，再交付</strong>给应用层。</p><p><u>UDP协议则和IP协议一样，提供不可靠服务</u>。它们都需要上层协议来处理数据确认和超时重传。</p><h2 id="32-tcp头部结构"><a class="markdownIt-Anchor" href="#32-tcp头部结构"></a> 3.2 TCP头部结构</h2><p>TCP头部信息出现在每个TCP报文段中，用于指定通信的源端端口，目的端端口，管理TCP连接等，本节详细介绍TCP的头部结构，包括固定头部结构和头部选项。</p><h3 id="321-tcp固定头部结构"><a class="markdownIt-Anchor" href="#321-tcp固定头部结构"></a> 3.2.1 TCP固定头部结构</h3><p>TCP头部结构如图3-3所示，其中的诸多字段为管理TCP连接和控制数据流提供了足够的信息。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091600766.png" alt="截屏2022-05-09 下午4.00.34" /></p><p><strong>16位端口号(port number)</strong>:告知主机该报文段是来自哪里(源端口)以及传给哪个上层协议或应用程序(目的端口)的。进行TCP通信时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号。1.3节中提到过，所有知名服务使用的端口号都定义在/etc/services文件中。</p><p><strong>32位序号(sequence number)</strong>:一次TCP通信(从TCP连接建立到断开)过程中某一个传输方向上的字节流的每个字节的编号。假设主机A和主机B进行TCP通信，A发送给B的第一个TCP报文段中，序号值被系统初始化为某个随机值ISN(Initial Sequence Number，初始序号 值)。那么在该传输方向上(从A到B)，后续的TCP报文段中序号值<u>将被系统设置成ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移</u>。例如，某个TCP报文段传送的数据是字节流中的第1025~2048字节，那么该报文段的序号值就是ISN+1025。另外一个传输方向 (从B到A)的TCP报文段的序号值也具有相同的含义。</p><p><strong>32位确认号(acknowledgement number)</strong>:用作对<u>另一方发送来的TCP报文段的响应</u>。其值是收到的TCP报文段的序号值加1。假设主机 A和主机B进行TCP通信，那么A发送出的TCP报文段不仅携带自己的序号，而且包含对B发送来的TCP报文段的确认号。反之，B发送出的 TCP报文段也同时携带自己的序号和对A发送来的报文段的确认号。</p><p><strong>4位头部长度(header length)</strong>:标识该TCP头部有多少个32bit字 (4字节)。因为4位最大能表示15，所以TCP头部最长是60字节。</p><p><strong>6位标志位</strong>包含如下几项:</p><p>1、URG标志，表示紧急指针(urgent pointer)是否有效。</p><p>2、ACK标志，表示确认号是否有效。我们称携带ACK标志的TCP报文段为确认报文段。</p><p>3、PSH标志，提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间(如果应用程序不将接收到的数据读走，它们就会一直停留在TCP接收缓冲区中)。</p><p>4、RST标志，表示要求对方重新建立连接。我们称携带RST标志的TCP报文段为复位报文段。</p><p>5、SYN标志，表示请求建立一个连接。我们称携带SYN标志的TCP报文段为同步报文段。</p><p>6、FIN标志，表示通知对方本端要关闭连接了。我们称携带FIN标志的TCP报文段为结束报文段。</p><p><strong>16位窗口大小(window size)</strong>:是<u>TCP流量控制</u>的一个手段。这里说的窗口，指的是接收通告窗口(Receiver Window，RWND)。它告诉对方本端的<u>TCP接收缓冲区还能容纳多少字节</u>的数据，这样对方就可以控制发送数据的速度。</p><p><strong>16位校验和(TCP checksum)</strong>:由发送端填充，接收端对TCP报 文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这 个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一 个重要保障。</p><p><strong>16位紧急指针(urgent pointer)</strong>:是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是<u>紧急指针相对当前序号的偏移</u>，不妨称之为紧急偏移。TCP的紧急指针是<u>发送端向接收端发送紧急数据</u>的方法。我们将在后面讨论TCP紧急数据。</p><h3 id="322-tcp头部选项"><a class="markdownIt-Anchor" href="#322-tcp头部选项"></a> 3.2.2 TCP头部选项</h3><p>TCP头部的最后一个选项字段(options)是<u>可变长的可选</u>信息。这部分最多包含40字节，因为TCP头部最长是60字节(其中还包含前面讨论的20字节的固定部分)。典型的TCP头部选项结构如图3-4所示。<img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091629187.png" alt="截屏2022-05-09 下午4.29.12" /></p><p>选项的第一个字段kind说明选项的类型。有的TCP选项没有后面两个字段，仅包含1字节的kind字段。第二个字段length(如果有的话)指定该选项的总长度，该长度包括kind字段和length字段占据的2字节。第三个字段info(如果有的话)是选项的具体信息。常见的TCP选项有7 种，如图3-5所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091633489.png" alt="截屏2022-05-09 下午4.33.50" /></p><p>kind=0是选项表结束选项。</p><p>kind=1是空操作(nop)选项，没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍。</p><p>kind=2是最大报文段长度选项。TCP连接初始化时，通信双方使用 该选项来协商最大报文段长度(Max Segment Size，MSS)。TCP模块 通常将MSS设置为(MTU-40)字节(减掉的这40字节包括20字节的 TCP头部和20字节的IP头部)。这样携带TCP报文段的IP数据报的长度就不会超过MTU(假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况)，从而避免本机发生IP分片。对以太网而言，MSS值是1460(1500-40)字节。</p><p>kind=3是窗口扩大因子选项。TCP连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子。在TCP的头部中，接收通告窗口 大小是用16位表示的，故最大为65535字节，但实际上TCP模块允许的接收通告窗口大小远不止这个数(为了提高TCP通信的吞吐量)。窗口扩大因子解决了这个问题。假设TCP头部中的接收通告窗口大小是N， 窗口扩大因子(移位数)是M，那么TCP报文段的实际接收通告窗口大小是N乘2M，或者说N左移M位。注意，M的取值范围是0~14。我们可以通过修改/proc/sys/net/ipv4/tcp_window_scaling内核变量来启用或关闭窗口扩大因子选项。</p><p>和MSS选项一样，窗口扩大因子选项只能出现在同步报文段中， 否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该TCP报文段的实际接收通告窗口大小。当连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了。关于窗口扩大因子选项的细节，可参考标准文档RFC 1323。</p><p>kind=4是选择性确认(Selective Acknowledgment，SACK)选项。 TCP通信时，如果某个TCP报文段丢失，则TCP模块会重传最后被确认 的TCP报文段后续的所有报文段，这样<u>原先已经正确传输的TCP报文段也可能重复发送，从而降低了TCP性能</u>。SACK技术正是为改善这种情况而产生的，它使TCP模块只重新发送丢失的TCP报文段，不用发送所有未被确认的TCP报文段。选择性确认选项用在连接初始化时，表示是否支持SACK技术。我们可以通过修改/proc/sys/net/ipv4/tcp_sack内核变量来启用或关闭选择性确认选项。</p><p>kind=5是SACK实际工作的选项。该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。每个块边沿(edge of block)参数包含一个4字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数(块左边沿和块右边沿)之间的数据是没有收到的。因为一个块信息占用8字节，所以TCP头部选项中实际上最多可以包含4个这样的不连续数据块(考虑选项类型和长度占用的2字节)。</p><p>kind=8是时间戳选项。该选项提供了较为准确的计算通信双方之间的回路时间(Round Trip Time，RTT)的方法，从而为TCP流量控制提供重要信息。我们可以通过修改/proc/sys/net/ipv4/tcp_timestamps内核变量来启用或关闭时间戳选项。</p><h3 id="323-使用tcpdump观察tcp头部信息"><a class="markdownIt-Anchor" href="#323-使用tcpdump观察tcp头部信息"></a> 3.2.3 使用tcpdump观察TCP头部信息</h3><p>在2.3节中，我们利用tcpdump抓取了一个数据包并分析了其中的IP头部信息，本节分析其中与TCP协议相关的部分(后面的分析中，我们 将所有<u>tcpdump抓取到的数据包都称为TCP报文段</u>，因为TCP报文段既是数据包的主要内容，也是我们主要讨论的对象)。为了方便阅读， 先将该TCP报文段的内容复制于代码清单3-1中。</p><p>代码清单3-1 用tcpdump抓取数据包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.41621</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[S],seq <span class="hljs-number">3499745539</span>,win <span class="hljs-number">32792</span>,options[mss <span class="hljs-number">16396</span>,sackOK,TS val <span class="hljs-number">40781017</span> ecr <span class="hljs-number">0</span>,nop,wscale <span class="hljs-number">6</span>],length <span class="hljs-number">0</span><br><span class="hljs-number">0x0000</span>:<span class="hljs-number">4510</span> <span class="hljs-number">003</span>c a5da <span class="hljs-number">4000</span> <span class="hljs-number">4006</span> <span class="hljs-number">96</span>cf <span class="hljs-number">7f</span>00 <span class="hljs-number">0001</span><br><span class="hljs-number">0x0010</span>:<span class="hljs-number">7f</span>00 <span class="hljs-number">0001</span> a295 <span class="hljs-number">0017</span> d099 e103 <span class="hljs-number">0000</span> <span class="hljs-number">0000</span><br><span class="hljs-number">0x0020</span>:a002 <span class="hljs-number">8018</span> fe30 <span class="hljs-number">0000</span> <span class="hljs-number">0204</span> <span class="hljs-number">400</span>c <span class="hljs-number">0402</span> <span class="hljs-number">080</span>a<br><span class="hljs-number">0x0030</span>:<span class="hljs-number">026</span>e <span class="hljs-number">44</span>d9 <span class="hljs-number">0000</span> <span class="hljs-number">0000</span> <span class="hljs-number">0103</span> <span class="hljs-number">0306</span><br></code></pre></td></tr></table></figure><p><strong>tcpdump输出Flags[S]</strong>，表示该TCP报文段包含SYN标志，因此它是一个<strong>同步报文段</strong>。如果TCP报文段包含其他标志，则tcpdump也会将该<strong>标志的首字母</strong>显示在“Flags”后的方括号中。</p><p><strong>seq是序号值</strong>。因为该同步报文段是从127.0.0.1.41621(客户端IP地址和端口号)到127.0.0.1.23(服务器IP地址和端口号)这个传输方向上的第一个TCP报文段，所以这个序号值也就是此次通信过程中该传输方向的<strong>ISN值</strong>。并且，因为这是整个通信过程中的第一个TCP报文段， 所以它没有针对对方发送来的TCP报文段的确认值(尚未收到任何对方发送来的TCP报文段)。</p><p><strong>win是接收通告窗口的大小</strong>。因为这是一个同步报文段，所以win值反映的是实际的接收通告窗口大小。</p><p><strong>options是TCP选项</strong>，其具体内容列在方括号中。<strong>mss</strong>是发送端(客户端)通告的最大报文段长度。通过ifconfig命令查看回路接口的MTU为16436字节，因此可以预想到TCP报文段的MSS为16396(16436-40) 字节。<strong>sackOK</strong>表示发送端支持并同意使用SACK选项。<strong>TS val</strong>是发送端的时间戳。<strong>ecr</strong>是时间戳回显应答。因为这是一次TCP通信的第一个 TCP报文段，所以它针对对方的时间戳的应答为0(尚未收到对方的时 间戳)。紧接着的<strong>nop</strong>是一个空操作选项。<strong>wscale</strong>指出发送端使用的窗口扩大因子为6。</p><p>接下来我们分析tcpdump输出的字节码中TCP头部对应的信息，它从第21字节开始，如表3-1所示。第一列的16进制没用，就是代表行号。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091654334.png" alt="截屏2022-05-09 下午4.54.28" /></p><p>从表3-1中可见，TCP报文段头部的二进制码和tcpdump输出的TCP报文段描述信息完全对应。在后面的tcpdump输出中，我们将省略大部 分TCP头部信息，仅显示序号、确认号、窗口大小以及标志位等与主题相关的字段。</p><h2 id="33-tcp连接的建立和关闭"><a class="markdownIt-Anchor" href="#33-tcp连接的建立和关闭"></a> 3.3 TCP连接的建立和关闭</h2><p>本节我们讨论建立和关闭TCP连接的过程。</p><h3 id="331-使用tcpdump观察tcp连接的建立和关闭"><a class="markdownIt-Anchor" href="#331-使用tcpdump观察tcp连接的建立和关闭"></a> 3.3.1 使用tcpdump观察TCP连接的建立和关闭</h3><p>首先从ernest-laptop上<u>执行telnet命令登录Kongming20的80端口</u>，然后抓取这一过程中<u>客户端和服务器交换的TCP报文段</u>。具体操作过程如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -i eth0 -nt<span class="hljs-number">&#x27;</span>(src <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-keyword">and</span> dst <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>)<span class="hljs-built_in"><span class="hljs-keyword">or</span></span>(src <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-keyword">and</span> dst <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>)&#x27;<br>$telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">80</span> Trying <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>... Connected to <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>. Escape character is<span class="hljs-number">&#x27;</span>^]<span class="hljs-string">&#x27;. ^](回车)#输入ctrl+]并回车 telnet&gt;quit(回车) Connection closed.</span><br></code></pre></td></tr></table></figure><p>当执行telnet命令并在两台通信主机之间建立TCP连接后(telnet输出“Connected to 192.168.1.109”)，输入Ctrl+]以调出telnet程序的命令提 示符，然后在telnet命令提示符后输入quit以退出telnet客户端程序，从而结束TCP连接。整个过程中(从连接建立到结束)，tcpdump输出的 内容如代码清单3-2所示。</p><p><strong>代码清单3-2 建立和关闭TCP连接的过程</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>:Flags[S],seq <span class="hljs-number">535734930</span>,win <span class="hljs-number">5840</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>:Flags[S.],seq <span class="hljs-number">2159701207</span>,ack <span class="hljs-number">535734931</span>,win <span class="hljs-number">5792</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">1</span>,win <span class="hljs-number">92</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>:Flags[F.],seq <span class="hljs-number">1</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">92</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>:Flags[.],ack <span class="hljs-number">2</span>,win <span class="hljs-number">91</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">6.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>:Flags[F.],seq <span class="hljs-number">1</span>,ack <span class="hljs-number">2</span>,win <span class="hljs-number">91</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">7.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60871</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">2</span>,win <span class="hljs-number">92</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>因为整个过程并<strong>没有发生应用层数据的交换</strong>，所以TCP报文段的数据部分的<strong>长度(length)总是0</strong>。为了更清楚地表示建立和关闭TCP连接 的整个过程，我们将tcpdump输出的内容绘制成图3-6所示的时序图。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091740284.png" alt="" /></p><h4 id="tcp三次握手tcp连接"><a class="markdownIt-Anchor" href="#tcp三次握手tcp连接"></a> TCP三次握手（TCP连接）</h4><p><strong>第1个TCP报文段</strong>包含SYN标志，因此它是一个<u>同步报文段</u>，即ernest-laptop(客户端)向Kongming20(服务器)发起连接请求。同时，该同步报文段包含一个ISN值为535734930的序号。</p><p><strong>第2个TCP报文段</strong>也是<u>同步报文段</u>，表示Kongming20同意与ernest-laptop建立连接。同时它发送自己的ISN值为2159701207的序号，并<u>对第1个同步报文段进行确认</u>。确认值是535734931，即第1个同步报文段的序号值加1。</p><p>前文说过，序号值是<u>用来标识TCP数据流中的每一字节</u>的。但<u>同步报文段比较特殊</u>，即使它并没有携带任何应用程序数据，它也要占用一个序号值。</p><p><strong>第3个TCP报文段</strong>是ernest-laptop对第2个同步报文段的确认。至此，TCP连接就建立起来了。建立TCP连接的这3个步骤被称为<strong>TCP三次握手。</strong></p><p>从第3个TCP报文段开始，tcpdump输出的序号值和确认值都是<u>相对初始ISN值的偏移</u>。当然，我们可以开启tcpdump的-S选项来选择打印 序号的绝对值。</p><h4 id="tcp四次握手tcp断开连接"><a class="markdownIt-Anchor" href="#tcp四次握手tcp断开连接"></a> TCP四次握手（TCP断开连接）</h4><p>后面4个TCP报文段是关闭连接的过程。</p><p><strong>第4个TCP报文段</strong>包含FIN标志，因此它是一个结束报文段，即ernest-laptop要求关闭连接。结束报文段和同步报文段一样，也要占用一个序号值。</p><p><strong>Kongming20用TCP报文段5</strong>来确认该结束报文段。紧接着Kongming20发送自己的结束报文段6，ernest-laptop则用TCP报文段7给予确认。实际上，仅用于确认目的的确认报文段5是<u>可以省略</u>的，因为<strong>结束报文段6也携带了该确认信息</strong>。确认报文段5是否出现在连接断开的过程中，取决于TCP的延迟确认特性。延迟确认将在后面讨论。</p><p>在连接的关闭过程中，因为ernest-laptop先发送结束报文段(telnet客户端程序主动退出)，故称<strong>ernest-laptop执行主动关闭</strong>，而称 <strong>Kongming20执行被动关闭</strong>。</p><p>一般而言，TCP连接是由客户端发起，并通过三次握手建立(特殊情况是所谓同时打开[1])的。TCP连接的关闭过程相对复杂一些。可能是客户端执行主动关闭，比如前面的例子;也可能是服务器执行主动关闭，比如服务器程序被中断而强制关闭连接;还可能是同时关闭(和同时打开一样，非常少见)。</p><h3 id="332-半关闭状态"><a class="markdownIt-Anchor" href="#332-半关闭状态"></a> 3.3.2 半关闭状态</h3><p>TCP连接是<strong>全双工</strong>的，所以<strong>它允许两个方向的数据传输被独立关闭</strong>。换言之，通信的一端可以发送结束报文段给对方，告诉它本端已经完成了数据的发送，但允许继续接收来自对方的数据，直到对方也发送结束报文段以关闭连接。TCP连接的这种状态称为<strong>半关闭(half close)状态</strong>，如图3-7所示。（一方结束了，等待另一方也结束的状态叫半关闭）</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205091833324.png" alt="截屏2022-05-09 下午6.33.29" /></p><p>请注意，在图3-7中，服务器和客户端应用程序判断对方<u>是否已经关闭连接</u>的方法是:<u>read系统调用返回0</u>(收到结束报文段)。当然， Linux还提供其他检测连接是否被对方关闭的方法，这将在后续章节讨论。</p><p>socket网络编程接口通过shutdown函数提供了对半关闭的支持，我们将在后续章节讨论它。这里强调一下，虽然我们介绍了<strong>半关闭状态</strong>，但是使用半关闭的应用程序很少见。</p><h3 id="333-连接超时"><a class="markdownIt-Anchor" href="#333-连接超时"></a> 3.3.3 连接超时</h3><p>前面我们讨论的是很快建立连接的情况。如果客户端访问一个距离它<strong>很远</strong>的服务器，或者由于网络繁忙，导致服务器对于客户端发送出的同步报文段没有应答，此时客户端程序将产生什么样的行为呢? 显然，对于提供可靠服务的TCP来说，它必然是先进行重连(可能执行多次)，如果重连仍然无效，则通知应用程序连接超时。</p><p>为了观察连接超时，我们模拟一个繁忙的服务器环境，在ernest-laptop上执行下面的操作:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo iptables -F<br>$sudo iptables -I INPUT -p tcp --syn -i eth0 -j DROP<br></code></pre></td></tr></table></figure><p>iptable命令用于<strong>过滤数据包</strong>，这里我们利用它来<u>丢弃所有接收到的连接请求</u>(丢弃所有同步报文段，这样客户端就无法得到任何确认报文段)。</p><p>接下来从Kongming20上执行telnet命令登录到ernest-laptop，并用tcpdump抓取这个过程中双方交换的TCP报文段。具体操作如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -n -i eth0 port <span class="hljs-number">23</span>#仅抓取telnet客户端和服务器交换的数据包<br>$date; telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>; date#在telnet命令前后都执行date命令，以计算超时时间<br>Mon Jun <span class="hljs-number">11</span> <span class="hljs-number">21</span>:<span class="hljs-number">23</span>:<span class="hljs-number">35</span> CST <span class="hljs-number">2012</span><br>Trying <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>...<br>telnet:connect to address <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:Connection timed out<br>Mon Jun <span class="hljs-number">11</span> <span class="hljs-number">21</span>:<span class="hljs-number">24</span>:<span class="hljs-number">38</span> CST <span class="hljs-number">2012</span><br></code></pre></td></tr></table></figure><p>从两次date命令的输出来看，Kongming20建立TCP连接的超时时间是63s。本次tcpdump的输出如代码清单3-3所示。</p><p>代码清单3-3 TCP超时重连</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.21</span>:<span class="hljs-number">23</span>:<span class="hljs-number">35.612136</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.39385</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.telnet:Flags[S],seq <span class="hljs-number">1355982096</span>，length <span class="hljs-number">0</span><br><span class="hljs-number">2.21</span>:<span class="hljs-number">23</span>:<span class="hljs-number">36.613146</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.39385</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.telnet:Flags[S],seq <span class="hljs-number">1355982096</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">3.21</span>:<span class="hljs-number">23</span>:<span class="hljs-number">38.617279</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.39385</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.telnet:Flags[S],seq <span class="hljs-number">1355982096</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.21</span>:<span class="hljs-number">23</span>:<span class="hljs-number">42.625140</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.39385</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.telnet:Flags[S],seq <span class="hljs-number">1355982096</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">5.21</span>:<span class="hljs-number">23</span>:<span class="hljs-number">50.641344</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.39385</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.telnet:Flags[S],seq <span class="hljs-number">1355982096</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">6.21</span>:<span class="hljs-number">24</span>:<span class="hljs-number">06.673331</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.39385</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.telnet:Flags[S],seq <span class="hljs-number">1355982096</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>这次抓包我们保留了tcpdump输出的时间戳(不使用其-t选项)，以便推理Linux的超时重连策略。</p><p>我们一共抓取到6个TCP报文段，它们都是<strong>同步报文段</strong>，并且具有<strong>相同的序号值</strong>，这说明后面5个同步报文段都是<u>超时重连报文段</u>。观察 这些TCP报文段被发送的时间间隔，它们分别为1s、2s、4s、8s和16s(由于定时器精度的问题，这些时间间隔都有一定偏差)，可以推断最后一个TCP报文段的超时时间是32s(63s-16s-8s-4s-2s-1s)。因此，TCP模块一共执行了5次重连操作，这是由/proc/sys/net/ipv4/tcp_syn_retries内核变量所定义的。<strong>每次重连的超时时间都增加一倍</strong>。在5次重连均失败的情况下，TCP模块放弃连接并通知应用程序。</p><p>在应用程序中，我们可以修改连接超时时间，具体方法将在本书后续章节中进行介绍。</p><h2 id="34-tcp状态转移"><a class="markdownIt-Anchor" href="#34-tcp状态转移"></a> 3.4 TCP状态转移</h2><p>TCP连接的<u>任意一端在任一时刻都处于某种状态</u>，当前状态可以通过netstat命令(见第17章)查看。本节我们要讨论的是TCP连接从建立到关闭的整个过程中通信两端状态的变化。图3-8是完整的状态转移图，它描绘了所有的TCP状态以及可能的状态转换。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205092023605.png" alt="截屏2022-05-09 下午8.23.24" /></p><p>图3-8中的<strong>粗虚线</strong>表示<strong>典型的服务器端连接的状态转移</strong>;<strong>粗实线</strong>表示<strong>典型的客户端连接的状态转移</strong>。<strong>CLOSED</strong>是一个<strong>假想的起始点</strong>，并不是一个实际的状态。</p><h3 id="341-tcp状态转移总图"><a class="markdownIt-Anchor" href="#341-tcp状态转移总图"></a> 3.4.1 TCP状态转移总图</h3><p>我们先讨论服务器的典型状态转移过程，此时我们说的<u>连接状态都是指该连接的服务器端的状态</u>。</p><p>1、服务器通过listen系统调用(见第5章)进入<strong>LISTEN状态</strong>，<u>被动等待客户端连接</u>，因此执行的是所谓的被动打开。</p><p>2、服务器一旦监听到某个连接请求(收到同步报文段)，就将该连接放入内核等待队列中，并向客户端发送带SYN标志的确认报文段。此时该连接处于SYN_RCVD状态。</p><p>3、如果服务器成功地接收到客户端发送回的确认报文段，则该连接转移到ESTABLISHED状态。<strong>ESTABLISHED状态</strong>是<strong>连接双方能够进行双向数据传输的状态</strong>。</p><p>4、当客户端主动关闭连接时(通过close或shutdown系统调用向服务器发送结束报文段)，服务器通过返回确认报文段使连接进入<strong>CLOSE_WAIT</strong>状态。这个状态的含义很明确:<u>等待服务器应用程序关闭连接</u>。通常，<u>服务器检测到客户端关闭连接后，也会立即给客户端发送一个结束报文段来关闭连接</u>。这将使连接转移到<strong>LAST_ACK</strong>状态，以等待客户端对结束报文段的最后一次确认。一旦确认完成，连 接就彻底关闭了。</p><p>下面讨论客户端的典型状态转移过程，此时我们说的<strong>连接状态</strong>都是指<strong>该连接的客户端的状态</strong>。</p><p>客户端通过connect系统调用(见第5章)<u>主动与服务器建立连接</u>。 connect系统调用首先给服务器发送一个同步报文段，使连接转移到 SYN_SENT状态。此后，connect系统调用可能因为如下两个原因失败返回:</p><p>1、如果connect连接的目标端口不存在(未被任何进程监听)，或者该端口仍被处于TIME_WAIT状态的连接所占用(见后文)，则服务器将给客户端发送一个复位报文段，connect调用失败。</p><p>2、如果目标端口存在，但connect在超时时间内<u>未收到服务器的确认报文段</u>，则connect调用失败。</p><p>connect调用失败将使连接立即返回到初始的<strong>CLOSED状态</strong>。如果客户端成功收到服务器的同步报文段和确认，则connect调用成功返 回，连接转移至ESTABLISHED状态。</p><p>当客户端执行主动关闭时，它将向服务器发送一个结束报文段， 同时连接进入FIN_WAIT_1状态。若此时客户端收到服务器专门用于确认目的的确认报文段(比如图3-6中的TCP报文段5)，则连接转移至FIN_WAIT_2状态。当客户端处于FIN_WAIT_2状态时，服务器处于 CLOSE_WAIT状态，这一对状态是可能发生半关闭的状态。此时如果服务器也关闭连接(发送结束报文段)，则客户端将给予确认并进入 TIME_WAIT状态。关于TIME_WAIT状态的含义，我们将在下一节讨论。</p><p>图3-8还给出了客户端从FIN_WAIT_1状态直接进入TIME_WAIT状态的一条线路(不经过FIN_WAIT_2状态)，前提是处于<strong>FIN_WAIT_1状态的服务器直接收到带确认信息的结束报文段</strong>(而不是先收到确认报文段，再收到结束报文段)。这种情况对应于图3-6中的服务器不发送TCP报文段5。</p><p>前面说过，处于FIN_WAIT_2状态的客户端需要等待服务器发送结束报文段，才能转移至TIME_WAIT状态，否则它将一直停留在这个状 态。如果不是为了在半关闭状态下继续接收数据，<u>连接长时间地停留在FIN_WAIT_2状态并无益处</u>。（属于一个工作一个不工作）连接停留在FIN_WAIT_2状态的情况可能发生在**:客户端执行半关闭<strong>后，未等服务器关闭连接就强行退出了。此时客户端连接由内核来接管，可称之为孤儿连接(和孤儿进程类似)。</strong>（相当于找了个保姆替你看着）<strong>Linux为了防止孤儿连接长时间存留在内核中，定义了两个内核变量:/proc/sys/net/ipv4/tcp_max_orphans 和/proc/sys/net/ipv4/tcp_fin_timeout。前者指定内核能接管的</strong>孤儿连接数目**，后者指定孤儿连接在内核中<strong>生存的时间</strong>。</p><p>至此，我们简单地讨论了服务器和客户端程序的典型TCP状态转移路线。对应于图3-6所示的TCP连接的建立与断开过程，客户端和服务 器的状态转移如图3-9所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205121608151.png" alt="截屏2022-05-12 下午4.08.47" /></p><p>图3-8<u>还描绘了其他非典型的TCP状态转移路线</u>，比如同时关闭与同时打开，本书不予讨论。</p><h3 id="342-time_wait状态"><a class="markdownIt-Anchor" href="#342-time_wait状态"></a> 3.4.2 TIME_WAIT状态</h3><p>从图3-9来看，客户端连接在收到服务器的结束报文段(TCP报文段6)之后，并没有直接进入CLOSED状态[1]，而是转移到TIME_WAIT状态。在这个状态，<u>客户端连接要等待一段长为2MSL(Maximum Segment Life，报文段最大生存时间)的时间</u>，才能完全关闭。MSL是 TCP报文段在网络中的最大生存时间，标准文档RFC 1122的建议值是2 min。</p><h4 id="time_wait状态存在的原因有两点"><a class="markdownIt-Anchor" href="#time_wait状态存在的原因有两点"></a> TIME_WAIT状态存在的原因有两点:</h4><p>1、可靠地终止TCP连接。</p><p>2、保证让迟来的TCP报文段有足够的时间被识别并丢弃。</p><p>第一个原因很好理解。假设图3-9中用于确认服务器结束报文段6的TCP报文段7丢失，那么服务器将重发结束报文段。因此客户端需要停 留在某个状态以处理重复收到的结束报文段(即向服务器发送确认报文段)。否则，客户端将以复位报文段来回应服务器，服务器则认为这是一个错误，因为它期望的是一个像TCP报文段7那样的确认报文段。</p><p>在Linux系统上，<strong>一个TCP端口不能被同时打开多次</strong>(两次及以上)。当一个TCP连接处于TIME_WAIT状态时，我们将无法立即使用该连接占用着的端口来建立一个新连接。反过来思考，如果不存在TIME_WAIT状态，则应用程序能够立即建立一个和刚关闭的连接相似的连接(这里说的相似，是指它们具有相同的IP地址和端口号)。这个新的、和原来相似的连接被称为<strong>原来的连接的化身(incarnation)</strong>。 新的化身可能接收到属于原来的连接的、携带应用程序数据的TCP报文段(迟到的报文段)，这显然是不应该发生的。这就是TIME_WAIT状态存在的第二个原因。</p><p>另外，因为TCP报文段的<strong>最大生存时间是MSL</strong>，所以<u>坚持2MSL时间的TIME_WAIT状态能够确保网络上两个传输方向上尚未被接收到的、迟到的TCP报文段都已经消失(被中转路由器丢弃)</u>。因此，一个连接的新的化身可以在2MSL时间之后安全地建立，而绝对不会接收到属于原来连接的应用程序数据，<strong>这就是TIME_WAIT状态要持续2MSL时间</strong>的原因。</p><p>有时候我们希望<u>避免TIME_WAIT状态</u>，因为当程序退出后，我们希望能够立即重启它。但由于处在TIME_WAIT状态的连接还占用着端 口，程序将无法启动(直到2MSL超时时间结束)。</p><h4 id="考虑一个例子"><a class="markdownIt-Anchor" href="#考虑一个例子"></a> 考虑一个例子:</h4><p>在测试机器ernest-laptop上以客户端方式运行nc(用于创建网络连接的工具，见第17章)命令，登录本机的Web服务，且明确指定客户端使用12345端口与服务器通信。然后从终端输入Ctrl+C终止客户端程序，接着又立即重启nc程序，以完全相同的方式再次连接本机的Web服务。具体操作如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">$nc-p <span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-number">80</span><br>ctrl+C#中断客户端程序<br>$nc-p <span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-number">80</span>#重启客户端程序，重新建立连接<br>nc:bind failed:Address already in use#输出显示连接失败，因为<span class="hljs-number">12345</span>端口<br>仍被占用<br>$netstat-nat#用netstat命令查看连接状态<br>Proto Recv-Q Send-Q Local Address Foreign Address State tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">80</span> TIME_WAIT<br></code></pre></td></tr></table></figure><p>这里我们使用netstat命令查看连接的状态。其输出显示，客户端程序被中断后，连接进入TIME_WAIT状态，12345端口仍被占用，所以 客户端重启失败。</p><p>对客户端程序来说，我们通常不用担心上面描述的重启问题。因为客户端<u>一般使用系统自动分配的临时端口号来建立连接</u>，而由于随机性，临时端口号一般和程序上一次使用的端口号(还处于TIME_WAIT状态的那个连接使用的端口号)不同，所以客户端程序一般可以立即重启。上面的例子仅仅是为了说明问题，我们强制客户端使用12345端口，这才导致立即重启客户端程序失败。</p><p>但如果是服务器主动关闭连接后异常终止，则因为它总是使用同一个知名服务端口号，所以连接的TIME_WAIT状态将导致它不能立即 重启。不过，我们可以通过socket选项SO_REUSEADDR来强制进程立 即使用处于TIME_WAIT状态的连接占用的端口，这将在第5章讨论。</p><h2 id="35-复位报文段"><a class="markdownIt-Anchor" href="#35-复位报文段"></a> 3.5 复位报文段</h2><p>在某些特殊条件下，<u>TCP连接的一端会向另一端发送携带RST标志的报文段，即复位报文段</u>，以通知对方关闭连接或重新建立连接。 本节讨论产生复位报文段的3种情况。</p><h3 id="351-访问不存在的端口"><a class="markdownIt-Anchor" href="#351-访问不存在的端口"></a> 3.5.1 访问不存在的端口</h3><p>3.4.1小节提到，当客户端程序访问一个不存在的端口时，目标主机将给它发送一个复位报文段。考虑从Kongming20上执行telnet命令登 录ernest-laptop上一个不存在的54321端口，并用tcpdump抓取该过程中两台主机交换的TCP报文段。具体操作过程如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -nt -i eth0 port <span class="hljs-number">54321</span>#仅抓取发送至和来自<span class="hljs-number">54321</span>端口的TCP报文段<br> $telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-number">54321</span><br> Trying <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>...<br> telnet:connect to address <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:Connection refused<br></code></pre></td></tr></table></figure><p>telnet程序的输出显示连接被<strong>拒绝</strong>了，因为这个端口<strong>不存在</strong>。 tcpdump抓取到的TCP报文段内容如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.42001</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.54321</span>:Flags[S],seq <span class="hljs-number">21621375</span>,win <span class="hljs-number">14600</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.54321</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.42001</span>:Flags[R.],seq <span class="hljs-number">0</span>,ack <span class="hljs-number">21621376</span>,win <span class="hljs-number">0</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>由此可见，ernest-laptop针对Kongming20的连接请求(同步报文段)回应了一个复位报文段(tcpdump输出R标志)。因为复位报文段的接收通告窗口大小为0，所以可以预见:收到复位报文段的一端应该关闭连接或者重新连接，而不能回应这个复位报文段。</p><p>实际上，当客户端程序向服务器的某个端口发起连接，而该端口仍被处于TIME_WAIT状态的连接所占用时，客户端程序也将收到复位报文段。</p><h3 id="352-异常终止连接"><a class="markdownIt-Anchor" href="#352-异常终止连接"></a> 3.5.2 异常终止连接</h3><p>前面讨论的连接终止方式都是正常的终止方式:数据交换完成之后，一方给另一方发送结束报文段。TCP提供了异常终止一个连接的方法，即给对方发送一个复位报文段。一旦发送了复位报文段，发送端所有排队等待发送的数据都将被丢弃。</p><p>应用程序可以使用socket选项SO_LINGER来发送复位报文段，以异常终止一个连接。我们将在第5章讨论SO_LINGER选项。</p><h3 id="353-处理半打开连接"><a class="markdownIt-Anchor" href="#353-处理半打开连接"></a> 3.5.3 处理半打开连接</h3><p>考虑下面的情况:服务器(或客户端)关闭或者异常终止了连接，而对方没有接收到结束报文段(比如发生了网络故障)，此时，客户端(或服务器)还维持着原来的连接，而服务器(或客户端)即使重启，也已经没有该连接的任何信息了。我们将这种状态称为<strong>半打开状态</strong>，处于这种状态的连接称为半打开连接。如果客户端(或服务器)往处于半打开状态的连接写入数据，则对方将回应一个复位报文段。（属于是客户单方面苦等）</p><p>举例来说，我们在Kongming20上使用nc命令模拟一个服务器程序，使之监听12345端口，然后从ernest-laptop运行telnet命令登录到该 端口上，接着拔掉ernest-laptop的网线，并在Kongming20上中断服务器程序。显然，此时ernest-laptop上运行的telnet客户端程序维持着一个半打开连接。然后接上ernest-laptop的网线，并从客户端程序往半打开连接写入1字节的数据“a”。同时，运行tcpdump程序抓取整个过程中telnet客户端和nc服务器交换的TCP报文段。具体操作过程如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">$nc -l <span class="hljs-number">12345</span>#在Kongming20上运行服务器程序<br>$sudo tcpdump -nt -i eth0 port <span class="hljs-number">12345</span><br>$telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">12345</span>#在ernest-laptop上运行客户端程序 Trying <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>...<br>Connected to <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>.<br>Escape character is<span class="hljs-number">&#x27;</span>^]<span class="hljs-string">&#x27;.#此时断开ernest-laptop的网线，并重启服务器 a(回车)#向半打开连接输入字符a</span><br><span class="hljs-string">Connection closed by foreign host.</span><br></code></pre></td></tr></table></figure><p>telnet的输出显示，连接被服务器关闭了。tcpdump抓取到的TCP 报文段内容如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.55100</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.12345</span>:Flags[S],seq <span class="hljs-number">3093809365</span>,length <span class="hljs-number">0</span>      <br><span class="hljs-number">2.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.55100</span>:Flags[S.],seq <span class="hljs-number">1495337791</span>,ack <span class="hljs-number">3093809366</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.55100</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.12345</span>:Flags[.],ack <span class="hljs-number">1</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.55100</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.12345</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">4</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">3</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.55100</span>:Flags[R],seq <span class="hljs-number">1495337792</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>该输出内容中，前3个TCP报文段是正常建立TCP连接的3次握手的过程。</p><p>第4个TCP报文段由客户端发送给服务器，它携带了3字节的应用程序数据，这3字节依次是:字母“a”、回车符“\r”和换行符“\n”。 不过因为服务器程序已经被中断，所以Kongming20对客户端发送的数据回应了一个复位报文段5。</p><h2 id="36-tcp交互数据流"><a class="markdownIt-Anchor" href="#36-tcp交互数据流"></a> 3.6 TCP交互数据流</h2><p>前面讨论了TCP连接及其状态，从本节开始我们讨论通过TCP连接交换的应用程序数据。TCP报文段所携带的应用程序数据按照长度分为两种:<strong>交互数据</strong>和<strong>成块数据</strong>。交互数据仅包含<u>很少</u>的字节。使用交互数据的应用程序(或协议)对实时性要求高，比如telnet、ssh等。 成块数据的长度则通常为TCP报文段允许的最大数据长度。使用成块数据的应用程序(或协议)对传输效率要求高，比如ftp。本节我们讨论交互数据流。</p><p>考虑如下情况:在ernest-laptop上执行telnet命令登录到本机，然后在shell命令提示符后执行ls命令，同时用tcpdump抓取这一过程中telnet 客户端和telnet服务器交换的TCP报文段。具体操作过程如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">$tcpdump -nt -i lo port <span class="hljs-number">23</span><br>$telnet <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>Trying <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>...<br>Connected to <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>.<br>Escape character is<span class="hljs-number">&#x27;</span>^]<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">Ubuntu 9.10</span><br><span class="hljs-string">ernest-laptop login:ernest(回车)#输入用户名并回车 Password:(回车)#输入密码并回车 ernest@ernest-laptop:~$ls(回车)</span><br></code></pre></td></tr></table></figure><p>上述过程将引起客户端和服务器交换很多TCP报文段。下面我们仅列出我们感兴趣的、执行ls命令产生的tcpdump输出，如代码清单3-4所示。</p><p>代码清单3-4 TCP交互数据流</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[P.],seq <span class="hljs-number">1408334812</span>:<span class="hljs-number">1408334813</span>,ack <span class="hljs-number">1415955507</span>,win <span class="hljs-number">613</span>,length <span class="hljs-number">1</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">2</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">512</span>,length <span class="hljs-number">1</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[.],ack <span class="hljs-number">2</span>,win <span class="hljs-number">613</span>,length<br><span class="hljs-number">0</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">2</span>,ack <span class="hljs-number">2</span>,win<br><span class="hljs-number">613</span>,length <span class="hljs-number">1</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>:Flags[P.],seq <span class="hljs-number">2</span>:<span class="hljs-number">3</span>,ack <span class="hljs-number">2</span>,win<br><span class="hljs-number">512</span>,length <span class="hljs-number">1</span><br><span class="hljs-number">6.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[.],ack <span class="hljs-number">3</span>,win <span class="hljs-number">613</span>,length<br><span class="hljs-number">0</span><br><span class="hljs-number">7.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[P.],seq <span class="hljs-number">2</span>:<span class="hljs-number">4</span>,ack <span class="hljs-number">3</span>,win<br><span class="hljs-number">613</span>,length <span class="hljs-number">2</span><br><span class="hljs-number">8.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>:Flags[P.],seq <span class="hljs-number">3</span>:<span class="hljs-number">176</span>,ack <span class="hljs-number">4</span>,win<br><span class="hljs-number">512</span>,length <span class="hljs-number">173</span><br><span class="hljs-number">9.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[.],ack <span class="hljs-number">176</span>,win<br><span class="hljs-number">630</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">10.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>:Flags[P.],seq <span class="hljs-number">176</span>:<span class="hljs-number">228</span>,ack<br><span class="hljs-number">4</span>,win <span class="hljs-number">512</span>,length <span class="hljs-number">52</span><br><span class="hljs-number">11.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.58130</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.23</span>:Flags[.],ack <span class="hljs-number">228</span>,win<br><span class="hljs-number">630</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>TCP报文段1</strong>由客户端发送给服务器，它携带1个字节的应用程序数据，即字母“l”。</p><p><strong>TCP报文段2</strong>是服务器对<u>TCP报文段1</u>的确认，同时回显字母“l”。</p><p><strong>TCP报文段3</strong>是客户端对<u>TCP报文段2</u>的确认。</p><p><strong>第4~6个TCP报文段</strong>是针对字母“s”的上述过程。</p><p><strong>TCP报文段7</strong>传送的2字节数据分别是:客户端键入的回车符和流结束符(EOF，本例中是0x00)。</p><p><strong>TCP报文段8</strong>携带服务器返回的客户<u>查询的目录的内容</u>(ls命令的输出)，包括该目录下文件的文件名及其显示控制参数。</p><p><strong>TCP报文段9</strong>是客户端对TCP报文段8的确认。</p><p><strong>TCP报文段10</strong>携带的也是服务器返回给客户端的数据，包括一个回车符、一个换行符、客户端登录用户的PS1环境变量(第一级命令提示符)。</p><p><strong>TCP报文段11</strong>是客户端对TCP报文段10的确认。</p><p>在上述过程中，客户端针对服务器返回的数据所发送的确认报文段(TCP报文段6、9和11)都不携带任何应用程序数据(长度为0)， 而服务器每次<u>发送的确认报文段</u>(TCP报文段2、5、8和10)<u>都包含它需要发送的应用程序数据</u>。服务器的这种处理方式称为<strong>延迟确认</strong>，即<u>它不马上确认上次收到的数据，而是在一段延迟时间后查看本端是否有数据需要发送</u>，如果有，则和确认信息一起发出。因为服务器对客户请求处理得很快，所以它发送确认报文段的时候总是有数据一起发送。<strong>延迟确认</strong>可以<strong>减少发送TCP报文段的数</strong>量。而<u>由于用户的输入速度明显慢于客户端程序的处理速度，所以客户端的确认报文段总是不携带任何应用程序数据</u>。前文曾提到，在TCP连接的建立和断开过程中，也可能发生延迟确认。</p><p>上例是在本地回路运行的结果，在局域网中也能得到基本相同的结果，但在广域网就未必如此了。广域网上的交互数据流可能经受很大的延迟，并且，携带交互数据的微小TCP报文段数量一般很多(一个按键输入就导致一个TCP报文段)，这些因素都可能导致拥塞发生。解决该问题的一个简单有效的方法是使用Nagle算法。</p><p>Nagle算法要求<u>一个TCP连接的通信双方在任意时刻都最多只能发送一个未被确认的TCP报文段</u>，在该TCP报文段的确认到达之前不能发送其他TCP报文段。另一方面，发送方在等待确认的同时收集本端需要发送的微量数据，并在确认到来时以一个TCP报文段将它们全部发出。这样就极大地减少了网络上的微小TCP报文段的数量。该算法的另一个优点在于其自适应性:<u>确认到达得越快，数据也就发送得越 快</u>。</p><h2 id="37-tcp成块数据流"><a class="markdownIt-Anchor" href="#37-tcp成块数据流"></a> 3.7 TCP成块数据流</h2><p>下面考虑用FTP协议传输一个大文件。在ernest-laptop上启动一个vsftpd服务器程序(升级的、安全版的ftp服务器程序)，并执行ftp命令登录该服务器上，然后在ftp命令提示符后输入get命令，从服务器下载一个几百兆的大文件。同时用tcpdump抓取这一个过程中ftp客户端和vsftpd服务器交换的TCP报文段。具体操作过程如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump -nt -i eth0 port <span class="hljs-number">20</span><span class="hljs-meta">#vsftpd服务器程序使用端口号20 $ftp 127.0.0.1</span><br>Connected to <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>.<br><span class="hljs-number">220</span>(vsFTPd <span class="hljs-number">2.3</span><span class="hljs-number">.0</span>) <span class="hljs-built_in">Name</span>(<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:ernest):<span class="hljs-built_in">ernest</span>(回车)#输入用户名并回车<br><span class="hljs-number">331</span> Please specify the password. Password:(回车)#输入密码并回车<br><span class="hljs-number">230</span> Login successful.<br>Remote system type is UNIX.<br>Using binary mode to transfer files. ftp&gt;<span class="hljs-function">get <span class="hljs-title">bigfile</span><span class="hljs-params">(回车)</span>#获取大文件bigfile</span><br></code></pre></td></tr></table></figure><p>代码清单3-5 是该过程的部分tcpdump输出。</p><p>代码清单3-5 TCP成块数据流</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205783041</span>:<span class="hljs-number">205799425</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205799425</span>:<span class="hljs-number">205815809</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205815809</span>:<span class="hljs-number">205832193</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[P.],seq <span class="hljs-number">205832193</span>:<span class="hljs-number">205848577</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205848577</span>:<span class="hljs-number">205864961</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">6.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205864961</span>:<span class="hljs-number">205881345</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">7.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205881345</span>:<span class="hljs-number">205897729</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">8.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[P.],seq <span class="hljs-number">205897729</span>:<span class="hljs-number">205914113</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">9.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205914113</span>:<span class="hljs-number">205930497</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">10.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205930497</span>:<span class="hljs-number">205946881</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">11.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205946881</span>:<span class="hljs-number">205963265</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">12.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[P.],seq <span class="hljs-number">205963265</span>:<span class="hljs-number">205979649</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">13.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205979649</span>:<span class="hljs-number">205996033</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">14.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">205996033</span>:<span class="hljs-number">206012417</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">15.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[.],seq <span class="hljs-number">206012417</span>:<span class="hljs-number">206028801</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">16.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>:Flags[P.],seq <span class="hljs-number">206028801</span>:<span class="hljs-number">206045185</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">513</span>,length <span class="hljs-number">16384</span><br><span class="hljs-number">17.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>:Flags[.],ack <span class="hljs-number">205815809</span>,win <span class="hljs-number">30084</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">18.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.39651</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>:Flags[.],ack <span class="hljs-number">206045185</span>,win <span class="hljs-number">27317</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>注意，客户端发送的最后两个TCP报文段17和18，它们分别是对TCP报文段2和16的确认(从序号值和确认值来判断)。由此可见，当传输大量大块数据的时候，<strong>发送方</strong>会<strong>连续发送多个TCP报文段</strong>，<strong>接收方</strong>可以<strong>一次确认所有这些报文段</strong>。</p><p>那么发送方在收到上一次确认后，能<u>连续发送多少个TCP报文</u>段呢?这是由接收通告<u>窗口(还需要考虑拥塞窗口，见后文)的大小决定</u>的。</p><p><strong>TCP报文段17</strong>说明客户端还能接收30 084×64字节(本例中窗口扩大因子为6)，即1 925 376字节的数据。</p><p>而在<strong>TCP报文段18</strong>中，接收通告窗口大小为1 748 288字节，即客户端能接收的数据量变小了。这表明客户端的TCP接收缓冲区有更多的数据未被应用程序读取而停留在其中，这些数据都来自TCP报文段3 ~16中的一部分。</p><p>服务器收到TCP报文段18后，它至少(因为接收通告窗口可能扩大)还能连续发送的未被确认的报文段数量是1 748 288/16 384个，即106个(但一般不会连续发送这么多)。其中，16 384是成块数据的长度(见TCP报文段1~16的length值)，很显然它小于但接近MSS规定的16 396字节。</p><p>另外一个值得注意的地方是，服务器每发送4个TCP报文段就传送一个PSH标志(tcpdump输出标志P)给客户端，以通知客户端的应用程序尽快读取数据。不过这对服务器来说显然不是必需的，因为它知道客户端的TCP接收缓冲区中还有空闲空间(接收通告窗口大小不为0)。</p><p>下面我们修改系统的TCP接收缓冲区和TCP发送缓冲区的大小 (如何修改将在第16章介绍)，使之都为4096字节，然后重启vsftpd服务器，并再次执行上述操作。此次tcpdump的部分输出如代码清单3-6 所示。</p><p>代码清单3-6 修改TCP接收和发送缓冲区大小后的TCP成块数据流</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.45227</span>:Flags[.],seq <span class="hljs-number">5195777</span>:<span class="hljs-number">5197313</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">3072</span>,length <span class="hljs-number">1536</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.45227</span>:Flags[.],seq <span class="hljs-number">5197313</span>:<span class="hljs-number">5198849</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">3072</span>,length <span class="hljs-number">1536</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.45227</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>:Flags[.],ack <span class="hljs-number">5198849</span>,win <span class="hljs-number">3072</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.45227</span>:Flags[P.],seq <span class="hljs-number">5198849</span>:<span class="hljs-number">5200385</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">3072</span>,length <span class="hljs-number">1536</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.45227</span>&gt;<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-number">.20</span>:Flags[.],ack <span class="hljs-number">5200385</span>,win <span class="hljs-number">3072</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>从同步报文段(未在代码清单3-6中列出)得知在这次通信过程中，客户端和服务器的窗口扩大因子都为0，因而客户端和服务器每次通告的窗口大小都是3072字节(没超过4096字节，预料之中)。因为每个成块数据的长度为1536字节，所以服务器在收到上一个TCP报文段的确认之前最多还能再发送1个TCP报文段，这正是TCP报文段1~3描述的情形。</p><h2 id="38-带外数据"><a class="markdownIt-Anchor" href="#38-带外数据"></a> 3.8 带外数据</h2><p>有些传输层协议具有带外(Out Of Band，OOB)数据的概念，用于<u>迅速通告对方本端发生的重要事件</u>。因此，带外数据比普通数据 (也称为带内数据)有<strong>更高的优先级</strong>，它应该总是立即被发送，而不论发送缓冲区中是否有排队等待发送的普通数据。带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接中。实际应用中，带外数据的使用很少见，已知的仅有telnet、ftp等远程非活跃程序。</p><p>UDP没有实现带外数据传输，TCP也没有真正的带外数据。不过TCP利用其头部中的紧急指针标志和紧急指针两个字段，给应用程序提供了一种紧急方式。TCP的紧急方式利用传输普通数据的连接来传输紧急数据。这种紧急数据的含义和带外数据类似，因此后文也将<u>TCP紧急数据称为带外数据</u>。</p><h3 id="381tcp发送带外数据的过程"><a class="markdownIt-Anchor" href="#381tcp发送带外数据的过程"></a> 3.8.1TCP发送带外数据的过程</h3><p>假设一个进程已经往某个TCP连接的发送缓冲区中写入了N字节的普通数据，并等待其发送。在数据被发送前，该进程又向这个连接写入了3字节的带外数据“abc”。此时，待发送的TCP报文段的头部将被设置URG标志，并且紧急指针被设置为指向最后一个带外数据的下一字节(进一步减去当前TCP报文段的序号值得到其头部中的紧急偏移值)，如图3-10所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205131634108.png" alt="截屏2022-05-13 下午4.34.33" /></p><p>由图3-10可见，发送端一次发送的多字节的带外数据中只有最后一字节被当作带外数据(字母c)，而其他数据(字母a和b)被当成了普通数据。如果TCP模块以多个TCP报文段来发送图3-10所示TCP发送缓冲区中的内容，则每个TCP报文段都将设置URG标志，并且它们的紧 急指针指向同一个位置(数据流中带外数据的下一个位置)，但<u>只有一个TCP报文段真正携带带外数据</u>。</p><p>现在考虑TCP接收带外数据的过程。TCP接收端只有在接收到紧急指针标志时才检查紧急指针，然后根据紧急指针所指的位置确定带外数据的位置，并将它读入一个特殊的缓存中。这个缓存只有1字节，称为<u>带外缓存</u>。<strong>如果上层应用程序没有及时将带外数据从带外缓存中读 出，则后续的带外数据(如果有的话)将覆盖它</strong>。</p><p>前面讨论的带外数据的接收过程是TCP模块接收带外数据的默认方式。如果我们给TCP连接设置了SO_OOBINLINE选项，则带外数据将 和普通数据一样被TCP模块存放在TCP接收缓冲区中。此时应用程序需要像读取普通数据一样来读取带外数据。那么这种情况下如何区分带外数据和普通数据呢?显然，紧急指针可以用来指出带外数据的位置，socket编程接口也提供了系统调用来识别带外数据(见第5章)。</p><p>至此，我们讨论了TCP模块发送和接收带外数据的过程。至于内核如何通知应用程序带外数据的到来，以及应用程序如何发送和接收带外数据，将在后续章节讨论。</p><h2 id="39-tcp超时重传"><a class="markdownIt-Anchor" href="#39-tcp超时重传"></a> 3.9 TCP超时重传</h2><p>在3.6节~3.8节中，我们讲述了TCP在正常网络情况下的数据流。 从本节开始，我们讨论异常网络状况下(开始出现超时或丢包)，TCP如何控制数据传输以保证其承诺的可靠服务。</p><p>TCP服务必须能够重传超时时间内未收到确认的TCP报文段。为此，TCP模块为每个TCP报文段都维护一个重传定时器，该定时器在TCP报文段第一次被发送时启动。如果超时时间内未收到接收方的应答，TCP模块将重传TCP报文段并重置定时器。至于下次重传的超时时间如何选择，以及最多执行多少次重传，就是TCP的重传策略。我们通过实例来研究Linux下TCP的超时重传策略。</p><p>在ernest-laptop上启动iperf服务器程序，然后从Kongming20上执行telnet命令登录该服务器程序。接下来，从telnet客户端发送一些数据 (此处是“1234”)给服务器，然后断开服务器的网线并再次从客户端发送一些数据给服务器(此处是“12”)。同时，用tcpdump抓取这一过程中客户端和服务器交换的TCP报文段。具体操作过程如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo tcpdump-n-i eth0 port <span class="hljs-number">5001</span> $iperf-s#在ernest-laptop上执行<br>$telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-number">5001</span>#在Kongming20上执行 Trying <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>...<br>Connected to <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>.<br>Escape character is<span class="hljs-number">&#x27;</span>^]<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">1234#发送完之后断开服务器网线</span><br><span class="hljs-string">12</span><br><span class="hljs-string">Connection closed by foreign host</span><br></code></pre></td></tr></table></figure><p>iperf是一个测量网络状况的工具，-s选项表示将其作为服务器运行。iperf默认监听5001端口，并丢弃该端口上接收到的所有数据，相当于一个discard服务器。上述操作过程的部分tcpdump输出如代码清单3-7所示。</p><p>代码清单3-7 TCP超时重传</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">57.580341</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[S],seq <span class="hljs-number">2381272950</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">2.18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">57.580477</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>:Flags[S.],seq <span class="hljs-number">466032301</span>,ack <span class="hljs-number">2381272951</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">3.18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">57.580498</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[.],ack <span class="hljs-number">1</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">59.866019</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">7</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">6</span><br><span class="hljs-number">5.18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">59.866165</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>:Flags[.],ack <span class="hljs-number">7</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">6.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">25.028933</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">7</span>:<span class="hljs-number">11</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">4</span><br><span class="hljs-number">7.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">25.230034</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">7</span>:<span class="hljs-number">11</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">4</span><br><span class="hljs-number">8.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">25.639407</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">7</span>:<span class="hljs-number">11</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">4</span><br><span class="hljs-number">9.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">26.455942</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">7</span>:<span class="hljs-number">11</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">4</span><br><span class="hljs-number">10.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">28.092425</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">7</span>:<span class="hljs-number">11</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">4</span><br><span class="hljs-number">11.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">31.362473</span> IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38234</span>&gt; <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.5001</span>:Flags[P.],seq <span class="hljs-number">7</span>:<span class="hljs-number">11</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">4</span><br><span class="hljs-number">12.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">33.100888</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">13.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">34.098156</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">14.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">35.100887</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">15.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">37.902034</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">16.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">38.903126</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">17.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">39.901421</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">18.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">44.440049</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">19.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">45.438840</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">20.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">46.439932</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">21.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">50.976710</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">22.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">51.974134</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br><span class="hljs-number">23.18</span>:<span class="hljs-number">45</span>:<span class="hljs-number">52.973939</span> ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>,length <span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p><strong>TCP报文段1~3</strong>是<strong>三次握手建立连接</strong>的过程。</p><p><strong>TCP报文段4~5</strong>是客户端发送数据“1234”(应用程序数据长度为6，包括回车、换行两个字符，后同)及服务器确认的过程。</p><p><strong>TCP报文段6</strong>是客户端第一次发送数据“12”的过程。因为服务器的网线被断开，所以客户端无法收到TCP报文段6的确认报文段。此后，客户端对TCP报文段6执行了5次重传，它们是TCP报文段7~11，这可以从每个TCP报文段的序号得知。</p><p>此后，<strong>数据包12~23</strong>都是ARP模块的输出内容，即Kongming20查询ernest-laptop的MAC地址。</p><p>我们保留了tcpdump输出的时间戳，以便推理TCP的超时重传策略。观察TCP报文段6~11被发送的时间间隔，它们分别为0.2 s、0.4 s、0.8 s、1.6 s和3.2 s。由此可见，TCP一共执行5次重传，每次重传超时时间都增加一倍(因此，和TCP超时重连的策略相似)。</p><p>在5次重传均失败的情况下，底层的IP和ARP开始接管，直到telnet客户端放弃连接为止。</p><p>Linux有两个重要的内核参数与TCP超时重传相关:/proc/sys/net/ipv4/tcp_retries1和/proc/sys/net/ipv4/tcp_retries2。前者指定在底层IP接管之前TCP最少执行的重传次数，默认值是3。后者指定连接放弃前TCP最多可以执行的重传次数，默认值是15(一般对应 13~30 min)。在我们的实例中，TCP超时重传发生了5次，连接坚持的时间是15 min(可以用date命令来测量)。</p><p>虽然超时会导致TCP报文段重传，但TCP报文段的重传可以发生在超时之前，即快速重传，这将在下一节中讨论。</p><h2 id="310-拥塞控制"><a class="markdownIt-Anchor" href="#310-拥塞控制"></a> 3.10 拥塞控制</h2><h3 id="3101-拥塞控制概述"><a class="markdownIt-Anchor" href="#3101-拥塞控制概述"></a> 3.10.1 拥塞控制概述</h3><p>TCP模块还有一个重要的任务，就是<u>提高网络利用率，降低丢包率</u>，并<u>保证网络资源对每条数据流的公平性</u>。这就是所谓的<strong>拥塞控制</strong>。</p><p>TCP拥塞控制的标准文档是RFC 5681，其中详细介绍了拥塞控制的四个部分:<strong>慢启动(slow start)</strong>、<strong>拥塞避免(congestion avoidance)</strong>、<strong>快速重传(fast retransmit)<strong>和</strong>快速恢复(fast recovery)</strong>。拥塞控制算法在Linux下有多种实现，比如<strong>reno算法</strong>、 <strong>vegas算法</strong>和<strong>cubic算法</strong>等。它们或者部分或者全部实现了上述四个部分。/proc/sys/net/ipv4/tcp_congestion_control文件指示机器当前所使用的拥塞控制算法。</p><p>拥塞控制的最终受控变量是发送端向网络一次连续写入(收到其中第一个数据的确认之前)的数据量，我们称为SWND(Send Window，发送窗口[1])。不过，发送端最终以TCP报文段来发送数据，所以SWND限定了发送端能连续发送的TCP报文段数量。这些**TCP报文段的最大长度(仅指数据部分)**称为SMSS(Sender Maximum Segment Size，发送者最大段大小)，其值一般等于MSS。</p><p>发送端需要合理地选择SWND的大小。如果<strong>SWND太小</strong>，会引起明显的<strong>网络延迟</strong>;反之，如果<strong>SWND太大</strong>，则容易导致<strong>网络拥塞</strong>。前文提到，接收方可通过其接收通告窗口(RWND)来控制发送端的SWND。但这显然不够，所以发送端引入了一个称为拥塞窗口(Congestion Window，CWND)的状态变量。实际的SWND值是RWND和CWND中的较小者。图3-11显示了拥塞控制的输入和输出(可见，它是一个闭环反馈控制)。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142122368.png" alt="截屏2022-05-14 下午9.22.16" /></p><h3 id="3102-慢启动和拥塞避免"><a class="markdownIt-Anchor" href="#3102-慢启动和拥塞避免"></a> 3.10.2 慢启动和拥塞避免</h3><p>TCP连接建立好之后，CWND将被设置成初始值IW(Initial Window)，其大小为2~4个SMSS。但新的Linux内核提高了该初始值，以减小传输滞后。此时发送端最多能发送IW字节的数据。此后发送端每收到接收端的一个确认，其CWND就按照式(3-1)增加:</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142127783.png" alt="截屏2022-05-14 下午9.27.56" /></p><p>其中N是此次确认中包含的之前未被确认的字节数。这样一来， CWND将按照指数形式扩大，这就是所谓的慢启动。慢启动算法的理由是，TCP模块刚开始发送数据时并不知道网络的实际情况，需要用一种<u>试探的方式</u>平滑地增加CWND的大小。</p><p>但是如果不施加其他手段，慢启动必然使得CWND很快膨胀(可见慢启动其实不慢)并最终导致网络拥塞。因此TCP拥塞控制中定义了另一个重要的状态变量:慢启动门限(slow start threshold size， ssthresh)。当CWND的大小超过该值时，TCP拥塞控制将进入拥塞避免阶段。</p><p>拥塞避免算法使得CWND按照线性方式增加，从而减缓其扩大。 RFC 5681中提到了如下两种实现方式:</p><p>1、每个RTT时间内按照式(3-1)计算新的CWND，而不论该RTT时间内发送端收到多少个确认。</p><p>2、每收到一个对新数据的确认报文段，就按照式(3-2)来更新CWND。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142147580.png" alt="截屏2022-05-14 下午9.47.31" /></p><p>图3-12粗略地描述了慢启动和拥塞避免发生的时机和区别。该图中，我们以SMSS为单位来显示CWND(实际上它是以字节为单位的)，以次数为单位来显示RTT，这只是为了方便讨论问题。此外，我们假设当前的ssthresh是16SMSS大小(当然，实际的ssthresh显然远不止这么大)。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142150680.png" alt="截屏2022-05-14 下午9.50.06" /></p><p>以上我们讨论了发送端在未检测到拥塞时所采用的积极避免拥塞的方法。接下来介绍拥塞发生时(可能发生在慢启动阶段或者拥塞避免阶段)拥塞控制的行为。不过我们先要搞清楚发送端是如何判断拥塞已经发生的。发送端<strong>判断拥塞发生</strong>的依据有如下两个:</p><p>1、传输超时，或者说TCP重传定时器溢出。</p><p>2、接收到重复的确认报文段。</p><p>拥塞控制对这两种情况有不同的处理方式。对第一种情况仍然使用慢启动和拥塞避免。对第二种情况则使用快速重传和快速恢复(如果是真的发生拥塞的话)，这种情况将在后面讨论。注意，第二种情况如果发生在重传定时器溢出之后，则也被拥塞控制当成第一种情况来对待。</p><p>如果发送端检测到拥塞发生是由于传输超时，即上述第一种情况，那么它将执行重传并做如下调整:</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142153207.png" alt="截屏2022-05-14 下午9.53.26" /></p><p>其中FlightSize是<strong>已经发送但未收到确认的字节数</strong>。这样调整之后，CWMD将小于SMSS，那么也必然小于新的慢启动门限值ssthresh(因为根据式(3-3)，它一定不小于SMSS的2倍)，故而拥塞控制再次进入慢启动阶段。</p><h3 id="3103-快速重传和快速恢复"><a class="markdownIt-Anchor" href="#3103-快速重传和快速恢复"></a> 3.10.3 快速重传和快速恢复</h3><p>在很多情况下，发送端都可能接收到重复的确认报文段，比如TCP报文段丢失，或者接收端收到乱序TCP报文段并重排之等。拥塞控制算 法需要判断当收到重复的确认报文段时，网络是否真的发生了拥塞，或者说TCP报文段是否真的丢失了。具体做法是:发送端如果连续收到 3个重复的确认报文段，就认为是拥塞发生了。然后它启用快速重传和快速恢复算法来处理拥塞，过程如下:</p><p>1)当收到第3个重复的确认报文段时，按照式(3-3)计算ssthresh，然后立即重传丢失的报文段，并按照式(3-4)设置CWND。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142156591.png" alt="截屏2022-05-14 下午9.56.04" /></p><p>2)每次收到1个重复的确认时，设置CWND=CWND+SMSS。此时发送端可以发送新的TCP报文段(如果新的CWND允许的话)。【扩大窗口，快速重传】</p><p>3)当收到新数据的确认时，设置CWND=ssthresh(ssthresh是新的慢启动门限值，由第一步计算得到)。【如果能收到说明没问题，重新确定阈值，快速恢复】</p><p>快速重传和快速恢复完成之后，拥塞控制将<u>恢复到拥塞避免阶段</u>，这一点由第3步操作可得知。</p><h1 id="第4章-tcpip通信案例访问internet上的web服务器"><a class="markdownIt-Anchor" href="#第4章-tcpip通信案例访问internet上的web服务器"></a> 第4章 TCP/IP通信案例:访问Internet上的Web服务器</h1><p>在第1章中，我们简单地讨论了TCP/IP协议族各层的功能和部分协议，以及它们之间是如何协作完成网络通信的。在第2章和第3章中， 我们详细地探讨了IP协议和TCP协议。本章，我们分析一个完整的 TCP/IP通信的实例——访问Internet上的Web服务器，通过该实例把这些知识串联起来。选择使用Web服务器展开讨论的理由是:</p><p>1、Internet上的Web服务器随处都可以获得，我们通过浏览器访问任何一个网站都是在与Web服务器通信。</p><p>2、本书后续章节将编写简单的Web服务器程序，因此先学习其工作原理是有好处的。</p><p>Web客户端和服务器之间使用<strong>HTTP协议通信</strong>。HTTP协议的内容相当广泛，涵盖了网络应用层协议需要考虑的诸多方面。因此，学习 HTTP协议对应用层协议设计将大有裨益。</p><h2 id="41-实例总图"><a class="markdownIt-Anchor" href="#41-实例总图"></a> 4.1 实例总图</h2><p>我们按照如下方法来部署通信实例:在Kongming20上运行wget客户端程序，在ernest-laptop上运行squid代理服务器程序。客户端通过代 理服务器的中转，获取Internet上的主机www.baidu.com的首页文档 index.html，如图4-1所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205142201066.png" alt="截屏2022-05-14 下午10.01.32" /></p><p>由图4-1可见，wget客户端程序和代理服务器之间，以及代理服务器与Web服务器之间都是使用HTTP协议通信的。HTTP协议是一种应用 层协议，它默认使用的传输层协议是TCP协议。我们将在后文中简单讨论HTTP协议。</p><p>为了将ernest-laptop设置为Kongming20的<strong>HTTP代理服务器</strong>，我们需要在Kongming20上设置环境变量http_proxy:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">$<span class="hljs-keyword">export</span> http_proxy=<span class="hljs-string">&quot;ernest-laptop:3128&quot;</span>#在Kongming20上执行<br></code></pre></td></tr></table></figure><p>其中，3128是squid服务器默认使用的端口号(可以通过lsof命令查看服务器程序监听的端口号，见第17章)。设置好环境变量之后， Kongming20访问任何Internet上的Web服务器时，其HTTP请求都将首先发送至ernest-laptop的3128端口。</p><p>squid代理服务器接收到wget客户端的HTTP请求之后，将简单地修改这个请求，然后把它发送给最终的目标Web服务器。既然代理服务器 访问的是Internet上的机器，可以预见它发送的IP数据报都将经过路由器的中转，这一点也体现在图4-1中了。</p><h2 id="42-部署代理服务器"><a class="markdownIt-Anchor" href="#42-部署代理服务器"></a> 4.2 部署代理服务器</h2><p>由于通信实例中使用了HTTP代理服务器(squid程序)，所以先简单介绍一下HTTP代理服务器的工作原理，以及如何部署squid代理服务 器。</p><h3 id="421-http代理服务器的工作原理"><a class="markdownIt-Anchor" href="#421-http代理服务器的工作原理"></a> 4.2.1 HTTP代理服务器的工作原理</h3><p>在HTTP通信链上，客户端和目标服务器之间通常存在某些中转代理服务器，它们提供对目标资源的中转访问。一个HTTP请求可能被多 个代理服务器转发，<u>后面的服务器称为前面服务器的上游服务器</u>。代理服务器按照其使用方式和作用，分为<strong>正向代理服务器</strong>、<strong>反向代理服务器</strong>和<strong>透明代理服务器</strong>。</p><h4 id="正向代理"><a class="markdownIt-Anchor" href="#正向代理"></a> 正向代理</h4><p>要求客户端自己设置代理服务器的地址。<u>客户的每次请求都将直接发送到该代理服务器，并由代理服务器来请求目标资源</u>。 比如处于防火墙内的局域网机器要访问Internet，或者要访问一些被屏蔽掉的国外网站，就需要使用正向代理服务器。</p><h4 id="反向代理"><a class="markdownIt-Anchor" href="#反向代理"></a> 反向代理</h4><p>则被设置在服务器端，因而客户端无须进行任何设置。 反向代理是<u>指用代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从内部服务器上得到的结果返回给客户端</u>。</p><p>这种情况下，代理服务器对外就表现为一个真实的服务器。各大网站通常分区域设置了多个代理服务器，所以在不同的地方ping同一个域名可能得到不同的IP地址，因为这些IP地址实际上是代理服务器的IP地址。图4-2显示了正向代理服务器和反向代理服务器在HTTP通信链上的逻辑位置。</p><p>图4-2中，正向代理服务器和客户端主机处于同一个逻辑网络中。 该逻辑网络可以是一个本地LAN，也可以是一个更大的网络。反向代理服务器和真正的Web服务器也位于同一个逻辑网络中，这通常由提供网站的公司来配置和管理。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205161643321.png" alt="截屏2022-05-16 下午4.43.52" /></p><p>透明代理只能设置在网关上。用户访问Internet的数据报必然都经过网关，如果在网关上设置代理，则该代理对用户来说显然是透明的。透明代理可以看作正向代理的一种特殊情况。</p><p>代理服务器通常还提供缓存目标资源的功能(可选)，这样用户下次访问同一资源时速度将很快。优秀的开源软件squid、varnish都是提供了缓存能力的代理服务器软件，其中squid支持所有代理方式，而varnish仅能用作反向代理。</p><h3 id="422-部署squid代理服务器"><a class="markdownIt-Anchor" href="#422-部署squid代理服务器"></a> 4.2.2 部署squid代理服务器</h3><p>现在我们在ernest-laptop上部署squid代理服务器。这个过程很简单，只需修改squid服务器的配置文件/etc/squid3/squid.conf，在其中加 入如下两行代码(需要root权限，且应该加在合适的位置，详情可参考其他类似条目的设置):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">acl localnet src <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span><br> http_access allow localnet<br></code></pre></td></tr></table></figure><p>这两行代码的含义是:允许网络192.168.1.0上的所有机器通过该代理服务器来访问Web服务器。其中，“192.168.1.0/24”是CIDR(Classless Inter-Domain Routing，无类域间路由)风格的IP地址表示方法:“/”前的部分指定网络的IP地址，“/”后的部分则指定子网掩码中“1”的位数。 对IPv4而言，上述表示等价于“192.168.1.0/255.255.255.0”(IP地址/子网掩码)。</p><p>我们通过上面的两行代码简单地配置了squid的访问控制。但实际应用中，squid提供更多、更安全的配置，比如用户验证等。</p><p>接下来在ernest-laptop上执行如下命令，以重启squid服务器:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo service squid3 restart<br>*Restarting Squid HTTP Proxy <span class="hljs-number">3.0</span> squid3[OK]<br></code></pre></td></tr></table></figure><p>service是一个脚本程序(/usr/sbin/service)，它为/etc/init.d/目录下的众多服务器程序(比如httpd、vsftpd、sshd和mysqld等)的启动 (start)、停止(stop)和重启(restart)等动作提供了一个统一的管理。现在，Linux程序员已经越来越偏向于使用service脚本来管理服务器程序了。</p><h2 id="43-使用tcpdump抓取传输数据包"><a class="markdownIt-Anchor" href="#43-使用tcpdump抓取传输数据包"></a> 4.3 使用tcpdump抓取传输数据包</h2><p>在执行wget命令前，我们首先应删除ernest-laptop的ARP高速缓存中路由器对应的项，以便观察TCP/IP通信过程中ARP协议何时起作 用。然后，使用tcpdump命令抓取整个通信过程中传输的数据包。完整的操作过程如代码清单4-1所示。</p><p>代码清单4-1 使用wget抓取网页</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo arp-d <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br>$sudo tcpdump -s <span class="hljs-number">2000</span> -i eth0 -ntX <span class="hljs-string">&#x27;(src 192.168.1.108)or(dst 192.168.1.108)or(arp)&#x27;</span><br>$wget --header=<span class="hljs-string">&quot;Connection:close&quot;</span> http:<span class="hljs-comment">//www.baidu.com/index.html</span><br>-<span class="hljs-number">-2012</span><span class="hljs-number">-07</span><span class="hljs-number">-03</span> <span class="hljs-number">00</span>:<span class="hljs-number">51</span>:<span class="hljs-number">12</span> --http:<span class="hljs-comment">//www.baidu.com/index.html</span><br>Resolving ernest-laptop..<span class="hljs-number">.192</span><span class="hljs-number">.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><br>Connecting to ernest-laptop|<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>|:<span class="hljs-number">3128.</span>..connected.<br>Proxy request sent,awaiting response..<span class="hljs-number">.200</span> OK<br>Length:<span class="hljs-number">8024</span>(<span class="hljs-number">7.8</span>K)[text/html]<br>Saving to:“index.html” <br><span class="hljs-number">100</span>%[=======================&gt;]<span class="hljs-number">8</span>,<span class="hljs-number">024</span>--.-K/s in <span class="hljs-number">0.001</span>s <span class="hljs-number">2012</span><span class="hljs-number">-07</span><span class="hljs-number">-03</span> <span class="hljs-number">00</span>:<span class="hljs-number">51</span>:<span class="hljs-number">12</span>(<span class="hljs-number">8.76</span> MB/s)-“index.html”              saved[<span class="hljs-number">8024</span>/<span class="hljs-number">8024</span>]<br></code></pre></td></tr></table></figure><p>wget命令的输出显示，HTTP请求确实是先被送至代理服务器的3128端口，并且代理服务器正确地返回了文件index.html的内容。</p><p>这次通信的完整tcpdump输出内容如代码清单4-2所示。</p><p>代码清单4-2 访问Internet上的Web服务器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[S],seq <span class="hljs-number">227192137</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[S.],seq <span class="hljs-number">1084588508</span>,ack <span class="hljs-number">227192138</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">1</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">137</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">136</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[.],ack <span class="hljs-number">137</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">6.</span>ARP,Request who-has <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> tell <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>,length <span class="hljs-number">28</span> <br><span class="hljs-number">7.</span>ARP,Reply <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> is-at <span class="hljs-number">14</span>:e6:e4:<span class="hljs-number">93</span>:<span class="hljs-number">5b</span>:<span class="hljs-number">78</span>,length <span class="hljs-number">46</span> <br><span class="hljs-number">8.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.46149</span>&gt;<span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><span class="hljs-number">.53</span>:<span class="hljs-number">59410</span>+A? www.baidu.com.(<span class="hljs-number">31</span>)<br><span class="hljs-number">9.</span>IP <span class="hljs-number">219.239</span><span class="hljs-number">.26</span><span class="hljs-number">.42</span><span class="hljs-number">.53</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.46149</span>:<span class="hljs-number">59410</span> <span class="hljs-number">3</span>/<span class="hljs-number">4</span>/<span class="hljs-number">0</span> CNAME www.a.shifen.com.,A <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span>,A <span class="hljs-number">119.75</span><span class="hljs-number">.217</span><span class="hljs-number">.56</span>(<span class="hljs-number">162</span>) <br><span class="hljs-number">10.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[S],seq <span class="hljs-number">1084002207</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">11.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[S.],seq <span class="hljs-number">4261071806</span>,ack <span class="hljs-number">1084002208</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">12.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">1</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">13.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">226</span>,ack <span class="hljs-number">1</span>,length <span class="hljs-number">225</span><br><span class="hljs-number">14.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[.],ack <span class="hljs-number">226</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">15.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">380</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">379</span><br><span class="hljs-number">16.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">380</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">17.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[.],seq <span class="hljs-number">380</span>:<span class="hljs-number">1820</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">1440</span><br><span class="hljs-number">18.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">1820</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">19.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[.],seq <span class="hljs-number">1820</span>:<span class="hljs-number">3260</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">1440</span><br><span class="hljs-number">20.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">3260</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">21.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[P.],seq <span class="hljs-number">3260</span>:<span class="hljs-number">4700</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">1440</span><br><span class="hljs-number">22.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">4700</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">23.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[.],seq <span class="hljs-number">1</span>:<span class="hljs-number">1449</span>,ack <span class="hljs-number">137</span>,length <span class="hljs-number">1448</span><br><span class="hljs-number">24.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[P.],seq <span class="hljs-number">1449</span>:<span class="hljs-number">2166</span>,ack <span class="hljs-number">137</span>,length <span class="hljs-number">717</span><br><span class="hljs-number">25.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[.],seq <span class="hljs-number">2166</span>:<span class="hljs-number">3614</span>,ack <span class="hljs-number">137</span>,length <span class="hljs-number">1448</span><br><span class="hljs-number">26.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[.],seq <span class="hljs-number">4700</span>:<span class="hljs-number">6140</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">1440</span><br><span class="hljs-number">27.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">6140</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">28.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[.],seq <span class="hljs-number">6140</span>:<span class="hljs-number">7580</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">1440</span><br><span class="hljs-number">29.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[.],ack <span class="hljs-number">7580</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">30.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[FP.],seq <span class="hljs-number">7580</span>:<span class="hljs-number">8404</span>,ack <span class="hljs-number">226</span>,length <span class="hljs-number">824</span><br><span class="hljs-number">31.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>&gt;<span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>:Flags[F.],seq <span class="hljs-number">226</span>,ack <span class="hljs-number">8405</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">32.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">1449</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">33.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[.],seq <span class="hljs-number">3614</span>:<span class="hljs-number">6510</span>,ack <span class="hljs-number">137</span>,length <span class="hljs-number">2896</span><br><span class="hljs-number">34.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">2166</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">35.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[.],seq <span class="hljs-number">6510</span>:<span class="hljs-number">7958</span>,ack <span class="hljs-number">137</span>,length <span class="hljs-number">1448</span><br><span class="hljs-number">36.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[FP.],seq <span class="hljs-number">7958</span>:<span class="hljs-number">8523</span>,ack <span class="hljs-number">137</span>,length <span class="hljs-number">565</span><br><span class="hljs-number">37.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">3614</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">38.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">5062</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">39.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">6510</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">40.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[.],ack <span class="hljs-number">7958</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">41.</span>IP <span class="hljs-number">119.75</span><span class="hljs-number">.218</span><span class="hljs-number">.77</span><span class="hljs-number">.80</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.34538</span>:Flags[.],ack <span class="hljs-number">227</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">42.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>:Flags[F.],seq <span class="hljs-number">137</span>,ack <span class="hljs-number">8524</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">43.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.3128</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.40988</span>:Flags[.],ack <span class="hljs-number">138</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>我们一共抓取了43个数据包。与前面章节的讨论不同，这些数据包不是一对客户端和服务器之间交换的内容，而是两对客户端和服务器(wget客户端和代理服务器，以及代理服务器和目标Web服务器) 之间通信的全部内容。所以，tcpdump的输出把这两组通信的内容交织在一起。但为了讨论问题的方便，我们将这43个数据包按照其逻辑关系分为如下4个部分:</p><p>1、代理服务器访问DNS服务器以查询域名www.baidu.com对应的IP地址，包括数据包8、9。</p><p>2、代理服务器查询路由器MAC地址的ARP请求和应答，包括数据包6、7。</p><p>3、wget客户端(192.168.1.109)和代理服务器(192.168.1.108)之间的HTTP通信，包括数据包1<sub>5、23</sub>25、32~40、42和43。</p><p>4、代理服务器和Web服务器(119.75.218.77)之间的HTTP通信， 包括数据包10<sub>22、26</sub>31和41。</p><p>下面我们将依次讨论前3个部分，第4个部分与第3个部分的内容基本相似，不再赘述。</p><h2 id="44-访问dns服务器"><a class="markdownIt-Anchor" href="#44-访问dns服务器"></a> 4.4 访问DNS服务器</h2><p>数据包8、9表示代理服务器ernest-laptop向DNS服务器(219.239.26.42，首选DNS服务器的IP地址，见1.6.2节)查询域名www.baidu.com对应的IP地址，并得到了回复。该回复包括一个主机别名(<a href="http://www.a.shifen.com">www.a.shifen.com</a>)和两个IP地址(119.75.218.77和 119.75.217.56)。代理服务器执行DNS查询的完整过程如图4-3所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205161712755.png" alt="截屏2022-05-16 下午5.12.04" /></p><p>squid程序通过读取/etc/resolv.conf文件获得DNS服务器的IP地址 (见1.6.2节)，然后将控制权传递给内核中的UDP模块。</p><p>UDP模块将DNS查询报文封装成UDP数据报，同时把源端口号和目标端口号加入UDP数据报头部，然后UDP模块调用IP服务。IP模块则将UDP数据报封装成IP数据报，并把源端IP地址(192.168.1.108)和DNS服务器的IP地址加入IP数据报头部。</p><p>接下来，IP模块查询路由表以决定如何发送该IP数据报。根据路由策略，目标IP地址(219.239.26.42)仅能匹配路由表中的默认路由项，因此该IP数据报先被发送至路由器(IP地址为192.168.1.1)，然后通过路由器来转发。</p><p>因为ernest-laptop的ARP缓存中没有与路由器对应的缓存项(我们手动将其删除了)，所以ernest-laptop需要发起一个ARP广播以查询路由器的IP地址，而这正是数据包6描述的内容。</p><p>路由器则通过ARP应答告诉ernest-laptop自己的MAC地址是14:e6:e4:93:5b:78，如数据包7所示。</p><p>最终，以太网驱动程序将IP数据报封装成以太网帧发送给路由器。</p><p>此后，代理服务器再次发送数据到Internet时将不再需要ARP查询，因为ernest-laptop的ARP高速缓存中已经记录了路由器的IP地址和MAC地址的映射关系。</p><p>需要指出的是，虽然IP数据报是先发送到路由器，再由它转发给目标主机，但是其头部的目标IP地址却是最终的目标主机(DNS服务器)的IP地址，而不是中转路由器的IP地址(192.168.1.1)。这说明， <u>IP头部的源端IP地址和目的端IP地址在转发过程中是始终不变</u>的(一种例外是源路由选择)。但<u>帧头部的源端物理地址和目的端物理地址在转发过程中则是一直在变化</u>的。</p><h2 id="45-本地名称查询"><a class="markdownIt-Anchor" href="#45-本地名称查询"></a> 4.5 本地名称查询</h2><p>一般来说，通过域名来访问Internet上的某台主机时，需要使用DNS服务来获取该主机的IP地址。但如果我们通过主机名来访问本地局域网上的机器，则可通过本地的静态文件来获得该机器的IP地址。</p><p>Linux将目标主机名及其对应的IP地址存储在/etc/hosts配置文件中。当需要查询某个主机名对应的IP地址时，程序将首先检查这个文件。Kongming20上/etc/hosts文件的内容如下(笔者手动修改过):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> localhost<br><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> Kongming20<br><span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> ernest-laptop<br></code></pre></td></tr></table></figure><p>其中第一项指出本地回路地址127.0.0.1的名称是localhost，第二项和第三项则分别描述了Kongming20和ernest-laptop的IP地址及对应的主机名。</p><p>代码清单4-1中，wget命令输出“Resolving ernest- laptop…192.168.1.108”，即它成功地解析了主机名ernest-laptop对应的IP地址，原因如下:当wget访问某个Web服务器时，它先读取环境变量http_proxy。如果该环境变量被设置，并且我们没有阻止wget使用代理服务，则wget将通过http_proxy指定的代理服务器来访问Web服务。</p><p>但http_proxy环境变量中包含主机名ernest-laptop，因此wget将首先读取/etc/hosts配置文件，试图通过它来解析主机名ernest-laptop对应的IP地址。其结果正如wget的输出所示，解析成功。</p><p>如果程序在/etc/hosts文件中<strong>未找到</strong>目标机器名对应的IP地址，它将求助于DNS服务。</p><p>用户可以通过修改/etc/host.conf文件来自定义系统解析主机名的方法和顺序(一般是先访问本地文件/etc/hosts，再访问DNS服务)， Kongming20上的该文件内容如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">order hosts,bind<br>multi on<br></code></pre></td></tr></table></figure><p>其中第一行表示优先使用/etc/hosts文件来解析主机名(hosts)， 失败后再使用DNS服务(bind)。第二行表示如果/etc/hosts文件中一个主机名对应多个IP地址，那么解析的结果就包含多个IP地址。/etc/host.conf文件通常仅包含这两行，但它支持更多选项，具体使用请参考其man手册。</p><p>标准文档RFC 1123指出，网络上的主机都应该实现一个简单的本地名称查询服务。</p><h2 id="46-http通信"><a class="markdownIt-Anchor" href="#46-http通信"></a> 4.6 HTTP通信</h2><p>为了方便讨论，我们将wget客户端和代理服务器之间的通信过程画成图4-4所示的TCP时序图。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205161827241.png" alt="截屏2022-05-16 下午6.26.57" /></p><p>首先应该注意的是，TCP连接从建立到关闭的过程中，客户端仅给服务器发送了一个HTTP请求(即TCP报文段4)，该请求的长度为136 字节(见代码清单4-2中TCP报文段4的length值)。代理服务器则用6个TCP报文段(23、24、25、33、35和36)给客户端返回了总长度为8522 字节(这可以从对方的最后一个确认报文段42的确认值计算得到，考虑同步报文段和结束报文段各占用一个序号)的HTTP应答。客户端使 用了7个TCP报文段(32、34、37、38、39、40和42)来确认这8522字节的HTTP应答数据。</p><p>下面我们简单分析一下这136字节的HTTP请求和8522字节的HTTP应答的部分主要内容(开启tcpdump的-X选项来查看)。</p><h3 id="461-http请求"><a class="markdownIt-Anchor" href="#461-http请求"></a> 4.6.1 HTTP请求</h3><p>HTTP请求的部分内容如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">GET http:<span class="hljs-comment">//www.baidu.com/index.html HTTP/1.0</span><br>User-Agent:Wget/<span class="hljs-number">1.12</span>(linux-gnu)<br>Host:www.baidu.com<br>Connection:close<br></code></pre></td></tr></table></figure><p>第1行是请求行。其中“GET”是请求方法，表示客户端以只读的方式来申请资源。常见的HTTP请求方法有9种，如表4-1所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205162120269.png" alt="截屏2022-05-16 下午9.20.40" /></p><p>这些方法中，HEAD、GET、OPTIONS和TRACE被视为安全的方法，因为它们只是从服务器获得资源或信息，而不对服务器进行任何修改。而POST、PUT、DELETE和PATCH则影响服务器上的资源。</p><p>另一方面，GET、HEAD、OPTIONS、TRACE、PUT和DELETE等请求方法被认为是等幂的(idempotent)，即<u>多次连续的、重复的请求和只发送一次该请求具有完全相同</u>的效果。而<strong>POST方法则不同</strong>，<u>连续多次发送同样一个请求可能进一步影响服务器上</u>的资源。</p><p>值得一提的是，Linux上提供了几个命令:HEAD、GET和POST。其含义基本与HTTP协议中的同名请求方法相同。它们适合用来快速测试Web服务器。</p><p>“<a href="http://www.baidu.com/index.html%E2%80%9D%E6%98%AF%E7%9B%AE%E6%A0%87%E8%B5%84%E6%BA%90%E7%9A%84URL%E3%80%82%E5%85%B6%E4%B8%AD%E2%80%9Chttp%E2%80%9D%E6%98%AF%E6%89%80%E8%B0%93%E7%9A%84scheme%EF%BC%8C%E8%A1%A8%E7%A4%BA">http://www.baidu.com/index.html”是目标资源的URL。其中“http”是所谓的scheme，表示</a><strong>获取目标资源需要使用的应用层协议</strong>。</p><p>其他常见的scheme还有ftp、rtsp和file等。“<a href="http://www.baidu.com">www.baidu.com</a>”指定资源所在的目标主机。“index.html”指定资源文件的名称，这里指的是服务器根目录(站点的根目录，而不是服务器的文件系统根目录“/”)中的索引文件。</p><p>“HTTP/1. 0”表示客户端(wget程序)使用的HTTP的版本号是1.0。 目前的主流HTTP版本是1.1。</p><p>HTTP请求内容中的第2~4行都是HTTP请求的头部字段。一个HTTP请求可以包含多个头部字段。一个头部字段用一行表示，包含字段名称、冒号、空格和字段的值。HTTP请求中的头部字段可按任意顺序排列。</p><p>“User-Agent:Wget/1.12(linux-gnu)”表示客户端使用的程序是wget。</p><p>“Host:www.baidu.com”<a href="http://xn--www-g88d49x1m3amsb25b822e81ekv2c.baidu.com">表示目标主机名是www.baidu.com</a>。HTTP协议规定HTTP请求中<strong>必须包含</strong>的头部字段就是目标主机名。</p><h4 id="短连接"><a class="markdownIt-Anchor" href="#短连接"></a> 短连接</h4><p>“Connection:close”是我们执行wget命令时传入的(见代码清单4-1)，用以告诉服务器处理完这个HTTP请求之后就关闭连接。在旧的HTTP协议中，Web客户端和Web服务器之间的一个TCP连接只能为一个HTTP请求服务。当处理完客户的一个HTTP请求之后，Web服务器就 (主动)将TCP连接关闭了。此后，同一客户如果要再发送一个HTTP请求的话，必须与服务器建立一个新的TCP连接。也就是说，同一个客户的多个连续的HTTP请求不能共用同一个TCP连接，这称为短连接。</p><h4 id="长连接"><a class="markdownIt-Anchor" href="#长连接"></a> 长连接</h4><p>与之相反，是指多个请求可以使用同一个TCP连接。长连接在编程上稍微复杂一些，但性能上却有很大提高:它极大地减少了网络上为建立TCP连接导致的负荷，同时对每次请求而言缩减了处理时间。 HTTP请求和应答中的“Connection”头部字段就是专门用于告诉对方一个请求完成之后该如何处理连接的，比如立即关闭连接(该头部字段的值为“close”)或者保持一段时间以等待后续请求(该头部字段的值为“keep-alive”)。当用浏览器访问一个网页时，读者不妨使用netstat命令来查看浏览器和Web服务器之间的连接是否是长连接，以及该连接维持了多长时间。</p><p>在所有头部字段之后，HTTP请求必须包含一个空行，以标识头部字段的结束。请求行和每个头部字段都必须以<CR><LF>结束(回车符和换行符);而空行则必须只包含一个<CR><LF>，不能有其他字符，甚至是空白字符。</p><p>在空行之后，HTTP请求可以包含可选的消息体。如果消息体非空，则HTTP请求的头部字段中必须包含描述该消息体长度的字段“Content-Length”。我们的实例只是获取目标服务器上的资源，所以没有消息体。</p><h3 id="462-http应答"><a class="markdownIt-Anchor" href="#462-http应答"></a> 4.6.2 HTTP应答</h3><p>HTTP应答的部分内容如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"> HTTP/<span class="hljs-number">1.0</span> <span class="hljs-number">200</span> OK<br>   Server:BWS/<span class="hljs-number">1.0</span><br>   Content-Length:<span class="hljs-number">8024</span><br>   Content-Type:text/html;charset=gbk<br>   Set-<br>Cookie:BAIDUID=A5B6C72D68CF639CE8896FD79A03FBD8:FG=<span class="hljs-number">1</span>;expires=Wed,<span class="hljs-number">04</span>-<br>Jul<span class="hljs-number">-42</span> <span class="hljs-number">00</span>:<span class="hljs-number">10</span>:<span class="hljs-number">47</span> GMT;path=/;domain=.baidu.com<br>   Via:<span class="hljs-number">1.0</span> <span class="hljs-built_in">localhost</span>(squid/<span class="hljs-number">3.0</span> STABLE18)<br></code></pre></td></tr></table></figure><p>第一行是状态行。“HTTP/1.0”是服务器使用的HTTP协议的版本号。通常，服务器需要使用和客户端相同的HTTP协议版本。“200 OK”是状态码和状态信息。常见的状态码和状态信息及其含义如表4-2 所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205162146797.png" alt="截屏2022-05-16 下午9.46.49" /></p><p><strong>第2~7行</strong>是HTTP应答的头部字段。其表示方法与HTTP请求中的头部字段相同。</p><p>**“Server:BWS/1. 0”**表示目标Web服务器程序的名字是BWS(Baidu Web Server)。</p><p>**“Content-Length:8024”**表示目标文档的长度为8024字节。这个值和wget输出的文档长度一致。</p><p>**“Content-Type:text/html;charset=gbk”**表示目标文档的MIME类型。 其中“text”是主文档类型，“html”是子文档类型。“text/html”表示目标文档index.html是text类型中的html文档。“charset”是text文档类型的一个参数，用于指定文档的字符编码。</p><p>**“Set-Cookie:BAIDUID=A5B6C72D68CF639CE8896FD79A03FBD8:FG=1;expi res=Wed,04-Jul-42 00:10:47 GMT;path=/;domain=. <a href="http://baidu.com">baidu.com</a>”<strong>表示服务器传送一个Cookie给客户端。其中，</strong>“BAIDUID”<strong>指定Cookie的名字，</strong>“expires”<strong>指定Cookie的生存时间，</strong>“domain”<strong>和</strong>“path”**指定该Cookie生效的域名和路径。下面我们简单分析一下Cookie的作用。</p><p>第2章中曾提到，HTTP协议是一种<strong>无状态</strong>的协议，即每个HTTP请求之间没有任何上下文关系。如果服务器处理后续HTTP请求时需要用到前面的HTTP请求的相关信息，客户端必须重传这些信息。这样就<u>导致HTTP请求必须传输更多</u>的数据。</p><p>在交互式Web应用程序兴起之后，HTTP协议的这种无状态特性就显得不适应了，因为交互程序<u>通常要承上启下</u>。因此，我们要<u>使用额外的手段来保持HTTP连接状态，常见的解决方法就是Cookie</u>。Cookie是服务器发送给客户端的特殊信息(通过HTTP应答的头部字段“Set- Cookie”)，客户端每次向服务器发送请求的时候都需要带上这些信息 (通过HTTP请求的头部字段“Cookie”)。这样服务器就可以区分不同 的客户了。<strong>基于浏览器的自动登录就是用Cookie实现的</strong>。</p><p>**“Via:1. 0 localhost(squid/3.0 STABLE18)”**表示HTTP应答在返回过程中经历过的所有代理服务器的地址和名称。这里的localhost实际上指的是“192.168.1.108”。这个头部字段的功能有点类似于IP协议的记录路由功能。</p><p>在所有头部字段之后，HTTP应答必须包含一个空行，以标识头部字段的结束。状态行和每个头部字段都必须以<CR><LF>结束;而空行则必须只包含一个<CR><LF>，不能有其他字符，甚至是空白字符。</p><p>空行之后是被请求文档index.html的内容(当然，我们并不关心它)，其长度是8024字节。</p><h2 id="47-实例总结"><a class="markdownIt-Anchor" href="#47-实例总结"></a> 4.7 实例总结</h2><p>至此，我们成功地访问了Internet上的Web服务器，通过该实例，我们分析了TCP/IP协议族各层的部分协议:应用层的HTTP和DNS、传输层的TCP和UDP、网络层的IP、数据链路层的ARP，以及它们之间是如何协作来完成网络通信的。我们的分析方法是使用tcpdump抓包， 然后观察各层协议的头部内容以推断其工作原理。在后续章节中，我们还将多次使用这种方法来分析问题。</p><h1 id="第5章-linux网络编程基础api"><a class="markdownIt-Anchor" href="#第5章-linux网络编程基础api"></a> 第5章 Linux网络编程基础API</h1><p>本章是承前启后的一章。它探讨Linux网络编程基础API与内核中TCP/IP协议族之间的关系，并为后续章节提供编程基础。我们将从如下3个方面讨论Linux网络API:</p><p><strong>socket地址API</strong></p><p>socket最开始的含义是一个IP地址和端口对(ip，port)。它唯一地表示了使用TCP通信的一端。本书称其为socket地址。</p><p><strong>socket基础API</strong></p><p>socket的主要API都定义在sys/socket.h头文件中，包括创建socket、命名socket、监听socket、接受连接、发起连接、读写数据、获取地址信息、检测带外标记，以及读取和设置socket选项。</p><p><strong>网络信息API</strong></p><p>Linux提供了一套网络信息API，以实现主机名和IP地址之间的转换，以及服务名称和端口号之间的转换。这些API都定义在netdb.h头文件中，我们将讨论其中几个主要的函数。</p><h2 id="51-socket地址api"><a class="markdownIt-Anchor" href="#51-socket地址api"></a> 5.1 socket地址API</h2><p>要学习socket地址API，先要理解<strong>主机字节序</strong>和<strong>网络字节序</strong>。</p><h3 id="511-主机字节序和网络字节序"><a class="markdownIt-Anchor" href="#511-主机字节序和网络字节序"></a> 5.1.1 主机字节序和网络字节序</h3><p>现代CPU的累加器一次都能装载(至少)4字节(这里考虑32位机，下同)，即一个整数。那么这4字节在内存中排列的顺序将影响它被累加器装载成的整数的值。这就是字节序问题。字节序分为<strong>大端字节序(big endian)<strong>和</strong>小端字节序(little endian)</strong>。大端字节序是指<u>一个整数的高位字节(23~31bit)存储在内存的低地址处</u>，<u>低位字节(0 ~7 bit)存储在内存的高地址处</u>。小端字节序则是指<u>整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处</u>。代码清单5-1可用于检查机器的字节序。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205172044910.png" alt="截屏2022-05-17 下午8.44.34" /></p><p>代码清单5-1 判断机器字节序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">byteorder</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">short</span> value;<br><span class="hljs-keyword">char</span> union_bytes[ <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( <span class="hljs-keyword">short</span> ) ];<br>&#125; test;<br>test.value = <span class="hljs-number">0x0102</span>; <span class="hljs-comment">// 用一个共用体来表示一个16进制的数，通过两种方式来表示结果</span><br><span class="hljs-keyword">if</span> (  ( test.union_bytes[ <span class="hljs-number">0</span> ] == <span class="hljs-number">1</span> ) &amp;&amp; ( test.union_bytes[ <span class="hljs-number">1</span> ] == <span class="hljs-number">2</span> ) )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;big endian\n&quot;</span> ); <span class="hljs-comment">// 判断低位是不是小的高位是不是大的</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( ( test.union_bytes[ <span class="hljs-number">0</span> ] == <span class="hljs-number">2</span> ) &amp;&amp; ( test.union_bytes[ <span class="hljs-number">1</span> ] == <span class="hljs-number">1</span> ) )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;little endian\n&quot;</span> ); <span class="hljs-comment">// 判断低位是不是大的高位是不是小的</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;unknown...\n&quot;</span> );<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现代PC大多采用小端字节序，因此小端字节序又被称为<strong>主机字节序</strong>。</p><p>当格式化的数据(比如32bit整型数和16bit短整型数)在两台使用不同字节序的主机之间直接传递时，接收端必然错误地解释之。解决问题的方法是:发送端总是把要发送的数据<u>转化成大端字节序数据后再发送</u>，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端<u>可以根据自身采用的字节序决定是否对接收到的数据进行转换</u>(小端机转换，大端机不转换)。因此大端字节序也称为<strong>网络字节序</strong>，它给所有接收数据的主机提供了一个正确解释收到的格式化数据的保证。</p><p>需要指出的是，即使是同一台机器上的两个进程(比如一个由C语言编写，另一个由JAVA编写)通信，也要考虑字节序的问题(JAVA虚拟机采用大端字节序)。</p><p>Linux提供了如下4个函数来完成<u>主机字节序和网络字节序之间的转换</u>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">htonl</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> hostlong)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> <span class="hljs-title">htons</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> hostshort)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ntohl</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> netlong)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ntohs</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> netshort)</span></span>;<br></code></pre></td></tr></table></figure><p>它们的含义很明确，比如htonl表示“host to network long”，即将长整型(32 bit)的主机字节序数据转化为网络字节序数据。这4个函数中，长整型函数通常<u>用来转换IP地址</u>，短整型函数用来<u>转换端口号</u>(当然不限于此。任何格式化的数据通过网络传输时，都应该使用这些函数来转换字节序)。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205181750387.png" alt="截屏2022-05-18 下午5.49.36" /></p><h3 id="512-通用socket地址"><a class="markdownIt-Anchor" href="#512-通用socket地址"></a> 5.1.2 通用socket地址</h3><p>socket网络编程接口中表示<strong>socket地址</strong>的是结构体sockaddr，其定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/socket.h&gt;</span> </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">sa_family_t</span> sa_family; <br>  <span class="hljs-keyword">char</span> sa_data[<span class="hljs-number">14</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>sa_family成员</strong>是**地址族类型(sa_family_t)**的变量。地址族类型通常与协议族类型对应。常见的协议族(protocol family，也称domain， 见后文)和对应的地址族如表5-1所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205172102909.png" alt="截屏2022-05-17 下午9.02.11" /></p><p>宏PF_ *和AF_ *都定义在bits/socket.h头文件中，且后者与前者有完全相同的值，所以二者通常混用。</p><p><strong>sa_data成员</strong>用于存放socket地址值。但是，不同的协议族的地址值具有不同的含义和长度，如表5-2所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205172105793.png" alt="截屏2022-05-17 下午9.05.36" /></p><p>由表5-2可见，14字节的sa_data根本无法完全容纳多数协议族的地址值。因此，Linux定义了下面这个新的通用socket地址结构体:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/socket.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">sa_family_t</span> sa_family;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> __ss_align; <br><span class="hljs-keyword">char</span> __ss_padding[<span class="hljs-number">128</span> - <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(__ss_align)];  <span class="hljs-comment">// 为什么是128 - sizeof是因为保证二三元素的大小一定是128个字节</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个结构体不仅提供了足够大的空间用于存放地址值，而且是<strong>内存对齐</strong>的(这是__ss_align成员的作用)。</p><p>内存对齐相关的知识：<a href="https://blog.csdn.net/feng__shuai/article/details/115768166">https://blog.csdn.net/feng__shuai/article/details/115768166</a></p><p><a href="https://blog.csdn.net/suoyudong/article/details/88366235?utm_medium=distribute.pc_relevant.none-task-blog-2">https://blog.csdn.net/suoyudong/article/details/88366235?utm_medium=distribute.pc_relevant.none-task-blog-2</a><sub>default</sub>baidujs_baidulandingword~default-0-88366235-blog-115768166.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=1</p><p>这部分说白了就是，当你的变量大小没办法一次性全部读取出来的话，会造成地址的浪费，不如直接补齐这部分都是你的。</p><h3 id="513-专用socket地址"><a class="markdownIt-Anchor" href="#513-专用socket地址"></a> 5.1.3 专用socket地址</h3><p>上面这两个通用socket地址结构体显然很不好用，比如设置与获取IP地址和端口号就需要执行烦琐的位操作。所以Linux为各个协议族提 供了专门的socket地址结构体。</p><p><strong>UNIX本地域协议族</strong>使用如下专用socket地址结构体:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/un.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_un</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">sa_family_t</span> sin_family;<span class="hljs-comment">/*地址族:AF_UNIX*/</span> <br><span class="hljs-keyword">char</span> sun_path[<span class="hljs-number">108</span>];<span class="hljs-comment">/*文件路径名*/</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>TCP/IP协议族有sockaddr_in和sockaddr_in6两个专用socket地址结构体，它们分别用于IPv4和IPv6:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">sa_family_t</span> sin_family;<span class="hljs-comment">/*地址族:AF_INET*/</span><br><span class="hljs-keyword">u_int16_t</span> sin_port;<span class="hljs-comment">/*端口号，要用网络字节序表示*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span><span class="hljs-comment">/*IPv4地址结构体，见下面*/</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">u_int32_t</span> s_addr;<span class="hljs-comment">/*IPv4地址，要用网络字节序表示*/</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in6</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">sa_family_t</span> sin6_family;<span class="hljs-comment">/*地址族:AF_INET6*/</span><br><span class="hljs-keyword">u_int16_t</span> sin6_port;<span class="hljs-comment">/*端口号，要用网络字节序表示*/</span> <br>  <span class="hljs-keyword">u_int32_t</span> sin6_flowinfo;<span class="hljs-comment">/*流信息，应设置为0*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span> <span class="hljs-title">sin6_addr</span>;</span><span class="hljs-comment">/*IPv6地址结构体，见下面*/</span> <br>  <span class="hljs-keyword">u_int32_t</span> sin6_scope_id;<span class="hljs-comment">/*scope ID，尚处于实验阶段*/</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in6_addr</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> sa_addr[<span class="hljs-number">16</span>];<span class="hljs-comment">/*IPv6地址，要用网络字节序表示*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure><p>这两个专用socket地址结构体各字段的含义都很明确，我们只在右边稍加注释。</p><p>所有专用socket地址(以及sockaddr_storage)类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr(强制转换即可)，因为<u>所有socket编程接口使用的地址参数</u>的类型都是<strong>sockaddr</strong>。</p><h3 id="514-ip地址转换函数"><a class="markdownIt-Anchor" href="#514-ip地址转换函数"></a> 5.1.4 IP地址转换函数</h3><p>通常，人们习惯用可读性好的字符串来表示IP地址，比如用点分十进制字符串表示IPv4地址，以及用十六进制字符串表示IPv6地址。但编程中我们需要先把它们转化为整数(二进制数)方能使用。</p><p>而记录日志时则相反，我们要把整数表示的IP地址转化为可读的字符串。下面3个函数可用于用<u>点分十进制</u>字符串表示的<strong>IPv4地址</strong>和<strong>用网络字节序</strong>整数表示的IPv4地址之间的转换:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">in_addr_t</span> <span class="hljs-title">inet_addr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*strptr)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inet_aton</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*cp, struct in_addr*inp)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">char</span>*<span class="hljs-title">inet_ntoa</span><span class="hljs-params">(struct in_addr in)</span></span>;<br></code></pre></td></tr></table></figure><p>inet_addr函数将用<u>点分十进制字符串</u>表示的IPv4地址转化为用<u>网络字节序整数</u>表示的IPv4地址。它失败时返回INADDR_NONE。</p><p>inet_aton函数完成和inet_addr同样的功能，但是将转化结果存储于 参数inp指向的地址结构中。它成功时返回1，失败则返回0。</p><p>inet_ntoa函数将用<u>网络字节序整数</u>表示的IPv4地址转化为<u>用点分十进制字符串</u>表示的IPv4地址。但需要注意的是，该函数内部用一个静 态变量存储转化结果，函数的返回值指向该静态内存，因此inet_ntoa是<strong>不可重入</strong>的。代码清单5-2揭示了其不可重入性。</p><p>代码清单5-2 不可重入的inet_ntoa函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">char</span>* szValue1 = <span class="hljs-built_in">inet_ntoa</span>(“<span class="hljs-number">1.2</span><span class="hljs-number">.3</span><span class="hljs-number">.4</span>”);<br><span class="hljs-keyword">char</span>* szValue2 = <span class="hljs-built_in">inet_ntoa</span>(“<span class="hljs-number">10.194</span><span class="hljs-number">.71</span><span class="hljs-number">.60</span>”);<br><span class="hljs-built_in">printf</span>(“address <span class="hljs-number">1</span>:%s\n”, szValue1);<br><span class="hljs-built_in">printf</span>(“address <span class="hljs-number">2</span>:%s\n”, szValue2);<br></code></pre></td></tr></table></figure><p>运行这段代码，得到的结果是: （说明了他们指向的是同一片区域，不可以用作并发执行）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">address1:<span class="hljs-number">10.194</span><span class="hljs-number">.71</span><span class="hljs-number">.60</span><br>address2:<span class="hljs-number">10.194</span><span class="hljs-number">.71</span><span class="hljs-number">.60</span><br></code></pre></td></tr></table></figure><p>下面这对更新的函数也能完成和前面3个函数同样的功能，并且它们同时适用于IPv4地址和IPv6地址:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inet_pton</span><span class="hljs-params">(<span class="hljs-keyword">int</span> af, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* src, <span class="hljs-keyword">void</span>* dst)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-title">inet_ntop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> af, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* src, <span class="hljs-keyword">char</span>* dst, <span class="hljs-keyword">socklen_t</span> cnt)</span></span>;<br></code></pre></td></tr></table></figure><p>inet_pton函数将用字符串表示的IP地址src(用点分十进制字符串表示的IPv4地址或用十六进制字符串表示的IPv6地址)转换成用网络字节序整数表示的IP地址，并把转换结果存储于<strong>dst指向的内存</strong>中。其中，af参数<u>指定地址族</u>，可以是AF_INET或者AF_INET6。inet_pton成功时返回1，失败则返回0并设置errno[1]。</p><p>inet_ntop函数进行相反的转换，前三个参数的含义与inet_pton的参数相同，最后一个参数cnt指定目标存储单元的大小。下面的两个宏能 帮助我们指定这个大小(分别用于IPv4和IPv6):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netinet/in.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INET_ADDRSTRLEN 16 </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INET6_ADDRSTRLEN 46</span><br></code></pre></td></tr></table></figure><p>inet_ntop成功时返回目标存储单元的地址，失败则返回NULL并设置errno。</p><p>[1]Linux提供众多errno以表示各种错误。如非特殊情况，本书将不一一指出各函数可能反馈的errno值。</p><h2 id="52-创建socket"><a class="markdownIt-Anchor" href="#52-创建socket"></a> 5.2 创建socket</h2><h3 id="用netstat命令显示套接字内容这个贯通全文"><a class="markdownIt-Anchor" href="#用netstat命令显示套接字内容这个贯通全文"></a> 用netstat命令显示套接字内容这个贯通全文</h3><p>UNIX/Linux的一个哲学是:<strong>所有东西都是文件</strong>。socket也不例外，它就是可读、可写、可控制、可关闭的文件描述符。下面的socket系统调用可创建一个socket:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> domain,<span class="hljs-keyword">int</span> type,<span class="hljs-keyword">int</span> protocol)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>domain参数</strong></p><p>告诉系统<u>使用哪个底层协议族</u>。对TCP/IP协议族而言，该参数应该设置为<strong>PF_INET</strong>(Protocol Family of Internet，用于IPv4)或<strong>PF_INET6</strong>(用于IPv6);对于UNIX本地域协议族而言，该参数应该设置为PF_UNIX。关于socket系统调用支持的所有协议族， 请读者自己参考其man手册。</p><p><strong>type参数</strong></p><p>指定服务类型。服务类型主要有<strong>SOCK_STREAM</strong>服务(流服务)和<strong>SOCK_UGRAM</strong>(数据报)服务。对TCP/IP协议族而言，其值取SOCK_STREAM表示传输层使用TCP协议，取SOCK_DGRAM表示传输层使用UDP协议。</p><p>值得指出的是，自Linux内核版本2.6.17起，type参数可以<u>接受上述服务类型与下面两个重要的标志相与</u>的值:SOCK_NONBLOCK和SOCK_CLOEXEC。它们分别表示将新创建的socket设为非阻塞的，以及用fork调用创建子进程时在子进程中关闭该socket。在内核版本 2.6.17之前的Linux中，文件描述符的这两个属性都需要使用额外的系统调用(比如fcntl)来设置。</p><p><strong>protocol参数</strong></p><p>是在前两个参数构成的协议集合下，再选择一个具体的协议。不过这个值通常都是唯一的(前两个参数已经完全决定了它的值)。几乎在所有情况下，我们都应该把它设置为0，表示使用默认协议。</p><p>socket系统调用成功时返回一个socket文件描述符，失败则返回-1并设置errno。</p><h2 id="53-命名socket"><a class="markdownIt-Anchor" href="#53-命名socket"></a> 5.3 命名socket</h2><p>创建socket时，我们给它指定了地址族，但是并未指定使用该地址族中的哪个具体<strong>socket地址</strong>。<u>将一个socket与socket地址绑定</u>称为给<strong>socket命名</strong>。在服务器程序中，我们通常要命名socket，因为只有命名后客户端才能知道该如何连接它。客户端则通常不需要命名socket，而是采用匿名方式，即使用操作系统自动分配的socket地址。命名socket的系统调用是bind，其定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">const</span> struct sockaddr* my_addr,<span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p>bind将<u>my_addr所指的socket地址</u>分配给未命名的<strong>sockfd文件描述符</strong>。</p><p><strong>addrlen参数</strong>指出该<strong>socket地址的长度</strong>。</p><p>bind成功时返回0，失败则返回-1并设置errno。其中两种常见的errno是EACCES和EADDRINUSE，它们的含义分别是:</p><p><strong>EACCES</strong></p><p>被绑定的地址是受保护的地址，仅超级用户能够访问。比如普通用户将socket绑定到知名服务端口(端口号为0~1023) 上时，bind将返回EACCES错误。</p><p><strong>EADDRINUSE</strong></p><p>被绑定的地址正在使用中。比如将socket绑定到一个处于TIME_WAIT状态的socket地址。</p><h2 id="54-监听socket"><a class="markdownIt-Anchor" href="#54-监听socket"></a> 5.4 监听socket</h2><p>socket被命名之后，还不能马上接受客户连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户连接:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">int</span> backlog)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>sockfd参数</strong>指定被监听的socket。</p><p><strong>backlog参数</strong>提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客户连接，客户端也将收到ECONNREFUSED错误信息。在内核版本2.2 之前的Linux中，backlog参数是指所有处于半连接状态 (SYN_RCVD)和完全连接状态(ESTABLISHED)的socket的上限。 但自内核版本2.2之后，它只表示处于完全连接状态的socket的上限，处于半连接状态的socket的上限则由/proc/sys/net/ipv4/tcp_max_syn_backlog内核参数定义。backlog参数的典型值是5。</p><p>listen成功时返回0，失败则返回-1并设置errno。</p><p>下面我们编写一个<strong>服务器程序</strong>，如代码清单5-3所示，以研究 backlog参数对listen系统调用的实际影响。</p><p>代码清单5-3 backlog参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> stop = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">/*SIGTERM信号的处理函数，触发时结束主程序中的循环*/</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle_term</span><span class="hljs-params">( <span class="hljs-keyword">int</span> sig )</span></span><br><span class="hljs-function"></span>&#123;<br>    stop = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span> <span class="hljs-comment">// argv[] : IP地址、端口号和backlog值</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">signal</span>( SIGTERM, handle_term );<br><br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">3</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number backlog\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) ); <span class="hljs-comment">// 0代表的是文件名字</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>]; <span class="hljs-comment">// IP地址</span><br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] ); <span class="hljs-comment">// 端口号</span><br>    <span class="hljs-keyword">int</span> backlog = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">3</span>] ); <span class="hljs-comment">// backlog值</span><br><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> ); <span class="hljs-comment">// 创立TCP写一个socket</span><br>    <span class="hljs-comment">// socket系统调用成功时返回一个socket文件描述符，失败则返回-1并设置errno。</span><br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">/*创建一个IPv4 socket地址 用于接收监听的ip*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;  <span class="hljs-comment">// 地址族 ： AF_INET</span><br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr ); <span class="hljs-comment">// 将IPv4地址转换成网络字节序整数表示的IP地址</span><br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );  <span class="hljs-comment">// 端口号，用网络字节序表示</span><br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );  <span class="hljs-comment">// 给sock套接字赋予地址</span><br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><br>    ret = <span class="hljs-built_in">listen</span>( sock, backlog );  <span class="hljs-comment">// 来监听这个套接字 backlog来确定可以监听队列的最大长度，再多就不听了</span><br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">/*循环等待连接，直到有SIGTERM信号将它中断*/</span><br>    <span class="hljs-keyword">while</span> ( ! stop )<br>    &#123;<br>        <span class="hljs-built_in">sleep</span>( <span class="hljs-number">1</span> );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-comment">/*关闭socket，见后文*/</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该服务器程序(名为testlisten)接收3个参数:IP地址、端口号和backlog值。我们在Kongming20上运行该服务器程序，并在ernest-laptop上多次执行telnet命令来连接该服务器程序。同时，每使用telnet命令建立一个连接，就执行一次netstat命令来查看服务器上连接的状态。具体操作过程如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">$./testlisten <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">12345</span> <span class="hljs-number">5</span>#监听<span class="hljs-number">12345</span>端口，给backlog传递典 型值<span class="hljs-number">5</span><br>$telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">12345</span>#多次执行之 <br>$netstat-nt|grep <span class="hljs-number">12345</span>#多次执行之<br></code></pre></td></tr></table></figure><p>代码清单5-4是netstat命令某次输出的内容，它显示了这一时刻listen监听队列的内容。</p><p>代码清单5-4 listen监听队列的内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">Proto Recv-Q Send-Q Local Address Foreign Address Statetcp<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2240</span> SYN_RECV<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2228</span> SYN_RECV[<span class="hljs-number">1</span>]<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2230</span> SYN_RECV<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2238</span> SYN_RECV<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2236</span> SYN_RECV<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2217</span> ESTABLISHED<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2226</span> ESTABLISHED<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2224</span> ESTABLISHED<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2212</span> ESTABLISHED<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2220</span> ESTABLISHED<br> tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">12345</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">2222</span> ESTABLISHED<br></code></pre></td></tr></table></figure><p>可见，在监听队列中，处于ESTABLISHED状态的连接只有6个 (backlog值加1)，其他的连接都处于SYN_RCVD状态。我们改变服务器程序的第3个参数并重新运行之，能发现同样的规律，即完整连接最多有(backlog+1)个。在不同的系统上，运行结果会有些差别，不过监听队列中完整连接的上限通常比backlog值略大。</p><h2 id="55-接受连接"><a class="markdownIt-Anchor" href="#55-接受连接"></a> 5.5 接受连接</h2><p>下面的系统调用从listen监听队列中接受一个连接:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,struct sockaddr*addr,<span class="hljs-keyword">socklen_t</span>*addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>sockfd参数</strong>是执行过listen系统调用的<strong>监听socket</strong>[1]。</p><p><strong>addr参数</strong>用来获取被接受连接的<strong>远端socket地址</strong>，该socket地址的长度由addrlen参数指出。</p><p>accept成功时返回一个<strong>新的连接socket</strong>，该socket唯一地<u>标识了被接受的这个连接</u>，服务器可通过读写该socket来与被接受连接对应的客户端通信。accept失败时返回-1并设置errno。</p><p>现在考虑如下情况:如果监听队列中处于ESTABLISHED状态的连接对应的客户端出现网络异常(比如掉线)，或者提前退出，那么服务器对这个连接执行的accept调用是否成功?我们编写一个简单的服务器程序来测试之，如代码清单5-5所示。</p><p>代码清单5-5 接受一个异常的连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br><span class="hljs-comment">/*创建一个IPv4 socket地址 用于接收得到的ip地址*/</span> <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );  <span class="hljs-comment">// 创建一个socket对象 用来准备接收处理过后结果</span><br>    <span class="hljs-comment">// sock本身是文件描述符可以找到对应的套接字</span><br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) ); <span class="hljs-comment">// sock接收</span><br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 以上就是监听ip : port ret socket为获取的那个对象</span><br>    <span class="hljs-comment">/*暂停20秒以等待客户端连接和相关操作(掉线或者退出)完成*/</span><br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-comment">/*创建一个IPv4 socket地址 用于接收得到的ip地址*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );  <br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength ); <span class="hljs-comment">// 接收接受套接字的结果</span><br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )  <br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span><span class="hljs-comment">/*接受连接成功则打印出客户端的IP地址和端口号*/</span><br>    &#123; <br>        <span class="hljs-keyword">char</span> remote[INET_ADDRSTRLEN ];<br>        <span class="hljs-comment">// 获取对应的连接成功套接字信息</span><br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;connected with ip: %s and port: %d\n&quot;</span>, <br>            <span class="hljs-built_in">inet_ntop</span>( AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN ), <span class="hljs-built_in">ntohs</span>( client.sin_port ) );<br>        <span class="hljs-built_in">close</span>( connfd );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在Kongming20上运行该服务器程序(名为testaccept)，并在ernest-laptop上执行telnet命令来连接该服务器程序。具体操作过程如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$./testaccept <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">54321</span>#监听<span class="hljs-number">54321</span>端口 <br>$ telnet <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">54321</span><br></code></pre></td></tr></table></figure><p>启动telnet客户端程序后，立即断开该客户端的网络连接(建立和断开连接的过程要在服务器启动后20秒内完成)。结果发现accept调用能够正常返回，服务器输出如下:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">connected</span> with ip:<span class="hljs-number">192.168.1.108</span> and port:<span class="hljs-number">38545</span><br></code></pre></td></tr></table></figure><p>接着，在服务器上运行netstat命令以查看accept返回的连接socket的状态:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$netstat -nt|grep <span class="hljs-number">54321</span><br>tcp <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">54321</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">38545</span> ESTABLISHED<br></code></pre></td></tr></table></figure><p>netstat命令的输出说明，accept调用对于客户端网络断开毫不知情。下面我们重新执行上述过程，不过这次不断开客户端网络连接，而是在建立连接后立即退出客户端程序。这次accept调用同样正常返回，服务器输出如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">connected with ip:<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-keyword">and</span> port:<span class="hljs-number">52070</span><br></code></pre></td></tr></table></figure><p>再次在服务器上运行netstat命令:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">$netstat -nt|grep <span class="hljs-number">54321</span><br>tcp <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span>:<span class="hljs-number">54321</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span>:<span class="hljs-number">52070</span> CLOSE_WAIT<br></code></pre></td></tr></table></figure><p>由此可见，accept只是从<u>监听队列中取出连接</u>，而不论连接处于何种状态(如上面的ESTABLISHED状态和CLOSE_WAIT状态)，更不关心任何网络状况的变化。</p><h2 id="56-发起连接"><a class="markdownIt-Anchor" href="#56-发起连接"></a> 5.6 发起连接</h2><p>如果说服务器通过listen调用来<u>被动接受连接</u>，那么客户端需要通过如下系统调用来<u>主动与服务器建立连接</u>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">const</span> struct sockaddr*serv_addr,<span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>sockfd参数</strong>由socket系统调用返回一个socket。</p><p><strong>serv_addr参数</strong>是服务器监听的socket地址，<strong>addrlen参数</strong>则指定这个地址的长度。</p><p>connect成功时返回0。一旦成功建立连接，sockfd就唯一地标识了这个连接，<strong>客户端就可以通过读写sockfd</strong>【连接建立好，我们可以从socket对应的那个地方写入或者选择读取】来与服务器通信。connect失 败则返回-1并设置errno。其中两种常见的errno是ECONNREFUSED和 ETIMEDOUT，它们的含义如下:</p><p>1、ECONNREFUSED，目标端口不存在，连接被拒绝。我们在 3.5.1小节讨论过这种情况。</p><p>2、ETIMEDOUT，连接超时。我们在3.3.3小节讨论过这种情况。</p><h2 id="57-关闭连接"><a class="markdownIt-Anchor" href="#57-关闭连接"></a> 5.7 关闭连接</h2><p>关闭一个连接实际上就是关闭该连接对应的socket，这可以通过如下关闭普通文件描述符的系统调用来完成:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<br></code></pre></td></tr></table></figure><p>fd参数是待关闭的socket。不过，close系统调用并非<u>总是立即关闭一个连接，而是将fd的引用计数减1</u>。只有当fd的引用计数为0时，才真 正关闭连接。多进程程序中，一次fork系统调用默认将使父进程中打开的socket的引用计数加1，因此我们必须在父进程和子进程中都对该socket执行close调用才能将连接关闭。</p><p>如果无论如何都要立即终止连接(而不是将socket的引用计数减1)，可以使用如下的shutdown系统调用(相对于close来说，它是专门为网络编程设计的):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shutdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">int</span> howto)</span></span>;<br></code></pre></td></tr></table></figure><p>sockfd参数是待关闭的socket。<strong>howto参数</strong>决定了shutdown的行为， 它可取表5-3中的某个值。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205182136344.png" alt="截屏2022-05-18 下午9.36.47" /></p><p>由此可见，shutdown能够分别关闭socket上的读或写，或者都关闭。而close在关闭连接时只能将socket上的读和写同时关闭。</p><p>shutdown成功时返回0，失败则返回-1并设置errno。</p><h2 id="58-数据读写"><a class="markdownIt-Anchor" href="#58-数据读写"></a> 5.8 数据读写</h2><h3 id="581-tcp数据读写"><a class="markdownIt-Anchor" href="#581-tcp数据读写"></a> 5.8.1 TCP数据读写</h3><p>对文件的读写操作read和write同样适用于socket。但是socket编程接口提供了几个专门用于socket数据读写的系统调用，它们增加了对数据读写的控制。其中用于<strong>TCP流数据读写</strong>的系统调用是:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">void</span>*buf,<span class="hljs-keyword">size_t</span> len,<span class="hljs-keyword">int</span> flags)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">send</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*buf,<span class="hljs-keyword">size_t</span> len,<span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>recv</strong>读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小，flags参数的含义见后文，通常设置为0即可。recv成功时返回 实际读取到的数据的长度，它可能小于我们期望的长度len。因此我们可能要多次调用recv，才能读取到完整的数据。<u>recv可能返回0，这意味着通信对方已经关闭连接</u>了。recv出错时返回-1并设置errno。</p><p><strong>send</strong>往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。send成功时返回实际写入的数据的长度，失败则返回-1并设置 errno。</p><p>flags参数为数据收发提供了额外的控制，它可以取表5-4所示选项中的一个或几个的逻辑或。</p><p>由于socket连接是<strong>全双工</strong>的，这里的“读端”是针对通信对方而言的</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205182140957.png" alt="截屏2022-05-18 下午9.40.39" /></p><p>我们举例来说明如何使用这些选项。MSG_OOB选项给应用程序<u>提供了发送和接收带外数据的方法</u>，如代码清单5-6和代码清单5-7所示。</p><p>代码清单5-6 发送带外数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 创建IPv4 地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;server_address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( server_address ) );<br>    server_address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;server_address.sin_addr );<br>    server_address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 建立套接字</span><br>    <span class="hljs-keyword">int</span> sockfd = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sockfd &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">connect</span>( sockfd, ( struct sockaddr* )&amp;server_address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( server_address ) ) &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">// 建立连接套接字并判断是否链接</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;connection failed\n&quot;</span> );<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;send oob data out\n&quot;</span> );<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* oob_data = <span class="hljs-string">&quot;abc&quot;</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* normal_data = <span class="hljs-string">&quot;123&quot;</span>;<br>        <span class="hljs-comment">// 发送套接字</span><br>        <span class="hljs-built_in">send</span>( sockfd, normal_data, <span class="hljs-built_in">strlen</span>( normal_data ), <span class="hljs-number">0</span> );<br>        <span class="hljs-built_in">send</span>( sockfd, oob_data, <span class="hljs-built_in">strlen</span>( oob_data ), MSG_OOB );<br>        <span class="hljs-built_in">send</span>( sockfd, normal_data, <span class="hljs-built_in">strlen</span>( normal_data ), <span class="hljs-number">0</span> );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sockfd );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码清单5-7 接收带外数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUF_SIZE 1024</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 建立监听套接字</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>     <br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// ipv4地址设置</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );<br>    <span class="hljs-comment">// 接受连接（从监听套接字里提取接结果）</span><br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );<br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">char</span> buffer[ BUF_SIZE ];<br>        <span class="hljs-comment">// 接受套接字 ret存储字节数，buffer存储结果</span><br>        <span class="hljs-built_in">memset</span>( buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE );<br>        ret = <span class="hljs-built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span> );<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );<br><br>        <span class="hljs-built_in">memset</span>( buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE );<br>        ret = <span class="hljs-built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="hljs-number">-1</span>, MSG_OOB );<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;got %d bytes of oob data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );<br><br>        <span class="hljs-built_in">memset</span>( buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUF_SIZE );<br>        ret = <span class="hljs-built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span> );<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );<br><br>        <span class="hljs-built_in">close</span>( connfd );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先在Kongming20上启动代码清单5-7所示的服务器程序(名为testoobrecv)，然后从ernest-laptop上执行代码清单5-6所示的客户端程序(名为testoobsend)来向服务器发送带外数据。同时用tcpdump抓取这一过程中客户端和服务器交换的TCP报文段。具体操作如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">$./testoobrecv <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">54321</span>#在Kongming20上执行服务器程序，监听 <span class="hljs-number">54321</span>端口<br>$./testoobsend <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span> <span class="hljs-number">54321</span>#在ernest-laptop上执行客户端程序 <br>$sudo tcpdump-ntx -i eth0 port <span class="hljs-number">54321</span><br></code></pre></td></tr></table></figure><p>服务器程序的输出如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">got <span class="hljs-number">5</span> bytes of normal data<span class="hljs-number">&#x27;123</span>ab<span class="hljs-number">&#x27;</span><br>got <span class="hljs-number">1</span> bytes of oob data<span class="hljs-number">&#x27;</span>c<span class="hljs-number">&#x27;</span><br>got <span class="hljs-number">3</span> bytes of normal data<span class="hljs-number">&#x27;123&#x27;</span><br></code></pre></td></tr></table></figure><p>由此可见，客户端发送给服务器的3字节的带外数据“abc”中，<strong>仅有</strong>最后一个字符“c”被服务器当成真正的带外数据接收(<strong>正如3.8节</strong>讨论的 那样)。并且，<strong>服务器对正常数据的接收将被带外数据截断</strong>，即前一部分正常数据“123ab”和后续的正常数据“123”是不能被一个recv调用全部读出的。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205182200198.png" alt="截屏2022-05-18 下午10.00.09" /></p><p>tcpdump的输出内容中，和带外数据相关的是代码清单5-8所示的TCP报文段。</p><p>代码清单5-8 <u>含带外数据</u>的TCP报文段</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.60460</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.54321</span>:Flags[P.U],seq <span class="hljs-number">4</span>:<span class="hljs-number">7</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">92</span>,urg <span class="hljs-number">3</span>,options[nop,nop,TS val <span class="hljs-number">102794322</span> ecr <span class="hljs-number">154703423</span>],length <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>这里我们第一次看到tcpdump输出<strong>标志U</strong>，这表示该TCP报文段的头部被设置了紧急标志。**“urg 3”**是紧急偏移值，它指出带外数据在字节流中的位置的下一字节位置是7【说明当前最后一个位置是6】(3+4，其中4是该TCP报文段的序号值相对初始序号值的偏移)。因此，带外数据是字节流中的第6字节， 即字符“c”。</p><p>值得一提的是，flags参数只对send和recv的当前调用生效，而后面我们将看到如何通过setsockopt系统调用永久性地修改socket的某些属 性。</p><h3 id="582-udp数据读写"><a class="markdownIt-Anchor" href="#582-udp数据读写"></a> 5.8.2 UDP数据读写</h3><p>socket编程接口中用于UDP数据报读写的系统调用是:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recvfrom</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">void</span>*buf,<span class="hljs-keyword">size_t</span> len,<span class="hljs-keyword">int</span> flags,struct sockaddr*src_addr,<span class="hljs-keyword">socklen_t</span>*addrlen)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendto</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*buf,<span class="hljs-keyword">size_t</span> len,<span class="hljs-keyword">int</span> flags,<span class="hljs-keyword">const</span> struct sockaddr*dest_addr,<span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>recvfrom</strong>读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小。因为UDP通信<strong>没有连接</strong>的概念【像tcp就有连接套接字和监听套接字提供一个平台让数据互通，但udp都是一个对一个的没法按照流发送】，所以我们<u>每次读取数据都 需要获取发送端的socket地址</u>，即参数src_addr所指的内容，addrlen参数则指定该地址的长度。</p><p><strong>sendto</strong>往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。dest_addr参数指定接收端的socket地址，addrlen参数则指定该地址的长度。</p><p>这两个系统调用的flags参数以及返回值的含义均与send/recv系统调用的flags参数及返回值相同。</p><p>值得一提的是，recvfrom/sendto系统调用<u>也可以用于面向连接 (STREAM)的socket的数据读写</u>，只需要把最后两个参数都设置为 NULL以忽略发送端/接收端的socket地址(因为我们已经和对方建立了连接，所以已经知道其socket地址了)。</p><h3 id="583-通用数据读写函数"><a class="markdownIt-Anchor" href="#583-通用数据读写函数"></a> 5.8.3 通用数据读写函数</h3><p>socket编程接口还提供了一对通用的数据读写系统调用。它们不仅能用于TCP流数据，也能用于UDP数据报:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">recvmsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,struct msghdr*msg,<span class="hljs-keyword">int</span> flags)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendmsg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,struct msghdr*msg,<span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><p>sockfd参数指定<strong>被操作的目标socket</strong>。msg参数是msghdr结构体类型的指针，msghdr结构体的定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">msghdr</span> &#123;</span><br>      <span class="hljs-keyword">void</span>*msg_name;<span class="hljs-comment">/*socket地址*/</span><br>      <span class="hljs-keyword">socklen_t</span> msg_namelen;<span class="hljs-comment">/*socket地址的长度*/</span><br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span>*<span class="hljs-title">msg_iov</span>;</span><span class="hljs-comment">/*分散的内存块，见后文*/</span><br>      <span class="hljs-keyword">int</span> msg_iovlen;<span class="hljs-comment">/*分散内存块的数量*/</span><br>      <span class="hljs-keyword">void</span>*msg_control;<span class="hljs-comment">/*指向辅助数据的起始位置*/</span><br>      <span class="hljs-keyword">socklen_t</span> msg_controllen;<span class="hljs-comment">/*辅助数据的大小*/</span><br>      <span class="hljs-keyword">int</span> msg_flags;<span class="hljs-comment">/*复制函数中的flags参数，并在调用过程中更新*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure><p>msg_name成员指向一个socket地址结构变量。它指定通信对方的socket地址。对于<strong>面向连接的TCP协议</strong>，该成员没有意义，必须被设置 为NULL。这是因为对数据流socket而言，对方的地址已经知道。 msg_namelen成员则指定了msg_name所指socket地址的长度。</p><p>msg_iov成员是iovec结构体类型的指针，iovec结构体的定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">void</span>*iov_base;<span class="hljs-comment">/*内存起始地址*/</span> <br>  <span class="hljs-keyword">size_t</span> iov_len;<span class="hljs-comment">/*这块内存的长度*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure><p>由上可见，iovec结构体封装了一块内存的起始位置和长度。 msg_iovlen指定这样的iovec结构对象有多少个。对于<strong>recvmsg</strong>而言，数据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长度则由<u>msg_iov指向的数组指定</u>，这称为<strong>分散读</strong>(scatter read);对于 <strong>sendmsg</strong>而言，msg_iovlen块分散内存中的数据将被一并发送，这称为<strong>集中写</strong>(gather write)。</p><p>msg_control和msg_controllen成员用于辅助数据的传送。我们不详细讨论它们，仅在第13章介绍如何使用它们来实现在进程间传递文件 描述符。</p><p>msg_flags成员无须设定，它会复制recvmsg/sendmsg的flags参数的内容以影响数据读写过程。recvmsg还会在调用结束前，将某些更新后的标志设置到msg_flags中。</p><p>recvmsg/sendmsg的flags参数以及返回值的含义均与send/recv的flags 参数及返回值相同。</p><h2 id="59-带外标记"><a class="markdownIt-Anchor" href="#59-带外标记"></a> 5.9 带外标记</h2><p>代码清单5-7演示了TCP带外数据的接收方法。但在实际应用中，我们通常无法预期带外数据何时到来。好在Linux内核检测到TCP紧急标志时，将通知应用程序有带外数据需要接收。内核通知应用程序带外数据到达的两种常见方式是:<strong>I/O复用产生的异常事件</strong>和<strong>SIGURG信 号</strong>。但是，即使应用程序得到了有带外数据需要接收的通知，还需要知道带外数据在数据流中的具体位置，才能准确接收带外数据。这一 点可通过如下系统调用实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sockatmark</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd)</span></span>;<br></code></pre></td></tr></table></figure><p>sockatmark判断<u>sockfd是否处于带外标记</u>，即下一个被读取到的数据是否是带外数据。如果是，sockatmark返回1，此时我们就可以利用 带MSG_OOB标志的recv调用来接收带外数据。如果不是，则 sockatmark返回0。</p><h2 id="510-地址信息函数"><a class="markdownIt-Anchor" href="#510-地址信息函数"></a> 5.10 地址信息函数</h2><p>在某些情况下，我们想知道一个<u>连接socket的本端socket地址</u>，以及<u>远端的socket地址</u>。下面这两个函数正是用于解决这个问题:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsockname</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,struct sockaddr* address,<span class="hljs-keyword">socklen_t</span>* address_len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getpeername</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,struct sockaddr* address,<span class="hljs-keyword">socklen_t</span>* address_len)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>getsockname</strong>获取<u>sockfd对应的本端socket地址</u>，并将其存储于address参数指定的内存中，该socket地址的长度则存储于address_len参数指向的变量中。如果实际socket地址的长度大于address所指内存区的大小，那么该socket地址将被截断。getsockname成功时返回0，失败返回-1并设置errno。</p><p><strong>getpeername</strong>获取<u>sockfd对应的远端socket地址</u>，其参数及返回值的含义与getsockname的参数及返回值相同。</p><h2 id="511-socket选项"><a class="markdownIt-Anchor" href="#511-socket选项"></a> 5.11 socket选项</h2><p>如果说fcntl系统调用是控制文件描述符属性的通用POSIX方法，那么下面两个系统调用则是专门用来<u><strong>读取</strong>和<strong>设置</strong>socket文件描述符属性</u>的 方法:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getsockopt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">int</span> level,<span class="hljs-keyword">int</span> option_name,<span class="hljs-keyword">void</span>* option_value,<span class="hljs-keyword">socklen_t</span>* <span class="hljs-keyword">restrict</span> option_len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setsockopt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd,<span class="hljs-keyword">int</span> level,<span class="hljs-keyword">int</span> option_name,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* option_value,<span class="hljs-keyword">socklen_t</span> option_len)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>sockfd参数</strong></p><p>指定被操作的目标socket。</p><p><strong>level参数</strong></p><p>指定要操作哪个协议的选项(即属性)，比如IPv4、IPv6、TCP等。</p><p><strong>option_name参数</strong></p><p>则指定选项的名字。我们在表5-5中列举了socket通信中几个比较常用的socket选项。</p><p><strong>option_value和option_len参数</strong></p><p>分别是被操作选项的值和长度。不同的选项具有不同类型的值，如表5-5中“数据类型”一列所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205192105914.png" alt="截屏2022-05-19 下午9.05.38" /></p><p>getsockopt和setsockopt这两个函数成功时返回0，失败时返回-1并设置errno。</p><p>值得指出的是，对服务器而言，有部分socket选项只能在调用listen系统调用前针对监听socket[1]</p><p>PS: 确切地说，socket<u>在执行listen调用前是不能称为监听socket</u>的，此处是指将执行listen调用的socket。</p><p>设置才有效。这是因为连接socket只能由accept调用返回，而accept从listen监听队列中接受的连接至少已经完成了TCP三次握手的前两个步骤(因为listen监听队列中的连接至少已进入SYN_RCVD状态，参见图3-8和代码清单5-4)，这说明服务器已经往被接受连接上发送出了TCP同步报文段。但有的socket选项却应该在TCP同步报文段中设置，比如TCP最大报文段选项(回忆3.2.2小节，该选项只能由同步报文段来发送)。对这种情况，Linux给开发人员提供的解决方案是:对监听socket设置这些socket选项，那么accept返回的连接socket将自动继承这些选项。这些socket选项包括:SO_DEBUG、 SO_DONTROUTE、SO_KEEPALIVE、SO_LINGER、 SO_OOBINLINE、SO_RCVBUF、SO_RCVLOWAT、SO_SNDBUF、 SO_SNDLOWAT、TCP_MAXSEG和TCP_NODELAY。而对客户端而言，这些<u>socket选项则应该在调用connect函数之前设置，因为connect调用成功返回之后，TCP三次握手已完成</u>。</p><p>下面我们详细讨论部分重要的socket选项。</p><h3 id="5111-so_reuseaddr选项"><a class="markdownIt-Anchor" href="#5111-so_reuseaddr选项"></a> 5.11.1 SO_REUSEADDR选项</h3><p>我们在3.4.2小节讨论过TCP连接的TIME_WAIT状态，并提到服务器程序可以通过设置socket选项SO_REUSEADDR来<u>强制使用被处于 TIME_WAIT状态的连接占用的socket地址</u>。具体实现方法如代码清单5-9所示。</p><p>代码清单5-9 重用本地地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 书中代码</span><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-keyword">int</span> reuse = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">setsockopt</span>( sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( reuse ) ); <span class="hljs-comment">// 给代码赋予重用功能</span><br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><span class="hljs-comment">// 书中代码</span><br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );<br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );<br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">char</span> remote[INET_ADDRSTRLEN ];<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;connected with ip: %s and port: %d\n&quot;</span>, <br>        <span class="hljs-built_in">inet_ntop</span>( AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN ), <span class="hljs-built_in">ntohs</span>( client.sin_port ) );<br>        <span class="hljs-built_in">close</span>( connfd );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过setsockopt的设置之后，即使sock处于TIME_WAIT状态，与之绑定的socket地址也可以立即被重用。此外，我们也可以通过修改内核参数/proc/sys/net/ipv4/tcp_tw_recycle来快速回收被关闭的socket，从而使得TCP连接根本就不进入TIME_WAIT状态，进而允许应用程序立即重用本地的socket地址。</p><h3 id="5112-so_rcvbuf和so_sndbuf选项"><a class="markdownIt-Anchor" href="#5112-so_rcvbuf和so_sndbuf选项"></a> 5.11.2 SO_RCVBUF和SO_SNDBUF选项</h3><p><strong>SO_RCVBUF</strong>和<strong>SO_SNDBUF</strong>选项分别表示<strong>TCP接收缓冲区</strong>和<strong>发送缓冲区</strong>的大小。不过，当我们用setsockopt来设置TCP的接收缓冲区和 发送缓冲区的大小时，<u>系统都会将其值加倍，并且不得小于某个最小值</u>。TCP接收缓冲区的最小值是256字节，而发送缓冲区的最小值是 2048字节(不过，不同的系统可能有不同的默认最小值)。系统这样做的目的，主要是确保一个TCP连接拥有足够的空闲缓冲区来处理拥塞 (比如快速重传算法就期望TCP接收缓冲区能至少容纳4个大小为SMSS的TCP报文段)。此外，我们可以直接修改内核参数/proc/sys/net/ipv4/tcp_rmem和/proc/sys/net/ipv4/tcp_wmem来强制TCP 接收缓冲区和发送缓冲区的大小没有最小值限制。我们将在第16章讨论这两个内核参数。</p><p>下面我们编写一对客户端和服务器程序，如代码清单5-10和代码清单5-11所示，它们分别修改TCP发送缓冲区和接收缓冲区的大小。</p><p>代码清单5-10 修改TCP发送缓冲区的客户端程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 512</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">3</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number send_bufer_size\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">server_address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;server_address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( server_address ) );<br>    server_address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;server_address.sin_addr );<br>    server_address.sin_port = <span class="hljs-built_in">htons</span>( port );<br><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br><br>    <span class="hljs-keyword">int</span> sendbuf = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">3</span>] );<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( sendbuf );<br>    <span class="hljs-comment">/*先设置TCP发送缓冲区的大小，然后立即读取之*/</span><br>    <span class="hljs-built_in">setsockopt</span>( sock, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( sendbuf ) );  <span class="hljs-comment">// 设置socket tcp发送缓冲区</span><br>    <span class="hljs-built_in">getsockopt</span>( sock, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, ( <span class="hljs-keyword">socklen_t</span>* )&amp;len ); <span class="hljs-comment">// 查看socket tcp发送缓冲区</span><br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;the tcp send buffer size after setting is %d\n&quot;</span>, sendbuf );<br><br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">connect</span>( sock, ( struct sockaddr* )&amp;server_address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( server_address ) ) != <span class="hljs-number">-1</span> ) <span class="hljs-comment">// 连接socket</span><br>    &#123;<br>        <span class="hljs-keyword">char</span> buffer[ BUFFER_SIZE ];<br>        <span class="hljs-built_in">memset</span>( buffer, <span class="hljs-string">&#x27;a&#x27;</span>, BUFFER_SIZE );<br>        <span class="hljs-built_in">send</span>( sock, buffer, BUFFER_SIZE, <span class="hljs-number">0</span> ); <span class="hljs-comment">// 发送socket</span><br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码清单5-11 修改TCP接收缓冲区的服务器程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 1024</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">3</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number receive_buffer_size\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-keyword">int</span> recvbuf = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">3</span>] );<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( recvbuf );<br>    <span class="hljs-comment">/*先设置TCP接收缓冲区的大小，然后立即读取之*/</span><br>    <span class="hljs-built_in">setsockopt</span>( sock, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( recvbuf ) );<br>    <span class="hljs-built_in">getsockopt</span>( sock, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, ( <span class="hljs-keyword">socklen_t</span>* )&amp;len );<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;the receive buffer size after settting is %d\n&quot;</span>, recvbuf );<br><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) ); <span class="hljs-comment">// 命名socket 相当于给对应端口安排一个人</span><br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> ); <span class="hljs-comment">// 监听</span><br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );<br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength ); <span class="hljs-comment">// accept监听结果</span><br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 如果监听到结果开始接收</span><br>    &#123;<br>        <span class="hljs-keyword">char</span> buffer[ BUFFER_SIZE ];<br>        <span class="hljs-built_in">memset</span>( buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE );<br>        <span class="hljs-keyword">while</span>( <span class="hljs-built_in">recv</span>( connfd, buffer, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-number">0</span> ) &gt; <span class="hljs-number">0</span> )&#123;&#125;<br>        <span class="hljs-built_in">close</span>( connfd );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在ernest-laptop上运行代码清单5-11所示的服务器程序(名为set_recv_buffer)，然后在Kongming20上运行代码清单5-10所示的客户 端程序(名为set_send_buffer)来向服务器发送512字节的数据，然后用 tcpdump抓取这一过程中双方交换的TCP报文段。具体操作过程如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">$./set_recv_buffer <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-number">12345</span> <span class="hljs-number">50</span> #将TCP接收缓冲区的大小设置为 <span class="hljs-number">50</span>字节<br> the tcp receive buffer size after settting is <span class="hljs-number">256</span><br>$./set_send_buffer <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span> <span class="hljs-number">12345</span> <span class="hljs-number">2000</span> #将TCP发送缓冲区的大小设置为 <span class="hljs-number">2000</span>字节<br> the tcp send buffer size after setting is <span class="hljs-number">4000</span><br>$tcpdump -nt -i eth0 port <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure><p>从服务器的输出来看，系统允许的TCP接收缓冲区最小为256字节。当我们设置TCP接收缓冲区的大小为50字节时，系统将<strong>忽略</strong>我们的设置。从客户端的输出来看，我们设置的<strong>TCP发送缓冲区的大小被系统增加了一倍</strong>。这两种情况和我们前面讨论的一致。下面是此次TCP通信的tcpdump输出:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[S],seq <span class="hljs-number">1425875256</span>,win <span class="hljs-number">14600</span>,options[mss <span class="hljs-number">1460</span>,sackOK,TS val <span class="hljs-number">7782289</span> ecr <span class="hljs-number">0</span>,nop,wscale <span class="hljs-number">4</span>],length <span class="hljs-number">0</span><br><span class="hljs-number">2.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>:Flags[S.],seq <span class="hljs-number">3109725840</span>,ack <span class="hljs-number">1425875257</span>,win <span class="hljs-number">192</span>,options[mss <span class="hljs-number">1460</span>,sackOK,TS val <span class="hljs-number">126229160</span> ecr <span class="hljs-number">7782289</span>,nop,wscale <span class="hljs-number">6</span>],length <span class="hljs-number">0</span><br><span class="hljs-number">3.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[.],ack <span class="hljs-number">1</span>,win <span class="hljs-number">913</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">4.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[P.],seq <span class="hljs-number">1</span>:<span class="hljs-number">193</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">913</span>,length <span class="hljs-number">192</span><br><span class="hljs-number">5.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>:Flags[.],ack <span class="hljs-number">193</span>,win <span class="hljs-number">0</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">6.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>:Flags[.],ack <span class="hljs-number">193</span>,win <span class="hljs-number">3</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">7.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[P.],seq <span class="hljs-number">193</span>:<span class="hljs-number">385</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">913</span>,length <span class="hljs-number">192</span><br><span class="hljs-number">8.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>:Flags[.],ack <span class="hljs-number">385</span>,win <span class="hljs-number">3</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">9.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[P.],seq <span class="hljs-number">385</span>:<span class="hljs-number">513</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">913</span>,length <span class="hljs-number">128</span><br><span class="hljs-number">10.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>:Flags[.],ack <span class="hljs-number">513</span>,win <span class="hljs-number">3</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">11.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[F.],seq <span class="hljs-number">513</span>,ack <span class="hljs-number">1</span>,win <span class="hljs-number">913</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">12.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>:Flags[F.],seq <span class="hljs-number">1</span>,ack <span class="hljs-number">514</span>,win <span class="hljs-number">3</span>,length <span class="hljs-number">0</span><br><span class="hljs-number">13.</span>IP <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.109</span><span class="hljs-number">.38663</span>&gt;<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.108</span><span class="hljs-number">.12345</span>:Flags[.],ack <span class="hljs-number">2</span>,win <span class="hljs-number">913</span>,length <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>首先注意<strong>第2个TCP报文段</strong>，它指出服务器的接收通告窗口大小为192字节。该值小于256字节，显然是在情理之中。同时，该同步报文段还指出服务器采用的窗口扩大因子是6【将窗口大小乘以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">2^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>】。所以服务器后续发送的大部分TCP报文段(6、8、10和12)的实际接收通告窗口大小都是3×26字节，即192字节。因此客户端每次最多给服务器发送192字节的数据。 客户端一共给服务器发送了512字节的数据，这些数据必须至少被分为3个TCP报文段(4、7和9)来发送。</p><p>有意思的是<strong>TCP报文段5和6</strong>。当服务器收到客户端发送过来的第一批数据(TCP报文段4)时，它立即用TCP报文段5给予了确认，但该确认报文段的接收通告窗口的大小为0。这说明<u>TCP模块发送该确认报文段时，应用程序还没来得及将数据从TCP接收缓冲中读出</u>。所以此时客户端是不能发送数据给服务器的，直到服务器发送一个重复的确认报文段(TCP报文段6)来扩大其接收通告窗口。</p><h3 id="5113-so_rcvlowat和so_sndlowat选项"><a class="markdownIt-Anchor" href="#5113-so_rcvlowat和so_sndlowat选项"></a> 5.11.3 SO_RCVLOWAT和SO_SNDLOWAT选项</h3><p>SO_RCVLOWAT和SO_SNDLOWAT选项分别表示TCP接收缓冲区和发送缓冲区的<strong>低水位标记</strong>。它们一般被I/O复用系统调用(见第9章)用来<u>判断socket是否可读或可写</u>。当<strong>TCP接收缓冲区</strong>中可读数据的总数大于其低水位标记时，I/O复用系统调用将通知应用程序可以从对应的 socket上读取数据;当<strong>TCP发送缓冲区</strong>中的空闲空间(可以写入数据的空间)大于其低水位标记时，I/O复用系统调用将通知应用程序可以往 对应的socke上写入数据。</p><p>默认情况下，TCP接收缓冲区的低水位标记和TCP发送缓冲区的低水位标记均为1字节。</p><h3 id="5114-so_linger选项"><a class="markdownIt-Anchor" href="#5114-so_linger选项"></a> 5.11.4 SO_LINGER选项</h3><p>SO_LINGER选项用于控制close系统调用在<u>关闭TCP连接时的行为</u>。<strong>默认</strong>情况下，当我们使用close系统调用来关闭一个socket时，close 将立即返回，TCP模块负责把该socket<u>对应的TCP发送缓冲区中残留的数据发送</u>给对方。</p><p>如表5-5所示，设置(获取)SO_LINGER选项的值时，我们需要给setsockopt(getsockopt)系统调用传递一个linger类型的结构体，其定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linger</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> l_onoff;<span class="hljs-comment">/*开启(非0)还是关闭(0)该选项*/</span> <br>  <span class="hljs-keyword">int</span> l_linger;<span class="hljs-comment">/*滞留时间*/</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>根据linger结构体中两个成员变量的不同值，close系统调用可能产生如下3种行为之一:</p><p>1、l_onoff == 0。此时SO_LINGER选项不起作用，close用默认行为来关闭socket。</p><p>2、l_onoff != 0，l_linger == 0。此时close系统调用立即返回，TCP模块将丢弃被关闭的socket对应的TCP发送缓冲区中残留的数据，同时 给对方发送一个复位报文段(见3.5.2小节)。因此，这种情况给服务器提供了异常终止一个连接的方法。</p><p>3、l_onoff != 0，l_linger &gt; 0。此时close的行为取决于两个条件:一是被关闭的socket对应的TCP发送缓冲区中是否还有残留的数据;二是该socket是阻塞的，还是非阻塞的。对于<strong>阻塞</strong>的socket，close将等待一段长为l_linger的时间，直到TCP模块发送完所有残留数据并得到对方的确认。如果这段时间内TCP模块没有发送完残留数据并得到对方的确认，那么close系统调用将返回-1并设置errno为 EWOULDBLOCK。如果socket是非阻塞的，close将立即返回，此时我们需要根据其返回值和errno来判断残留数据是否已经发送完毕。关于阻塞和非阻塞，我们将在第8章讨论。</p><h2 id="512-网络信息api"><a class="markdownIt-Anchor" href="#512-网络信息api"></a> 5.12 网络信息API</h2><p>socket地址的两个要素，即<strong>IP地址和端口号</strong>，都是用数值表示的。这不便于记忆，也不便于扩展(比如从IPv4转移到IPv6)。因此在前面的章节中，我们用主机名来访问一台机器，而避免直接使用其IP地址。同样，我们用服务名称来代替端口号。比如，下面两条telnet命令具有完全相同的作用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">telnet <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-number">80</span><br> telnet localhost www<br></code></pre></td></tr></table></figure><p>上面的例子中，telnet客户端程序是通过<u>调用某些网络信息API</u>来<u>实现主机名到IP地址</u>的转换，以及服务名称到端口号的转换的。下面我们将讨论网络信息API中比较重要的几个。</p><h3 id="5121-gethostbyname和gethostbyaddr"><a class="markdownIt-Anchor" href="#5121-gethostbyname和gethostbyaddr"></a> 5.12.1 gethostbyname和gethostbyaddr</h3><p>gethostbyname<u>函数根据主机名称获取主机的完整信息</u>， gethostbyaddr函数根据<u>IP地址获取主机的完整信息</u>。gethostbyname函数通常先在本地的/etc/hosts配置文件中查找主机，如果没有找到，再去访问DNS服务器。这些在前面章节中都讨论过。这两个函数的定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function">struct hostent* <span class="hljs-title">gethostbyname</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name)</span></span>;<br><span class="hljs-function">struct hostent* <span class="hljs-title">gethostbyaddr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* addr,<span class="hljs-keyword">size_t</span> len,<span class="hljs-keyword">int</span> type)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>name参数</strong>指定目标主机的主机名，<strong>addr参数</strong>指定目标主机的IP地址，<strong>len参数</strong>指定addr所指IP地址的长度，<strong>type参数</strong>指定addr所指IP地址 的类型，其合法取值包括AF_INET(用于IPv4地址)和AF_INET6(用于IPv6地址)。</p><p>这两个函数返回的都是hostent结构体类型的指针，hostent结构体的定义如下:</p><p>**可以理解为指针数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">char</span>* h_name;<span class="hljs-comment">/*主机名*/</span> <br>  <span class="hljs-keyword">char</span>** h_aliases;<span class="hljs-comment">/*主机别名列表，可能有多个*/</span> <br>  <span class="hljs-keyword">int</span> h_addrtype;<span class="hljs-comment">/*地址类型(地址族)*/</span><br>  <span class="hljs-keyword">int</span> h_length;<span class="hljs-comment">/*地址长度*/</span> <br>  <span class="hljs-keyword">char</span>** h_addr_list<span class="hljs-comment">/*按网络字节序列出的主机IP地址列表*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5122-getservbyname和getservbyport"><a class="markdownIt-Anchor" href="#5122-getservbyname和getservbyport"></a> 5.12.2 getservbyname和getservbyport</h3><p>getservbyname函数<u>根据名称获取某个服务的完整信息</u>， getservbyport函数<u>根据端口号获取某个服务的完整信息</u>。它们实际上都是通过读取/etc/services文件来获取服务的信息的。这两个函数的定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function">struct servent* <span class="hljs-title">getservbyname</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* proto)</span></span>; <br><span class="hljs-function">struct servent* <span class="hljs-title">getservbyport</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* proto)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>name参数</strong>指定目标服务的名字，<strong>port参数</strong>指定目标服务对应的端口号。<strong>proto参数</strong>指定服务类型，给它传递“tcp”表示获取流服务，给它传递“udp”表示获取数据报服务，给它传递NULL则表示获取所有类型的服务。</p><p>这两个函数返回的都是servent结构体类型的指针，结构体servent的定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">servent</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">char</span>* s_name;<span class="hljs-comment">/*服务名称*/</span> <br>    <span class="hljs-keyword">char</span>** s_aliases;<span class="hljs-comment">/*服务的别名列表，可能有多个*/</span> <br>    <span class="hljs-keyword">int</span> s_port;<span class="hljs-comment">/*端口号*/</span> <br>    <span class="hljs-keyword">char</span>* s_proto;<span class="hljs-comment">/*服务类型,通常是tcp或者udp*/</span> <br>&#125;;<br><br></code></pre></td></tr></table></figure><p>下面我们通过主机名和服务名来访问目标服务器上的<strong>daytime服务</strong>，以获取该机器的系统时间，如代码清单5-12所示。</p><p>代码清单5-12 访问daytime服务</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>( argc == <span class="hljs-number">2</span> );<br>    <span class="hljs-keyword">char</span> *host = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">/*获取目标主机地址信息*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hostent</span>* <span class="hljs-title">hostinfo</span> =</span> <span class="hljs-built_in">gethostbyname</span>( host );<br>    <span class="hljs-built_in">assert</span>( hostinfo );<br>    <span class="hljs-comment">/*获取daytime服务信息*/</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">servent</span>* <span class="hljs-title">servinfo</span> =</span> <span class="hljs-built_in">getservbyname</span>( <span class="hljs-string">&quot;daytime&quot;</span>, <span class="hljs-string">&quot;tcp&quot;</span> );<br>    <span class="hljs-built_in">assert</span>( servinfo );<br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;daytime port is %d\n&quot;</span>, <span class="hljs-built_in">ntohs</span>( servinfo-&gt;s_port ) );<br>    <span class="hljs-comment">// 设置socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    address.sin_family = AF_INET;<br>    address.sin_port = servinfo-&gt;s_port;<br>    <span class="hljs-comment">/*注意下面的代码，因为h_addr_list本身是使用网络字节序的地址列表，所以使用其中的IP地址时，无须对目标IP地址转换字节序*/</span><br>    address.sin_addr = *( struct in_addr* )*hostinfo-&gt;h_addr_list;<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-keyword">int</span> sockfd = <span class="hljs-built_in">socket</span>( AF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 请求链接</span><br>    <span class="hljs-keyword">int</span> result = <span class="hljs-built_in">connect</span>( sockfd, (struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( result != <span class="hljs-number">-1</span> );<br><br>    <span class="hljs-keyword">char</span> buffer[<span class="hljs-number">128</span>];<br>    <span class="hljs-comment">// 获取返回的套接字数据部分进入buffer</span><br>    result = <span class="hljs-built_in">read</span>( sockfd, buffer, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( buffer ) );<br>    <span class="hljs-built_in">assert</span>( result &gt; <span class="hljs-number">0</span> );<br>    buffer[ result ] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-comment">// 打印结果</span><br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;the day tiem is: %s&quot;</span>, buffer );<br>    <span class="hljs-built_in">close</span>( sockfd );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>重入</strong></p><p>一般可以理解为一个函数在同时多次调用,例如操作系统在进程调度过程中,或者单片机、处理器等的中断的时候会发生重入的现象</p><p>需要指出的是，上面讨论的4个函数都是不可重入的，即<u>非线程安全</u>的。不过netdb.h头文件给出了它们的可重入版本。正如Linux下所有 其他函数的可重入版本的命名规则那样，这些函数的函数名是在原函数名尾部加上_r(re-entrant)。</p><h3 id="5123-getaddrinfo"><a class="markdownIt-Anchor" href="#5123-getaddrinfo"></a> 5.12.3 getaddrinfo</h3><p>getaddrinfo函数既能通过<u>主机名获得IP地址</u>(内部使用的是gethostbyname函数)，也能通过<u>服务名获得端口号</u>(内部使用的是getservbyname函数)。它<strong>是否可重入取决</strong>于其内部调用的gethostbyname和getservbyname函数是否是它们的可重入版本。该函数的定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getaddrinfo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* hostname,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* service,<span class="hljs-keyword">const</span> struct addrinfo* hints,struct addrinfo** result)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>hostname参数</strong>可以接收<strong>主机名</strong>，也可以接收字符串表示的IP地址 (IPv4采用点分十进制字符串，IPv6则采用十六进制字符串)。同样， <strong>service参数</strong>可以接收<strong>服务名</strong>，也可以接收字符串表示的十进制端口号。</p><p><strong>hints参数</strong>是应用程序给getaddrinfo的一个提示，以对getaddrinfo的输出进行更精确的控制。hints参数可以被设置为NULL，表示允许 getaddrinfo反馈任何可用的结果。</p><p><strong>result参数</strong>指向一个链表，该链表用于存储getaddrinfo反馈的结果。</p><p>getaddrinfo反馈的每一条结果都是addrinfo结构体类型的对象，结构体addrinfo的定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-keyword">int</span> ai_flags;<span class="hljs-comment">/*见后文*/</span><br>  <span class="hljs-keyword">int</span> ai_family;<span class="hljs-comment">/*地址族*/</span><br>  <span class="hljs-keyword">int</span> ai_socktype;<span class="hljs-comment">/*服务类型，SOCK_STREAM或SOCK_DGRAM*/</span> <br>  <span class="hljs-keyword">int</span> ai_protocol;<span class="hljs-comment">/*见后文*/</span><br>  <span class="hljs-keyword">socklen_t</span> ai_addrlen;<span class="hljs-comment">/*socket地址ai_addr的长度*/</span><br>  <span class="hljs-keyword">char</span>* ai_canonname;<span class="hljs-comment">/*主机的别名*/</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span>* <span class="hljs-title">ai_addr</span>;</span><span class="hljs-comment">/*指向socket地址*/</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span>* <span class="hljs-title">ai_next</span>;</span><span class="hljs-comment">/*指向下一个sockinfo结构的对象*/</span> <br>&#125;;<br></code></pre></td></tr></table></figure><p>该结构体中，ai_protocol成员是指具体的网络协议，其含义和socket系统调用的第三个参数相同，它通常被设置为0。ai_flags成员可以取表5-6中的标志的按位或。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205201338156.png" alt="截屏2022-05-20 下午1.38.28" /></p><p>当我们使用hints参数的时候，可以设置其ai_flags，ai_family， ai_socktype和ai_protocol四个字段，其他字段则必须被设置为NULL。 例如，代码清单5-13利用了hints参数获取主机ernest-laptop上的“daytime”流服务信息。</p><p>代码清单5-13 使用getaddrinfo函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> <span class="hljs-title">hints</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span>* <span class="hljs-title">res</span>;</span><br><span class="hljs-comment">//  bzero(void *s, int n) 与 memset((void*)s, 0,size_tn)是等价</span><br><span class="hljs-built_in">bzero</span>(&amp;hints,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(hints)); <br>hints.ai_socktype = SOCK_STREAM; <br><span class="hljs-built_in">getaddrinfo</span>(<span class="hljs-string">&quot;ernest-laptop&quot;</span>,<span class="hljs-string">&quot;daytime&quot;</span>,&amp;hints,&amp;res);<br></code></pre></td></tr></table></figure><p>从代码清单5-13中我们能分析出，getaddrinfo将隐式地分配堆内存 (可以通过valgrind等工具查看)，因为res指针原本是没有指向一块合法内存的，所以，getaddrinfo调用结束后，我们必须使用如下配对函数来释放这块内存:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeaddrinfo</span><span class="hljs-params">(struct addrinfo* res)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="5124-getnameinfo"><a class="markdownIt-Anchor" href="#5124-getnameinfo"></a> 5.12.4 getnameinfo</h3><p>getnameinfo函数能<u>通过socket地址同时获得以字符串表示的主机名</u>(内部使用的是gethostbyaddr函数)和服务名(内部使用的是 getservbyport函数)。它是否可重入取决于其内部调用的gethostbyaddr和getservbyport函数是否是它们的可重入版本。该函数的定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getnameinfo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct sockaddr* sockaddr,<span class="hljs-keyword">socklen_t</span> addrlen,<span class="hljs-keyword">char</span>* host,<span class="hljs-keyword">socklen_t</span> hostlen,<span class="hljs-keyword">char</span>* serv,<span class="hljs-keyword">socklen_t</span> servlen,<span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><p>getnameinfo将返回的主机名存储在host参数指向的缓存中，将服务名存储在serv参数指向的缓存中，hostlen和servlen参数分别指定这两块缓存的长度。flags参数控制getnameinfo的行为，它可以接收表5-7中的选项。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205201347161.png" alt="截屏2022-05-20 下午1.47.47" /></p><p>getaddrinfo和getnameinfo函数成功时返回0，失败则返回错误码，可能的错误码如表5-8所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205201348081.png" alt="截屏2022-05-20 下午1.48.13" /></p><p>Linux下strerror函数能将数值错误码errno转换成易读的字符串形式。同样，下面的函数可将表5-8中的错误码转换成其字符串形式:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*<span class="hljs-title">gai_strerror</span><span class="hljs-params">(<span class="hljs-keyword">int</span> error)</span></span>;<br></code></pre></td></tr></table></figure><h1 id="第6章-高级io函数"><a class="markdownIt-Anchor" href="#第6章-高级io函数"></a> 第6章 高级I/O函数</h1><p>Linux提供了很多高级的I/O函数。它们并不像Linux基础I/O函数 (比如open和read)那么常用(编写内核模块时一般要实现这些I/O函数)，但在特定的条件下却表现出优秀的性能。本章将讨论其中和网络编程相关的几个，这些函数大致分为三类:</p><p>1、用于创建文件描述符的函数，包括pipe、dup/dup2函数。</p><p>2、用于读写数据的函数，包括readv/writev、sendfile、mmap/munmap、splice和tee函数。</p><p>3、用于控制I/O行为和属性的函数，包括fcntl函数。</p><h2 id="61-pipe函数"><a class="markdownIt-Anchor" href="#61-pipe函数"></a> 6.1 pipe函数</h2><p>pipe函数可用于创建一个管道，以实现进程间通信。我们将在13.4节讨论如何使用管道来实现进程间通信，本章只介绍其基本使用方式。pipe函数的定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span> </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pipe</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd[<span class="hljs-number">2</span>])</span></span>;<br></code></pre></td></tr></table></figure><h3 id="管道定义"><a class="markdownIt-Anchor" href="#管道定义"></a> 管道定义：</h3><p>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为<strong>进程间通信</strong>。</p><p>不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了<a href="https://so.csdn.net/so/search?q=%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F&amp;spm=1001.2101.3001.7020">通信方式</a>不同，而pipe就是提供这份公共资源的形式的一种。</p><p><a href="https://blog.csdn.net/skyroben/article/details/71513385">https://blog.csdn.net/skyroben/article/details/71513385</a></p><h3 id="fork"><a class="markdownIt-Anchor" href="#fork"></a> fork：</h3><p>一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。<br />一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</p><p><a href="https://blog.csdn.net/stpeace/article/details/38805369?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-38805369-blog-107159115.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-38805369-blog-107159115.pc_relevant_paycolumn_v3&amp;utm_relevant_index=2">https://blog.csdn.net/stpeace/article/details/38805369?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-38805369-blog-107159115.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-38805369-blog-107159115.pc_relevant_paycolumn_v3&amp;utm_relevant_index=2</a></p><p>pipe函数的参数是一个包含两个int型整数的数组指针。该函数成功时返回0，并将一对打开的文件描述符值填入其参数指向的数组。如果失败，则返回-1并设置errno。</p><p>通过pipe函数创建的这两个文件描述符fd[0]和fd[1]分别构成管道的两端，往fd[1]写入的数据可以从fd[0]读出。并且，fd[0]只能用于从管道<strong>读出数据</strong>，fd[1]则只能用于往管道<strong>写入数据</strong>，而不能反过来使用。</p><p>如果要实现<u>双向的数据传输，就应该使用两个管道</u>。默认情况下，这一对文件描述符都是阻塞的。此时如果我们用read系统调用来读取一个空的管道，则read将被阻塞，直到管道内有数据可读;如果我们用write系统调用来往一个满的管道(见后文)中写入数据，则write亦将被阻塞，直到管道有足够多的空闲空间可用。</p><p>但如果应用程序将fd[0]和fd[1]都设置为非阻塞的，则read和write会有不同的行为。 关于阻塞和非阻塞的讨论，见第8章。如果管道的写端文件描述符fd[1]的引用计数(见5.7节)减少至0，即没有任何进程需要往管道中写入数据，则针对该管道的读端文件描述符fd[0]的read操作将返回0，即读取到了文件结束标记(End Of File，EOF); 反之，如果管道的读端文件描述符fd[0]的引用计数减少至0，即没有任何进程需要从管道读取数据，则针对该管道的写端文件描述符fd[1]的write操作将失败，并引发SIGPIPE信号。关于SIGPIPE信号，我们将在第10章讨论。</p><p>管道内部传输的数据是<strong>字节流</strong>，这和TCP字节流的概念相同。但二者又有细微的区别。应用层程序能往一个TCP连接中写入多少字节的数据，取决于对方的<u>接收通告窗口的大小和本端的拥塞窗口的大小</u>。而管道本身拥有一个容量限制，它规定如果应用程序不将数据从管道读走的话，该管道最多能被写入多少字节的数据。自Linux 2.6.11内核起，管道容量的大小默认是65536字节。我们可以使用fcntl函数来修改管道容量(见后文)。</p><p>此外，socket的基础API中有一个socketpair函数。它能够方便地创建双向管道。其定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">socketpair</span><span class="hljs-params">(<span class="hljs-keyword">int</span> domain,<span class="hljs-keyword">int</span> type,<span class="hljs-keyword">int</span> protocol,<span class="hljs-keyword">int</span> fd[<span class="hljs-number">2</span>])</span></span>;<br></code></pre></td></tr></table></figure><p>socketpair前三个参数的含义与socket系统调用的三个参数完全相同，但domain只能使用UNIX本地域协议族AF_UNIX，因为我们仅能在本地使用这个双向管道。最后一个参数则和pipe系统调用的参数一样，只不过socketpair创建的这对文件描述符都是既可读又可写的。 socketpair成功时返回0，失败时返回-1并设置errno。</p><h2 id="62-dup函数和dup2函数"><a class="markdownIt-Anchor" href="#62-dup函数和dup2函数"></a> 6.2 dup函数和dup2函数</h2><p>有时我们希望把标准输入重定向到一个文件，或者把标准输出重定向到一个网络连接(比如CGI编程)。这可以通过下面的用于复制文件描述符的dup或dup2函数来实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> file_descriptor)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dup2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> file_descriptor_one,<span class="hljs-keyword">int</span> file_descriptor_two)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>dup函数</strong>创建一个新的文件描述符，该新文件描述符和原有文件描述符file_descriptor指向相同的文件、管道或者网络连接。并且dup返回 的文件描述符总是取系统当前可用的最小整数值。dup2和dup类似，不过它将返回第一个不小于file_descriptor_two的整数值。dup和dup2系统调用失败时返回-1并设置errno。</p><p>注意通过dup和dup2创建的文件描述符<u>并不继承原文件描述符</u>的属性，比如close-on-exec和non-blocking等。</p><p>代码清单6-1利用dup函数实现了一个基本的CGI服务器。</p><p>代码清单6-1 CGI服务器原理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 创建并设置IPv4socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 将sock进行命名</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 监听socket</span><br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 再次创建一个socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );<br>    <span class="hljs-comment">// 接收连接</span><br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );<br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">// 没有接收到</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 若接收到了连接 -- 相当于成功建立连接</span><br>    &#123;<br>        <span class="hljs-comment">//我们先关闭标准输出文件描述符 STDOUT_FILENO(其值是1)</span><br>        <span class="hljs-built_in">close</span>( STDOUT_FILENO );<br>        <span class="hljs-comment">// 复制socket文件描述符connfd</span><br>        <span class="hljs-built_in">dup</span>( connfd );<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;abcd\n&quot;</span> );<br>        <span class="hljs-built_in">close</span>( connfd );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在代码清单6-1中，我们先关闭标准输出文件描述符STDOUT_FILENO(其值是1)，然后复制socket文件描述符connfd。因为dup总是返回系统中最小的可用文件描述符，所以它的返回值实际上是1，即之前关闭的标准输出文件描述符的值。这样一来，<u>服务器输出到标准输出的内容(这里是“abcd”)就会直接发送到与客户连接对应的socket</u>上，因此printf调用的输出将被客户端获得(而不是显示在服务器程序的终端上)。这就是CGI服务器的基本工作原理。</p><h2 id="63-readv函数和writev函数"><a class="markdownIt-Anchor" href="#63-readv函数和writev函数"></a> 6.3 readv函数和writev函数</h2><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205201626146.png" alt="截屏2022-05-20 下午4.26.38" /></p><p>readv函数将数据从文件描述符读到分散的内存块中，即<strong>分散读</strong>; writev函数则将多块分散的内存数据一并写入文件描述符中，即<strong>集中写</strong>。它们的定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/uio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">readv</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd,<span class="hljs-keyword">const</span> struct iovec* vector,<span class="hljs-keyword">int</span> count)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">writev</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd,<span class="hljs-keyword">const</span> struct iovec* vector,<span class="hljs-keyword">int</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>fd参数</strong>是被操作的目标文件描述符。</p><p><strong>vector参数</strong>的类型是iovec结构数组。</p><p>我们在第5章讨论过<u>结构体iovec，该结构体描述一块内存区</u>。</p><p><strong>count参数</strong>是vector数组的长度，即有多少块内存数据需要从fd读出或写到fd。readv和writev在成功时返回读出/写入fd的字节数，失败则返回-1并设置errno。它们相当于简化版的recvmsg和sendmsg函数。</p><p>考虑第4章讨论过的Web服务器。当Web服务器解析完一个HTTP请求之后，如果目标文档存在且客户具有读取该文档的权限，那么它就需要发送一个HTTP应答来传输该文档。这个HTTP应答包含<u>1个状态行、多个头部字段、1个空行</u>和文档的内容。其中，前3部分的内容可能被Web服务器放置在一块内存中，而文档的内容则通常被读入到另外一块单独的内存中(通过read函数或mmap函数)。我们并不需要把这两部分内容拼接到一起再发送，而是可以使用writev函数将它们同时写出，如代码清单6-2所示。</p><p>代码清单6-2 Web服务器上的集中写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 1024</span><br><span class="hljs-comment">/*定义两种HTTP状态码和状态信息*/</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* status_line[<span class="hljs-number">2</span>] = &#123; <span class="hljs-string">&quot;200 OK&quot;</span>, <span class="hljs-string">&quot;500 Internal server error&quot;</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span>  <span class="hljs-comment">// 这个文件就是本地的问题</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">3</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number filename\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 读入获得的ip、port还有文件名</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* file_name = argv[<span class="hljs-number">3</span>];<br>    <span class="hljs-comment">// 建立IPv4 socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 给socket命名</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 监听socket</span><br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 建立IPv4 socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );<br>    <span class="hljs-comment">// 接收连接到文件描述符connfd</span><br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );<br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">// 连接失败</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span>  <span class="hljs-comment">// 连接成功</span><br>    &#123;<br>        <span class="hljs-comment">/*用于保存HTTP应答的状态行、头部字段和一个空行的缓存区*/</span><br>        <span class="hljs-keyword">char</span> header_buf[ BUFFER_SIZE ];<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-built_in">memset</span>( header_buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE );<br>        <span class="hljs-comment">/*用于存放目标文件内容的应用程序缓存*/</span><br>        <span class="hljs-keyword">char</span>* file_buf;<br>        <span class="hljs-comment">/*用于获取目标文件的属性，比如是否为目录，文件大小等*/</span><br>        <span class="hljs-comment">// struct stat这个结构体是用来描述一个linux系统文件系统中的文件属性的结构。</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">file_stat</span>;</span><br>        <span class="hljs-comment">/*记录目标文件是否是有效文件*/</span><br>        <span class="hljs-keyword">bool</span> valid = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">/*缓存区header_buf目前已经使用了多少字节的空间*/</span><br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>( <span class="hljs-built_in">stat</span>( file_name, &amp;file_stat ) &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">/*目标文件不存在*/</span><br>        &#123;<br>            valid = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>( <span class="hljs-built_in">S_ISDIR</span>( file_stat.st_mode ) )  <span class="hljs-comment">/*目标文件是一个目录*/</span><br>            &#123;<br>                valid = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( file_stat.st_mode &amp; S_IROTH ) <span class="hljs-comment">/*当前用户有读取目标文件的权限*/</span><br>            &#123;<br>                <span class="hljs-comment">/*动态分配缓存区file_buf，并指定其大小为目标文件的大小file_stat.st_size加1*/</span><br>                <span class="hljs-keyword">int</span> fd = <span class="hljs-built_in">open</span>( file_name, O_RDONLY ); <span class="hljs-comment">// 将fd文件描述符 指向服务器端的本地文件</span><br>                file_buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span> [ file_stat.st_size + <span class="hljs-number">1</span> ];<br>                <span class="hljs-built_in">memset</span>( file_buf, <span class="hljs-string">&#x27;\0&#x27;</span>, file_stat.st_size + <span class="hljs-number">1</span> );<br>                <span class="hljs-comment">/*将目标文件读入缓存区file_buf中*/</span><br>                <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">read</span>( fd, file_buf, file_stat.st_size ) &lt; <span class="hljs-number">0</span> )<br>                &#123;<br>                    valid = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                valid = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*如果目标文件有效，则发送正常的HTTP应答*/</span><br>        <span class="hljs-keyword">if</span>( valid ) <br>        &#123;<br>            <span class="hljs-comment">/*下面这部分内容将HTTP应答的状态行、“Content-Length”头部字段和一个空行依次加入header_buf中*/</span><br>            ret = <span class="hljs-built_in">snprintf</span>( header_buf, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-string">&quot;%s %s\r\n&quot;</span>, <span class="hljs-string">&quot;HTTP/1.1&quot;</span>, status_line[<span class="hljs-number">0</span>] );<br>            len += ret;<br>            ret = <span class="hljs-built_in">snprintf</span>( header_buf + len, BUFFER_SIZE<span class="hljs-number">-1</span>-len, <br>                             <span class="hljs-string">&quot;Content-Length: %d\r\n&quot;</span>, file_stat.st_size );<br>            len += ret;<br>            ret = <span class="hljs-built_in">snprintf</span>( header_buf + len, BUFFER_SIZE<span class="hljs-number">-1</span>-len, <span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;\r\n&quot;</span> );<br>            <span class="hljs-comment">// 上面这部分是在制作头部信息</span><br>            <span class="hljs-comment">/*利用writev将header_buf和file_buf的内容一并写出*/</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span> <span class="hljs-title">iv</span>[2];</span><br>            <span class="hljs-comment">// 分别制定对应的内存缓冲区以及其大小</span><br>            iv[ <span class="hljs-number">0</span> ].iov_base = header_buf;<br>            iv[ <span class="hljs-number">0</span> ].iov_len = <span class="hljs-built_in">strlen</span>( header_buf );<br>            iv[ <span class="hljs-number">1</span> ].iov_base = file_buf;<br>            iv[ <span class="hljs-number">1</span> ].iov_len = file_stat.st_size;<br>            <span class="hljs-comment">// 一起写回给套接字发送回去 【集中写】</span><br>            ret = <span class="hljs-built_in">writev</span>( connfd, iv, <span class="hljs-number">2</span> );<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">/*如果目标文件无效，则通知客户端服务器发生了“内部错误”*/</span><br>        &#123;<br>            ret = <span class="hljs-built_in">snprintf</span>( header_buf, BUFFER_SIZE<span class="hljs-number">-1</span>, <span class="hljs-string">&quot;%s %s\r\n&quot;</span>, <span class="hljs-string">&quot;HTTP/1.1&quot;</span>, status_line[<span class="hljs-number">1</span>] );<br>            len += ret;<br>            ret = <span class="hljs-built_in">snprintf</span>( header_buf + len, BUFFER_SIZE<span class="hljs-number">-1</span>-len, <span class="hljs-string">&quot;%s&quot;</span>, <span class="hljs-string">&quot;\r\n&quot;</span> );<br>            <span class="hljs-built_in">send</span>( connfd, header_buf, <span class="hljs-built_in">strlen</span>( header_buf ), <span class="hljs-number">0</span> );<br>        &#125;<br>        <span class="hljs-built_in">close</span>( connfd );<br>        <span class="hljs-keyword">delete</span> [] file_buf;  <span class="hljs-comment">// 清空文件缓存区</span><br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码清单6-2中，我们省略了HTTP请求的接收及解析，因为现在关注的重点是HTTP应答的发送。我们直接将目标文件作为第3个参数传递给服务器程序，客户telnet到该服务器上【对应ip和port即可触发socket套接字】即可获得该文件。关于HTTP请求的解析，我们将在第8章给出相关代码。</p><h2 id="64-sendfile函数"><a class="markdownIt-Anchor" href="#64-sendfile函数"></a> 6.4 sendfile函数</h2><p>sendfile函数在<u>两个文件描述符之间直接传递数据</u>(完全在内核中操作)，从而<strong>避免</strong>了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，这被称为<strong>零拷贝</strong>。sendfile函数的定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/sendfile.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">sendfile</span><span class="hljs-params">(<span class="hljs-keyword">int</span> out_fd,<span class="hljs-keyword">int</span> in_fd,<span class="hljs-keyword">off_t</span>*offset,<span class="hljs-keyword">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>in_fd参数</strong>是待读出内容的文件描述符，<strong>out_fd参数</strong>是待写入内容的文件描述符。<strong>offset参数</strong>指定从读入文件流的哪个位置开始读，如果 为空，则使用读入文件流默认的起始位置。<strong>count参数</strong>指定在文件描述符in_fd和out_fd之间传输的字节数。sendfile成功时返回传输的字节 数，失败则返回-1并设置errno。该函数的man手册明确指出，in_fd必须是一个支持类似mmap函数的文件描述符，即它必须指向真实的文 件，不能是socket和管道;而out_fd则必须是一个socket。由此可见，sendfile几乎是专门为在网络上传输文件而设计的。下面的代码清单6-3 利用sendfile函数将服务器上的一个文件传送给客户端。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205210748418.png" alt="截屏2022-05-21 上午7.48.15" /></p><p>代码清单6-3 用sendfile函数传输文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/sendfile.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">3</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number filename\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 转换获取到的网络信息</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* file_name = argv[<span class="hljs-number">3</span>];<br>    <span class="hljs-comment">// 定位服务器端需要发送的文件描述符</span><br>    <span class="hljs-keyword">int</span> filefd = <span class="hljs-built_in">open</span>( file_name, O_RDONLY );<br>    <span class="hljs-built_in">assert</span>( filefd &gt; <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 用来获取指定路径的文件或者文件夹的信息的结构体</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">stat_buf</span>;</span><br>    <span class="hljs-comment">// fstat（由文件描述词取得文件状态）</span><br>    <span class="hljs-built_in">fstat</span>( filefd, &amp;stat_buf );<br>    <span class="hljs-comment">// 创建IPv4 socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 命名socket</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 监听socket</span><br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 创建IPv4 socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );<br>    <span class="hljs-comment">// 接收监听socket</span><br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );<br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">// 如果没有成功获取到</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 如果成功获取到</span><br>    &#123;<br>        <span class="hljs-comment">// 不需要分配任何的用户空间 将数据从filefd -&gt; connfd</span><br>        <span class="hljs-built_in">sendfile</span>( connfd, filefd, <span class="hljs-literal">NULL</span>, stat_buf.st_size );<br>        <span class="hljs-built_in">close</span>( connfd );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码清单6-3中，我们将目标文件作为<u>第3个参数传递给服务器程序</u>，客户telnet到该服务器上即可获得该文件。相比代码清单6-2，代码清单6-3没有为目标文件分配任何用户空间的缓存，也没有执行读取文件的操作，但同样实现了文件的发送，其效率显然要高得多。</p><h2 id="65-mmap函数和munmap函数"><a class="markdownIt-Anchor" href="#65-mmap函数和munmap函数"></a> 6.5 mmap函数和munmap函数</h2><p>mmap函数用于<strong>申请</strong>一段内存空间。我们可以将这段内存作为<u>进程间通信的共享内存</u>，也可以<u>将文件直接映射到其中</u>。munmap函数则<strong>释 放</strong>由mmap创建的这段内存空间。它们的定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span>*<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* start,<span class="hljs-keyword">size_t</span> length,<span class="hljs-keyword">int</span> prot,<span class="hljs-keyword">int</span> flags,<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> offset)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">munmap</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* start,<span class="hljs-keyword">size_t</span> length)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>start参数</strong>允许用户使用某个特定的地址作为这段内存的起始地址。 如果它被设置成NULL，则系统自动分配一个地址。</p><p><strong>length参数</strong>指定内存段的长度。</p><p><strong>prot参数</strong>用来设置内存段的访问权限。它可以取以下几个值的按位或:</p><p>1、PROT_READ，内存段可读。</p><p>2、PROT_WRITE，内存段可写。</p><p>3、PROT_EXEC，内存段可执行。</p><p>4、PROT_NONE，内存段不能被访问。</p><p><strong>flags参数</strong>控制内存段内容被修改后程序的行为。它可以被设置为表6-1中的某些值(这里仅列出了常用的值)的按位或(其中MAP_SHARED和MAP_PRIVATE是互斥的，不能同时指定)。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205210756313.png" alt="截屏2022-05-21 上午7.56.55" /></p><p><strong>fd参数</strong>是被映射文件对应的文件描述符。它一般通过open系统调用获得。</p><p><strong>offset参数</strong>设置从文件的何处开始映射(对于不需要读入整个文件的情况)。</p><p>mmap函数成功时返回指向目标内存区域的指针，失败则返回 MAP_FAILED((void*)-1)并设置errno。munmap函数成功时返回0， 失败则返回-1并设置errno。</p><p>我们将在第13章进一步讨论如何利用mmap函数实现进程间共享内 存。</p><h2 id="66-splice函数"><a class="markdownIt-Anchor" href="#66-splice函数"></a> 6.6 splice函数</h2><p>splice函数用于在<u>两个文件描述符之间移动数据</u>，也是<strong>零拷贝操作</strong>。splice函数的定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">splice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd_in,<span class="hljs-keyword">loff_t</span>* off_in,<span class="hljs-keyword">int</span> fd_out,<span class="hljs-keyword">loff_t</span>* off_out,<span class="hljs-keyword">size_t</span> len,<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>fd_in参数</strong>是待输入数据的文件描述符。如果fd_in是一个管道文件描述符，那么off_in参数必须被设置为NULL。如果fd_in不是一个管道文件描述符(比如socket)，那么off_in表示从输入数据流的何处开始读取数据。此时，若off_in被设置为NULL，则表示从输入数据流的当前偏移位置读入;若off_in不为NULL，则它将指出具体的偏移位置。</p><ul><li><p><strong>fd_out/off_out参数</strong>的含义与fd_in/off_in相同，不过用于输出数据流。</p></li><li><p><strong>len 参数</strong>指定移动数据的长度;</p></li><li><p><strong>flags参数</strong>则控制数据如何移动，它可以被设置为表6-2中的某些值的按位或。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205210800519.png" alt="截屏2022-05-21 上午8.00.40" /></p><p>使用splice函数时，fd_in和fd_out必须至少有一个是管道文件描述符【说明不是从管道到某个文件就是某个文件到管道要不就是管道和管道之间的通信】。splice函数调用成功时返回移动字节的数量。它可能返回0，表示没有数据需要移动，这发生在从管道中读取数据(fd_in是管道文件描述符)而该管道没有被写入任何数据时。splice函数失败时返回-1并设置errno。常见的errno如表6-3所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205210803060.png" alt="截屏2022-05-21 上午8.02.59" /></p><p>下面我们使用splice函数来实现一个零拷贝的回射服务器，它将客户端发送的数据原样返回给客户端，具体实现如代码清单6-4所示。</p><p>代码清单6-4 使用splice函数实现的回射服务器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// ip 和 port 读取</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 创建IPv4 socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-keyword">int</span> sock = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( sock &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 命名socket</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 监听socket</span><br>    ret = <span class="hljs-built_in">listen</span>( sock, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 创建IPv4 socket地址</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client );<br>    <span class="hljs-comment">// 接收socket</span><br>    <span class="hljs-keyword">int</span> connfd = <span class="hljs-built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );<br>    <span class="hljs-keyword">if</span> ( connfd &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">// 没接受</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span>  <span class="hljs-comment">// 成功接收</span><br>    &#123;   <span class="hljs-comment">// 来我们的管道走一波之后又发回去了</span><br>        <span class="hljs-keyword">int</span> pipefd[<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>        ret = <span class="hljs-built_in">pipe</span>( pipefd ); <span class="hljs-comment">/*创建管道*/</span><br>        <span class="hljs-comment">/*将connfd上流入的客户数据定向到管道中 其中pipefd[1]为管道的入*/</span> <br>        ret = <span class="hljs-built_in">splice</span>( connfd, <span class="hljs-literal">NULL</span>, pipefd[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE ); <br>        <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>        <span class="hljs-comment">/*将管道的输出定向到connfd客户连接文件描述符*/</span><br>        ret = <span class="hljs-built_in">splice</span>( pipefd[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>, connfd, <span class="hljs-literal">NULL</span>, <span class="hljs-number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );<br>        <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>        <span class="hljs-built_in">close</span>( connfd );<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>( sock );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们通过splice函数将客户端的内容读入到pipefd[1]中，然后再使用splice函数从pipefd[0]中读出该内容到客户端，从而实现了简单高效</p><p>的回射服务。整个过程未执行recv/send操作，因此也未涉及用户空间和内核空间之间的数据拷贝。</p><h2 id="67-tee函数"><a class="markdownIt-Anchor" href="#67-tee函数"></a> 6.7 tee函数</h2><p>tee函数在<strong>两个管道文件描述符</strong>之间复制数据，也是零拷贝操作。它不消耗数据，因此源文件描述符上的数据<strong>仍然可以用于</strong>后续的读操 作。tee函数的原型如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">ssize_t</span> <span class="hljs-title">tee</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd_in,<span class="hljs-keyword">int</span> fd_out,<span class="hljs-keyword">size_t</span> len,<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><p>该函数的参数的含义与splice相同(但fd_in和fd_out必须都是管道文件描述符)。tee函数成功时返回在两个文件描述符之间复制的数据数量(字节数)。返回0表示没有复制任何数据。tee失败时返回-1并设置errno。</p><p>代码清单6-5利用tee函数和splice函数，实现了Linux下tee程序(同时输出数据到终端和文件的程序，不要和tee函数混淆)的基本功能。</p><p>代码清单6-5 同时输出数据到终端和文件的程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> ( argc != <span class="hljs-number">2</span> )<br>&#123;<br><span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s &lt;file&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>] );<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>  <span class="hljs-comment">// 定位电脑中的文件描述符</span><br><span class="hljs-keyword">int</span> filefd = <span class="hljs-built_in">open</span>( argv[<span class="hljs-number">1</span>], O_CREAT | O_WRONLY | O_TRUNC, <span class="hljs-number">0666</span> );<br><span class="hljs-built_in">assert</span>( filefd &gt; <span class="hljs-number">0</span> );<br>  <span class="hljs-comment">// 创建管道1 -&gt; 终端</span><br><span class="hljs-keyword">int</span> pipefd_stdout[<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">pipe</span>( pipefd_stdout );<br><span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>  <span class="hljs-comment">// 创建管道2 -&gt; 文件</span><br><span class="hljs-keyword">int</span> pipefd_file[<span class="hljs-number">2</span>];<br>  ret = <span class="hljs-built_in">pipe</span>( pipefd_file );<br><span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br><br><span class="hljs-comment">//close( STDIN_FILENO );</span><br><span class="hljs-comment">// dup2( pipefd_stdout[1], STDIN_FILENO );</span><br><span class="hljs-comment">//write( pipefd_stdout[1], &quot;abc\n&quot;, 4 );</span><br>  <span class="hljs-comment">/*将标准输入内容输入管道pipefd_stdout*/</span><br>ret = <span class="hljs-built_in">splice</span>( STDIN_FILENO, <span class="hljs-literal">NULL</span>, pipefd_stdout[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );<br><span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>  <span class="hljs-comment">/*将管道pipefd_stdout的输出复制到管道pipefd_file的输入端*/</span><br>ret = <span class="hljs-built_in">tee</span>( pipefd_stdout[<span class="hljs-number">0</span>], pipefd_file[<span class="hljs-number">1</span>], <span class="hljs-number">32768</span>, SPLICE_F_NONBLOCK ); <br><span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>  <span class="hljs-comment">/*将管道pipefd_file的输出定向到文件描述符filefd上，从而将标准输入的内容写入文件*/</span><br>ret = <span class="hljs-built_in">splice</span>( pipefd_file[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>, filefd, <span class="hljs-literal">NULL</span>, <span class="hljs-number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );<br><span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>  <span class="hljs-comment">/*将管道pipefd_stdout的输出定向到标准输出，其内容和写入文件的内容完全一致*/</span><br>ret = <span class="hljs-built_in">splice</span>( pipefd_stdout[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>, STDOUT_FILENO, <span class="hljs-literal">NULL</span>, <span class="hljs-number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );<br><span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>  <br><span class="hljs-built_in">close</span>( filefd );<br>  <span class="hljs-built_in">close</span>( pipefd_stdout[<span class="hljs-number">0</span>] );<br>  <span class="hljs-built_in">close</span>( pipefd_stdout[<span class="hljs-number">1</span>] );<br>  <span class="hljs-built_in">close</span>( pipefd_file[<span class="hljs-number">0</span>] );<br>  <span class="hljs-built_in">close</span>( pipefd_file[<span class="hljs-number">1</span>] );<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="68-fcntl函数"><a class="markdownIt-Anchor" href="#68-fcntl函数"></a> 6.8 fcntl函数</h2><p>fcntl函数，正如其名字(file control)描述的那样，提供了<strong>对文件描述符的各种控制操作</strong>。另外一个常见的控制文件描述符属性和行为的系统调用是ioctl，而且ioctl比fcntl能够执行更多的控制。但是，对于控制文件描述符常用的属性和行为，fcntl函数是由POSIX规范指定的首选方法。所以本书仅讨论fcntl函数。fcntl函数的定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd,<span class="hljs-keyword">int</span> cmd,...)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>fd参数</strong>是被操作的文件描述符，<strong>cmd参数</strong>指定执行何种类型的操作。根据操作类型的不同，该函数可能还需要第三个可选参数arg。 fcntl函数支持的常用操作及其参数如表6-4所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205210959142.png" alt="截屏2022-05-21 上午9.59.48" /></p><p>fcntl函数成功时的返回值如表6-4最后一列所示，失败则返回-1并设置errno。</p><p>在网络编程中，fcntl函数<u>通常用来将一个文件描述符设置为非阻塞</u>的，如代码清单6-6所示。</p><p>代码清单6-6 将文件描述符设置为非阻塞的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> old_option=<span class="hljs-built_in">fcntl</span>(fd,F_GETFL);<span class="hljs-comment">/*获取文件描述符旧的状态标志*/</span> <br>  <span class="hljs-keyword">int</span> new_option=old_option|O_NONBLOCK;<span class="hljs-comment">/*设置非阻塞标志*/</span> <br>  <span class="hljs-built_in">fcntl</span>(fd,F_SETFL,new_option);<br><span class="hljs-keyword">return</span> old_option;<span class="hljs-comment">/*返回文件描述符旧的状态标志，以便*/</span> <span class="hljs-comment">/*日后恢复该状态标志*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此外，SIGIO和SIGURG这两个信号与其他Linux信号不同，它们必须与某个文件描述符相关联方可使用:当被关联的文件描述符可读或可写时，系统将触发SIGIO信号;当被关联的文件描述符(而且必须是一个socket)上有带外数据可读时，系统将触发SIGURG信号。将信号和文件描述符关联的方法，就是使用fcntl函数为目标文件描述符指定宿主进程或进程组，那么被指定的宿主进程或进程组将捕获这两个信号。使用SIGIO时，还需要利用fcntl设置其O_ASYNC标志(异步I/O标志，不过SIGIO信号模型并非真正意义上的异步I/O模型，见第8章)。 关于信号SIGURG的更多内容，我们将在第10章讨论。</p><h1 id="第7章-linux服务器程序规范"><a class="markdownIt-Anchor" href="#第7章-linux服务器程序规范"></a> 第7章 Linux服务器程序规范</h1><p>除了网络通信外，服务器程序通常还必须考虑许多其他细节问题。这些细节问题涉及面广且零碎，而且基本上是模板式的，所以我们称之为服务器程序规范。比如:</p><ul><li>Linux服务器程序一般以<strong>后台</strong>进程形式运行。后台进程又称<strong>守护进程(daemon)</strong>。它没有控制终端，因而也不会意外接收到用户输入。守护进程的父进程通常是init进程(PID为1的进程)。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205211008893.png" alt="截屏2022-05-21 上午10.08.33" /></p><ul><li><p>Linux服务器程序通常有一套日志系统，它至少能输出日志到文件，有的高级服务器还能输出日志到专门的UDP服务器。大部分后台 进程都在/var/log目录下拥有自己的日志目录。</p></li><li><p>Linux服务器程序一般以某个专门的非root身份运行。比如mysqld、httpd、syslogd等后台进程，分别拥有自己的运行账户mysql、 apache和syslog。</p></li><li><p>Linux服务器程序通常是可配置的。服务器程序通常能处理很多命令行选项，如果一次运行的选项太多，则可以用配置文件来管理。 绝大多数服务器程序都有配置文件，并存放在/etc目录下。比如第4章讨论的squid服务器的配置文件是/etc/squid3/squid.conf。</p></li><li><p>Linux服务器进程通常会在启动的时候生成一个PID文件并存入/var/run目录中，以记录该后台进程的PID。比如syslogd的PID文件 是/var/run/syslogd.pid。</p></li><li><p>Linux服务器程序通常需要考虑系统资源和限制，以预测自身能承受多大负荷，比如进程可用文件描述符总数和内存总量等。</p></li></ul><p>在开始系统地学习网络编程之前，我们将用一章的篇幅来探讨服务器程序的一些主要的规范。</p><h2 id="71-日志"><a class="markdownIt-Anchor" href="#71-日志"></a> 7.1 日志</h2><h3 id="711-linux系统日志"><a class="markdownIt-Anchor" href="#711-linux系统日志"></a> 7.1.1 Linux系统日志</h3><p>工欲善其事，必先利其器。服务器的调试和维护都需要一个专业的日志系统。Linux提供一个守护进程来处理系统日志——syslogd，不过现在的Linux系统上使用的都是它的升级版——rsyslogd。</p><p>rsyslogd守护进程既能<strong>接收用户进程</strong>输出的日志，又能<strong>接收内核日志</strong>。用户进程是通过调用syslog函数生成系统日志的。该函数将日志输 出到一个UNIX本地域socket类型(AF_UNIX)的文件/dev/log中， rsyslogd则监听该文件以获取用户进程的输出。内核日志在老的系统上是通过另外一个守护进程rklogd来管理的，rsyslogd利用额外的模块实现了相同的功能。内核日志由printk等函数打印至内核的环状缓存 (ring buffer)中。环状缓存的内容直接映射到/proc/kmsg文件中。 rsyslogd则通过读取该文件获得内核日志。</p><p>rsyslogd守护进程在接收到用户进程或内核输入的日志后，会把它们输出至某些特定的日志文件。默认情况下，调试信息会保存 至/var/log/debug文件，普通信息保存至/var/log/messages文件，内核消息则保存至/var/log/kern.log文件。不过，日志信息具体如何分发，可以在rsyslogd的配置文件中设置。rsyslogd的主配置文件是/etc/rsyslog.conf，其中主要可以设置的项包括:内核日志输入路径， 是否接收UDP日志及其监听端口(默认是514，见/etc/services文件)， 是否接收TCP日志及其监听端口，日志文件的权限，包含哪些子配置文 件(比如/etc/rsyslog.d/*.conf)。rsyslogd的子配置文件则指定各类日志的目标存储文件。</p><p>图7-1总结了Linux的系统日志体系。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205211014062.png" alt="截屏2022-05-21 上午10.13.57" /></p><h3 id="712-syslog函数"><a class="markdownIt-Anchor" href="#712-syslog函数"></a> 7.1.2 syslog函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;syslog.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">syslog</span><span class="hljs-params">(<span class="hljs-keyword">int</span> priority,<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*message,...)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>该函数采用可变参数(第二个参数message和第三个参数…)来结构化输出。</p></li><li><p>priority参数是所谓的设施值与日志级别的按位或。设施值的默认值是LOG_USER，我们下面的讨论也只限于这一种设施值。日志级别有如下几个:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;syslog.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_EMERG 0<span class="hljs-comment">/*系统不可用*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_ALERT 1<span class="hljs-comment">/*报警，需要立即采取动作*/</span> #<span class="hljs-meta-keyword">define</span> LOG_CRIT 2<span class="hljs-comment">/*非常严重的情况*/</span> #<span class="hljs-meta-keyword">define</span> LOG_ERR 3<span class="hljs-comment">/*错误*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_WARNING 4<span class="hljs-comment">/*警告*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_NOTICE 5<span class="hljs-comment">/*通知*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_INFO 6<span class="hljs-comment">/*信息*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_DEBUG 7<span class="hljs-comment">/*调试*/</span></span><br></code></pre></td></tr></table></figure></li></ul><p>下面这个函数可以改变syslog的默认输出方式，进一步结构化日志内容:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;syslog.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">openlog</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ident,<span class="hljs-keyword">int</span> logopt,<span class="hljs-keyword">int</span> facility)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>ident参数</strong>指定的字符串将被添加到日志消息的日期和时间之后， 它通常被设置为程序的名字。logopt参数对后续syslog调用的行为进行 配置，它可取下列值的按位或:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_PID 0x01<span class="hljs-comment">/*在日志消息中包含程序PID*/</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_CONS 0x02<span class="hljs-comment">/*如果消息不能记录到日志文件，则打印至终端*/</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_ODELAY 0x04<span class="hljs-comment">/*延迟打开日志功能直到第一次调用syslog*/</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOG_NDELAY 0x08<span class="hljs-comment">/*不延迟打开日志功能*/</span></span><br></code></pre></td></tr></table></figure><p><strong>facility参数</strong>可用来修改syslog函数中的默认设施值。</p><p>此外，日志的过滤也很重要。程序在开发阶段可能需要输出很多调试信息，而发布之后我们又需要将这些调试信息关闭。解决这个问题的方法并不是在程序发布之后删除调试代码(因为日后可能还需要用到)，而是简单地设置日志掩码，使日志级别大于日志掩码的日志信息被系统忽略。下面这个函数用于设置syslog的日志掩码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;syslog.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setlogmask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maskpri)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>maskpri参数</strong>指定日志掩码值。该函数始终会成功，它返回调用进程先前的日志掩码值。最后，不要忘了使用如下函数关闭日志功能:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;syslog.h&gt;</span> </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">closelog</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h2 id="72-用户信息"><a class="markdownIt-Anchor" href="#72-用户信息"></a> 7.2 用户信息</h2><h3 id="721-uid-euid-gid和egid"><a class="markdownIt-Anchor" href="#721-uid-euid-gid和egid"></a> 7.2.1 UID、EUID、GID和EGID</h3><p>用户信息对于服务器程序的安全性来说是很重要的，比如大部分服务器就必须以root身份启动，但不能以root身份运行。下面这一组函数可以获取和设置当前进程的真实用户ID(UID)、有效用户ID(EUID)、真实组ID(GID)和有效组ID(EGID):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/types.h&gt;</span> #<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">uid_t</span> <span class="hljs-title">getuid</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/*获取真实用户ID*/</span><br><span class="hljs-function"><span class="hljs-keyword">uid_t</span> <span class="hljs-title">geteuid</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/*获取有效用户ID*/</span><br><span class="hljs-function"><span class="hljs-keyword">gid_t</span> <span class="hljs-title">getgid</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/*获取真实组ID*/</span><br><span class="hljs-function"><span class="hljs-keyword">gid_t</span> <span class="hljs-title">getegid</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/*获取有效组ID*/</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setuid</span><span class="hljs-params">(<span class="hljs-keyword">uid_t</span> uid)</span></span>;<span class="hljs-comment">/*设置真实用户ID*/</span> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">seteuid</span><span class="hljs-params">(<span class="hljs-keyword">uid_t</span> uid)</span></span>;<span class="hljs-comment">/*设置有效用户ID*/</span> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setgid</span><span class="hljs-params">(<span class="hljs-keyword">gid_t</span> gid)</span></span>;<span class="hljs-comment">/*设置真实组ID*/</span> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setegid</span><span class="hljs-params">(<span class="hljs-keyword">gid_t</span> gid)</span></span>;<span class="hljs-comment">/*设置有效组ID*/</span><br></code></pre></td></tr></table></figure><p>需要指出的是，<u>一个进程拥有两个用户ID:UID和EUID</u>。</p><p>EUID存在的目的是方便资源访问:它使得运行程序的用户拥有该程序的有效用户的权限。比如su程序，任何用户都可以使用它来修改自己的账户信息，但修改账户时su程序不得不访问/etc/passwd文件，而访问该文件是需要root权限的。</p><p>那么以普通用户身份启动的su程序如何能访问/etc/passwd文件呢?窍门就在EUID。用ls命令可以查看到，su程序的所有者是root，并且它<u>被设置了set-user-id标志</u>。这个标志表示，任何普通用户运行su程序时，其有效用户就是该程序的所有者root。那么，根据有效用户的含义，任何运行su程序的普通用户都能够访问/etc/passwd文件。<strong>有效用户为root的进程称为特权进程(privileged processes</strong>)。EGID的含义与EUID类似:<u>给运行目标程序的组用户提供有效组的权限</u>。</p><p>下面的代码清单7-1可以用来测试进程的UID和EUID的区别。</p><p>代码清单7-1 测试进程的UID和EUID的区别</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">uid_t</span> uid=<span class="hljs-built_in">getuid</span>(); <span class="hljs-comment">// 获取真实用户ID</span><br>   <span class="hljs-keyword">uid_t</span> euid=<span class="hljs-built_in">geteuid</span>(); <span class="hljs-comment">// 获取有效用户ID</span><br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;userid is %d,effective userid is:%d\n&quot;</span>,uid,euid);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译该文件，将生成的可执行文件(名为test_uid)的所有者设置为root，并设置该文件的set-user-id标志，然后运行该程序以查看UID和EUID。具体操作如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">$sudo chown root:root test_uid#修改目标文件的所有者为root <br>$sudo chmod +s test_uid#设置目标文件的set-user-id标志 <br>$./test_uid#运行程序<br>userid is <span class="hljs-number">1000</span>, effective userid is:<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>从测试程序的输出来看，进程的UID是启动程序的用户的ID，而EUID则是root账户(文件所有者)的ID。</p><h3 id="722-切换用户"><a class="markdownIt-Anchor" href="#722-切换用户"></a> 7.2.2 切换用户</h3><p>下面的代码清单7-2展示了如何将以root身份启动的进程切换为以一个普通用户身份运行。</p><p>代码清单7-2 切换用户</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">switch_to_user</span><span class="hljs-params">( <span class="hljs-keyword">uid_t</span> user_id, <span class="hljs-keyword">gid_t</span> gp_id )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">/*先确保目标用户不是root id == 0 就是root */</span><br>    <span class="hljs-keyword">if</span> ( ( user_id == <span class="hljs-number">0</span> ) &amp;&amp; ( gp_id == <span class="hljs-number">0</span> ) )<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">/*确保当前用户是合法用户:root或者目标用户*/</span><br>    <span class="hljs-keyword">gid_t</span> gid = <span class="hljs-built_in">getgid</span>();<br>    <span class="hljs-keyword">uid_t</span> uid = <span class="hljs-built_in">getuid</span>();<br>    <span class="hljs-keyword">if</span> ( ( ( gid != <span class="hljs-number">0</span> ) || ( uid != <span class="hljs-number">0</span> ) ) &amp;&amp; ( ( gid != gp_id ) || ( uid != user_id ) ) )<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">/*如果不是root，则已经是目标用户*/</span><br>    <span class="hljs-keyword">if</span> ( uid != <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">/*切换到目标用户 设置真实用户 和真实组 */</span><br>    <span class="hljs-keyword">if</span> ( ( <span class="hljs-built_in">setgid</span>( gp_id ) &lt; <span class="hljs-number">0</span> ) || ( <span class="hljs-built_in">setuid</span>( user_id ) &lt; <span class="hljs-number">0</span> ) )<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="73-进程间关系"><a class="markdownIt-Anchor" href="#73-进程间关系"></a> 7.3 进程间关系</h2><h3 id="731-进程组"><a class="markdownIt-Anchor" href="#731-进程组"></a> 7.3.1 进程组</h3><p>Linux下每个进程都隶属于一个进程组，因此它们除了<strong>PID信息</strong>外，还有<strong>进程组ID(PGID)</strong>。我们可以用如下函数来获取指定进程的PGID:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">getpgid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span>;<br></code></pre></td></tr></table></figure><p>该函数成功时返回进程<u>pid所属进程组的PGID</u>，失败则返回-1并设置errno。</p><p>每个进程组都有一个<strong>首领进程</strong>，其PGID和PID相同。进程组将一 直存在，直到其中所有进程都退出，或者加入到其他进程组。</p><p>下面的函数用于设置PGID:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setpgid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid,<span class="hljs-keyword">pid_t</span> pgid)</span></span>;<br></code></pre></td></tr></table></figure><p>该函数将PID为pid的进程的PGID设置为pgid。如果<u>pid和pgid相同</u>，则由pid指定的进程将被设置为<strong>进程组首领</strong>;如果pid为0，则表示设置当前进程的PGID为pgid【就是改变进程组为pgid】;如果pgid为0，则使用pid作为目标PGID【如果有就变成首领进程， 如果没有就建立进程成为首领进程】。setpgid函数成功时返回0，失败则返回-1并设置errno。</p><p>一个进程只能<u>设置自己或者其子进程</u>的PGID。并且，当子进程调用exec系列函数后，我们也不能再在父进程中对它设置PGID。</p><h3 id="732-会话"><a class="markdownIt-Anchor" href="#732-会话"></a> 7.3.2 会话</h3><p>Session详解：</p><p><a href="https://www.cnblogs.com/sparkdev/p/12146305.html">https://www.cnblogs.com/sparkdev/p/12146305.html</a></p><p>一些<u>有关联的进程组</u>将形成一个会话(session)。下面的函数用于创建一个会话:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">setsid</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>该函数<strong>不能</strong>由进程组的首领进程调用【因为本身是前台job 相当于当前这个session散了】，否则将产生一个错误。对于非组首领的进程，调用该函数不仅创建新会话，而且有如下额外效果:</p><ul><li>调用进程成为会话的首领【前台job】，此时该进程是新会话的唯一成员。</li><li>新建一个进程组，其PGID就是调用进程的PID，调用进程成为该组的首领。</li><li>调用进程将甩开终端(如果有的话)。</li></ul><p>该函数成功时返回新的进程组的PGID，失败则返回-1并设置 errno。</p><p>Linux进程并未提供所谓会话ID(SID)的概念，但Linux系统认为它<u>等于会话首领所在的进程组的PGID</u>，并提供了如下函数来读取SID:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span> </span><br><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">getsid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="733-用ps命令查看进程关系"><a class="markdownIt-Anchor" href="#733-用ps命令查看进程关系"></a> 7.3.3 用ps命令查看进程关系</h3><p>执行ps命令可查看进程、进程组和会话之间的关系:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">$ps -o pid,ppid,pgid,sid,comm|less<br>PID PPID PGID SID COMMAND<br><span class="hljs-number">1943</span> <span class="hljs-number">1942</span> <span class="hljs-number">1943</span> <span class="hljs-number">1943</span> bash<br><span class="hljs-number">2298</span> <span class="hljs-number">1943</span> <span class="hljs-number">2298</span> <span class="hljs-number">1943</span> ps<br><span class="hljs-number">2299</span> <span class="hljs-number">1943</span> <span class="hljs-number">2298</span> <span class="hljs-number">1943</span> less<br></code></pre></td></tr></table></figure><p>我们是在bash shell下执行ps和less命令的，所以ps和less命令的<strong>父进程</strong>是bash命令，这可以从PPID(父进程PID)一列看出。这3条命令创 建了1个会话(SID是1943)和2个进程组(PGID分别是1943和 2298)。bash命令的PID、PGID和SID都相同，很明显它既是会话的首领，也是组1943的首领。ps命令则是组2298的首领，因为其PID也是2298。图7-2描述了此三者的关系。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205211145639.png" alt="截屏2022-05-21 上午11.44.53" /></p><h2 id="74-系统资源限制"><a class="markdownIt-Anchor" href="#74-系统资源限制"></a> 7.4 系统资源限制</h2><p>Linux上运行的程序都会受到资源限制的影响，比如物理设备限制 (CPU数量、内存数量等)、系统策略限制(CPU时间等)，以及具体实现的限制(比如文件名的最大长度)。Linux系统资源限制可以通过如下一对函数来读取和设置:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;sys/resource.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getrlimit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> resource,struct rlimit*rlim)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">setrlimit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> resource,<span class="hljs-keyword">const</span> struct rlimit*rlim)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>rlim参数</strong>是rlimit结构体类型的指针，rlimit结构体的定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rlimit</span>&#123;</span><br>    <span class="hljs-keyword">rlim_t</span> rlim_cur;<br>    <span class="hljs-keyword">rlim_t</span> rlim_max;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>rlim_t是一个整数类型，它描述资源级别。</li><li>rlim_cur成员指定资源的软限制，rlim_max成员指定资源的硬限制。</li><li>软限制是一个建议性的、最好不要超越的限制，如果超越的话，系统可能向进程发送信号以终止其运行。例如，当进程CPU时间超过其软限制时，系统将向进程发送SIGXCPU信号;当文件尺寸超过其软限制时，系统将向进程发送SIGXFSZ信号(见第10章)。</li><li>硬限制一般是软限制的上限。普通程序可以减小硬限制，而只有以root身份运行的程序才能增加硬限制。</li><li>此外，我们可以使用ulimit命令修改当前shell环境下的资源限制(软限制或/和硬限制)，这种修改将对该shell启动的所有后续程序有效。我们也可以通过修改配置文件来改变系统软限制和硬限制，而且这种修改 是永久的，详情见第16章。</li></ul><p>resource参数指定资源限制类型。表7-1列举了部分比较重要的资源限制类型。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205211150756.png" alt="截屏2022-05-21 上午11.50.29" /></p><p>setrlimit和getrlimit成功时返回0，失败则返回-1并设置errno。</p><h2 id="75-改变工作目录和根目录"><a class="markdownIt-Anchor" href="#75-改变工作目录和根目录"></a> 7.5 改变工作目录和根目录</h2><p>有些服务器程序还需要改变工作目录和根目录，比如我们第4章讨论的Web服务器。一般来说，Web服务器的逻辑根目录并非文件系统的根目录“/”，而是站点的根目录(对于Linux的Web服务来说，该目录一般是/var/www/)。</p><p><strong>获取进程当前工作目录</strong>和<strong>改变进程工作目录</strong>的函数分别是:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span> </span><br><span class="hljs-function"><span class="hljs-keyword">char</span>* <span class="hljs-title">getcwd</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* buf,<span class="hljs-keyword">size_t</span> size)</span></span>; <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">chdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><strong>buf参数</strong>指向的内存用于存储进程当前工作目录的绝对路径名，其大小由size参数指定。如果当前工作目录的绝对路径的长度(再加上 一个空结束字符“\0”)超过了size，则getcwd将返回NULL，并设置 errno为ERANGE。如果buf为NULL并且size非0，则getcwd可能在内部使用malloc动态分配内存，<strong>并将进程的当前工作目录存储</strong>在其中。如果是这种情况，则我们必须自己来释放getcwd在内部创建的这块内存。getcwd函数成功时返回一个指向目标存储区(buf指向的缓存区或是getcwd在内部动态创建的缓存区)的指针，失败则返回NULL并设 置errno。</li><li><strong>chdir函数</strong>的path参数指定要<u>切换到的目标目录</u>。它成功时返回0， 失败时返回-1并设置errno。</li></ul><p>改变进程根目录的函数是chroot，其定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">chroot</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* path)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>path参数</strong>指定要切换到的目标根目录。</p><p>chdir()用来将当前的工作目录改变成以参数path所指的目录.</p><p>它成功时返回0，失败时返 回-1并设置errno。chroot并不改变进程的当前工作目录，所以调用chroot之后，我们仍然需要使用chdir(“/”)来将工作目录切换至新的根目录。改变进程的根目录之后，程序可能无法访问类似/dev的文件(和目录)，因为这些文件(和目录)并非处于新的根目录之下。不过好在调用chroot之后，进程<strong>原先打开的文件描述符依然生效</strong>，所以我们可以利用这些早先打开的文件描述符来访问调用chroot之后不能直接访问的文件(和目录)，尤其是一些日志文件。此外，只有<strong>特权进程</strong>才能改变根目录。</p><h2 id="76-服务器程序后台化"><a class="markdownIt-Anchor" href="#76-服务器程序后台化"></a> 7.6 服务器程序后台化</h2><p>最后，我们讨论如何在代码中让一个进程以守护进程的方式运行。守护进程的编写遵循一定的步骤[2]，下面我们通过一个具体实现来探讨，如代码清单7-3所示。</p><p>代码清单7-3 将服务器程序以守护进程的方式运行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">daemonize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*创建子进程，关闭父进程，这样可以使程序在后台运行*/</span><br>    <span class="hljs-keyword">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> ( pid &lt; <span class="hljs-number">0</span> ) <span class="hljs-comment">// 创建子进程没成功</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( pid &gt; <span class="hljs-number">0</span> ) <span class="hljs-comment">// pid &gt; 0 代表父进程 关闭 pid = 0 代表子进程</span><br>    &#123;<br>        <span class="hljs-built_in">exit</span>( <span class="hljs-number">0</span> );<br>    &#125;<br>    <span class="hljs-comment">/*设置文件权限掩码。当进程创建新文件(使用open(const char*pathname,intflags,mode_t mode)系统调用)时，文件的权限将是mode&amp;0777*/</span><br>    <span class="hljs-built_in">umask</span>( <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">/*创建新的会话，设置本进程为进程组的首领，这个时候子进程父亲进程已经G了*/</span><br>    <span class="hljs-keyword">pid_t</span> sid = <span class="hljs-built_in">setsid</span>();<br>    <span class="hljs-keyword">if</span> ( sid &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">// 没成功就退出</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ( ( <span class="hljs-built_in">chdir</span>( <span class="hljs-string">&quot;/&quot;</span> ) ) &lt; <span class="hljs-number">0</span> )  <span class="hljs-comment">// 重新设置子进程的工作路径</span><br>    &#123;<br>        <span class="hljs-comment">/* Log the failure */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">/*关闭标准输入设备、标准输出设备和标准错误输出设备*/</span><br>    <span class="hljs-built_in">close</span>( STDIN_FILENO );<br>    <span class="hljs-built_in">close</span>( STDOUT_FILENO );<br>    <span class="hljs-built_in">close</span>( STDERR_FILENO );<br>    <span class="hljs-comment">/*关闭其他已经打开的文件描述符，代码省略*/</span> <br>    <span class="hljs-comment">/*将标准输入、标准输出和标准错误输出都定向到/dev/null文件【说明此时不会有终端的输出，全部到重定向的文件描述符】*/</span><br>    <span class="hljs-built_in">open</span>( <span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDONLY );<br>    <span class="hljs-built_in">open</span>( <span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDWR );<br>    <span class="hljs-built_in">open</span>( <span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDWR );<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，Linux提供了完成同样功能的库函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">daemon</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nochdir,<span class="hljs-keyword">int</span> noclose)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>nochdir参数用于指定是否改变工作目录，如果给它传递0，则工作目录将被设置为“/”(根目录)，否则继续使用当前工作目录。</li><li>noclose参数为0时，标准输入、标准输出和标准错误输出都被重定向到/dev/null文件，否则依然使用原来的设备。该函数成功时返回 0，失败则返回-1并设置errno。</li></ul><h1 id="第8章-高性能服务器程序框架"><a class="markdownIt-Anchor" href="#第8章-高性能服务器程序框架"></a> 第8章 高性能服务器程序框架</h1><p>这一章是全书的核心，也是后续章节的总览。在这一章中，我们按照服务器程序的一般原理，将服务器解构为如下三个主要模块:</p><ul><li><p>I/O处理单元。本章将介绍I/O处理单元的<strong>四种I/O模型</strong>和<strong>两种高效事件</strong>处理模式。</p></li><li><p>逻辑单元。本章将介绍逻辑单元的<strong>两种高效并发</strong>模式，以及高效的逻辑处理方式——<strong>有限状态机</strong>。</p></li><li><p>存储单元。本书不讨论存储单元，因为它只是服务器程序的可选模块，而且其内容与网络编程本身无关。</p><p>最后，本章还介绍了提高服务器性能的其他建议。</p></li></ul><h2 id="81-服务器模型"><a class="markdownIt-Anchor" href="#81-服务器模型"></a> 8.1 服务器模型</h2><h3 id="811-cs模型"><a class="markdownIt-Anchor" href="#811-cs模型"></a> 8.1.1 C/S模型</h3><p>TCP/IP协议在设计和实现上并没有客户端和服务器的概念，在通信过程中所有机器都是对等的。但由于资源(视频、新闻、软件等) 都被数据提供者所垄断，所以几乎所有的网络应用程序都很自然地采用了图8-1所示的C/S(客户端/服务器)模型:所有客户端都通过访问服务器来获取所需的资源。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221725664.png" alt="截屏2022-05-22 下午5.25.29" /></p><p>采用C/S模型的TCP服务器和TCP客户端的工作流程如图8-2所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221726905.png" alt="截屏2022-05-22 下午5.26.32" /></p><p>C/S模型的逻辑很简单。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221731291.png" alt="截屏2022-05-22 下午5.31.09" /></p><ul><li>服务器启动后，首先创建一个(或多个) 监听socket，并调用bind函数将其绑定到服务器感兴趣的端口上，然后调用listen函数等待客户连接。</li><li>服务器稳定运行之后，客户端就可以调用connect函数向服务器发起连接了。由于客户连接请求是随机到达的异步事件，服务器需要使用某种I/O模型来监听这一事件。</li><li>I/O模型有多种，图8-2中，服务器使用的是<strong>I/O复用技术</strong>之一的<strong>select系统调用</strong>。</li><li>当监听到连接请求后，服务器就调用accept函数接受它，并分配一个<u>逻辑单元为新的连接服务</u>。逻辑单元可以是新创建的子进程、子线程或者其他。</li><li>图8-2中，服务器给客户端分配的<strong>逻辑单元</strong>是由fork系统调用创建的子进程。逻辑单元<u>读取客户请求，处理该请求</u>，然后将处理结果 返回给客户端。</li><li>客户端接收到服务器反馈的结果之后，可以继续向服务器发送请求，也可以立即主动关闭连接。如果客户端主动关闭连接，则服务器执行被动关闭连接。</li><li>至此，双方的通信结束。需要注意的是，服务器在处理一个客户请求的同时还会继续监听其他客户请求，否则就变成了效率低下的串行服务器了(必须先处理完前一个客户的请求，才能继续处理下一个客户请求)。图8-2中，服务器同时监听多个客户请求是通过select系统调用实现的。</li></ul><p><strong>I/O复用</strong></p><p><a href="https://www.cnblogs.com/edwardliu2000/p/15047886.html">https://www.cnblogs.com/edwardliu2000/p/15047886.html</a></p><p>C/S模型非常适合资源相对集中的场合，并且它的实现也很简单，但其缺点也很明显:服务器是通信的中心，当访问量过大时，可能所有客户都将得到很慢的响应。下面讨论的P2P模型解决了这个问题。</p><h3 id="812-p2p模型"><a class="markdownIt-Anchor" href="#812-p2p模型"></a> 8.1.2 P2P模型</h3><p>P2P(Peer to Peer，点对点)模型比C/S模型更符合网络通信的实际情况。它摒弃了以服务器为中心的格局，让网络上所有主机重新回归对等的地位。P2P模型如图8-3a所示。</p><p>P2P模型使得每台机器在消耗服务的同时也给别人提供服务，这样资源能够充分、自由地共享。云计算机群可以看作P2P模型的一个典 范。但P2P模型的<strong>缺点</strong>也很明显:<u>当用户之间传输的请求过多时，网络的负载将加重</u>。</p><p>图8-3a所示的P2P模型存在一个显著的<strong>问题</strong>，即<u>主机之间很难互相发现</u>。所以实际使用的P2P模型通常带有一个专门的发现服务器，如图 8-3b所示。这个发现服务器通常还提供<strong>查找服务</strong>(甚至还可以提供内容服务)，使每个客户都能尽快地找到自己需要的资源。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221752179.png" alt="截屏2022-05-22 下午5.51.56" /></p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221752817.png" alt="截屏2022-05-22 下午5.52.52" /></p><p>从编程角度来讲，P2P模型可以看作C/S模型的扩展:每台主机既是客户端，又是服务器。因此，我们仍然采用C/S模型来讨论网络编程。</p><h2 id="82-服务器编程框架"><a class="markdownIt-Anchor" href="#82-服务器编程框架"></a> 8.2 服务器编程框架</h2><p>虽然服务器程序种类繁多，但其基本框架都一样，不同之处在于逻辑处理。为了让读者能从设计的角度把握服务器编程，本章先讨论基本框架，如图8-4所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221754982.png" alt="截屏2022-05-22 下午5.54.21" /></p><p>该图既能用来描述一台服务器，也能用来描述一个服务器机群。 两种情况下各个部件的含义和功能如表8-1所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221757761.png" alt="截屏2022-05-22 下午5.57.09" /></p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221759451.png" alt="截屏2022-05-22 下午5.59.29" /></p><p><strong>I/O处理单元</strong>是<u>服务器管理客户连接</u>的模块。</p><p>它通常要完成以下工作:等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端。但是，数据的收发不一定在I/O处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式(见后文)。对于一个服务器机群来说，I/O处理单元是一个专门的接入服务器。它实现<strong>负载均衡</strong>，从<u>所有逻辑服务器中选取负荷最小的一台来为新客户服务</u>。</p><p><strong>一个逻辑单元</strong>通常是<strong>一个进程或线程</strong>。</p><p>它分析并处理客户数据，然后将结果传递给I/O处理单元或者直接发送给客户端(具体使用哪种方式取决于事件处理模式)。对服务器机群而言，一个逻辑单元本身就是一台逻辑服务器。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并行处理。</p><p><strong>网络存储单元</strong></p><p>可以是数据库、缓存和文件，甚至是一台独立的服务器。但它不是必须的，比如ssh、telnet等登录服务就不需要这个单元。</p><p><strong>请求队列</strong>是各单元之间的通信方式的抽象。</p><p>I/O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。请求队列通常被实现为池的一部分，我们将在后面讨论池的概念。对于服务器机群而言，请求队列是各台服务器之间预先<strong>建立的、静态的、永久的</strong>TCP连接。这种TCP连接能提高服务器之间交换数据的效率，因为它避免了动态建立TCP连接导致的额外的系统开销。</p><h2 id="83-io模型"><a class="markdownIt-Anchor" href="#83-io模型"></a> 8.3 I/O模型</h2><p>第5章讲到，socket在创建的时候<u>默认是阻塞</u>的。我们可以给socket系统调用的第2个参数传递SOCK_NONBLOCK标志，或者通过fcntl系 统调用的F_SETFL命令，将其<u>设置为非阻塞</u>的。<strong>阻塞和非阻塞的概念能应用于所有文件描述符</strong>，而不仅仅是socket。我们称<strong>阻塞的文件描述符为阻塞I/O</strong>，称<strong>非阻塞的文件描述符为非阻塞I/O</strong>。</p><p>针对阻塞I/O执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。比如，客户端通过connect向服务器发起连接时，connect将首先发送同步报文段给服务器，然后等待服务器返回确认报文段。如果服务器的确认报文段没有立即到达客户端， 则connect调用将被挂起，直到客户端收到确认报文段并唤醒connect调用。socket的基础API中，可能被阻塞的系统调用包括accept、send、 recv和connect。</p><p>针对非阻塞I/O执行的系统调用则总是<strong>立即返回</strong>，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用就返回-1，和出错的 情况一样。此时我们必须根据<u>errno来区分这两种</u>情况。对accept、send和recv而言，事件未发生时errno通常被设置成EAGAIN(意为“再来一次”)或者EWOULDBLOCK(意为“期望阻塞”);对connect而言， errno则被设置成EINPROGRESS(意为“在处理中”)。</p><p>很显然，我们只有在事件已经发生的情况下操作非阻塞I/O(读、 写等)，才能提高程序的效率。因此，非阻塞I/O通常要和其他I/O通知机制一起使用，比如I/O复用和SIGIO信号。</p><p><strong>I/O复用</strong>是最常使用的<strong>I/O通知</strong>机制。它指的是，<u>应用程序通过I/O复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序</u>。Linux上常用的I/O复用函数是select、poll和epoll_wait，我们将在第9章详细讨论它们。需要指出的是，I/O复用函数本身是阻塞的，它们能<strong>提高程序效率</strong>的原因在于它们具有<strong>同时监听多个I/O事件</strong>的能力。</p><p><strong>SIGIO信号</strong>也可以用来报告I/O事件。6.8节的最后一段提到，我们可以为一个目标文件描述符指定宿主进程，那么被指定的宿主进程将捕获到SIGIO信号。这样，当目标文件描述符上有事件发生时，SIGIO信号的信号处理函数将被触发，我们也就可以在该信号处理函数中对 目标文件描述符执行非阻塞I/O操作了。关于信号的使用，我们将在第10章讨论。</p><p>从理论上说，阻塞I/O、I/O复用和信号驱动I/O都是<strong>同步I/O模型</strong>。 因为在这三种I/O模型中，I/O的读写操作，都是在I/O事件发生之后， 由应用程序来完成的。而POSIX规范所定义的异步I/O模型则不同。对异步I/O而言，用户可以直接对I/O执行读写操作，这些操作告诉内核用 户读写缓冲区的位置，以及I/O操作完成之后内核通知应用程序的方式。异步I/O的读写操作总是立即返回，而不论I/O是否是阻塞的，因为 真正的读写操作已经由内核接管。也就是说，同步I/O模型要求用户代码自行<strong>执行I/O操作(将数据从内核缓冲区读入用户缓冲区，或将数据 从用户缓冲区写入内核缓冲区)</strong>，而异步I/O机制则由<strong>内核来执行I/O操作(数据在内核缓冲区和用户缓冲区之间的移动是由内核在“后台”完 成的</strong>)。你可以这样认为，<strong>同步I/O向应用程序通知的是<u>I/O就绪事件</u>， 而异步I/O向应用程序通知的是<u>I/O完成事件</u></strong>【这句话太重要了】。Linux环境下，aio.h头文件中定义的函数提供了对异步I/O的支持。不过这部分内容不是本书的重点，所以只做简单的讨论。</p><p>作为总结，我们将上面讨论的几种I/O模型的差异列于表8-2中。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221839581.png" alt="截屏2022-05-22 下午6.39.29" /></p><h2 id="84-两种高效的事件处理模式"><a class="markdownIt-Anchor" href="#84-两种高效的事件处理模式"></a> 8.4 两种高效的事件处理模式</h2><p>服务器程序通常需要处理三类事件:I/O事件、信号及定时事件。 我们将在后续章节依次讨论这三种类型的事件，这一节先从整体上介绍一下两种高效的事件处理模式:Reactor和Proactor。</p><p>随着网络设计模式的兴起，Reactor和Proactor事件处理模式应运而生。同步I/O模型通常用于实现Reactor模式，异步I/O模型则用于实现 Proactor模式。不过后面我们将看到，如何使用同步I/O方式模拟出Proactor模式。</p><h3 id="841-reactor模式"><a class="markdownIt-Anchor" href="#841-reactor模式"></a> 8.4.1 Reactor模式</h3><p>Reactor是这样一种模式，它要求主线程(<strong>I/O处理单元</strong>，下同)<strong>只负责监听</strong>文件描述上是否有事件发生，有的话就立即将该事件通知工作线程(<strong>逻辑单元</strong>，下同)。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</p><p>使用同步I/O模型(以epoll_wait为例)实现的Reactor模式的工作流程是:</p><ol><li><p>主线程往epoll内核事件表中注册socket上的<strong>读就绪</strong>事件。</p></li><li><p>主线程调用epoll_wait等待socket上有数据可读。</p></li><li><p>当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列。</p></li><li><p>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就 绪事件。</p></li><li><p>主线程调用epoll_wait等待socket可写。</p></li><li><p>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。</p></li><li><p>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。</p></li></ol><p>图8-5总结了Reactor模式的工作流程。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221901531.png" alt="截屏2022-05-22 下午7.01.16" /></p><p>图 8-5 Reactor模式</p><p>图8-5中，工作线程从请求队列中取出事件后，将根据事件的类型来决定如何处理它:对于可读事件，执行读数据和处理请求的操作; 对于可写事件，执行写数据的操作。因此，图8-5所示的Reactor模式中，没必要区分所谓的“读工作线程”和“写工作线程”。【说白了主线程用epoll 将监听到的socket放到请求队列里，等待着被处理，就比如消息队列像一个秘书，你告诉他可以处理了他去处理，你只告诉他可以做了就行】</p><h3 id="842-proactor模式"><a class="markdownIt-Anchor" href="#842-proactor模式"></a> 8.4.2 Proactor模式</h3><p>与Reactor模式不同，Proactor模式将所有I/O操作都交给主线程和内核来处理，<u>工作线程仅仅负责业务逻辑</u>。因此，Proactor模式更符合图 8-4所描述的服务器编程框架。</p><p>使用异步I/O模型(以aio_read和aio_write为例)实现的Proactor模式的工作流程是:</p><ol><li><p>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序 (这里以信号为例，详情请参考sigevent的man手册)。</p></li><li><p>主线程继续处理其他逻辑。</p></li><li><p>当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。</p></li><li><p>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注 册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序(仍然以信号为例)。</p></li><li><p>主线程继续处理其他逻辑。</p></li><li><p>当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</p></li><li><p>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221910960.png" alt="截屏2022-05-22 下午7.10.09" /></p></li></ol><p>在图8-6中，连接socket上的读写事件是通过aio_read/aio_write向内核注册的，因此内核将通过信号来向应用程序报告连接socket上的读写事件。所以，主线程中的epoll_wait调用<u>仅能用来检测监听socket上的连接请求事</u>件，而<strong>不能</strong><u>用来检测连接socket上的读写</u>事件。</p><p>csdn讲解：<a href="https://zhuanlan.zhihu.com/p/428693405">https://zhuanlan.zhihu.com/p/428693405</a></p><h3 id="843-模拟proactor模式"><a class="markdownIt-Anchor" href="#843-模拟proactor模式"></a> 8.4.3 模拟Proactor模式</h3><p>参考文献[3]提到了使用同步I/O方式模拟出Proactor模式的一种方法。其原理是:主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。</p><p>使用同步I/O模型(仍然以epoll_wait为例)模拟出的Proactor模式的工作流程如下:</p><ol><li><p>主线程往epoll内核事件表中注册socket上的<strong>读就绪</strong>事件。</p></li><li><p>主线程调用epoll_wait等待socket上有数据可读。</p></li><li><p>当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封 装成一个请求对象并插入请求队列。【这里和reactor非常不一样，这个是主线程读写工作线程是只负责逻辑；那个是工作线程负责读，主线程负责发送信号，所以区别在于他们的分工不同，所以一个epoll的结果是准备读，一个是已经读完了】</p></li><li><p>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的<strong>写就绪</strong>事件。</p></li><li><p>主线程调用epoll_wait等待socket可写。</p></li><li><p>当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。</p></li></ol><p>PS：我自己总结就是发送到消息队列的东西不一样，reactor是提交【读/写+处理】的通知，然后工作线程开始进行【读/写+处理】，而proactor是【读入的数据包】然后给消息队列请求工作线程处理而已。</p><p>图8-7总结了用同步I/O模型模拟出的Proactor模式的工作流程。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222157650.png" alt="截屏2022-05-22 下午9.57.05" /></p><h2 id="85-两种高效的并发模式"><a class="markdownIt-Anchor" href="#85-两种高效的并发模式"></a> 8.5 两种高效的并发模式</h2><p>并发编程的目的是让程序“同时”执行多个任务。如果程序是<strong>计算密集型</strong>的，并发编程并没有优势，反而由于任务的切换使效率降低。但如果程序是<strong>I/O密集型</strong>的，比如经常读写文件，访问数据库等，则情况就不同了。由于<u>I/O操作的速度远没有CPU的计算速度快</u>，所以让程序阻塞于I/O操作将浪费大量的CPU时间。如果程序有多个执行线程， 则当前被I/O操作所阻塞的执行线程可主动放弃CPU(或由操作系统来 调度)，并将执行权转移到其他线程。这样一来，CPU就可以用来做更加有意义的事情(除非所有线程都同时被I/O操作所阻塞)，而不是等待I/O操作完成，因此CPU的利用率显著提升。</p><p>从实现上来说，并发编程主要有<strong>多进程</strong>和<strong>多线程</strong>两种方式，我们将在后续章节详细讨论它们，这一节先讨论<strong>并发模式</strong>。对应于图8-4，并发模式是指<u>I/O处理单元和多个逻辑单元之间协调完成任务</u>的方法。 服务器主要有两种并发编程模式:半同步/半异步(half-sync/half-async)模式和领导者/追随者(Leader/Followers)模式。我们将依次讨论之。</p><h3 id="851-半同步半异步模式"><a class="markdownIt-Anchor" href="#851-半同步半异步模式"></a> 8.5.1 半同步/半异步模式</h3><p>首先，半同步/半异步模式中的“同步”和“异步”与前面讨论的I/O模型中的“同步”和“异步”是完全不同的概念。在I/O模型中，“同步”和“异 步”区分的是内核向应用程序通知的是何种I/O事件(是<u>就绪事件还是完成事件</u>)，以及<u>该由谁来完成I/O读写</u>(是应用程序【主线程】还是内核)。</p><p>在并发模式中，“<strong>同步</strong>”指的是<u>程序完全按照代码序列的顺序执行</u>;“<strong>异步</strong>”指的是<u>程序的执行需要由系统事件来驱动</u>。常见的系统事件包括中断、信号等。比如，图8-8a描述了同步的读操作，而图8-8b则描述了异步的读操作。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222203553.png" alt="截屏2022-05-22 下午10.03.54" /></p><p>按照同步方式运行的线程称为同步线程，按照异步方式运行的线程称为异步线程。显然，异步线程的执行效率高，实时性强，这是很多嵌入式程序采用的模型。但编写以异步方式执行的程序相对复杂，难于调试和扩展，而且<strong>不适合于大量</strong>的并发。而同步线程则相反，它虽然效率相对较低，实时性较差，但逻辑简单。因此，对于像服务器这种既要求较好的实时性，又要求能同时处理多个客户请求的应用程 序，我们就应该同时使用同步线程和异步线程来实现，即采用半同步/ 半异步模式来实现。</p><p>半同步/半异步模式中，<strong>同步线程</strong>用于处理<strong>客户逻辑</strong>，相当于图8-4中的<strong>逻辑单元</strong>;<strong>异步线程</strong>用于处理I/O事件，相当于图8-4中的I/O处理单元。<u>异步线程监听</u>到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并 处理该请求对象。具体选择哪个工作线程来为新的客户请求服务，则取决于请求队列的设计。比如最简单的轮流选取工作线程的Round Robin算法，也可以通过条件变量(见第14章)或信号量(见第14章) 来随机地选择一个工作线程。图8-9总结了半同步/半异步模式的工作流 程。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222213581.png" alt="截屏2022-05-22 下午10.13.22" /></p><p>在服务器程序中，如果结合考虑两种事件处理模式和几种I/O模型，则半同步/半异步模式就存在多种变体。其中有一种变体称为半同步/半反应堆(half-sync/half-reactive)模式，如图8-10所示。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222214153.png" alt="截屏2022-05-22 下午10.13.58" /></p><p>图8-10中，异步线程只有一个，由主线程来充当。它负责监听所有socket上的事件。如果监听socket上有可读事件发生，即有新的连接请 求到来，主线程就接受之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。【这里知识建立连接】如果连接socket上有读写事件发生，即有新的客户请求到来或有数据要发送至客户端，主线程就将该连接socket插入请求队列中。所有工作线程都睡眠在请求队列上，当有任务到来时，它们将通过竞争(比如申请互斥锁)获得任务的接管权。这种竞争机制使得只有空闲的工作线程才有机会来处理新任务，这是很合理的。</p><p>图8-10中，主线程插入请求队列中的任务是<strong>就绪的连接socket</strong>。这说明该图所示的半同步/半反应堆模式采用的事件处理模式是<strong>Reactor模式</strong>:它要求工作线程自己<u>从socket上读取客户请求和往socket写入服务器应答</u>。这就是该模式的名称中“half-reactive”的含义。实际上，半同步/半反应堆模式也可以使用模拟的Proactor事件处理模式，即由主线程来完成数据的读写。在这种情况下，主线程一般会将应用程序数据、任务类型等信息封装为一个任务对象，然后将其(或者指向该任务对象的一个指针)插入请求队列。工作线程从请求队列中取得任务对象之后，即可直接处理之，而无须执行读写操作了。我们将在第15章给出一个用半同步/半反应堆模式实现的简单Web服务器的代码。</p><p>半同步/半反应堆模式存在如下<strong>缺点</strong>:</p><ul><li><p>主线程和工作线程共享请求队列。主线程往请求队列中添加任务，或者工作线程从请求队列中取出任务，都需要对请求队列加锁保 护，从而白白耗费CPU时间。</p></li><li><p>每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而<u>工作线程较少</u>，则请求队列中将<u>堆积很多</u>任务对象，客户端的<u>响应速度将越来越慢</u>。如果通过<u>增加工作线程</u>来解决这一问题， 则工作线程的<u>切换也将耗费大量CPU时间</u>。</p></li></ul><p>图8-11描述了一种相对高效的半同步/半异步模式，它的每个工作线程都能同时处理多个客户连接。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222218451.png" alt="截屏2022-05-22 下午10.18.44" /></p><p>图8-11中，主线程只管理监听socket，连接socket由工作线程来管理。</p><ul><li>当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程。</li><li>此后该新socket上的任何I/O操作都由被选中的工作线程来处理，直到客户关闭连接。【发给你的小兄弟们】</li><li>主线程向工作线程派发socket的最简单的方式，是往它和工作线程之间的管道里写数据。</li><li>工作线程检测到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。 如果是，则把该新socket上的读写事件注册到自己的epoll内核事件表中。</li></ul><p>可见，图8-11中，每个线程(主线程和工作线程)都维持自己的事件循环，它们各自独立地监听不同的事件。因此，在这种高效的半同步/半异步模式中，每个线程都工作在异步模式，所以它并非严格意义上的半同步/半异步模式。我们将在第15章给出一个用这种高效的半同步/半异步模式实现的简单CGI服务器的代码。</p><h3 id="852-领导者追随者模式"><a class="markdownIt-Anchor" href="#852-领导者追随者模式"></a> 8.5.2 领导者/追随者模式</h3><p>领导者/追随者模式是多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。</p><p>在任意时间点，程序都<strong>仅有一个领导者线程</strong>，它<strong>负责监听I/O</strong>事件。而其他线程则都是追随者，它们<u>休眠在线程池中等待成为新的领导者</u>。</p><p>当前的领导者如果检测到I/O事件， 首先要从线程池中推<strong>选出新</strong>的领导者线程，然后<strong>处理</strong>I/O事件。此时，新的领导者等待新的I/O事件，而原来的领导者则处理I/O事件，二者实现了并发。【轮流处理，交替给权力】</p><p>领导者/追随者模式包含如下几个组件:句柄集(HandleSet)、线程集(ThreadSet)、事件处理器(EventHandler)和具体的事件处理器(ConcreteEventHandler)。它们的关系如图8-12所示[4]。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222224608.png" alt="截屏2022-05-22 下午10.24.12" /></p><h4 id="1-句柄集"><a class="markdownIt-Anchor" href="#1-句柄集"></a> 1、句柄集</h4><p>句柄(Handle)用于表示I/O资源，在Linux下通常就是一个文件描述符。句柄集管理众多句柄，它使用wait_for_event方法来监听这些句柄上的I/O事件，并将其中的就绪事件通知给领导者线程。领导者则调用绑定到Handle上的事件处理器来处理事件。领导者将Handle和事件处 理器绑定是通过调用句柄集中的<strong>register_handle方法</strong>实现的。</p><h4 id="2-线程集"><a class="markdownIt-Anchor" href="#2-线程集"></a> 2、线程集</h4><p>这个组件是所有工作线程(包括领导者线程和追随者线程)的管理者。它负责各<strong>线程之间的同步</strong>，以及<strong>新领导者线程的推选</strong>。线程集中的线程在任一时间必处于如下三种状态之一:</p><ul><li><p>Leader:线程当前处于领导者身份，负责等待句柄集上的I/O事件。</p></li><li><p>Processing:线程正在处理事件。领导者<u>检测到I/O事件之后，可以转移到</u>Processing状态来处理该事件，并调用promote_new_leader方法推选新的领导者;</p><p>也可以指定其他追随者来处理事件(Event Handoff)，此时领导者的地位不变。当处于Processing状态的线程处理完事件之后，如果当前线程集中<strong>没有领导者</strong>，则它将成为新的领导者，否则它就直接转变为追随者。</p></li><li><p>Follower:线程当前处于追随者身份，通过调用线程集的join方法等待成为新的领导者，也可能被当前的领导者指定来处理新的任务。</p></li></ul><p>图8-13显示了这三种状态之间的转换关系。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222230567.png" alt="截屏2022-05-22 下午10.30.36" /></p><p>需要注意的是，领导者线程<strong>推选新的领导者</strong>和<strong>追随者等待成为新领导者</strong>这两个操作都将修改线程集，因此线程集提供一个成员 Synchronizer来同步这两个操作，以避免竞态条件。</p><h4 id="3事件处理器和具体的事件处理器"><a class="markdownIt-Anchor" href="#3事件处理器和具体的事件处理器"></a> 3.事件处理器和具体的事件处理器</h4><p>事件处理器通常包含一个或多个回调函数handle_event。这些回调函数<strong>用于处理事件对应的业务逻辑</strong>。事件处理器在使用前需要被绑定到某个句柄上，当该句柄上有事件发生时，领导者就执行与之绑定的事件处理器中的回调函数。具体的事件处理器是事件处理器的派生类。它们必须重新实现基类的handle_event方法，以处理特定的任务。根据上面的讨论，我们将领导者/追随者模式的工作流程总结于图8-14中。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205222236451.png" alt="截屏2022-05-22 下午10.36.25" /></p><p>由于<strong>领导者线程自己监听I/O事件并处理客户请求</strong>，因而领导者/追随者模式<u>不需要在线程之间传递任何额外的数据</u>，也无须像半同步/半 反应堆模式那样在线程之间同步对请求队列的访问。但领导者/追随者的一个明显缺点是<strong>仅支持一个事件源</strong>集合，因此也无法像图8-11所示的那样，让每个工作线程独立地管理多个客户连接。</p><h2 id="86-有限状态机"><a class="markdownIt-Anchor" href="#86-有限状态机"></a> 8.6 有限状态机</h2><p>前面两节探讨的是服务器的I/O处理单元、请求队列和逻辑单元之间协调完成任务的各种模式，这一节我们介绍逻辑单元内部的一种高效编程方法:有限状态机(finite state machine)。</p><p>有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑，如代码清单8-1所示。</p><p>代码清单8-1 状态独立的有限状态机</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">代码清单<span class="hljs-number">8</span><span class="hljs-number">-1</span> 状态独立的有限状态机<br><span class="hljs-built_in">STATE_MACHINE</span>(Package_pack)&#123;<br>   PackageType_type=_pack.<span class="hljs-built_in">GetType</span>();<br>   <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(_type)<br>   &#123;<br>       <span class="hljs-keyword">case</span> type_A:<br>       <span class="hljs-built_in">process_package_A</span>(_pack);<br>       <span class="hljs-keyword">break</span>;<br>       <span class="hljs-keyword">case</span> type_B:<br>       <span class="hljs-built_in">process_package_B</span>(_pack);<br>       <span class="hljs-keyword">break</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是一个简单的有限状态机，只不过该状态机的每个状态都是<strong>相互独立</strong>的，即状态之间没有相互转移。状态之间的转移是需要状态机内部驱动的，如代码清单8-2所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">STATE_MACHINE</span>()<br></code></pre></td></tr></table></figure><p>代码清单8-2 带状态转移的有限状态机</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br>&#123;<br>    State cur_State=type_A;<br>    <span class="hljs-keyword">while</span>(cur_State!=type_C)<br>    &#123;<br>        Package_pack=<span class="hljs-built_in">getNewPackage</span>();<br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(cur_State)<br>        &#123;<br>            <span class="hljs-keyword">case</span> type_A:<br>            <span class="hljs-built_in">process_package_state_A</span>(_pack);<br>            cur_State=type_B;<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> type_B:<br>            <span class="hljs-built_in">process_package_state_B</span>(_pack);<br>            cur_State=type_C;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该状态机包含三种状态:type_A、type_B和type_C，其中type_A是状态机的<strong>开始状态</strong>，type_C是状态机的<strong>结束状态</strong>。状态机的当前状态记录在cur_State变量中。在一趟循环过程中，状态机先通过getNewPackage方法<u>获得一个新的数据包</u>，然后根据cur_State变量的值判断如何处理该数据包。数据包处理完之后，状态机通过给cur_State变量传递目标状态值来实现状态转移。那么当状态机进入下一趟循环时，它将执行新的状态对应的逻辑。</p><p>下面我们考虑有限状态机应用的一个实例:HTTP请求的读取和分析。很多网络协议，包括TCP协议和IP协议，都在其头部中提供头部长度字段。程序根据该字段的值就可以知道是否接收到一个完整的协议头部。但HTTP协议并未提供这样的头部长度字段，并且其头部长度变 化也很大，可以只有十几字节，也可以有上百字节。根据协议规定， 我们判断HTTP头部<strong>结束的依据是遇到一个空行</strong>，该空行仅包含一对回车换行符(<CR><LF>)。如果一次读操作没有读入HTTP请求的整个头部，<u>即没有遇到空行</u>，那么我们必须等待客户继续写数据并再次读入。因此，我们每完成一次读操作，就要分析新读入的数据中是否有空行。不过在寻找空行的过程中，我们可以同时完成对整个HTTP请求头部的分析(记住，空行前面还有请求行和头部域)，以提高解析HTTP请求的效率。代码清单8-3使用主、从两个有限状态机实现了最简单的HTTP请求的读取和分析。为了使表述简洁，我们约定，直接称HTTP请求的一行(包括请求行和头部字段)为行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BUFFER_SIZE 4096 <span class="hljs-comment">/*读缓冲区大小*/</span></span><br><span class="hljs-comment">/*主状态机的两种可能状态，分别表示:当前正在分析请求行，当前正在分析头部字段 */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">CHECK_STATE</span> &#123;</span> CHECK_STATE_REQUESTLINE = <span class="hljs-number">0</span>, CHECK_STATE_HEADER, CHECK_STATE_CONTENT &#125;;<br><span class="hljs-comment">/*从状态机的三种可能状态，即行的读取状态，分别表示:读取到一个完整的行、行出错和行数据尚且不完整*/</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">LINE_STATUS</span> &#123;</span> LINE_OK = <span class="hljs-number">0</span>, LINE_BAD, LINE_OPEN &#125;;<br><span class="hljs-comment">/*服务器处理HTTP请求的结果:NO_REQUEST表示请求不完整，需要继续读取客户数据;GET_REQUEST表示获得了一个完整的客户请求;BAD_REQUEST表示客户请求有语法错误;FORBIDDEN_REQUEST表示客户对资源没有足够的访问权限;INTERNAL_ERROR表示服务器内部错误;CLOSED_CONNECTION表示客户端已经关闭连接了*/</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">HTTP_CODE</span> &#123;</span> NO_REQUEST, GET_REQUEST, BAD_REQUEST, FORBIDDEN_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION &#125;;<br><span class="hljs-comment">/*为了简化问题，我们没有给客户端发送一个完整的HTTP应答报文，而只是根据服务器的处理结果发送如下成功或失败信息*/</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* szret[] = &#123; <span class="hljs-string">&quot;I get a correct result\n&quot;</span>, <span class="hljs-string">&quot;Something wrong\n&quot;</span> &#125;;<br><span class="hljs-comment">/*从状态机，用于解析出一行内容*/</span><br><span class="hljs-function">LINE_STATUS <span class="hljs-title">parse_line</span><span class="hljs-params">( <span class="hljs-keyword">char</span>* buffer, <span class="hljs-keyword">int</span>&amp; checked_index, <span class="hljs-keyword">int</span>&amp; read_index )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> temp;<br>  <span class="hljs-comment">/*checked_index指向buffer(应用程序的读缓冲区)中当前正在分析的字节，read_index指向buffer中客户数据的尾部的下一字节。buffer中第0~checked_index字节都已分析完毕，第checked_index~(read_index-1)字节由下面的循环挨个分析*/</span><br>    <span class="hljs-keyword">for</span> ( ; checked_index &lt; read_index; ++checked_index )<br>    &#123;<br>      <span class="hljs-comment">/*获得当前要分析的字节*/</span><br>        temp = buffer[ checked_index ];<br>        <span class="hljs-comment">/*如果当前的字节是“\r”，即回车符，则说明可能读取到一个完整的行*/</span><br>        <span class="hljs-keyword">if</span> ( temp == <span class="hljs-string">&#x27;\r&#x27;</span> )<br>        &#123;<br>            <span class="hljs-comment">/*如果“\r”字符碰巧是目前buffer中的最后一个已经被读入的客户数据【但不代表tcp的结尾】，那么这次分析没有读取到一个完整的行，返回LINE_OPEN以表示还需要继续读取客户数据才能进一步分析*/</span><br>            <span class="hljs-keyword">if</span> ( ( checked_index + <span class="hljs-number">1</span> ) == read_index )<br>            &#123;<br>                <span class="hljs-keyword">return</span> LINE_OPEN;<br>            &#125;<br>            <span class="hljs-comment">/*如果下一个字符是“\n”，则说明我们成功读取到一个完整的行*/</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( buffer[ checked_index + <span class="hljs-number">1</span> ] == <span class="hljs-string">&#x27;\n&#x27;</span> )<br>            &#123;<br>                buffer[ checked_index++ ] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                buffer[ checked_index++ ] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                <span class="hljs-keyword">return</span> LINE_OK;<br>            &#125;<br>            <span class="hljs-comment">/*否则的话，说明客户发送的HTTP请求存在语法问题*/</span><br>            <span class="hljs-keyword">return</span> LINE_BAD;<br>        &#125;<br>        <span class="hljs-comment">/*如果当前的字节是“\n”，即换行符，则也说明可能读取到一个完整的行*/</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( temp == <span class="hljs-string">&#x27;\n&#x27;</span> )<br>        &#123;   <br>            <span class="hljs-keyword">if</span>( ( checked_index &gt; <span class="hljs-number">1</span> ) &amp;&amp;  buffer[ checked_index - <span class="hljs-number">1</span> ] == <span class="hljs-string">&#x27;\r&#x27;</span> )<br>            &#123;<br>                buffer[ checked_index<span class="hljs-number">-1</span> ] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">// 去掉\r </span><br>                buffer[ checked_index++ ] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                <span class="hljs-keyword">return</span> LINE_OK; <span class="hljs-comment">//说明是对滴</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> LINE_BAD;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*如果所有内容都分析完毕也没遇到“\r”字符【说明连一行都不是】，则返回LINE_OPEN，表示还需要继续读取客户数据才能进一步分析*/</span><br>    <span class="hljs-keyword">return</span> LINE_OPEN;<br>&#125;<br><span class="hljs-comment">/*分析请求行*/</span><br><span class="hljs-function">HTTP_CODE <span class="hljs-title">parse_requestline</span><span class="hljs-params">( <span class="hljs-keyword">char</span>* szTemp, CHECK_STATE&amp; checkstate )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span>* szURL = <span class="hljs-built_in">strpbrk</span>( szTemp, <span class="hljs-string">&quot; \t&quot;</span> );<br>    <span class="hljs-comment">/*如果请求行中没有空白字符或“\t”字符，则HTTP请求必有问题*/</span><br>    <span class="hljs-keyword">if</span> ( ! szURL )<br>    &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br>    *szURL++ = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    <span class="hljs-keyword">char</span>* szMethod = szTemp;<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strcasecmp</span>( szMethod, <span class="hljs-string">&quot;GET&quot;</span> ) == <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;The request method is GET\n&quot;</span> );<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br>    <br>    szURL += <span class="hljs-built_in">strspn</span>( szURL, <span class="hljs-string">&quot; \t&quot;</span> );<br>    <span class="hljs-keyword">char</span>* szVersion = <span class="hljs-built_in">strpbrk</span>( szURL, <span class="hljs-string">&quot; \t&quot;</span> );<br>   <br>    <span class="hljs-keyword">if</span> ( ! szVersion )<br>    &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br>    *szVersion++ = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    szVersion += <span class="hljs-built_in">strspn</span>( szVersion, <span class="hljs-string">&quot; \t&quot;</span> );<br>    <span class="hljs-comment">/*仅支持HTTP/1.1*/</span><br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strcasecmp</span>( szVersion, <span class="hljs-string">&quot;HTTP/1.1&quot;</span> ) != <span class="hljs-number">0</span> )<br>    &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br>    <span class="hljs-comment">/*检查URL是否合法*/</span><br>    <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strncasecmp</span>( szURL, <span class="hljs-string">&quot;http://&quot;</span>, <span class="hljs-number">7</span> ) == <span class="hljs-number">0</span> )<br>    &#123;<br>        szURL += <span class="hljs-number">7</span>;<br>        szURL = <span class="hljs-built_in">strchr</span>( szURL, <span class="hljs-string">&#x27;/&#x27;</span> );<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> ( ! szURL || szURL[ <span class="hljs-number">0</span> ] != <span class="hljs-string">&#x27;/&#x27;</span> )<br>    &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br><br>    <span class="hljs-comment">//URLDecode( szURL );</span><br>    <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;The request URL is: %s\n&quot;</span>, szURL );<br>    <span class="hljs-comment">/*HTTP请求行处理完毕，状态转移到头部字段的分析 就是通过状态字转换功能*/</span><br>    checkstate = CHECK_STATE_HEADER;<br>    <span class="hljs-keyword">return</span> NO_REQUEST;<br>&#125;<br><span class="hljs-comment">/*分析头部字段*/</span><br><span class="hljs-function">HTTP_CODE <span class="hljs-title">parse_headers</span><span class="hljs-params">( <span class="hljs-keyword">char</span>* szTemp )</span></span><br><span class="hljs-function"></span>&#123;   <br>    <span class="hljs-comment">/*遇到一个空行，说明我们得到了一个正确的HTTP请求*/</span><br>    <span class="hljs-keyword">if</span> ( szTemp[ <span class="hljs-number">0</span> ] == <span class="hljs-string">&#x27;\0&#x27;</span> )<br>    &#123;<br>        <span class="hljs-keyword">return</span> GET_REQUEST;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strncasecmp</span>( szTemp, <span class="hljs-string">&quot;Host:&quot;</span>, <span class="hljs-number">5</span> ) == <span class="hljs-number">0</span> )  <span class="hljs-comment">/*处理“HOST”头部字段*/</span><br>    &#123;<br>        szTemp += <span class="hljs-number">5</span>;<br>        szTemp += <span class="hljs-built_in">strspn</span>( szTemp, <span class="hljs-string">&quot; \t&quot;</span> );<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;the request host is: %s\n&quot;</span>, szTemp );<br>    &#125;<br>    <span class="hljs-keyword">else</span>  <span class="hljs-comment">/*其他头部字段都不处理*/</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;I can not handle this header\n&quot;</span> );<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> NO_REQUEST;<br>&#125;<br><span class="hljs-comment">/*分析HTTP请求的入口函数*/</span><br><span class="hljs-function">HTTP_CODE <span class="hljs-title">parse_content</span><span class="hljs-params">( <span class="hljs-keyword">char</span>* buffer, <span class="hljs-keyword">int</span>&amp; checked_index, CHECK_STATE&amp; checkstate, <span class="hljs-keyword">int</span>&amp; read_index, <span class="hljs-keyword">int</span>&amp; start_line )</span></span><br><span class="hljs-function"></span>&#123;<br>    LINE_STATUS linestatus = LINE_OK; <span class="hljs-comment">/*记录当前行的读取状态*/</span><br>    HTTP_CODE retcode = NO_REQUEST;  <span class="hljs-comment">/*记录HTTP请求的处理结果*/</span><br>    <span class="hljs-comment">/*主状态机，用于从buffer中取出所有完整的行*/</span><br>    <span class="hljs-keyword">while</span>( ( linestatus = <span class="hljs-built_in">parse_line</span>( buffer, checked_index, read_index ) ) == LINE_OK ) <br>    &#123;<br>        <span class="hljs-keyword">char</span>* szTemp = buffer + start_line;  <span class="hljs-comment">/*start_line是行在buffer中的起始位置*/</span><br>        start_line = checked_index;  <span class="hljs-comment">/*记录下一行的起始位置*/</span><br>        <span class="hljs-comment">/*checkstate记录主状态机当前的状态*/</span><br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> ( checkstate )<br>        &#123;<br>            <span class="hljs-keyword">case</span> CHECK_STATE_REQUESTLINE: <span class="hljs-comment">/*第一个状态，分析请求行*/</span><br>            &#123;<br>                retcode = <span class="hljs-built_in">parse_requestline</span>( szTemp, checkstate );<br>                <span class="hljs-keyword">if</span> ( retcode == BAD_REQUEST )<br>                &#123;<br>                    <span class="hljs-keyword">return</span> BAD_REQUEST;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> CHECK_STATE_HEADER:   <span class="hljs-comment">/*第二个状态，分析头部字段*/</span><br>            &#123;<br>                retcode = <span class="hljs-built_in">parse_headers</span>( szTemp );<br>                <span class="hljs-keyword">if</span> ( retcode == BAD_REQUEST )<br>                &#123;<br>                    <span class="hljs-keyword">return</span> BAD_REQUEST;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( retcode == GET_REQUEST )<br>                &#123;<br>                    <span class="hljs-keyword">return</span> GET_REQUEST;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">default</span>:<br>            &#123;<br>                <span class="hljs-keyword">return</span> INTERNAL_ERROR;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*若没有读取到一个完整的行，则表示还需要继续读取客户数据才能进一步分析*/</span><br>    <span class="hljs-keyword">if</span>( linestatus == LINE_OPEN )<br>    &#123;<br>        <span class="hljs-keyword">return</span> NO_REQUEST;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[] )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>( argc &lt;= <span class="hljs-number">2</span> )<br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>( argv[<span class="hljs-number">0</span>] ) );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 读取需要监听的ip 和 端口</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">int</span> port = <span class="hljs-built_in">atoi</span>( argv[<span class="hljs-number">2</span>] );<br>    <span class="hljs-comment">// 创建ipv4 的socket</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">address</span>;</span><br>    <span class="hljs-built_in">bzero</span>( &amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );<br>    address.sin_port = <span class="hljs-built_in">htons</span>( port );<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-keyword">int</span> listenfd = <span class="hljs-built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );<br>    <span class="hljs-built_in">assert</span>( listenfd &gt;= <span class="hljs-number">0</span> );<br>    <span class="hljs-comment">// 命名socket</span><br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-built_in">bind</span>( listenfd, ( struct sockaddr* )&amp;address, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( address ) );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 开始监听</span><br>    ret = <span class="hljs-built_in">listen</span>( listenfd, <span class="hljs-number">5</span> );<br>    <span class="hljs-built_in">assert</span>( ret != <span class="hljs-number">-1</span> );<br>    <span class="hljs-comment">// 创建ipv4 socket套接字 用于获取远端的ip</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_address</span>;</span><br>    <span class="hljs-keyword">socklen_t</span> client_addrlength = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>( client_address );<br>    <span class="hljs-keyword">int</span> fd = <span class="hljs-built_in">accept</span>( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );<br>    <span class="hljs-keyword">if</span>( fd &lt; <span class="hljs-number">0</span> ) <span class="hljs-comment">// 如果没有接收到</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;errno is: %d\n&quot;</span>, errno );<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 接收套接字</span><br>    &#123;<br>        <span class="hljs-keyword">char</span> buffer[ BUFFER_SIZE ]; <span class="hljs-comment">/*读缓冲区*/</span><br>        <span class="hljs-built_in">memset</span>( buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE );<br>        <span class="hljs-keyword">int</span> data_read = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> read_index = <span class="hljs-number">0</span>; <span class="hljs-comment">/*当前已经读取了多少字节的客户数据*/</span><br>        <span class="hljs-keyword">int</span> checked_index = <span class="hljs-number">0</span>; <span class="hljs-comment">/*当前已经分析完了多少字节的客户数据*/</span><br>        <span class="hljs-keyword">int</span> start_line = <span class="hljs-number">0</span>; <span class="hljs-comment">/*行在buffer中的起始位置*/</span><br>        <span class="hljs-comment">/*设置主状态机的初始状态*/</span><br>        CHECK_STATE checkstate = CHECK_STATE_REQUESTLINE;<br>        <span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> ) <span class="hljs-comment">/*循环读取客户数据并分析之*/</span><br>        &#123;<br>            data_read = <span class="hljs-built_in">recv</span>( fd, buffer + read_index, BUFFER_SIZE - read_index, <span class="hljs-number">0</span> ); <span class="hljs-comment">//通过连接socket获取信息</span><br>            <span class="hljs-keyword">if</span> ( data_read == <span class="hljs-number">-1</span> )<br>            &#123;<br>                <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;reading failed\n&quot;</span> );<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( data_read == <span class="hljs-number">0</span> )<br>            &#123;<br>                <span class="hljs-built_in">printf</span>( <span class="hljs-string">&quot;remote client has closed the connection\n&quot;</span> );<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>    <br>            read_index += data_read;<br>            <span class="hljs-comment">/*分析目前已经获得的所有客户数据*/</span><br>            HTTP_CODE result = <span class="hljs-built_in">parse_content</span>( buffer, checked_index, checkstate, read_index, start_line );<br>            <span class="hljs-comment">// 判断状态</span><br>            <span class="hljs-keyword">if</span>( result == NO_REQUEST )<br>            &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( result == GET_REQUEST )<br>            &#123;<br>                <span class="hljs-built_in">send</span>( fd, szret[<span class="hljs-number">0</span>], <span class="hljs-built_in">strlen</span>( szret[<span class="hljs-number">0</span>] ), <span class="hljs-number">0</span> );<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">send</span>( fd, szret[<span class="hljs-number">1</span>], <span class="hljs-built_in">strlen</span>( szret[<span class="hljs-number">1</span>] ), <span class="hljs-number">0</span> );<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">close</span>( fd );<br>    &#125;<br>    <br>    <span class="hljs-built_in">close</span>( listenfd );<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们将代码清单8-3中的两个有限状态机分别称为主状态机和从状态机，这体现了它们之间的关系:主状态机在内部调用从状态机。下面先分析从状态机，即parse_line函数，它从buffer中解析出一个行。图 8-15描述了其可能的状态及状态转移过程。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CodeTop</title>
    <link href="/2022/03/15/codeTop/"/>
    <url>/2022/03/15/codeTop/</url>
    
    <content type="html"><![CDATA[<h1 id="codetop做题总结"><a class="markdownIt-Anchor" href="#codetop做题总结"></a> CodeTop做题总结🔥</h1><p>按照微软题库的频率顺序进行练习</p><h2 id="day1"><a class="markdownIt-Anchor" href="#day1"></a> Day1</h2><h3 id="206-反转链表"><a class="markdownIt-Anchor" href="#206-反转链表"></a> 206、反转链表</h3><p><strong>递归法</strong> 时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        ListNode* nextNode = head-&gt;next;<br>        ListNode* newHead = <span class="hljs-built_in">reverseList</span>(nextNode);<br>        nextNode-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>头插法</strong> 时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* newHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            ListNode* nextNode = head-&gt;next;<br>            head-&gt;next = newHead-&gt;next;<br>            newHead-&gt;next = head;<br>            head = nextNode;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="146-lru缓存机制"><a class="markdownIt-Anchor" href="#146-lru缓存机制"></a> 146、LRU缓存机制</h3><p>这道题让我们实现一个 LRU 缓存器，LRU 是 Least Recently Used 的简写，就是最近最少使用的意思。那么这个缓存器主要有两个成员函数，get 和 put，其中 get 函数是通过输入 key 来获得 value，如果成功获得后，这对 (key, value) 升至缓存器中最常用的位置（顶部），如果 key 不存在，则返回 -1。而 put 函数是插入一对新的 (key, value)，如果原缓存器中有该 key，则需要先删除掉原有的，将新的插入到缓存器的顶部。如果不存在，则直接插入到顶部。若加入新的值后缓存器超过了容量，则需要删掉一个最不常用的值，也就是底部的值。具体实现时我们需要三个私有变量，cap, l和m，其中 cap 是缓存器的容量大小，l是保存缓存器内容的列表，m是 HashMap，保存关键值 key 和缓存器各项的迭代器之间映射，方便我们以 O(1) 的时间内找到目标项。</p><p>然后我们再来看 get 和 put 如何实现，get 相对简单些，我们在 HashMap 中查找给定的 key，若不存在直接返回 -1。如果存在则将此项移到顶部，这里我们使用 C++ STL 中的函数 splice，专门移动链表中的一个或若干个结点到某个特定的位置，这里我们就只移动 key 对应的迭代器到列表的开头，然后返回 value。这里再解释一下为啥 HashMap 不用更新，因为 HashMap 的建立的是关键值 key 和缓存列表中的迭代器之间的映射，get 函数是查询函数，如果关键值 key 不在 HashMap，那么不需要更新。如果在，我们需要更新的是该 key-value 键值对儿对在缓存列表中的位置，而 HashMap 中还是这个 key 跟键值对儿的迭代器之间的映射，并不需要更新什么。</p><p>对于 put，我们也是现在 HashMap 中查找给定的 key，如果存在就删掉原有项，并在顶部插入新来项，然后判断是否溢出，若溢出则删掉底部项(最不常用项)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLinkedNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> key, value;<br>    DLinkedNode* next;<br>    DLinkedNode* prev;<br>    <span class="hljs-built_in">DLinkedNode</span>(): <span class="hljs-built_in">key</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    <span class="hljs-built_in">DLinkedNode</span>(<span class="hljs-keyword">int</span> _key, <span class="hljs-keyword">int</span> _value): <span class="hljs-built_in">key</span>(_key), <span class="hljs-built_in">value</span>(_value), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125; <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, DLinkedNode*&gt; cache;  <span class="hljs-comment">// 用哈希表作为一个索引工具，获取双向链表上的某个节点</span><br>    DLinkedNode* head;<br>    DLinkedNode* tail;<br>    <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-keyword">int</span> capacity;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-keyword">int</span> _capacity): <span class="hljs-built_in">capacity</span>(_capacity), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>)&#123;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>();<br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-comment">//如果没有找到该节点</span><br>        <span class="hljs-keyword">if</span> (!cache.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果该节点存在 需要将该节点移动到第一位</span><br>            DLinkedNode* node = cache[key];<br>            <span class="hljs-built_in">moveToHead</span>(node);<br>            <span class="hljs-keyword">return</span> node-&gt;value;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-comment">//如果没有找到该节点</span><br>        <span class="hljs-keyword">if</span> (!cache.<span class="hljs-built_in">count</span>(key)) &#123;<br>            DLinkedNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>(key, value);<br>            <span class="hljs-built_in">addToHead</span>(node);<br>            cache[key] = node; <span class="hljs-comment">// 更新cache</span><br>            size++;<br>            <span class="hljs-keyword">if</span> (size &gt; capacity) &#123;   <br>                DLinkedNode* removed = <span class="hljs-built_in">removeTail</span>();<br>                cache.<span class="hljs-built_in">erase</span>(removed-&gt;key); <span class="hljs-comment">// 删除被挤出的key</span><br>                <span class="hljs-keyword">delete</span> removed;<br>                size--;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            DLinkedNode* node = cache[key];<br>            node-&gt;value = value;<br>            <span class="hljs-built_in">moveToHead</span>(node); <span class="hljs-comment">// 因为最新处理过所以放在第一个</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 链表函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addToHead</span><span class="hljs-params">(DLinkedNode* node)</span></span>&#123;<br>        node-&gt;next = head-&gt;next;<br>        head-&gt;next-&gt;prev = node;<br>        node-&gt;prev = head;<br>        head-&gt;next = node;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(DLinkedNode* node)</span></span>&#123;<br>        node-&gt;prev-&gt;next = node-&gt;next;<br>        node-&gt;next-&gt;prev = node-&gt;prev;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(DLinkedNode* node)</span></span>&#123;<br>        <span class="hljs-built_in">removeNode</span>(node);<br>        <span class="hljs-built_in">addToHead</span>(node);<br>    &#125;<br>    <br>    <span class="hljs-function">DLinkedNode* <span class="hljs-title">removeTail</span><span class="hljs-params">()</span></span>&#123;<br>        DLinkedNode* node = tail-&gt;prev;<br>        <span class="hljs-built_in">removeNode</span>(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="3-无重复字符的最长子串"><a class="markdownIt-Anchor" href="#3-无重复字符的最长子串"></a> 3、无重复字符的最长子串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; map = vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">256</span>);<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (r &lt; s.<span class="hljs-built_in">size</span>()) &#123;<br>            map[s[r]]++;<br>            <span class="hljs-keyword">while</span> (map[s[r]] &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果发现当前这个字母出现过 那就缩小滑动窗口直到没有出现重复的</span><br>                map[s[l++]]--; <span class="hljs-comment">// 清除左边界的状态</span><br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, r - l + <span class="hljs-number">1</span>);<br>            r++; <span class="hljs-comment">// 一轮正常之后再进行下一轮</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="215-数组中的第k个最大元素"><a class="markdownIt-Anchor" href="#215-数组中的第k个最大元素"></a> 215、数组中的第K个最大元素</h3><p>用优先队列（小顶堆实现， 大顶堆反过来就行）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; minHeap;  <span class="hljs-comment">// 这道题的思路就是组合滑动窗口 为了让滑动窗口中小的数先出局</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            minHeap.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">if</span>(minHeap.<span class="hljs-built_in">size</span>() &gt; k)&#123;<br>                minHeap.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minHeap.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以用<strong>快速排序</strong>实现一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>() - k];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以用<strong>快速选择</strong>+<strong>二分</strong>， 最差情况就和快速排序是一个样子了。</p><p>分开写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 左闭右闭区间</span><br>        k = nums.<span class="hljs-built_in">size</span>() - k; <span class="hljs-comment">// 更新一下k</span><br>        <span class="hljs-keyword">int</span> cur = <span class="hljs-built_in">partition</span>(nums, l, h, k);<br>        <span class="hljs-keyword">while</span> (l &lt;= h)&#123;<br>            <span class="hljs-keyword">if</span> (k &gt; cur)<br>                cur = <span class="hljs-built_in">partition</span>(nums, cur + <span class="hljs-number">1</span>, h, k); <span class="hljs-comment">// 相当于在大的区域里接着找</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &lt; cur)<br>                cur = <span class="hljs-built_in">partition</span>(nums, l, cur - <span class="hljs-number">1</span>, k);<br>            <span class="hljs-keyword">else</span> <br>                <span class="hljs-keyword">return</span> nums[cur];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> l = low, h = high;<br>        <span class="hljs-keyword">int</span> pivot = nums[l];<br>        <span class="hljs-keyword">while</span> (l &lt; h) &#123;<br>            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; nums[h] &gt;= pivot) h--;<br>            <span class="hljs-keyword">if</span> (l &lt; h) nums[l] = nums[h];<br>            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; nums[l] &lt;= pivot) l++;<br>            <span class="hljs-keyword">if</span> (l &lt; h) nums[h] = nums[l];<br>        &#125;<br>        <span class="hljs-comment">//此刻一定l == h</span><br>        nums[l] = pivot;<br>        <span class="hljs-comment">//此刻l左边的数一定小于pivot l 右边的数一定大于pivot</span><br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>合在一起写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">partition</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>() - k);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> l = low, h = high;<br>        <span class="hljs-keyword">int</span> pivot = nums[l];<br>        <span class="hljs-keyword">while</span> (l &lt; h)&#123;<br>            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; nums[h] &gt;= pivot) h--;<br>            <span class="hljs-keyword">if</span> (l &lt; h) nums[l] = nums[h];<br>            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; nums[l] &lt;= pivot) l++;<br>            <span class="hljs-keyword">if</span> (l &lt; h) nums[h] = nums[l];<br>        &#125;<br>        <span class="hljs-comment">//此刻一定l == h</span><br>        nums[l] = pivot;<br>        <span class="hljs-comment">//此刻l左边的数一定小于pivot l 右边的数一定大于pivot</span><br>        <span class="hljs-keyword">if</span> (k &gt; l)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">partition</span>(nums, l + <span class="hljs-number">1</span>, high, k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k &lt; l)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">partition</span>(nums, low, h - <span class="hljs-number">1</span>, k);<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> pivot;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="236-二叉树的最近公共祖先"><a class="markdownIt-Anchor" href="#236-二叉树的最近公共祖先"></a> 236、二叉树的最近公共祖先</h3><p>递归 后序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// </span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root || root == p || root == q) <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 这里存储了当前节点为p 或者 q 或者是空 三种情况都是返回自己</span><br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">return</span> !left ? right : !right ? left : root;  <span class="hljs-comment">// 左右都找到了那就是当前是最近祖先 左边没找到 那一定在右边 右边没找到就一定在左边</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day2"><a class="markdownIt-Anchor" href="#day2"></a> Day2</h2><h3 id="1-二叉树的最大路径和"><a class="markdownIt-Anchor" href="#1-二叉树的最大路径和"></a> 1、二叉树的最大路径和</h3><p>无需要打印路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> ans = INT_MIN;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">scan</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">scan</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-comment">//当遍历到空的位置的时候返回0</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//如果左叶子和右叶子只要是有一个是负数我们就抛弃</span><br>        <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">scan</span>(root-&gt;left), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">scan</span>(root-&gt;right), <span class="hljs-number">0</span>);<br>        ans = <span class="hljs-built_in">max</span>(ans, root-&gt;val + left + right); <span class="hljs-comment">// 每一个字结构就是左根右 做记录就好</span><br>        <span class="hljs-keyword">return</span> root-&gt;val + <span class="hljs-built_in">max</span>(left, right); <span class="hljs-comment">// 因为是路径 所以只能是走一边（下一层针对上一层）</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>增加难度打印路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span> <span class="hljs-comment">// 用一个结构体去存储一个节点的值和状态</span><br>        <span class="hljs-keyword">int</span> val;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; path;<br>        <span class="hljs-built_in">Node</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>)&#123;&#125;<br>        <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">int</span> _val) : <span class="hljs-built_in">val</span>(_val)&#123;&#125;<br>        <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">int</span> _val, vector&lt;<span class="hljs-keyword">int</span>&gt; _path) : <span class="hljs-built_in">val</span>(_val), <span class="hljs-built_in">path</span>(_path)&#123;&#125;<br>    &#125;;<br>    <span class="hljs-keyword">int</span> ans = INT_MIN;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; Path;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">scan</span>(root);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p : Path)&#123;<br>            cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function">Node* <span class="hljs-title">scan</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-comment">//当遍历到空的位置的时候返回一个空状态</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(); <br>        <br>        <span class="hljs-comment">//如果左叶子和右叶子只要是有一个是负数我们就抛弃</span><br>        Node* left = <span class="hljs-built_in">scan</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span> (left-&gt;val &lt;= <span class="hljs-number">0</span>)<br>            left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        Node* right = <span class="hljs-built_in">scan</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (right-&gt;val &lt;= <span class="hljs-number">0</span>)<br>            right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; cur; <span class="hljs-comment">// 建立一下当前状态</span><br>        <span class="hljs-keyword">if</span> (ans &lt; root-&gt;val + left-&gt;val + right-&gt;val) &#123; <span class="hljs-comment">// 先不处理等于的状态</span><br>            ans = root-&gt;val + left-&gt;val + right-&gt;val; <br>            <span class="hljs-comment">// 每一个字结构就是左根右 做记录就好</span><br>            cur.<span class="hljs-built_in">insert</span>(cur.<span class="hljs-built_in">end</span>(), left-&gt;path.<span class="hljs-built_in">begin</span>(), left-&gt;path.<span class="hljs-built_in">end</span>());<br>            cur.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            cur.<span class="hljs-built_in">insert</span>(cur.<span class="hljs-built_in">end</span>(), right-&gt;path.<span class="hljs-built_in">begin</span>(), right-&gt;path.<span class="hljs-built_in">end</span>());<br>            Path = cur;  <br>        &#125;<br>        Node* re = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        <span class="hljs-keyword">if</span> (left-&gt;val &gt; right-&gt;val) &#123; <span class="hljs-comment">//如果左边大于右边</span><br>            re-&gt;val = root-&gt;val + left-&gt;val; <span class="hljs-comment">// 当前状态的值为根 + 左</span><br>            re-&gt;path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            re-&gt;path.<span class="hljs-built_in">insert</span>(re-&gt;path.<span class="hljs-built_in">end</span>(), left-&gt;path.<span class="hljs-built_in">begin</span>(), left-&gt;path.<span class="hljs-built_in">end</span>());<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            re-&gt;val = root-&gt;val + right-&gt;val; <span class="hljs-comment">// 当前状态的值为右 + 根</span><br>            re-&gt;path.<span class="hljs-built_in">insert</span>(re-&gt;path.<span class="hljs-built_in">end</span>(), right-&gt;path.<span class="hljs-built_in">begin</span>(), right-&gt;path.<span class="hljs-built_in">end</span>());<br>            re-&gt;path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> re; <span class="hljs-comment">// 返回当前状态</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-删除二叉搜索树中的节点"><a class="markdownIt-Anchor" href="#2-删除二叉搜索树中的节点"></a> 2、删除二叉搜索树中的节点</h3><p>先序遍历处理节点，后序来将处理后的节点进行收集处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <br>        <span class="hljs-comment">// 找到该节点进行处理</span><br>        <span class="hljs-keyword">if</span> (root-&gt;val == key) &#123;<br>            <span class="hljs-keyword">if</span> (!root-&gt;left) <span class="hljs-comment">// 如果当前节点没有左节点，只能从他的右边找</span><br>                <span class="hljs-keyword">return</span> root-&gt;right;<br>            <span class="hljs-keyword">if</span> (!root-&gt;right) <span class="hljs-comment">// 如果当前节点没有右节点，只能从他的左边找</span><br>                <span class="hljs-keyword">return</span> root-&gt;left;<br>            TreeNode* r = root-&gt;right; <br>            <span class="hljs-keyword">while</span> (r-&gt;left) &#123; <span class="hljs-comment">// 我们要去找右子树的最左节点</span><br>                r = r-&gt;left;<br>            &#125;<br>            <span class="hljs-comment">//找到后需要接回去</span><br>            r-&gt;left = root-&gt;left;<br>            <span class="hljs-keyword">return</span> root-&gt;right; <span class="hljs-comment">// 返回处理的开始起点</span><br>        &#125;<br>        TreeNode* l = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key); <span class="hljs-comment">// 新构造的左子树</span><br>        TreeNode* r = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key); <span class="hljs-comment">// 新构造的右子树</span><br>        <span class="hljs-comment">// 后序遍历收集一下状态</span><br>        root-&gt;left = l;<br>        root-&gt;right = r;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="53-最大子序和"><a class="markdownIt-Anchor" href="#53-最大子序和"></a> 53、最大子序和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = INT_MIN;<br>        <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            cur = cur &lt;= <span class="hljs-number">0</span> ? num: cur + num;<br>            ans = <span class="hljs-built_in">max</span>(ans, cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>记录一下最大的路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = INT_MIN;<br>        <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录起始结束位置</span><br>        <span class="hljs-keyword">int</span> dist = INT_MIN;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (cur &lt;= <span class="hljs-number">0</span>) &#123;<br>                cur = nums[i];<br>                start = i;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                cur += nums[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ans &lt; cur) &#123;<br>                end = i;<br>                ans = cur;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;[&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= end; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i != end)<br>                cout &lt;&lt; nums[i] &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>            <span class="hljs-keyword">else</span><br>                cout &lt;&lt; nums[i] &lt;&lt; <span class="hljs-string">&quot;]&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="207-课程表"><a class="markdownIt-Anchor" href="#207-课程表"></a> 207、课程表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-comment">// 这道题就是检测环</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">2001</span>;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; graph[M];<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(M); <span class="hljs-comment">// 用于整体的剪枝</span><br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; dfsvis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(M); <span class="hljs-comment">// 用于每一回合检测是否出现环</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : prerequisites) &#123;<br>            graph[p[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(p[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 转换一下图的存储</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; ++i)&#123;<br>            <span class="hljs-keyword">if</span> (!vis[i]) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(i)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123; <span class="hljs-comment">// true代表有环</span><br>        vis[v] = <span class="hljs-literal">true</span>;<br>        dfsvis[v] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> g : graph[v]) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[g]) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(g)) &#123; <span class="hljs-comment">// 如果当前这一轮检测到环</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;  <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dfsvis[g]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        dfsvis[v] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="103-二叉树的锯齿形层次遍历"><a class="markdownIt-Anchor" href="#103-二叉树的锯齿形层次遍历"></a> 103、二叉树的锯齿形层次遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; ans; <span class="hljs-comment">// 用于存储答案</span><br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 用来控制左右方向</span><br>        queue&lt;TreeNode* &gt; q; <span class="hljs-comment">// 用于层次遍历的队列</span><br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> n = q.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; curVec;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                TreeNode* cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span> (cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                curVec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (flag) &#123;<br>                <span class="hljs-built_in">reverse</span>(curVec.<span class="hljs-built_in">begin</span>(), curVec.<span class="hljs-built_in">end</span>());<br>            &#125;<br>            flag = !flag; <span class="hljs-comment">// 反转状态</span><br>            ans.<span class="hljs-built_in">push_back</span>(curVec);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day3"><a class="markdownIt-Anchor" href="#day3"></a> Day3</h2><h3 id="15-3sum"><a class="markdownIt-Anchor" href="#15-3sum"></a> 15、3Sum</h3><p>这道题就是2Sum的改进版，只需要添加一个外层的循环即可，相当于一个动态的target。注意两次去重：1）当我们获取到当前满足target的结果之后需要给left和right找到和当前的不同的，如果相同也不可能有答案 2）对于开头是相同的数列，不可能获得不同的结果我们也需要跳过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123; <span class="hljs-comment">// 加了一个遍历的双指针</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; ans;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 排序一下</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; ++i) &#123;<br>            <span class="hljs-keyword">int</span> l = i + <span class="hljs-number">1</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">1</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-keyword">int</span> cur = nums[i] + nums[l] + nums[r];<br>                <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">0</span>) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[l], nums[r]&#125;);<br>                    <span class="hljs-keyword">int</span> left = nums[l++];<br>                    <span class="hljs-keyword">int</span> right = nums[r--];<br>                    <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; left == nums[l]) l++;<br>                    <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; right == nums[r]) r--;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur &lt; <span class="hljs-number">0</span>) &#123;<br>                    l++;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    r--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="33-搜索旋转排序数组"><a class="markdownIt-Anchor" href="#33-搜索旋转排序数组"></a> 33、搜索旋转排序数组</h3><p>第一个二分法用于找到旋转排序数组的分界线就当作模版记住就好了：）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123; <span class="hljs-comment">// 使用两次二分法</span><br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (nums[<span class="hljs-number">0</span>] == target) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 左闭右闭 就当模版愣背吧</span><br>        <span class="hljs-comment">// 先确定转折的区域</span><br>        <span class="hljs-keyword">while</span> (l &lt; h) &#123; <span class="hljs-comment">// 正好就是l == h 退出</span><br>            <span class="hljs-keyword">int</span> m = l + ((h - l) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[m] &gt; nums[h]) &#123; <span class="hljs-comment">// 只要当前的数不是比他小 拿我们就得前进</span><br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 比我小了我原地踏步 这样最后停的位置一定在最小数的位置，不会越过去 如果加一个-1那就会变化</span><br>                h = m;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> pivot = l;<br>        <span class="hljs-comment">// 再用二分法确定 所有区间均为左闭右闭</span><br>        <span class="hljs-keyword">if</span> (pivot != <span class="hljs-number">0</span> &amp;&amp; nums[<span class="hljs-number">0</span>] &lt;= target &amp;&amp; target &lt;= nums[pivot - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">//如果在左区间 如果pivot等于0 就等于是没有发生旋转 正常做就行</span><br>            l = <span class="hljs-number">0</span>, h = pivot - <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 如果在右区间</span><br>            h = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (l &lt;= h) &#123;<br>            <span class="hljs-keyword">int</span> m = l + ((h - l) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[m] &gt; target) &#123;<br>                h = m - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[m] &lt; target) &#123;<br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> m;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-寻找两个正序数组的中位数"><a class="markdownIt-Anchor" href="#4-寻找两个正序数组的中位数"></a> 4、寻找两个正序数组的中位数</h3><p>合并两个数组，直接求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mo>+</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(M+N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = nums1.<span class="hljs-built_in">size</span>(), n = nums2.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">double</span>&gt; arr = vector&lt;<span class="hljs-keyword">double</span>&gt;(m + n);<br>        <span class="hljs-built_in">mergeArr</span>(arr, nums1, nums2);<br>        <span class="hljs-keyword">if</span> ((m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> arr[(m + n) / <span class="hljs-number">2</span>];<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (arr[(m + n) / <span class="hljs-number">2</span>] + arr[(m + n) / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeArr</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">double</span>&gt;&amp; arr, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">0</span>, i2 = <span class="hljs-number">0</span>, idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i1 &lt; nums1.<span class="hljs-built_in">size</span>() &amp;&amp; i2 &lt; nums2.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (nums1[i1] &lt;= nums2[i2]) &#123;<br>                arr[idx++] = nums1[i1++];<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                arr[idx++] = nums2[i2++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i1 &lt; nums1.<span class="hljs-built_in">size</span>()) &#123;<br>            arr[idx++] = nums1[i1++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i2 &lt; nums2.<span class="hljs-built_in">size</span>()) &#123;<br>            arr[idx++] = nums2[i2++];<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>利用二分法 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(n + m))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202204301401924.png" alt="截屏2022-04-30 下午2.01.25"  /><p>(m + n + 1) / 2 代表两个数组的中间位置，cut2根据cut1来变换位置。</p><p>这道题真的很妙，让两边的二分中轴进行联合移动cut1越大 cut2越小 cut1越小 cut2 越大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = nums1.<span class="hljs-built_in">size</span>(), n = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (m &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-built_in">findMedianSortedArrays</span>(nums2, nums1); <span class="hljs-comment">// 为了让nums1永远是短的那个</span><br>        <span class="hljs-keyword">bool</span> isOdd = ((m + n) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>; <span class="hljs-comment">//判断是不是奇数</span><br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = m; <span class="hljs-comment">// 只在nums1中做二分法 取一半 要不是中间数 要不就是 中间偏右一位</span><br>        <span class="hljs-keyword">int</span> cut1, cut2; <span class="hljs-comment">// cut2 随着 cut1 进行联动 代表切开两部分的两个索引 cut位于中间偏右一位</span><br>        <span class="hljs-keyword">while</span> (start &lt;= end) &#123;<br>            cut1 = (start + end) / <span class="hljs-number">2</span>;  <span class="hljs-comment">// num1的中间位置</span><br>            cut2 = (m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - cut1; <span class="hljs-comment">// 这里+1为了解决m + n 合在一起时 cut == m的情况下不会让cut2跑到第一个数组的位置 如 nums1: 1 2 nums2: 3 4 5 的情况自己推算</span><br>            <span class="hljs-keyword">int</span> nums1LeftMax = cut1 == <span class="hljs-number">0</span> ? INT_MIN : nums1[cut1 - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> nums1RightMin = cut1 == m ? INT_MAX : nums1[cut1];<br>            <span class="hljs-keyword">int</span> nums2LeftMax = cut2 == <span class="hljs-number">0</span> ? INT_MIN : nums2[cut2 - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> nums2RightMin = cut2 == n ? INT_MAX : nums2[cut2];<br>            <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">max</span>(nums1LeftMax, nums2LeftMax);<br>            <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">min</span>(nums1RightMin, nums2RightMin);<br>            <span class="hljs-keyword">if</span> (left &lt;= right) &#123;<br>                <span class="hljs-keyword">if</span> (isOdd) &#123;<br>                    <span class="hljs-keyword">return</span> left * <span class="hljs-number">1.0</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in"><span class="hljs-keyword">return</span></span> (left + right) / <span class="hljs-number">2.0</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (nums1LeftMax &gt; nums2RightMin) &#123; <span class="hljs-comment">// 需要找她左边区域</span><br>                    end = cut1 - <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums2LeftMax &gt; nums1RightMin) &#123; <span class="hljs-comment">// 需要找他右边区域</span><br>                    start = cut1 + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day4"><a class="markdownIt-Anchor" href="#day4"></a> Day4</h2><h3 id="22-括号生成"><a class="markdownIt-Anchor" href="#22-括号生成"></a> 22、括号生成</h3><p>dfs来解决</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; ans;<br>    <span class="hljs-keyword">int</span> N;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        N = n;<br>        string temp = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-built_in">dfs</span>(temp, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string temp, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123; <span class="hljs-comment">// input为左括号和右括号的个数 temp作为中间值进行记录</span><br>        <span class="hljs-keyword">if</span> (left == N &amp;&amp; right == N) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left &lt; N) <span class="hljs-comment">// 只要不大于总个数就行</span><br>            <span class="hljs-built_in">dfs</span>(temp + <span class="hljs-string">&quot;(&quot;</span>, left + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-comment">// 只有左边比右边多才可以放</span><br>            <span class="hljs-built_in">dfs</span>(temp + <span class="hljs-string">&quot;)&quot;</span>, left, right + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="151-反转字符串里的单词需要消除特别空格"><a class="markdownIt-Anchor" href="#151-反转字符串里的单词需要消除特别空格"></a> 151、反转字符串里的单词（需要消除特别空格）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 整个字符串的长度</span><br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sIdx = <span class="hljs-number">0</span>, eIdx = n - <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录一下开始第一个不是空格和最后一个不是空格的索引</span><br>        <span class="hljs-keyword">while</span>(s[sIdx] == <span class="hljs-string">&#x27; &#x27;</span>) sIdx++;<br>        <span class="hljs-keyword">while</span>(s[eIdx] == <span class="hljs-string">&#x27; &#x27;</span>) eIdx--;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = sIdx; i &lt;= eIdx; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123; <span class="hljs-comment">// 如果检测到空格</span><br>                <span class="hljs-built_in">reverse</span>(s, start, i - <span class="hljs-number">1</span>); <span class="hljs-comment">// 相当于i是空格我选择了跳过 直接处理每一个单词就好</span><br>                start = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(s, start, n - <span class="hljs-number">1</span>); <span class="hljs-comment">// 反转最后一组</span><br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<span class="hljs-comment">// 反转整体</span><br>        <span class="hljs-comment">//使用erase删除多余空格</span><br>        <span class="hljs-built_in">cleanSpace</span>(s);<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cleanSpace</span><span class="hljs-params">(string&amp; s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; s[i - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27; &#x27;</span>) &#123; <span class="hljs-comment">// 当i - 1 和 i - 2都是空格这个时候删除 也就是 “空空字母” 的模式</span><br>                s.<span class="hljs-built_in">erase</span>(i - <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>                i--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> temp;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            temp = s[l];<br>            s[l] = s[r];<br>            s[r] = temp;<br>            l++, r--;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="297-二叉树的序列化和反序列化"><a class="markdownIt-Anchor" href="#297-二叉树的序列化和反序列化"></a> 297、二叉树的序列化和反序列化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> idx; <span class="hljs-comment">//用于构造时遍历使用</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">preOrder</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (idx &gt; s.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        string cur = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (s[idx] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>            idx += <span class="hljs-number">2</span>;  <span class="hljs-comment">//跳过 “*,”</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (s[idx] != <span class="hljs-string">&#x27;,&#x27;</span>) &#123; <span class="hljs-comment">// 凑齐每一个数</span><br>            cur += s[idx++];<br>        &#125;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-built_in">atoi</span>(cur.<span class="hljs-built_in">c_str</span>()));<br>        idx++; <span class="hljs-comment">// 此时停在&#x27;,&#x27; 我们跳下一个就行</span><br>        root-&gt;left = <span class="hljs-built_in">preOrder</span>(s);<br>        root-&gt;right = <span class="hljs-built_in">preOrder</span>(s);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;*&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(root-&gt;val) + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-built_in">serialize</span>(root-&gt;left) + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-built_in">serialize</span>(root-&gt;right); <span class="hljs-comment">//使用,隔开用于解决不是个位数组成的节点值</span><br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">preOrder</span>(data);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Your Codec object will be instantiated and called as such:</span><br><span class="hljs-comment">// Codec ser, deser;</span><br><span class="hljs-comment">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span><br></code></pre></td></tr></table></figure><h2 id="day5"><a class="markdownIt-Anchor" href="#day5"></a> Day5</h2><h3 id="1-旋转图像"><a class="markdownIt-Anchor" href="#1-旋转图像"></a> 1、旋转图像</h3><p>借助了辅助空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; temp = vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(n));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                temp[i][j] = matrix[n - j - <span class="hljs-number">1</span>][i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                matrix[i][j] = temp[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        n = matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//先转置 再上下翻转</span><br>        <span class="hljs-built_in">transpose</span>(matrix);<br>        <span class="hljs-built_in">reverseCol</span>(matrix);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transpose</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;  <span class="hljs-comment">// 转置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; n; ++r) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = r + <span class="hljs-number">1</span>; c &lt; n; ++c) &#123;<br>                <span class="hljs-keyword">int</span> temp = matrix[r][c];<br>                matrix[r][c] = matrix[c][r];<br>                matrix[c][r] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseCol</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123; <span class="hljs-comment">// 左右翻转</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; n; ++r) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; n / <span class="hljs-number">2</span>; ++c) &#123;<br>                <span class="hljs-keyword">int</span> temp = matrix[r][c];<br>                matrix[r][c] = matrix[r][n - c - <span class="hljs-number">1</span>];<br>                matrix[r][n - c - <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="8-字符串转换整数atoi"><a class="markdownIt-Anchor" href="#8-字符串转换整数atoi"></a> 8、字符串转换整数（atoi）</h3><p>这道题别太在意，就是到面向用例的编程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">bool</span> neg = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 判断是否时负数</span><br>        <span class="hljs-keyword">while</span> (s[idx] == <span class="hljs-string">&#x27; &#x27;</span>) &#123; <span class="hljs-comment">// 跳过开头的空格</span><br>            idx++;<br>        &#125;<br>    <br>        <span class="hljs-keyword">if</span> (s[idx] == <span class="hljs-string">&#x27;-&#x27;</span> || s[idx] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (s[idx] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                neg = <span class="hljs-literal">true</span>;<br>            &#125;<br>            idx++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span> (s[idx] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[idx] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>            ans = ans * <span class="hljs-number">10</span> + (s[idx] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (ans &gt; INT_MAX) &#123;<br>                <span class="hljs-keyword">if</span> (neg) &#123; <span class="hljs-comment">// 溢出的话只显示最大值</span><br>                    <span class="hljs-keyword">return</span> INT_MIN;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> INT_MAX;<br>                &#125;<br>            &#125;<br>            idx++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (neg) &#123;<br>            ans *= <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="200-岛屿数量"><a class="markdownIt-Anchor" href="#200-岛屿数量"></a> 200、岛屿数量</h3><p>基本dfs的题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt; &gt; g;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        g = grid;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; g.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; g[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); ++j) &#123;<br>                <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    <span class="hljs-built_in">dfs</span>(i, j);<br>                    ans++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        g[x][y] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> d : dir) &#123;<br>            <span class="hljs-keyword">int</span> nx = x + d[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> ny = y + d[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt;= (g.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &amp;&amp; ny &lt;= (g[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &amp;&amp; g[nx][ny] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                <span class="hljs-built_in">dfs</span>(nx, ny);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="560-和为k的子数组"><a class="markdownIt-Anchor" href="#560-和为k的子数组"></a> 560、和为K的子数组</h3><p>这道题太妙了！！！sum是所有的前缀和，这道题的思想就是结合了动态规划，它记录了每一种和的情况下有几种能够达到该值的方式，0的时候为1次也就是正好是k；如果sum - k出现在map中，那也就是说当前这个num等于k，该循环sum没有变化。出现过该sum-k也说明，只要前缀和不带上它，当前状态+去掉sum-k组成的前缀和的差值就是咱们当前可以求到的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        unordered_map &lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m; <span class="hljs-comment">// 记忆map 前一个int 是值</span><br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        m[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            sum += num;<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(sum - k)) &#123;<br>                ans += m[sum - k];<br>            &#125;<br>            m[sum]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day6"><a class="markdownIt-Anchor" href="#day6"></a> Day6</h2><h3 id="56-合并区间"><a class="markdownIt-Anchor" href="#56-合并区间"></a> 56、合并区间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; ans;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; intervals) &#123;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>());<br>        ans.<span class="hljs-built_in">push_back</span>(intervals[<span class="hljs-number">0</span>]); <span class="hljs-comment">//先放第一个</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> val : intervals) &#123;<br>            <span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>] &gt;= val[<span class="hljs-number">0</span>]) &#123; <span class="hljs-comment">//若当前存储的结尾大于等于下一个的开始</span><br>                ans.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(ans.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>], val[<span class="hljs-number">1</span>]); <span class="hljs-comment">//更新一下结尾 若没有当前和这个大 那就不更新</span><br>            &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//不然就单独存放当前这个</span><br>                ans.<span class="hljs-built_in">push_back</span>(val); <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1-两数之和"><a class="markdownIt-Anchor" href="#1-两数之和"></a> 1、两数之和</h3><p>利用map记录</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(target - nums[i])) &#123; <span class="hljs-comment">// 如果库里有那就输出</span><br>                <span class="hljs-keyword">return</span> &#123;m[target - nums[i]], i&#125;;<br>            &#125;<br>            m[nums[i]] = i; <span class="hljs-comment">//存储一下</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-最长回文子串"><a class="markdownIt-Anchor" href="#5-最长回文子串"></a> 5、最长回文子串</h3><p>暴力解（超时）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    string res;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">judge</span>(s, i, j) &amp;&amp; (j - i + <span class="hljs-number">1</span> &gt; res.<span class="hljs-built_in">size</span>())) &#123;<br>                    res = s.<span class="hljs-built_in">substr</span>(i, j - i + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (start == end) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (start == end - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s[start] == s[end];<br>        <span class="hljs-keyword">bool</span> ans = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (s[start] == s[end]) &#123;<br>            ans = <span class="hljs-built_in">judge</span>(s, start + <span class="hljs-number">1</span>, end - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>中心扩散法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    string res;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">int</span> len1 = <span class="hljs-built_in">spread</span>(s, i, i); <span class="hljs-comment">// 奇数</span><br>            <span class="hljs-keyword">int</span> len2 = <span class="hljs-built_in">spread</span>(s, i, i + <span class="hljs-number">1</span>); <span class="hljs-comment">//偶数</span><br>            <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">max</span>(len1, len2);<br>            <span class="hljs-keyword">if</span> (len &gt; (end - start)) &#123;<br>                start = i - (len - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>                end = i + len / <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(start, end - start + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">spread</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (start &gt;= <span class="hljs-number">0</span> &amp;&amp; end &lt; n &amp;&amp; s[start] == s[end]) &#123;<br>            start--;<br>            end++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> end - start - <span class="hljs-number">1</span>; <span class="hljs-comment">//求一下这个扩散区间的距离有多少</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day7"><a class="markdownIt-Anchor" href="#day7"></a> Day7</h2><h3 id="98-验证二叉搜索树"><a class="markdownIt-Anchor" href="#98-验证二叉搜索树"></a> 98、验证二叉搜索树</h3><p>递归版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">bool</span> ans = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">inOrder</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span> (pre &amp;&amp; pre-&gt;val &gt;= root-&gt;val) &#123;<br>            ans = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        pre = root;<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>java版本但是没有用新的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> TreeNode prev = <span class="hljs-keyword">null</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (!isValidBST(root.left)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (prev != <span class="hljs-keyword">null</span> &amp;&amp; prev.val &gt;= root.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    prev = root;<br>    <span class="hljs-keyword">if</span> (!isValidBST(root.right)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>非递归版本（偷偷练习一下非递归的中序遍历）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    stack&lt;TreeNode* &gt; s;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        TreeNode* cur = root, *pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur || !s.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (cur) &#123; <span class="hljs-comment">// 尽量往左走</span><br>                s.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;left;<br>            &#125;<br>            TreeNode* node = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (pre &amp;&amp; pre-&gt;val &gt;= node-&gt;val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            pre = node;<br>            cur = node-&gt;right; <span class="hljs-comment">//去右边看看</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="32-最长有效括号"><a class="markdownIt-Anchor" href="#32-最长有效括号"></a> 32、最长有效括号</h3><p>动态规划 + 栈 转换空间 方便统计个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; S; <span class="hljs-comment">//用于记录下标</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; dp = vector&lt;<span class="hljs-keyword">int</span>&gt;(n);<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                S.<span class="hljs-built_in">push</span>(i); <span class="hljs-comment">// 存储一下为了待会儿记录dp的位置</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; !S.<span class="hljs-built_in">empty</span>())&#123; <span class="hljs-comment">//将可以配对的赋值1</span><br>                dp[S.<span class="hljs-built_in">top</span>()] = <span class="hljs-number">1</span>;<br>                dp[i] = <span class="hljs-number">1</span>;<br>                S.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 开始处理dp</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-number">0</span>) &#123;<br>                cur = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (dp[i] == <span class="hljs-number">1</span>) &#123;<br>                cur++;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>还有一种空间复杂度不增加的方法 左右遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//通过左右遍历 把没有办法匹配的括号全部去除</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                c++;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>                    s[i] = <span class="hljs-string">&#x27;*&#x27;</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    c--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        c = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                c++;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>                    s[i] = <span class="hljs-string">&#x27;*&#x27;</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    c--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//最后再统计一遍</span><br>        c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                c++;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                ans = ans &gt; c ? ans : c;<br>                c = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        ans = ans &gt; c ? ans : c;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="94-二叉树的中序遍历"><a class="markdownIt-Anchor" href="#94-二叉树的中序遍历"></a> 94、二叉树的中序遍历</h3><p>递归版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">inOrder</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;left);<br>        ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>迭代版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        stack&lt;TreeNode*&gt; s;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span> (cur || !s.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (cur) &#123;<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;left;<br>            &#125;<br>            TreeNode* node = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            cur = node-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="141-环形链表"><a class="markdownIt-Anchor" href="#141-环形链表"></a> 141、环形链表</h3><p>使用快慢指针的经典案例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        ListNode* slow = head;<br>        ListNode* fast = head-&gt;next;<br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span> (slow == fast) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day8"><a class="markdownIt-Anchor" href="#day8"></a> Day8</h2><h3 id="25-k个一组反转链表好题"><a class="markdownIt-Anchor" href="#25-k个一组反转链表好题"></a> 25、K个一组反转链表✨好题！</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">// 构造dummy防止head翻转</span><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), * pre = dummy, * cur = head;<br>        dummy-&gt;next = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; cur; ++i) &#123;<br>            <span class="hljs-comment">// 当达到个数就反转</span><br>            <span class="hljs-keyword">if</span> (i % k == <span class="hljs-number">0</span>) &#123;<br>                pre = <span class="hljs-built_in">reverseOne</span>(pre, cur-&gt;next);<br>                cur = pre-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果不是该处理的时候 我们就直接正常下一个</span><br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//1 3 2 4 5</span><br>   <span class="hljs-comment">// p.  l c</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseOne</span><span class="hljs-params">(ListNode* pre, ListNode* next)</span> </span>&#123; <span class="hljs-comment">// pre代表上一组的最后一个节点， next代表下一组的第一个节点 也就是大循环中的cur下一个</span><br>        ListNode* last = pre-&gt;next, * cur = last-&gt;next;<br>        <span class="hljs-comment">// 这个过程就是尾巴出头接</span><br>        <span class="hljs-keyword">while</span> (cur != next) &#123;<br>            last-&gt;next = cur-&gt;next; <span class="hljs-comment">// 先把第一个放到该组下一个位置</span><br>            cur-&gt;next = pre-&gt;next;<br>            pre-&gt;next = cur;<br>            cur = last-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> last; <span class="hljs-comment">// 返回该组的最后一个</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="20-有效括号括号匹配"><a class="markdownIt-Anchor" href="#20-有效括号括号匹配"></a> 20、有效括号（括号匹配）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-keyword">char</span>&gt; S;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span>) &#123;<br>                S.<span class="hljs-built_in">push</span>(c);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (S.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">char</span> cur = S.<span class="hljs-built_in">top</span>();<br>                S.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">bool</span> b1 = (cur == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;)&#x27;</span>);<br>                <span class="hljs-keyword">bool</span> b2 = (cur == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>                <span class="hljs-keyword">bool</span> b3 = (cur == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;]&#x27;</span>);<br>                <span class="hljs-keyword">if</span> (!b1 &amp;&amp; !b2 &amp;&amp; !b3) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> S.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="121-买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#121-买卖股票的最佳时机"></a> 121、买卖股票的最佳时机</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = INT_MIN, minBuy = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            minBuy = <span class="hljs-built_in">min</span>(minBuy, prices[i]);<br>            ans = <span class="hljs-built_in">max</span>(ans, prices[i] - minBuy);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="210-课程表2"><a class="markdownIt-Anchor" href="#210-课程表2"></a> 210、课程表2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; Graph[<span class="hljs-number">2001</span>];<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">2001</span>);<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; dfsvis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">2001</span>);<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; path; <span class="hljs-comment">// 最后的结果路径</span><br>    <span class="hljs-keyword">int</span> n; <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        n = numCourses;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : prerequisites) &#123;<br>            Graph[p[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(p[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>            <span class="hljs-keyword">if</span> (!vis[i]) &#123; <span class="hljs-comment">// 检测是否走过</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(i)) <span class="hljs-keyword">return</span> &#123;&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123; <span class="hljs-comment">// 有环返回true</span><br>        vis[s] = <span class="hljs-literal">true</span>;<br>        dfsvis[s] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> edge : Graph[s]) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[edge]) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(edge)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dfsvis[edge]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        dfsvis[s] = <span class="hljs-literal">false</span>;<br>        path.<span class="hljs-built_in">push_back</span>(s);<br>        <span class="hljs-keyword">if</span> (path.<span class="hljs-built_in">size</span>() == n) &#123;<br>            <span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day9"><a class="markdownIt-Anchor" href="#day9"></a> Day9</h2><h3 id="41-缺失的第一个正数"><a class="markdownIt-Anchor" href="#41-缺失的第一个正数"></a> 41、缺失的第一个正数</h3><p>利用hashset做，时间复杂度和空间复杂度都是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(nums.begin(), nums.end())</span></span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (res &lt;= n) &#123;<br>            <span class="hljs-keyword">if</span> (!s.<span class="hljs-built_in">count</span>(res)) <span class="hljs-keyword">return</span> res;<br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，空间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i] - <span class="hljs-number">1</span>]) &#123;  <span class="hljs-comment">//将在0到n的正数放到属于自己的位置</span><br>                <span class="hljs-built_in">swap</span>(nums[i], nums[nums[i] - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != i + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>; <span class="hljs-comment">// 出去的话那就是最后一个的下一个</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="39-组合总和"><a class="markdownIt-Anchor" href="#39-组合总和"></a> 39、组合总和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-comment">//dfs走一个</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; ans;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; temp; <span class="hljs-comment">// 中间存储</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; Can;  <span class="hljs-comment">//方便全局遍历</span><br>    <span class="hljs-keyword">int</span> tar; <span class="hljs-comment">//方便遍历记录target</span><br>    <span class="hljs-keyword">int</span> n; <span class="hljs-comment">// 记录一共有多少个数</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; candidates, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        Can = candidates, n = Can.<span class="hljs-built_in">size</span>(), tar = target;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">int</span> curVal)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (curVal == tar) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = idx; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (curVal + Can[i] &lt;= tar) &#123;<br>                temp.<span class="hljs-built_in">push_back</span>(Can[i]);<br>                <span class="hljs-built_in">dfs</span>(i, curVal + Can[i]);<br>                temp.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="168-excel表列名称"><a class="markdownIt-Anchor" href="#168-excel表列名称"></a> 168、Excel表列名称</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convertToTitle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> columnNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (columnNumber == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        columnNumber--; <span class="hljs-comment">// 因为A对应的是1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">convertToTitle</span>(columnNumber / <span class="hljs-number">26</span>) + (<span class="hljs-keyword">char</span>)(columnNumber % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;A&#x27;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="47-全排列2"><a class="markdownIt-Anchor" href="#47-全排列2"></a> 47、全排列2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; Nums;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; res;<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">15</span>);<br>    <span class="hljs-keyword">int</span> N;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        N = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        Nums = nums;<br>        <span class="hljs-built_in">dfs</span>(&#123;&#125;);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; temp)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (temp.<span class="hljs-built_in">size</span>() == N) &#123;  <span class="hljs-comment">//完成一个就剪枝</span><br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">1</span> &amp;&amp; vis[i - <span class="hljs-number">1</span>] &amp;&amp; Nums[i - <span class="hljs-number">1</span>] == Nums[i]) &#123; <span class="hljs-comment">// 如果上一个使用过 且和我当前这个一样的话 那就跳过</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!vis[i]) &#123; <span class="hljs-comment">// 如果这个没有用过</span><br>                vis[i] = <span class="hljs-literal">true</span>;<br>                temp.<span class="hljs-built_in">push_back</span>(Nums[i]);<br>                <span class="hljs-built_in">dfs</span>(temp);<br>                temp.<span class="hljs-built_in">pop_back</span>();<br>                vis[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="543-二叉树的直径"><a class="markdownIt-Anchor" href="#543-二叉树的直径"></a> 543、二叉树的直径</h3><p>主要求的是路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">f</span>(root);<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">f</span>(root-&gt;left);<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">f</span>(root-&gt;right);<br>        sum = <span class="hljs-built_in">max</span>(sum, left + right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(left, right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day10"><a class="markdownIt-Anchor" href="#day10"></a> Day10</h2><h3 id="91-解码方法"><a class="markdownIt-Anchor" href="#91-解码方法"></a> 91、解码方法</h3><p>为什么第一个是= 第二个是+= 因为第i个状态先存储i - 1 个状态 然后在组合判断两位数的。其实第一个也可以改成+=。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; dp = vector&lt;<span class="hljs-keyword">int</span>&gt;(n);<br>        dp[<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">int</span> one = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">int</span> two = one + (s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (one != <span class="hljs-number">0</span>) &#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 继承上一个没有当前这个字符的状态</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">10</span> &lt;= two &amp;&amp; two &lt;= <span class="hljs-number">26</span>) &#123;<br>                dp[i] += i &gt;= <span class="hljs-number">2</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">1</span>;   <span class="hljs-comment">//这个判断用于第二位</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="142-环形链表2"><a class="markdownIt-Anchor" href="#142-环形链表2"></a> 142、环形链表2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        ListNode* slow = head, * fast = head;<br>        <span class="hljs-keyword">do</span> &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<span class="hljs-keyword">while</span> (slow &amp;&amp; fast &amp;&amp; fast-&gt;next &amp;&amp; fast != slow);<br>        <span class="hljs-keyword">if</span> (!slow || !fast || !fast-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        slow = head;<br>        <span class="hljs-keyword">while</span> (fast != slow) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="46-全排列"><a class="markdownIt-Anchor" href="#46-全排列"></a> 46、全排列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; ans;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; Nums;<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">15</span>);<br>    <span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        n = nums.<span class="hljs-built_in">size</span>();<br>        Nums = nums;<br>        <span class="hljs-built_in">dfs</span>(&#123;&#125;);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; temp)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (temp.<span class="hljs-built_in">size</span>() == n) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[i]) &#123;<br>                vis[i] = <span class="hljs-literal">true</span>;<br>                temp.<span class="hljs-built_in">push_back</span>(Nums[i]);<br>                <span class="hljs-built_in">dfs</span>(temp);<br>                temp.<span class="hljs-built_in">pop_back</span>();<br>                vis[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="415-字符串相加"><a class="markdownIt-Anchor" href="#415-字符串相加"></a> 415、字符串相加</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addStrings</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n1 = num1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> n2 = num2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n1 &gt;= <span class="hljs-number">0</span> || n2 &gt;= <span class="hljs-number">0</span> || carry) &#123;<br>            <span class="hljs-keyword">if</span> (n1 &gt;= <span class="hljs-number">0</span>) &#123;<br>                carry += num1[n1--] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (n2 &gt;= <span class="hljs-number">0</span>) &#123;<br>                carry += num2[n2--] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            ans += carry % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>            carry /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day11"><a class="markdownIt-Anchor" href="#day11"></a> Day11</h2><h3 id="240-搜索二维矩阵2"><a class="markdownIt-Anchor" href="#240-搜索二维矩阵2"></a> 240、搜索二维矩阵2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>, c = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (r &lt; m &amp;&amp; c &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[r][c] == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[r][c] &gt; target) &#123;<br>                c--;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                r++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="93-复制ip地址"><a class="markdownIt-Anchor" href="#93-复制ip地址"></a> 93、复制IP地址</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;string&gt; ans;<br>    <span class="hljs-keyword">int</span> n;<br>    string S;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        n = s.<span class="hljs-built_in">size</span>();<br>        S = s;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">3</span> || s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 当长度超了不可以 如果没有了也不可以</span><br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">// 第一位不可以为&#x27;0&#x27;（如果是两位以上）</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &gt; <span class="hljs-built_in">stoi</span>(s) || <span class="hljs-built_in">stoi</span>(s) &gt; <span class="hljs-number">255</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 值的范围在0~255</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string temp, <span class="hljs-keyword">int</span> dot, <span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (dot == <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">isValid</span>(S.<span class="hljs-built_in">substr</span>(start))) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(temp + S.<span class="hljs-built_in">substr</span>(start));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt; start + <span class="hljs-number">3</span> &amp;&amp; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(S.<span class="hljs-built_in">substr</span>(start, i - start + <span class="hljs-number">1</span>))) &#123;<br>                <span class="hljs-built_in">dfs</span>(temp + S.<span class="hljs-built_in">substr</span>(start, i - start + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;.&quot;</span> , dot + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="72-编辑距离"><a class="markdownIt-Anchor" href="#72-编辑距离"></a> 72、编辑距离</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n1 = word1.<span class="hljs-built_in">size</span>(), n2 = word2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">dp</span> (n1 + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n2 + <span class="hljs-number">1</span>));  <span class="hljs-comment">// dp这个状态数组表示两个字付串不同长度下的改变状态值</span><br>        <span class="hljs-comment">// 对于一个空一个没有那改变的数量就是当前另一个的长度值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n1; ++i) &#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= n2; ++j) &#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n2; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 如果字符串相等 那就是  ｜ 这里 -1 是数组索引的问题 0 是第一个</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// dp[i - 1][j - 1] 代表替换当前这个字符, min(dp[i - 1][j], dp[i][j - 1])代表删除一个字符串里的字符或者插入一个字符</span><br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>; <span class="hljs-comment">// +1代表一个操作处理</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n1][n2];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="752-打开转盘锁"><a class="markdownIt-Anchor" href="#752-打开转盘锁"></a> 752、打开转盘锁</h3><p>BFS遍历变种题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; dir&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">openLock</span><span class="hljs-params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;<br>        unordered_set&lt;string&gt; vis;  <span class="hljs-comment">// 计算过的状态</span><br>        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">dead</span><span class="hljs-params">(deadends.begin(), deadends.end())</span></span>; <span class="hljs-comment">// 不可以触碰的状态</span><br>        <span class="hljs-keyword">if</span> (dead.<span class="hljs-built_in">count</span>(<span class="hljs-string">&quot;0000&quot;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 防止一开始的开头出问题</span><br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-string">&quot;0000&quot;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        queue&lt;string&gt; q; <span class="hljs-comment">// 用于BFS中间存储状态</span><br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;0000&quot;</span>);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = q.<span class="hljs-built_in">size</span>();<br>            ans++;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                string cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cur.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> d : dir) &#123;<br>                        string t = cur;  <span class="hljs-comment">// 每次只要动一处 所以每次都得还原一次状态</span><br>                        t[i] = (((t[i] - <span class="hljs-string">&#x27;0&#x27;</span>) + <span class="hljs-number">10</span>) + d) % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-comment">// 为了让她在0 ～ 9 无限循环</span><br>                        <span class="hljs-keyword">if</span>(!vis.<span class="hljs-built_in">count</span>(t) &amp;&amp; !dead.<span class="hljs-built_in">count</span>(t)) &#123; <span class="hljs-comment">// 必须得都没有在违法区域的</span><br>                            <span class="hljs-keyword">if</span> (t == target) &#123;<br>                                <span class="hljs-keyword">return</span> ans;<br>                            &#125;<span class="hljs-keyword">else</span> &#123;<br>                                vis.<span class="hljs-built_in">insert</span>(t);<br>                                q.<span class="hljs-built_in">push</span>(t);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day12"><a class="markdownIt-Anchor" href="#day12"></a> Day12</h2><h3 id="138-复制带随机指针的链表"><a class="markdownIt-Anchor" href="#138-复制带随机指针的链表"></a> 138、复制带随机指针的链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>: <span class="hljs-comment">// 空间换时间就可以 用hashmap记录成成对的节点</span><br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> head; <span class="hljs-comment">// 不处理单个节点因为只要有节点就需要复制重新弄</span><br>        Node* res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(head-&gt;val); <br>        Node* cur = res, * node = head-&gt;next;<br>        unordered_map&lt;Node*, Node*&gt; m; <span class="hljs-comment">// 用于存储原链表与新链表的对应位置</span><br>        m[head] = res;  <span class="hljs-comment">// 第一个单独处理</span><br>        <span class="hljs-keyword">while</span>(node) &#123;<br>            Node* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(node-&gt;val);  <span class="hljs-comment">// 创建新的链表</span><br>            cur-&gt;next = newNode;<br>            m[node] = newNode;<br>            cur = cur-&gt;next;<br>            node = node-&gt;next;<br>        &#125;<br>        cur = res, node = head;<br>        <span class="hljs-keyword">while</span>(cur) &#123;<br>            cur-&gt;random = m[node-&gt;random];  <span class="hljs-comment">//m[node-&gt;random] 就等于是在cur上面找</span><br>            cur = cur-&gt;next;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="468-验证ip地址"><a class="markdownIt-Anchor" href="#468-验证ip地址"></a> 468、验证IP地址</h3><p>这道题太过于细致复杂，观看大神详解：</p><p>这道题让我们验证两种IP地址，LeetCode之前有一道关于IPv4的题<a href="http://www.cnblogs.com/grandyang/p/4305572.html">Restore IP Addresses</a>，给我们了一个字符串，让我们通过在中间加点来找出所有正确的IP地址，这道题给了我们中间加点或者冒号的字符串，让我们验证其是否是正确的IPv4或者IPv6，感觉要稍稍复杂一些。那么我们只有分别来验证了，那么我们怎么样能快速的区别是IPv4或者IPv6呢，当然是通过中间的点或者冒号啦，所以我们首先在字符串中找冒号(当然你想找点也可以)，如果字符串中没有冒号，那么我们来验证其是否是IPv4，如果有冒号，我们就来验证其是否是IPv6.</p><p>首先对于IPv4，我们使用getline函数来截取两个点之间的字符串，我们还需要一个计数器cnt来记录我们已经截取了多少段，如果cnt大于4了，说明超过了4段，说明是不是正确的地址。如果取出的字符串为空，说明两个点连在一起了，也不对。再有就是如果字符串长度大于1，且第一个字符是0，也不对。由于IPv4的地址在0到255之间，所以如果字符串长度大于3，也不正确。下面我们检查每一个字符，如果有不是数字的字符，返回Neither。最后我们再把字符串转为数字，如果不在0到255之间就是非法的。最后的最后，我们要保证cnt正好为4，而且最后一个字符不能是点，统统满足以上条件才是正确的IPv4地址。</p><p>然后对于IPv6，我们也使用getline函数来截取两个冒号之间的字符串，我们同样需要计数器cnt来记录我们已经截取了多少段，如果cnt大于8了，说明超过了8段，说明是不是正确的地址。如果取出的字符串为空，说明两个冒号连在一起了，也不对。面我们检查每一个字符，正确的字符应该是0到9之间的数字，或者a到f，或A到F之间的字符，如果出现了其他字符，返回Neither。最后的最后，我们要保证cnt正好为8，而且最后一个字符不能是冒号，统统满足以上条件才是正确的IPv6地址。</p><p><strong>这题回头考试前多看看吧，也没办法去记忆这些规则</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">validIPAddress</span><span class="hljs-params">(string IP)</span> </span>&#123;<br>        <span class="hljs-function">istringstream <span class="hljs-title">is</span><span class="hljs-params">(IP)</span></span>; <span class="hljs-comment">// 转换字符流好处理</span><br>        string t = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (IP.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;:&quot;</span>) == string::npos) &#123; <span class="hljs-comment">// 如果是IPv4</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(is, t, <span class="hljs-string">&#x27;.&#x27;</span>)) &#123;<br>                cnt++; <span class="hljs-comment">// 记录有几段</span><br>                <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">4</span> || t.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">3</span> || (t.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; t[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) || t.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t) &#123;<br>                    <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27;0&#x27;</span> || c &gt; <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>                &#125;<br>                <span class="hljs-keyword">int</span> val = <span class="hljs-built_in">stoi</span>(t);<br>                <span class="hljs-keyword">if</span> (val &lt; <span class="hljs-number">0</span> || val &gt; <span class="hljs-number">255</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> (cnt == <span class="hljs-number">4</span> &amp;&amp; IP.<span class="hljs-built_in">back</span>() != <span class="hljs-string">&#x27;.&#x27;</span>) ? <span class="hljs-string">&quot;IPv4&quot;</span> : <span class="hljs-string">&quot;Neither&quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 判断IPv6</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">getline</span>(is, t, <span class="hljs-string">&#x27;:&#x27;</span>)) &#123;<br>                cnt++;<br>                <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">8</span> || t.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">4</span> || t.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t) &#123;<br>                    <span class="hljs-keyword">if</span> (!(<span class="hljs-string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &amp;&amp; !(<span class="hljs-string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;f&#x27;</span>) &amp;&amp; !(<span class="hljs-string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;F&#x27;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> (cnt == <span class="hljs-number">8</span> &amp;&amp; IP.<span class="hljs-built_in">back</span>() != <span class="hljs-string">&#x27;:&#x27;</span>) ? <span class="hljs-string">&quot;IPv6&quot;</span> : <span class="hljs-string">&quot;Neither&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Neither&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="64-最小路径和"><a class="markdownIt-Anchor" href="#64-最小路径和"></a> 64、最小路径和</h3><p>不记录路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> m = grid.<span class="hljs-built_in">size</span>(), n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; dp = vector&lt;<span class="hljs-keyword">int</span>&gt;(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 在第一列只能向下走</span><br>                    dp[j] += grid[i][j];<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">// 在第一行只能向右走</span><br>                    dp[j] = dp[j - <span class="hljs-number">1</span>] + grid[i][j];<br>                &#125;<span class="hljs-keyword">else</span>&#123;  <span class="hljs-comment">// 可以往下也可以往右</span><br>                    dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - <span class="hljs-number">1</span>]) + grid[i][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>记录路径（延伸）【肯定超时】</p><p>但是思路就是用<strong>二维dp数组</strong>，然后根据<strong>dp的数据状态图</strong>进行<strong>dfs</strong>得到结果。</p><h3 id="224-基本计算器好题"><a class="markdownIt-Anchor" href="#224-基本计算器好题"></a> 224、基本计算器（好题）</h3><p>在于遇到括号需要存储当前的状态，并且我们对于数字的处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; st;  <span class="hljs-comment">//对于遇到括号 用于存储中间状态</span><br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>, sign = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;0&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123; <span class="hljs-comment">// 数字的话就把这个数解决了</span><br>                <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-string">&#x27;0&#x27;</span> &lt;= s[i] &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                    num = num * <span class="hljs-number">10</span> + (s[i++] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                &#125;<br>                res += num * sign;<br>                i--; <span class="hljs-comment">// 因为退出的时候会多加一个</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                sign = <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>                sign = <span class="hljs-number">-1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) &#123; <span class="hljs-comment">// 存储状态并初始化</span><br>                st.<span class="hljs-built_in">push</span>(res);<br>                st.<span class="hljs-built_in">push</span>(sign);<br>                res = <span class="hljs-number">0</span>;<br>                sign = <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                res *= st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 解决左括号前的符号问题</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                res += st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day13"><a class="markdownIt-Anchor" href="#day13"></a> Day13</h2><h3 id="剑指-offer-51-数组中的逆序对"><a class="markdownIt-Anchor" href="#剑指-offer-51-数组中的逆序对"></a> 剑指 Offer 51. 数组中的逆序对</h3><p>就是归并排序上再外加一个统计逆序就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">InversePairs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; data)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">copy</span><span class="hljs-params">(data.begin(), data.end())</span></span>; <span class="hljs-comment">// copy数组用于给数组更新当中间变量</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">inverseCount</span>(data, copy, <span class="hljs-number">0</span>, data.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inverseCount</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; data, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; copy, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (low &gt;= high) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> leftCnt = <span class="hljs-built_in">inverseCount</span>(copy, data, low, mid) % <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-keyword">int</span> rightCnt = <span class="hljs-built_in">inverseCount</span>(copy, data, mid + <span class="hljs-number">1</span>, high) % <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-keyword">int</span> i = mid, j = high;<br>        <span class="hljs-keyword">int</span> locCopy = high;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录当前多少逆续对</span><br>        <span class="hljs-keyword">while</span> (i &gt;= low &amp;&amp; j &gt; mid) &#123;<br>            <span class="hljs-keyword">if</span> (data[i] &gt; data[j]) &#123; <br>                count += j - mid; <span class="hljs-comment">// 因为j到mid一定小于i i到mid肯定大于j</span><br>                copy[locCopy--] = data[i--];<br>                <span class="hljs-keyword">if</span> (count &gt;= <span class="hljs-number">1000000007</span>) &#123;<br>                    count %= <span class="hljs-number">1000000007</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                copy[locCopy--] = data[j--];<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//把剩余的更新了</span><br>        <span class="hljs-keyword">while</span> (i &gt;= low) &#123;<br>            copy[locCopy--] = data[i--];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (j &gt; mid) &#123;<br>            copy[locCopy--] = data[j--];<br>        &#125;<br>        <span class="hljs-keyword">return</span> (leftCnt + rightCnt + count) % <span class="hljs-number">1000000007</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="239-滑动窗口最大值"><a class="markdownIt-Anchor" href="#239-滑动窗口最大值"></a> 239、滑动窗口最大值</h3><p>使用k大小的堆来维护滑动窗口<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>时间复杂度 但是这部分只能用java实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">maxInWindows</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] num, <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">0</span> || size &gt; num.length)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        &#125;<br>        ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 初始化窗口</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)&#123;<br>            maxHeap.offer(num[i]);<br>        &#125;<br>        ans.add(maxHeap.peek());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = size; j &lt; num.length; ++i, ++j)&#123;<br>            maxHeap.remove(num[i]);<br>            maxHeap.offer(num[j]);<br>            ans.add(maxHeap.peek());<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建单调队列时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> &#123;</span> <span class="hljs-comment">// 创建单调队列</span><br>            <span class="hljs-keyword">private</span>:<br>                deque&lt;<span class="hljs-keyword">int</span>&gt; que;<br>            <span class="hljs-keyword">public</span>:<br>                <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>                    <span class="hljs-comment">//队头这个数就是当前最大值</span><br>                    <span class="hljs-keyword">if</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; val == que.<span class="hljs-built_in">front</span>()) &#123;  <span class="hljs-comment">//如果当前退出数是当前最大值，那么我们就踢出他 但是踢出当前这个不能踢出多的</span><br>                        que.<span class="hljs-built_in">pop_front</span>();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123; <span class="hljs-comment">// 插入操作</span><br>                    <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>() &amp;&amp; val &gt; que.<span class="hljs-built_in">back</span>()) &#123;  <span class="hljs-comment">// 吧没有用的小值清干净 然后吧当前值放在能放的最大值的位置 如果有一样的也不破坏最大值的数量</span><br>                        que.<span class="hljs-built_in">pop_back</span>();<br>                    &#125;<br>                    que.<span class="hljs-built_in">push_back</span>(val);<br>                &#125;<br>                <span class="hljs-comment">// 通过pop 和 push保证这个单调队列里面包含的就是当前滑动窗口的最大值 以及候选人们</span><br>                <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span></span>&#123;<br>                    <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">front</span>();<br>                &#125;<br>        &#125;;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>            MyQueue Q;<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>                Q.<span class="hljs-built_in">push</span>(nums[i]);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(Q.<span class="hljs-built_in">front</span>());<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = k; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                Q.<span class="hljs-built_in">pop</span>(nums[i - k]);<br>                Q.<span class="hljs-built_in">push</span>(nums[i]);<br>                ans.<span class="hljs-built_in">push_back</span>(Q.<span class="hljs-built_in">front</span>());<br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="153-寻找旋转排序数组中的最小值"><a class="markdownIt-Anchor" href="#153-寻找旋转排序数组中的最小值"></a> 153、寻找旋转排序数组中的最小值</h3><p>按照时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的时间复杂度，所以是二分法的拓展应用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; h) &#123;<br>            <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[m] &gt; nums[h]) &#123; <span class="hljs-comment">// 比最右边的大 那一定不是</span><br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 比他小或着等于他 那都代表的是可能是或者说她是右边界</span><br>                h = m;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[l];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day14"><a class="markdownIt-Anchor" href="#day14"></a> Day14</h2><h3 id="8-二叉树的下一个节点"><a class="markdownIt-Anchor" href="#8-二叉树的下一个节点"></a> 8、二叉树的下一个节点</h3><p>题目链接：<a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=11210&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github">https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=11210&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking&amp;from=cyc_github</a></p><p>中序遍历</p><p>1）如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点</p><p>2）否则，向上找第一个左链接指向的树包含该节点的祖先节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct TreeLinkNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    struct TreeLinkNode *left;</span><br><span class="hljs-comment">    struct TreeLinkNode *right;</span><br><span class="hljs-comment">    struct TreeLinkNode *next;</span><br><span class="hljs-comment">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeLinkNode* <span class="hljs-title">GetNext</span><span class="hljs-params">(TreeLinkNode* pNode)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pNode-&gt;right != <span class="hljs-literal">NULL</span>) &#123;<br>            TreeLinkNode* r = pNode-&gt;right;<br>            <span class="hljs-keyword">while</span> (r-&gt;left) &#123;<br>                r = r-&gt;left;<br>            &#125;<br>            <span class="hljs-keyword">return</span> r;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span>(pNode-&gt;next) &#123; <span class="hljs-comment">// 爹还一直在</span><br>                TreeLinkNode* parent = pNode-&gt;next;<br>                <span class="hljs-keyword">if</span> (parent-&gt;left == pNode) &#123;<br>                    <span class="hljs-keyword">return</span> parent;<br>                &#125;<br>                pNode = pNode-&gt;next; <span class="hljs-comment">// 往上走</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day15"><a class="markdownIt-Anchor" href="#day15"></a> Day15</h2><h3 id="76-最小覆盖子串"><a class="markdownIt-Anchor" href="#76-最小覆盖子串"></a> 76、最小覆盖子串</h3><p>收缩左边界，由于遍历的时候，对映射值减了1，所以此时去除字母的时候，就要把减去的1加回来，此时如果加1后的值大于0了，说明此时少了一个T中的字母，那么 cnt 值就要减1了，然后移动左边界 left。</p><p>- 先<strong>扫描一遍T</strong>，把对应的字符及其出现的次数存到 HashMap 中。</p><p>- 然后开始<strong>遍历S</strong>，就把遍历到的字母对应的 HashMap 中的 value 减一，如果减1后仍大于等于0，cnt 自增1。</p><p>- 如果 cnt 等于T串长度时，开始循环，纪录一个字串并更新最小字串值。然后将子窗口的左边界向右移，如果某个移除掉的字母是T串中不可缺少的字母，那么 cnt 自减1，表示此时T串并没有完全匹配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, left = <span class="hljs-number">0</span>, minDist = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : t) &#123;  <span class="hljs-comment">// 记录一下模版</span><br>            m[c]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (--m[s[i]] &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 遇到了t中对应的字母 记录一下个数</span><br>                cnt++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (cnt == t.<span class="hljs-built_in">size</span>()) &#123;<br>                <span class="hljs-keyword">if</span> (i - left + <span class="hljs-number">1</span> &lt; minDist) &#123;<br>                    minDist = i - left + <span class="hljs-number">1</span>;<br>                    res = s.<span class="hljs-built_in">substr</span>(left, minDist);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (++m[s[left]] &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果某个移除掉的字母是T串中不可缺少的字母，那么 cnt 自减1</span><br>                    --cnt;<br>                &#125;<br>                ++left;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a class="markdownIt-Anchor" href="#34-在排序数组中查找元素的第一个和最后一个位置"></a> 34、在排序数组中查找元素的第一个和最后一个位置</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-built_in">binarySearch</span>(nums, target, <span class="hljs-number">0</span>), <span class="hljs-built_in">binarySearch</span>(nums, target, <span class="hljs-number">1</span>)&#125;; <span class="hljs-comment">// 前左后右</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> mode)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= h) &#123;<br>            <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[m] &gt; target) &#123;<br>                h = m - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[m] &lt; target) &#123;<br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                ans = m;<br>                mode == <span class="hljs-number">0</span> ? h = m - <span class="hljs-number">1</span> : l = m + <span class="hljs-number">1</span>; <span class="hljs-comment">// 因为前面是+1 和 -1 所以这个h不可能超出这个值的范围</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="110-平衡二叉树"><a class="markdownIt-Anchor" href="#110-平衡二叉树"></a> 110、平衡二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">bool</span> ans = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">isB</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isB</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-built_in">isB</span>(root-&gt;left);<br>        <span class="hljs-keyword">int</span> r = <span class="hljs-built_in">isB</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(l - r) &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 不符合平衡二叉树的定义</span><br>            ans = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(r, l);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="21-合并两个有序链表"><a class="markdownIt-Anchor" href="#21-合并两个有序链表"></a> 21、合并两个有序链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        <span class="hljs-comment">//谁没了就接另一个</span><br>        <span class="hljs-keyword">if</span> (!list1) <span class="hljs-keyword">return</span> list2;<br>        <span class="hljs-keyword">if</span> (!list2) <span class="hljs-keyword">return</span> list1;<br>        <span class="hljs-keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;<br>            list1-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(list1-&gt;next, list2);<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            list2-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(list1, list2-&gt;next);<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果发现单个链表中有重复数字，直接跳到最后一个<br />(1-&gt;1-&gt;1-&gt;2) 转换为 (1-&gt;2)<br />有可能会出现list1与list2有相同元素，跳过其中的一个<br />(1-&gt;3) and (1-&gt;2) 转换为 (1-&gt;3) and (2)</p><p>在上面解法中再加入以下代码在上面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//单个链表中有重复数字，直接跳到最后一个</span><br><span class="hljs-keyword">while</span>(list1-&gt;next != null &amp;&amp; list1-&gt;val == list1-&gt;next-&gt;val)&#123;<br>list1 = list1-&gt;next;<br>&#125;<br><span class="hljs-keyword">while</span>(list2-&gt;next!=null &amp;&amp; list2-&gt;val == list2-&gt;next-&gt;val)&#123;<br>list2 = list2-&gt;next;<br>&#125;<br><span class="hljs-comment">//list1与list2有相同元素</span><br><span class="hljs-keyword">if</span>(list1-&gt;val == list2-&gt;val)&#123;<br><span class="hljs-keyword">if</span>(list2-&gt;next != null)&#123;<br>list2 = list2-&gt;next;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> list1;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>变形：合并多个有序链表 思路：以合并两个链表的思路为基础，使用<strong>归并自底向上合并</strong>。</p><h2 id="day16"><a class="markdownIt-Anchor" href="#day16"></a> Day16</h2><h3 id="14-排序链表"><a class="markdownIt-Anchor" href="#14-排序链表"></a> 14、排序链表</h3><p>用归并排序和合并有序链表组合实现</p><p>非递归实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head; <span class="hljs-comment">// 若为空 或者就自己 那就是返回自己</span><br>        ListNode* fast = head, * slow = head, * pre = head;<br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>            pre = slow; <span class="hljs-comment">// 为了截断两边用</span><br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//此时slow就是另一个新的链表的头</span><br>        pre-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 以上是自顶向下拆分</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">sortList</span>(head), <span class="hljs-built_in">sortList</span>(slow)); <span class="hljs-comment">//以下是自底向上合并</span><br>    &#125;<br>    <br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;  <span class="hljs-comment">// 合并两个有序链表</span><br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* cur = dummy;<br>        <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) &#123;<br>            <span class="hljs-keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;<br>                cur-&gt;next = l1;<br>                l1 = l1-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                cur-&gt;next = l2;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l1) &#123;<br>            cur-&gt;next = l1;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l2) &#123;<br>            cur-&gt;next = l2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>递归实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head; <span class="hljs-comment">// 若为空 或者就自己 那就是返回自己</span><br>        ListNode* fast = head, * slow = head, * pre = head;<br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>            pre = slow; <span class="hljs-comment">// 为了截断两边用</span><br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        pre-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">sortList</span>(head), <span class="hljs-built_in">sortList</span>(slow));<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123; <span class="hljs-comment">// 这部分就是合并两个有序链表</span><br>        <span class="hljs-keyword">if</span> (!l1) <span class="hljs-keyword">return</span> l2;<br>        <span class="hljs-keyword">if</span> (!l2) <span class="hljs-keyword">return</span> l1;<br>        <span class="hljs-keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;<br>            l1-&gt;next = <span class="hljs-built_in">merge</span>(l1-&gt;next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            l2-&gt;next = <span class="hljs-built_in">merge</span>(l1, l2-&gt;next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="69-x的平方根"><a class="markdownIt-Anchor" href="#69-x的平方根"></a> 69、x的平方根</h3><p>二分法结束条件就是除数和结果一致</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, h = x, sqrt;<br>        <span class="hljs-keyword">while</span> (l &lt;= h) &#123;<br>            <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;<br>            sqrt = x / m;<br>            <span class="hljs-keyword">if</span> (sqrt == m) <span class="hljs-keyword">return</span> m;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sqrt &lt; m) h = m - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> l = m + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> h; <span class="hljs-comment">// h = l - 1 说明取小数那端</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="173-二叉搜索树迭代器"><a class="markdownIt-Anchor" href="#173-二叉搜索树迭代器"></a> 173、二叉搜索树迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BSTIterator</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;TreeNode* &gt; temp; <span class="hljs-comment">// 用于存储层次序列</span><br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BSTIterator</span>(TreeNode* root) &#123;<br>        <span class="hljs-built_in">create</span>(root);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">create</span>(root-&gt;left);<br>        temp.<span class="hljs-built_in">push_back</span>(root);<br>        <span class="hljs-built_in">create</span>(root-&gt;right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> temp[idx++]-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> idx &lt; temp.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your BSTIterator object will be instantiated and called as such:</span><br><span class="hljs-comment"> * BSTIterator* obj = new BSTIterator(root);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;next();</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;hasNext();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>非递归版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BSTIterator</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    stack&lt;TreeNode* &gt; st; <span class="hljs-comment">// 用于存储层次序列</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushAll</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (root) &#123;<br>            st.<span class="hljs-built_in">push</span>(root);<br>            root = root-&gt;left;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BSTIterator</span>(TreeNode* root) &#123;<br>        <span class="hljs-built_in">pushAll</span>(root);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 找到最新的左孩子</span><br>        TreeNode* cur = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-built_in">pushAll</span>(cur-&gt;right);<br>        <span class="hljs-keyword">return</span> cur-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> !st.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your BSTIterator object will be instantiated and called as such:</span><br><span class="hljs-comment"> * BSTIterator* obj = new BSTIterator(root);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;next();</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;hasNext();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="152-乘积最大子数组"><a class="markdownIt-Anchor" href="#152-乘积最大子数组"></a> 152、乘积最大子数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// dp1 代表 当前最小值用于处理负数 dp2 当前最大值</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; dp1 = vector&lt;<span class="hljs-keyword">int</span>&gt;(n);<br>        dp1[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; dp2 = vector&lt;<span class="hljs-keyword">int</span>&gt;(n);<br>        dp2[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> ans = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            dp1[i] = <span class="hljs-built_in">min</span>(nums[i] * dp1[i - <span class="hljs-number">1</span>], nums[i]);<br>            dp2[i] = <span class="hljs-built_in">max</span>(nums[i] * dp2[i - <span class="hljs-number">1</span>], nums[i]);<br>            <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果遇到负数</span><br>                dp1[i] = <span class="hljs-built_in">min</span>(nums[i] * dp2[i - <span class="hljs-number">1</span>], nums[i]);<br>                dp2[i] = <span class="hljs-built_in">max</span>(nums[i] * dp1[i - <span class="hljs-number">1</span>], nums[i]);<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, dp2[i]); <span class="hljs-comment">// 更新最优值</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day17"><a class="markdownIt-Anchor" href="#day17"></a> Day17</h2><h3 id="105-从前序与中序遍历序列构造二叉树"><a class="markdownIt-Anchor" href="#105-从前序与中序遍历序列构造二叉树"></a> 105、从前序与中序遍历序列构造二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; M; <span class="hljs-comment">// 用于从中序队列中找到前序队列中根的位置</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            M[inorder[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(preorder, <span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; pre, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> inL)</span> </span>&#123;  <span class="hljs-comment">//inL代表中序遍历的左边界</span><br>        <span class="hljs-keyword">if</span> (l &gt; r) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(pre[l]);  <span class="hljs-comment">// 建立好当前的根(前序遍历当前第一个为根)</span><br>        <span class="hljs-keyword">int</span> rootIdx = M[pre[l]];<br>        <span class="hljs-keyword">int</span> lenL = rootIdx - inL; <span class="hljs-comment">// 获取左边界的长度（从中序遍历中获得）</span><br>        root-&gt;left = <span class="hljs-built_in">build</span>(pre, l + <span class="hljs-number">1</span>, l + lenL, inL);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(pre, l + lenL + <span class="hljs-number">1</span>, r, rootIdx + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="剑指offer04二维数组中的查找"><a class="markdownIt-Anchor" href="#剑指offer04二维数组中的查找"></a> 剑指Offer04.二维数组中的查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; array)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> m = array.<span class="hljs-built_in">size</span>(), n = array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (target == array[i][j]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; array[i][j]) &#123;<br>                ++i;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                --j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="23-合并k个排序链表"><a class="markdownIt-Anchor" href="#23-合并k个排序链表"></a> 23、合并K个排序链表</h3><p>利用归并的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">int</span> n;<br>    vector&lt;ListNode*&gt; Ls;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        n = lists.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        Ls = lists;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">conquer</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">conquer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> Ls[l];<br>        <span class="hljs-keyword">int</span> m = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeTwo</span>(<span class="hljs-built_in">conquer</span>(l, m), <span class="hljs-built_in">conquer</span>(m + <span class="hljs-number">1</span>, r)); <span class="hljs-comment">// 这一步将分解问题和合并问题写在了一起</span><br>    &#125;<br>        <br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwo</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!l1) <span class="hljs-keyword">return</span> l2;<br>        <span class="hljs-keyword">if</span> (!l2) <span class="hljs-keyword">return</span> l1;<br>        <span class="hljs-keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;<br>            l1-&gt;next = <span class="hljs-built_in">mergeTwo</span>(l1-&gt;next, l2);<br>            <span class="hljs-keyword">return</span> l1;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            l2-&gt;next = <span class="hljs-built_in">mergeTwo</span>(l1, l2-&gt;next);<br>            <span class="hljs-keyword">return</span> l2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>用空间换时间，小顶堆 + 尾插法从小到大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; minHeap; <span class="hljs-comment">// 小顶堆</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = lists.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            ListNode* cur = lists[i];<br>            <span class="hljs-keyword">while</span> (cur) &#123;<br>                minHeap.<span class="hljs-built_in">push</span>(cur-&gt;val);<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* node = dummy;<br>        <span class="hljs-comment">//小顶堆 + 尾插法 从小到大</span><br>        <span class="hljs-keyword">while</span>(!minHeap.<span class="hljs-built_in">empty</span>())&#123; <br>            node-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(minHeap.<span class="hljs-built_in">top</span>());<br>            minHeap.<span class="hljs-built_in">pop</span>();<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day18"><a class="markdownIt-Anchor" href="#day18"></a> Day18</h2><h3 id="剑指offer-33二叉搜索树的后序遍历序列"><a class="markdownIt-Anchor" href="#剑指offer-33二叉搜索树的后序遍历序列"></a> 剑指Offer 33.二叉搜索树的后序遍历序列</h3><p>找根然后确定左右子树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; sequence)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sequence.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Verify</span>(sequence, <span class="hljs-number">0</span>, sequence.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Verify</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; seq, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;  <span class="hljs-comment">// 每回合判断是否符合规矩</span><br>        <span class="hljs-keyword">if</span>(end - start &lt;= <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">//这个时候就是RD or D </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> rootVal = seq[end];  <span class="hljs-comment">// 获取跟节点的数值</span><br>        <span class="hljs-keyword">int</span> idx = start;<br>        <span class="hljs-keyword">while</span> (idx &lt; end &amp;&amp; seq[idx] &lt; rootVal) &#123;<br>            idx++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> center = idx - <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录一下左右子树的分界点</span><br>        <span class="hljs-comment">// 此时处理leftIdx指向右子树遍历的第一个节点</span><br>        <span class="hljs-keyword">while</span> (idx &lt; end) &#123;<br>            <span class="hljs-keyword">if</span> (seq[idx] &lt; rootVal) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            idx++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Verify</span>(seq, start, center) &amp;&amp; <span class="hljs-built_in">Verify</span>(seq, center + <span class="hljs-number">1</span>, end - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="208-实现trie前缀树"><a class="markdownIt-Anchor" href="#208-实现trie前缀树"></a> 208、实现Trie（前缀树）</h3><p>26分枝的树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span> &#123;</span> <span class="hljs-comment">// 拥有26个分支的字典树</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span>* <span class="hljs-title">dict</span>[26];</span> <span class="hljs-comment">// 这26个数组的索引就代表了他们的字符</span><br>        <span class="hljs-keyword">bool</span> isleaf; <span class="hljs-comment">// 是否是叶子</span><br>    &#125;;<br>    TrieNode* root;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Trie</span>() &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        TrieNode* cur = root; <span class="hljs-comment">// 开始从根开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : word) &#123;<br>            <span class="hljs-keyword">if</span> (!cur-&gt;dict[c - <span class="hljs-string">&#x27;a&#x27;</span>]) cur-&gt;dict[c -<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>(); <span class="hljs-comment">// 如果没有这个字母节点 就给他生成</span><br>            cur = cur-&gt;dict[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        cur-&gt;isleaf = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 到达最后的低端就做个标记</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        TrieNode* cur = root; <span class="hljs-comment">// 开始从根开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : word) &#123;<br>            <span class="hljs-keyword">if</span> (!cur-&gt;dict[c - <span class="hljs-string">&#x27;a&#x27;</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果没有这个字母节点 就是错的</span><br>            cur = cur-&gt;dict[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur-&gt;isleaf; <span class="hljs-comment">// 能到达叶子就说明是有的</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>        TrieNode* cur = root; <span class="hljs-comment">// 开始从根开始</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : prefix) &#123;<br>            <span class="hljs-keyword">if</span> (!cur-&gt;dict[c - <span class="hljs-string">&#x27;a&#x27;</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果没有这个字母节点 就是错的</span><br>            cur = cur-&gt;dict[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 不用到底 只要有就行</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Trie* obj = new Trie();</span><br><span class="hljs-comment"> * obj-&gt;insert(word);</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;search(word);</span><br><span class="hljs-comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="92-反转链表2"><a class="markdownIt-Anchor" href="#92-反转链表2"></a> 92、反转链表2</h3><p>经典好题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next = head;<br>        ListNode* pre = dummy, * cur = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; ++i) &#123;<br>            pre = pre-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; right; ++j) &#123;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-built_in">reverseOne</span>(pre, cur);<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseOne</span><span class="hljs-params">(ListNode* pre, ListNode* next)</span> </span>&#123; <span class="hljs-comment">// pre是上一组的最后一个， next是下一组的第一个</span><br>        <span class="hljs-comment">//尾巴出头接</span><br>        ListNode* last = pre-&gt;next, * cur = last-&gt;next;  <span class="hljs-comment">// last是该组第一个 cur是该组准备换链表头</span><br>        <span class="hljs-keyword">while</span> (cur != next) &#123;<br>            last-&gt;next = cur-&gt;next;<br>            cur-&gt;next = pre-&gt;next;<br>            pre-&gt;next = cur;<br>            cur = last-&gt;next;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>也可以转成数组处理完再放回去（太偷懒了……</p><h3 id="189-轮转数组"><a class="markdownIt-Anchor" href="#189-轮转数组"></a> 189、轮转数组</h3><p>注意题目中的要求是左旋转还是右旋转</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        k = k % nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 每当k循环数组长度的时候就等于没有动</span><br>        <span class="hljs-built_in">reverse</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 这放在最上面是左移动，放在最下面是右移动</span><br>        <span class="hljs-built_in">reverse</span>(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">reverse</span>(nums, k, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-keyword">int</span> temp = nums[l];<br>            nums[l++] = nums[r];<br>            nums[r--] = temp;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day19"><a class="markdownIt-Anchor" href="#day19"></a> Day19</h2><h3 id="428-序列化和反序列化n叉树"><a class="markdownIt-Anchor" href="#428-序列化和反序列化n叉树"></a> 428、序列化和反序列化N叉树</h3><p>这道题网上有问题，所以就直接参考别的大神的解题修改。</p><p>就是序列化和反序列化二叉树的部分进行循环处理n叉树就行。</p><p>大神是存了节点本身的值和孩子的数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    vector&lt;Node*&gt; children;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node() &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        children = _children;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Codec</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(Node* root)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        ostringstream out;<br>        <span class="hljs-built_in">serialize</span>(root,out);<br>        <span class="hljs-keyword">return</span> out.<span class="hljs-built_in">str</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">Node* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">istringstream <span class="hljs-title">in</span><span class="hljs-params">(data)</span></span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">deserialize</span>(in);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(Node* root,ostringstream &amp;out)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(root)<br>        &#123;<br>            out&lt;&lt; root-&gt;val &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            out&lt;&lt; root-&gt;children.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<span class="hljs-comment">//记录子节点个数</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p : root-&gt;children)<br>                <span class="hljs-built_in">serialize</span>(p, out);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            out &lt;&lt; <span class="hljs-string">&quot;N &quot;</span>;  <br>    &#125;<br>    <span class="hljs-function">Node* <span class="hljs-title">deserialize</span><span class="hljs-params">(istringstream &amp;in)</span></span><br><span class="hljs-function">    </span>&#123;<br>        string val;<br>        in &gt;&gt; val;<br>        <span class="hljs-keyword">if</span>(val == <span class="hljs-string">&quot;N&quot;</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        Node* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-built_in">stoi</span>(val));<br>        in &gt;&gt; val;<br>        <span class="hljs-keyword">int</span> n = <span class="hljs-built_in">stoi</span>(val);<br>        <span class="hljs-keyword">while</span>(n--)<span class="hljs-comment">//子节点个数</span><br>        &#123;<br>            Node* p = <span class="hljs-built_in">deserialize</span>(in);<br>            root-&gt;children.<span class="hljs-built_in">push_back</span>(p);<br>        &#125;    <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="24-两两交换链表中的节点"><a class="markdownIt-Anchor" href="#24-两两交换链表中的节点"></a> 24、两两交换链表中的节点</h3><p>可以理解：k个一组翻转链表的特殊情况</p><p>也可以转换成数组做完再回去</p><p>正常递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        ListNode* newHead = head-&gt;next;<br>        head-&gt;next = <span class="hljs-built_in">swapPairs</span>(head-&gt;next-&gt;next); <span class="hljs-comment">// 当前这个组的最后一个接到下一个状态的开头</span><br>        newHead-&gt;next = head; <span class="hljs-comment">// 用新头指向新换位置的那个</span><br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="386-字典序排数"><a class="markdownIt-Anchor" href="#386-字典序排数"></a> 386、字典序排数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>    <span class="hljs-keyword">int</span> N;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">lexicalOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        N = n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; ++i) &#123;<br>            <span class="hljs-built_in">dfs</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123; <span class="hljs-comment">//val为当前遍历的数的大小</span><br>        <span class="hljs-keyword">if</span> (val &gt; N) &#123;  <span class="hljs-comment">//结束条件</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ans.<span class="hljs-built_in">push_back</span>(val);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; ++i) &#123;<br>            <span class="hljs-built_in">dfs</span>(val * <span class="hljs-number">10</span> + i);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="88-合并两个有序数组"><a class="markdownIt-Anchor" href="#88-合并两个有序数组"></a> 88、合并两个有序数组</h3><p>双指针空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-keyword">int</span> m, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l1 = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> l2 = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> len = m + n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (len &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1 &lt; <span class="hljs-number">0</span>) &#123;<br>                nums1[len--] = nums2[l2--];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2 &lt; <span class="hljs-number">0</span>) &#123;<br>                nums1[len--] = nums1[l1--];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[l1] &gt; nums2[l2]) &#123;<br>                nums1[len--] = nums1[l1--];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[l1] &gt; nums2[l2]) &#123;<br>                nums1[len--] = nums1[l1--];<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                nums1[len--] = nums2[l2--];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其他的解法就简单了 只要是空间复杂度不是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>随便做</p><h3 id="273-整数转换英文表示"><a class="markdownIt-Anchor" href="#273-整数转换英文表示"></a> 273、整数转换英文表示</h3><p>分层判断，就是单纯麻烦</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">string <span class="hljs-title">onedigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        string word[] = &#123;<span class="hljs-string">&quot;One &quot;</span>,<span class="hljs-string">&quot;Two &quot;</span>,<span class="hljs-string">&quot;Three &quot;</span>,<span class="hljs-string">&quot;Four &quot;</span>,<span class="hljs-string">&quot;Five &quot;</span>,<span class="hljs-string">&quot;Six &quot;</span>,<span class="hljs-string">&quot;Seven &quot;</span>,<span class="hljs-string">&quot;Eight &quot;</span>,<span class="hljs-string">&quot;Nine &quot;</span>&#125;;<br>        <span class="hljs-keyword">return</span> word[n - <span class="hljs-number">1</span>];<br>    &#125;<br>    <br>    <span class="hljs-function">string <span class="hljs-title">twodigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">10</span>) &#123;<br>            ans += <span class="hljs-built_in">onedigit</span>(n);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">19</span>) &#123;<br>            string word[]=&#123;<span class="hljs-string">&quot;Twenty &quot;</span>,<span class="hljs-string">&quot;Thirty &quot;</span>,<span class="hljs-string">&quot;Forty &quot;</span>,<span class="hljs-string">&quot;Fifty &quot;</span>,<span class="hljs-string">&quot;Sixty &quot;</span>,<span class="hljs-string">&quot;Seventy &quot;</span>,<span class="hljs-string">&quot;Eighty &quot;</span>,<span class="hljs-string">&quot;Ninety &quot;</span>&#125;;<br>            ans += word[n / <span class="hljs-number">10</span> - <span class="hljs-number">2</span>] + <span class="hljs-built_in">onedigit</span>(n % <span class="hljs-number">10</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            string word[]=&#123;<span class="hljs-string">&quot;Ten &quot;</span>,<span class="hljs-string">&quot;Eleven &quot;</span>,<span class="hljs-string">&quot;Twelve &quot;</span>,<span class="hljs-string">&quot;Thirteen &quot;</span>,<span class="hljs-string">&quot;Fourteen &quot;</span>,<span class="hljs-string">&quot;Fifteen &quot;</span>,<span class="hljs-string">&quot;Sixteen &quot;</span>,<span class="hljs-string">&quot;Seventeen &quot;</span>,<span class="hljs-string">&quot;Eighteen &quot;</span>,<span class="hljs-string">&quot;Nineteen &quot;</span>&#125;;<br>            ans += word[n - <span class="hljs-number">10</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">threedigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">int</span> hundred = n / <span class="hljs-number">100</span>; <span class="hljs-comment">//确定百位数的值</span><br>        n %= <span class="hljs-number">100</span>; <span class="hljs-comment">// 获取个位和十位</span><br>        <span class="hljs-keyword">if</span> (hundred) &#123;<br>            ans += <span class="hljs-built_in">onedigit</span>(hundred) + <span class="hljs-string">&quot;Hundred &quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n) &#123;<br>            ans += <span class="hljs-built_in">twodigit</span>(n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">numberToWords</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Zero&quot;</span>;<br>        &#125;<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> billion = num / <span class="hljs-number">1e9</span>;<br>        num %= <span class="hljs-number">1000000000</span>;<br>        <span class="hljs-keyword">if</span> (billion) &#123;<br>            ans += <span class="hljs-built_in">threedigit</span>(billion) + <span class="hljs-string">&quot;Billion &quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> million = num / <span class="hljs-number">1e6</span>;<br>        num %= <span class="hljs-number">1000000</span>;<br>        <span class="hljs-keyword">if</span> (million) &#123;<br>            ans += <span class="hljs-built_in">threedigit</span>(million) + <span class="hljs-string">&quot;Million &quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> thousand = num / <span class="hljs-number">1e3</span>;<br>        num %= <span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">if</span> (thousand) &#123;<br>            ans += <span class="hljs-built_in">threedigit</span>(thousand) + <span class="hljs-string">&quot;Thousand &quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">//最后判断最后三位</span><br>        <span class="hljs-keyword">if</span> (num) &#123;<br>            ans += <span class="hljs-built_in">threedigit</span>(num);<br>        &#125;<br>        ans.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 去除最后的空格</span><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day20"><a class="markdownIt-Anchor" href="#day20"></a> Day20</h2><h3 id="89-格雷编码"><a class="markdownIt-Anchor" href="#89-格雷编码"></a> 89、格雷编码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">find</span>(n - <span class="hljs-number">1</span>); <span class="hljs-comment">// 递归处理</span><br>        <span class="hljs-keyword">int</span> last = ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 从当前状态下最后一个数开始逐个处理，</span><br>        <span class="hljs-comment">//例如n == 2 将 1 左移动（n - 1）位后与 00 相加-&gt; 01 </span><br>        <span class="hljs-comment">//1 左移动（n - 1）位后与 01 相加-&gt; 11</span><br>        <span class="hljs-comment">//两两对应</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = last; i &gt;= <span class="hljs-number">0</span>; --i) &#123; <br>            ans.<span class="hljs-built_in">push_back</span>(ans[i] + (<span class="hljs-number">1</span> &lt;&lt; (n - <span class="hljs-number">1</span>)));<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">grayCode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-built_in">find</span>(n);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="384-打乱数组"><a class="markdownIt-Anchor" href="#384-打乱数组"></a> 384、打乱数组</h3><p><strong>洗牌算法Knuth-Shuffle大神</strong></p><p>算法可简单表述为：将最后一个数和前面任意 n-1个数中的一个数进行交换（也可以不换），然后倒数第二个数和前面任意 n-2 个数中的一个数进行交换，如此往复直到最后一个元素，就完成了洗牌，该算法保证了每个元素在每个位置的概率都是相等的。</p><p>Prove:</p><p>为什么是相等的呢？可以举例说明！</p><p>比如12345是最初的排列，从最后一个数5开始。</p><p>**第一轮：**5跟12345换的概率都是相等的，比如随机出了2，因为下一轮要从倒数第二个开始了，所以2肯定就在最后一位了，现在就是15342，因为是五个数里面选一个，所以2在最后一位的概率就是1/5；</p><p>**第二轮：**不算最后一个数2，还剩1534，轮到4选一个，比如选了3，交换完就是1543，那么3出现在第4个位置的概率是多少呢？因为第一轮五个选一个没选中3的概率是4/5，这一轮是四个选一个，1/4，所以3在第四位的概率就是4/5 * 1/4 = 1/5；</p><p>**第三轮：**不算最后两个数32，还剩154，轮到4选一个，比如选了自己，交换完就还是154，那么4出现在第三个位置的概率就是，4/5（第一轮没选4）*3/4（第二轮没选4）*1/3（第三轮选了4） = 1/5；</p><p>以此类推，就会发现，每个元素在每个位置的概率都是1/5，真正的做到了乱！（当然这个东西可以用严谨的数学证明验证）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; arr;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        arr = nums;<br>    &#125;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">shuffle</span><span class="hljs-params">()</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; a = arr;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-built_in">swap</span>(a[i], a[<span class="hljs-built_in">rand</span>() % (i + <span class="hljs-number">1</span>)]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Solution object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Solution* obj = new Solution(nums);</span><br><span class="hljs-comment"> * vector&lt;int&gt; param_1 = obj-&gt;reset();</span><br><span class="hljs-comment"> * vector&lt;int&gt; param_2 = obj-&gt;shuffle();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="160-相交链表"><a class="markdownIt-Anchor" href="#160-相交链表"></a> 160、相交链表</h3><p>设公共部分的长度为c，两者不同部分的分别为a和b，那么结果为a+c和b+c。</p><p>则当双方都过a + b + c时只剩下c了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode* l1 = headA, * l2 = headB;<br>        <span class="hljs-keyword">while</span>(l1 != l2)&#123;<br>            l1 = !l1 ? headB: l1-&gt;next;<br>            l2 = !l2 ? headA: l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="62-独一无二的路径"><a class="markdownIt-Anchor" href="#62-独一无二的路径"></a> 62、独一无二的路径</h3><p>简单动态规划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            dp[i] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 第一行的走法只有一种</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i) &#123; <span class="hljs-comment">// 第一行处理过了</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                dp[j] += dp[j - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 将向下和向右的方法数量加在一起</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>也可以直接用数学公式求解，这是一个组合问题。机器人总共移动的次数 S=m+n-2，向下移动的次数 D=m-1，那么问题可以看成从 S 中取出 D 个位置的组合数量，这个问题的解为 C(S, D)。</p><p>S = m - 1 + n - 1</p><p>只会用java 不会c++数据结构出问题了:)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> S = m + n - <span class="hljs-number">2</span>;  <span class="hljs-comment">// 总共的移动次数</span><br>    <span class="hljs-keyword">int</span> D = m - <span class="hljs-number">1</span>;      <span class="hljs-comment">// 向下的移动次数</span><br>    <span class="hljs-keyword">long</span> ret = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= D; i++) &#123;<br>        ret = ret * (S - D + i) / i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="51-n皇后问题"><a class="markdownIt-Anchor" href="#51-n皇后问题"></a> 51、N皇后问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    <span class="hljs-keyword">int</span> N;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-keyword">int</span> n) &#123;<br>        vector&lt;string&gt; temp;<br>        string t = <span class="hljs-string">&quot;&quot;</span>;<br>        N = n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            t += <span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(t);<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(temp, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;string&gt;&amp; temp, <span class="hljs-keyword">int</span> row)</span> </span>&#123; <span class="hljs-comment">// row记录我们遍历到了第几行</span><br>        <span class="hljs-keyword">if</span> (row == N) &#123; <span class="hljs-comment">//完成目标</span><br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123; <span class="hljs-comment">// i是列</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">valid</span>(temp, row, i)) &#123;<br>                temp[row][i] = <span class="hljs-string">&#x27;Q&#x27;</span>; <span class="hljs-comment">// 放皇后</span><br>                <span class="hljs-built_in">dfs</span>(temp, row + <span class="hljs-number">1</span>); <span class="hljs-comment">// 去下一行弄</span><br>                temp[row][i] = <span class="hljs-string">&#x27;.&#x27;</span>; <span class="hljs-comment">// 拿走皇后</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">valid</span><span class="hljs-params">(vector&lt;string&gt;&amp; temp, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>        <span class="hljs-comment">// 检测改行上方是否有</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (temp[i][c] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//检测左上方是否有</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = r, j = c; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; --i, --j) &#123;<br>            <span class="hljs-keyword">if</span> (temp[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//检测右上方是否有</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = r, j = c; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt;= N; --i, ++j) &#123;<br>            <span class="hljs-keyword">if</span> (temp[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day21"><a class="markdownIt-Anchor" href="#day21"></a> Day21</h2><h3 id="912-手撕排序数组"><a class="markdownIt-Anchor" href="#912-手撕排序数组"></a> 912、手撕排序数组</h3><p>从此以后所有的排序任务都手撕</p><h4 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// quickSort</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span> <span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pivot = nums[low]; <span class="hljs-comment">// 将第一个数作为我们的标准轴</span><br>        <span class="hljs-keyword">int</span> l = low, h = high;<br>        <span class="hljs-keyword">while</span> (l &lt; h) &#123; <span class="hljs-comment">// 当左边界小于右边界我们再继续</span><br>            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; pivot &lt;= nums[h]) --h;<span class="hljs-comment">// 包含等于</span><br>            <span class="hljs-keyword">if</span> (l &lt; h) nums[l] = nums[h];<br>            <span class="hljs-keyword">while</span> (l &lt; h &amp;&amp; pivot &gt;= nums[l]) ++l;<span class="hljs-comment">// 包含等于</span><br>            <span class="hljs-keyword">if</span> (l &lt; h) nums[h] = nums[l];<br>        &#125;<br>        nums[l] = pivot; <span class="hljs-comment">// 出来的时候一定是l == h 的情况</span><br>        <span class="hljs-keyword">return</span> l; <span class="hljs-comment">// 返回轴的位置</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (low &gt;= high) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> pivot = <span class="hljs-built_in">partition</span>(nums, low, high);<br>        <span class="hljs-built_in">quicksort</span>(nums, low, pivot);<br>        <span class="hljs-built_in">quicksort</span>(nums, pivot + <span class="hljs-number">1</span>, high);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">quicksort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; copy, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (low &gt;= high) &#123;  <span class="hljs-comment">//先设立推出条件</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 找到中心位置</span><br>        <span class="hljs-comment">// divide 关注一下copy和nums交换位置，因为这样可以将正确顺序的数组传入上一个状态</span><br>        <span class="hljs-built_in">mergesort</span>(copy, nums, low, mid);<br>        <span class="hljs-built_in">mergesort</span>(copy, nums, mid + <span class="hljs-number">1</span>, high);<br>        <span class="hljs-comment">// merge</span><br>        <span class="hljs-keyword">int</span> l = mid, h = high;<br>        <span class="hljs-keyword">int</span> len = high;<br>        <span class="hljs-keyword">while</span> (l &gt;= low &amp;&amp; h &gt; mid) &#123;<br>            <span class="hljs-keyword">if</span> (nums[l] &lt; nums[h]) &#123;<br>                copy[len--] = nums[h--];<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                copy[len--] = nums[l--];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (l &gt;= low) &#123;<br>            copy[len--] = nums[l--];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (h &gt; mid) &#123;<br>            copy[len--] = nums[h--];<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">copy</span><span class="hljs-params">(nums.begin(), nums.end())</span></span>;<br>        <span class="hljs-built_in">mergesort</span>(nums, copy, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);  <span class="hljs-comment">// 为什么copy是正确答案因为 最顶层就是把正确答案放入了copy</span><br>        <span class="hljs-keyword">return</span> copy;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">minHeap</span>&#123;</span><br>        <span class="hljs-keyword">private</span>:<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; H;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-built_in">minHeap</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>                H.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);  <span class="hljs-comment">// 把第一位空出来</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>                    H.<span class="hljs-built_in">push_back</span>(num);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 注意这里的堆排序我们用的是索引 1 ～ n 这样好计算</span><br>            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapadjust</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>                <span class="hljs-keyword">int</span> rc = H[s];<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span> * s; j &lt;= m; j *= <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// *=2 往下找孩子</span><br>                    <span class="hljs-keyword">if</span> (j &lt; m &amp;&amp; H[j] &gt; H[j + <span class="hljs-number">1</span>]) j++; <span class="hljs-comment">// 选择大的分支走下去，因为我们是小顶堆 （因为小顶堆先输出小的数 我们只需要push_back插入就行） j &lt; m 防止 j = m 再 + 1 超界限</span><br>                    <span class="hljs-keyword">if</span> (rc &lt;= H[j]) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//（rc只要小于等于当前节点的 儿子j，我们就停下来放好那个值) 等于也算上</span><br>                    <span class="hljs-comment">//这两步为了将符合要求的小节点往上移动</span><br>                    H[s] = H[j];<br>                    s = j; <span class="hljs-comment">//s永远代表父亲节点</span><br>                &#125;<br>                H[s] = rc; <span class="hljs-comment">//再把当前处理的节点放到对应的位置</span><br>            &#125;<br>        <br>            <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">heapsort</span><span class="hljs-params">()</span> </span>&#123;<br>                vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>                <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = H.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 因为有一个第0位 所以排除掉</span><br>                <span class="hljs-comment">// 先构建出堆</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123; <span class="hljs-comment">// 1 ～ n为有效数据</span><br>                    <span class="hljs-built_in">heapadjust</span>(i, n);<br>                &#125;<br>                cout &lt;&lt; endl;<br>                <span class="hljs-comment">// 然后输出结果</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i &gt; <span class="hljs-number">1</span>; --i) &#123;  <span class="hljs-comment">// 不需要处理第一个 因为还剩两个的时候也就是一个有效一个无效，我们已经放好了那个有效的</span><br>                    ans.<span class="hljs-built_in">push_back</span>(H[<span class="hljs-number">1</span>]);<br>                    <span class="hljs-built_in">swap</span>(H[<span class="hljs-number">1</span>], H[i]); <span class="hljs-comment">// 将大顶放到最后，这样只需要调整 i - 1 位置的就可以得到最终的结果了 这样循环就可以找到第二个大的以此类推</span><br>                    <span class="hljs-built_in">heapadjust</span>(<span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>); <span class="hljs-comment">// 新上位的在1的位置，然后只需要调整1 ～ i - 1 这样就相当于吧刚才存入的那个扔出去了</span><br>                &#125;<br>                ans.<span class="hljs-built_in">push_back</span>(H[<span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br>    &#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        minHeap* H = <span class="hljs-keyword">new</span> <span class="hljs-built_in">minHeap</span>(nums);<br>        <span class="hljs-keyword">return</span> H-&gt;<span class="hljs-built_in">heapsort</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="179-最大数"><a class="markdownIt-Anchor" href="#179-最大数"></a> 179、最大数</h3><p>可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，应该比较的是S1+S2 和S2+S1的大小，如果S1+S2 &lt; S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。</p><p>注意⚠️：cmp返回值的实际意义是传入a、b两个参数，a在前b在后的排序是否是正确的，若是正确的返回1（true），否则返回0（false）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;string&gt; dicts;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-keyword">static</span> <span class="hljs-title">cmp</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b &gt; b + a;  <span class="hljs-comment">// 如果ab 比 ba大的话 就说明这个排序是true的 不需要改变 当 ab 比 ba小的时候为false 那么这个排序就是不正确的 需要改变排列</span><br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">largestNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>            dicts.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">to_string</span>(num));<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(dicts.<span class="hljs-built_in">begin</span>(), dicts.<span class="hljs-built_in">end</span>(), cmp);<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> dict : dicts) &#123;<br>            ans += dict;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dicts[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;0&quot;</span> ? dicts[<span class="hljs-number">0</span>] : ans; <span class="hljs-comment">// 这个判断为了防止出现00的情况</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day22"><a class="markdownIt-Anchor" href="#day22"></a> Day22</h2><h3 id="123-买卖股票的最佳时机三"><a class="markdownIt-Anchor" href="#123-买卖股票的最佳时机三"></a> 123、买卖股票的最佳时机三</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-comment">// 用两个数组保存两个状态 </span><br>        <span class="hljs-comment">// buy数组 ： 如果当前是买的情况下这个最好结果是什么（注意买的时候需要将之前的所有股票清空）</span><br>        <span class="hljs-comment">// sell数组 ： 如果当前是卖的情况下这个最好结果是什么</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">buy</span><span class="hljs-params">(<span class="hljs-number">3</span>, INT_MIN)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sell</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> price : prices) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span>; ++i) &#123; <span class="hljs-comment">// 遍历不大于两次的买卖的情况</span><br>                buy[i] = <span class="hljs-built_in">max</span>(buy[i], sell[i - <span class="hljs-number">1</span>] - price);  <span class="hljs-comment">// 因为是负数 所以我们让他价格绝对值最小 也就是去最大值</span><br>                sell[i] = <span class="hljs-built_in">max</span>(sell[i], buy[i] + price);  <span class="hljs-comment">// 这个也就是我们当前最好的利润</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sell[<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="40-组合总和2"><a class="markdownIt-Anchor" href="#40-组合总和2"></a> 40、组合总和2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; ans;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; can;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">101</span>, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">int</span> tar; <span class="hljs-comment">// 记录目标值</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; candidates, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>());<br>        can = candidates;<br>        tar = target;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (t &gt; tar) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 加出界了就不算了</span><br>        <span class="hljs-keyword">if</span> (t == tar) &#123;  <span class="hljs-comment">// 当数值够了 就存一波</span><br>            ans.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = s; i &lt; can.<span class="hljs-built_in">size</span>(); ++i) &#123; <span class="hljs-comment">// 设置s因为我们没必要往回去找，往回找那是全排列</span><br>            <span class="hljs-keyword">if</span> (!vis[i]) &#123;<br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; !vis[i - <span class="hljs-number">1</span>] &amp;&amp; can[i] == can[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 当前这个的前一个我们未处理，但是却相等。等于是开始的东西是相同的，所以我们就没必要计算了</span><br>                vis[i] = <span class="hljs-literal">true</span>;<br>                temp.<span class="hljs-built_in">push_back</span>(can[i]);<br>                <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, t + can[i]);<br>                temp.<span class="hljs-built_in">pop_back</span>();<br>                vis[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="392-字符串解码"><a class="markdownIt-Anchor" href="#392-字符串解码"></a> 392、字符串解码</h3><p>双栈解法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; sn; <span class="hljs-comment">// 记录重复次数的</span><br>    stack&lt;string&gt; sc; <span class="hljs-comment">// 记录内容的 PS：栈底一直是最初的状态</span><br>    string tn = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 记录所需要的值</span><br>    string ans = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 记录内容</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;  <span class="hljs-comment">//只要是数字就统计一波</span><br>                tn += c;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                sn.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(tn));  <span class="hljs-comment">// 存储一波次数状态</span><br>                sc.<span class="hljs-built_in">push</span>(ans); <span class="hljs-comment">// 存储一波数字状态</span><br>                <span class="hljs-comment">// 状态清空</span><br>                tn = <span class="hljs-string">&quot;&quot;</span>;<br>                ans = <span class="hljs-string">&quot;&quot;</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>                string con = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// 用来更新现在的结果</span><br>                <span class="hljs-comment">// 获取状态字需要输出的次数</span><br>                <span class="hljs-keyword">int</span> num = sn.<span class="hljs-built_in">top</span>();<br>                sn.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">// 按照括号内容以及次数制作结果</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i) &#123;<br>                    con += ans;<br>                &#125;<br>                <span class="hljs-comment">// 这里这么处理的话，只要是最后一个]遇到之后一定会吧栈底的那个答案提取出来并拼接</span><br>                ans = sc.<span class="hljs-built_in">top</span>() + con;  <span class="hljs-comment">// 与上一个状态进行拼接，更新答案【如果是嵌套ing，那就是更新当前嵌套的内容，如果里面是空的，那就是单纯的更新答案】</span><br>                sc.<span class="hljs-built_in">pop</span>();<br>            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 如果是内容</span><br>                ans += c;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>DFS递归解法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    string S;<br>    <span class="hljs-function">string <span class="hljs-title">decode</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; i)</span> </span>&#123; <span class="hljs-comment">// 这里必须是引用需要把整个值传递下去</span><br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; S.<span class="hljs-built_in">size</span>() &amp;&amp; S[i] != <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;a&#x27;</span> &lt;= S[i] &amp;&amp; S[i] &lt;= <span class="hljs-string">&#x27;z&#x27;</span>) &#123;<br>                res += S[i++];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;0&#x27;</span> &lt;= S[i] &amp;&amp; S[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                <span class="hljs-keyword">int</span> freq = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录需要循环的次数</span><br>                <span class="hljs-keyword">while</span> (<span class="hljs-string">&#x27;0&#x27;</span> &lt;= S[i] &amp;&amp; S[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                    freq = freq * <span class="hljs-number">10</span> + S[i++] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                &#125;<br>                <span class="hljs-comment">// 数字后面必定是 &#x27;[&#x27;</span><br>                i++; <span class="hljs-comment">// 所以这里需要往下走一个</span><br>                string t = <span class="hljs-built_in">decode</span>(i);<br>                i++; <span class="hljs-comment">//出来的时候一定是不满足（i &lt; S.size() &amp;&amp; S[i] != &#x27;]&#x27;）所以这里再往下一个</span><br>                <span class="hljs-keyword">while</span> (freq--) &#123; <span class="hljs-comment">// 给当前状态的结果处理好</span><br>                    res += t;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        S = s;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">decode</span>(i);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day23"><a class="markdownIt-Anchor" href="#day23"></a> Day23</h2><h3 id="907-子数组最小值之和"><a class="markdownIt-Anchor" href="#907-子数组最小值之和"></a> 907、子数组最小值之和</h3><p>dp解法</p><p>我们其实关心的是以某个数字结尾时的子数组最小值之和，可以用一个一维数组 dp，其中 dp[i] 表示以数字 arr[i] 结尾的所有子数组最小值之和，将 dp[0] 初始化为 arr[0]，结果 res 也初始化为 arr[0]。然后从第二个数字开始遍历，若大于等于前一个数字，则当前 dp[i] 赋值为 dp[i-1]+arr[i]，前面的分析已经解释了，当前数字 arr[i] 组成了新的子数组，同时由于 arr[i] 不会影响最小值，所以要把之前的最小值之和再加一遍。假如小于前一个数字，就需要向前遍历，去找到第一个小于 arr[i] 的位置j，假如j小于0，表示前面所有的数字都是小于 arr[i] 的，那么 arr[i] 是前面 i+1 个以 arr[i] 结尾的子数组的最小值，累加和为 (i+1) x arr[i]，若j大于等于0，则需要分成两部分累加，dp[j] + (i-j)xA[i]，这个也不难理解，前面有 i-j 个以 arr[i] 为结尾的子数组的最小值是 arr[i]，而再前面的子数组的最小值就不是 arr[i] 了，但是还是需要加上一遍其本身的最小值之和，因为每个子数组末尾都加上 arr[i] 均可以组成一个新的子数组，最终的结果 res 就是将 dp 数组累加起来即可，别忘了对超大数取余，参见代码如下（现在这种方法已经超时 TLE 了）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumSubarrayMins</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> res = arr[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 先得把第一个算上</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">dp</span>(n);<br>        dp[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &gt;= arr[i - <span class="hljs-number">1</span>]) dp[i] = dp[i - <span class="hljs-number">1</span>] + arr[i];<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[i] &lt; arr[j]) &#123;  <span class="hljs-comment">//向左扫描找到第一个a[j] &lt;= a[i]</span><br>                    j--;<br>                &#125;<br>                <span class="hljs-comment">// 如果j小于0 说明所有的都比i大 所有的最小值都是arr[i] 包括一个 arr[i]自身的子集</span><br>                dp[i] = (j &lt; <span class="hljs-number">0</span>) ? (i + <span class="hljs-number">1</span>) * arr[i] : (dp[j] + (i - j) * arr[i]);<br>            &#125;<br>            res = (res + dp[i]) % M; <span class="hljs-comment">// 每次算出当前结果记录一波</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面的方法虽然 work，但不是很高效，原因是在向前找第一个小于当前的数字，每次都要线性遍历一遍，造成了平方级的时间复杂度。而<strong>找每个数字的前小数字或是后小数字，正是单调栈擅长</strong>的，可以参考博主之前的总结贴 <a href="http://www.cnblogs.com/grandyang/p/8887985.html">LeetCode Monotonous Stack Summary 单调栈小结</a>。这里我们用一个单调栈来保存之前一个小的数字的位置，栈里先提前放一个 -1，作用会在之后讲解。还是需要一个 dp 数组，跟上面的定义基本一样，但是为了避免数组越界，将长度初始化为 n+1，其中 dp[i] 表示以数字 arr[i-1] 结尾的所有子数组最小值之和。对数组进行遍历，当栈顶元素不是 -1 且 arr[i] 小于等于栈顶元素，则将栈顶元素移除。这样栈顶元素就是前面第一个比 arr[i] 小的数字，此时 dp[i+1] 更新还是跟之前一样，分为两个部分，由于知道了前面第一个小于 arr[i] 的数字位置，用当前位置减去栈顶元素位置再乘以 arr[i]，就是以 arr[i] 为结尾且最小值为 arr[i] 的子数组的最小值之和，而栈顶元素之前的子数组就不受 arr[i] 影响了，直接将其 dp 值加上即可。将当前位置压入栈，并将 dp[i+1] 累加到结果 res，同时对超大值取余，参见代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> M = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumSubarrayMins</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; st&#123;&#123;<span class="hljs-number">-1</span>&#125;&#125;;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;  <span class="hljs-comment">// dp[0] 就是单独的一个</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (st.<span class="hljs-built_in">top</span>() != <span class="hljs-number">-1</span> &amp;&amp; arr[i] &lt;= arr[st.<span class="hljs-built_in">top</span>()]) &#123;  <span class="hljs-comment">// 为栈保留一个-1 用于找dp[0] 如果还有别的那就是当前最小值的下标 或者是</span><br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-comment">// st.top() + 1 就是存的当前比你小的 【这个太妙了 这里如果是i - 1 那么变成了 dp[i] + arr[i]】</span><br>            dp[i + <span class="hljs-number">1</span>] = (dp[st.<span class="hljs-built_in">top</span>() + <span class="hljs-number">1</span>] + (i - st.<span class="hljs-built_in">top</span>()) * arr[i]) % M;<br>            st.<span class="hljs-built_in">push</span>(i);<br>            res = (res + dp[i + <span class="hljs-number">1</span>]) % M;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="322-零钱兑换"><a class="markdownIt-Anchor" href="#322-零钱兑换"></a> 322、零钱兑换</h3><p>完全背包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (amount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 防止出现amount == 0的边界条件</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> coin : coins) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = coin; j &lt;= amount; ++j) &#123; <span class="hljs-comment">// 因为是完全背包，所以这里是正序的</span><br>                <span class="hljs-keyword">if</span> (j == coin) &#123; <span class="hljs-comment">// 这个时候只能装下这个同样大小的硬币是最小值</span><br>                    dp[j] = <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[j] == <span class="hljs-number">0</span> &amp;&amp; dp[j - coin] != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 说明当前这个大小的包没有被正好放下（包括不是正好可以放下一枚硬币）此时放下这颗硬币正好放下</span><br>                    <span class="hljs-comment">//dp[j - coin] != 0 代表我之前已经装过硬币了，不会出现硬币放入后不能满足最终结果的情况比如[2] 3 是非法的</span><br>                    <span class="hljs-comment">// 这句话是为了确保我们是按照装满进行的操作 但是因为dp[j] == 0 所以没处理过 用min的话那结果一致是0了 就错了</span><br>                    dp[j] = dp[j - coin] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dp[j - coin] != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 说明至少放了一种硬币</span><br>                    dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - coin] + <span class="hljs-number">1</span>);  <br>                &#125; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="96-不同的二叉搜索树"><a class="markdownIt-Anchor" href="#96-不同的二叉搜索树"></a> 96、不同的二叉搜索树</h3><p>直接卡特兰数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup><mo>−</mo><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mfrac><msubsup><mi>C</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>n</mi></msubsup><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">C^n_{2n} - C^{n + 1}_{2n} = \frac{C^n_{2n}}{n + 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.931438em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.120547em;vertical-align:-0.266308em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.430511em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.02718em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5102em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7385428571428572em;"><span style="top:-2.214em;margin-left:-0.07153em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> res = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n + <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; ++i) &#123;<br>            res = res * i / (i - n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res / (n + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205201118746.png" alt="截屏2022-05-20 上午11.18.32" /></p><p>至于这里为什么是左子树乘以右子树是因为这是全排列问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>, dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>                dp[i] += dp[j] * dp[i - j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day24"><a class="markdownIt-Anchor" href="#day24"></a> Day24</h2><h3 id="198-打家劫舍"><a class="markdownIt-Anchor" href="#198-打家劫舍"></a> 198、打家劫舍</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;  <span class="hljs-comment">// 存储到第n个的最大值</span><br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]); <span class="hljs-comment">// 其实就是选和不选当前的两个状态</span><br>            <span class="hljs-comment">// 只不过当我们选的时候一定是上上个状态的最大值 + 当前这个</span><br>            <span class="hljs-comment">// 如果不选的话 那我们可以选择上一个状态的最大值，因为我不选所以我可以贴着</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="day25"><a class="markdownIt-Anchor" href="#day25"></a> Day25</h2><h3 id="143-重排链表"><a class="markdownIt-Anchor" href="#143-重排链表"></a> 143、重排链表</h3><p>利用多余空间完成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; temp; <span class="hljs-comment">// 用数组转换一下</span><br>        ListNode* node = head-&gt;next;<br>        <span class="hljs-keyword">while</span> (node) &#123;<br>            temp.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            node = node-&gt;next;<br>        &#125;<br>        ListNode* newLink = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = temp.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res; <span class="hljs-comment">// 这里存储最后的结果</span><br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp[r--]);<br>            res.<span class="hljs-built_in">push_back</span>(temp[l++]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l == r) res.<span class="hljs-built_in">push_back</span>(temp[l]);<br>        ListNode* tail = newLink;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> r : res) &#123;<br>            ListNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(r);<br>            tail-&gt;next = newNode;<br>            tail = newNode;<br>        &#125;<br>        head-&gt;next = newLink-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221040826.png" alt="截屏2022-05-22 上午10.40.38" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 非递归版本</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseNo</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span> (head) &#123;<br>            ListNode* next = head-&gt;next;<br>            head-&gt;next = dummy;<br>            dummy = head;<br>            head = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy;<br>    &#125;<br>    <span class="hljs-comment">// 递归版本</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        ListNode* nextNode = head-&gt;next;<br>        ListNode* newHead = <span class="hljs-built_in">reverse</span>(head-&gt;next); <span class="hljs-comment">// 去获取新头</span><br>        nextNode-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// head 就是当前节点</span><br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>    <span class="hljs-comment">// 1 2</span><br>    <span class="hljs-comment">// 1 2 4 5 6</span><br>    <span class="hljs-comment">// 6 5 4</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123; <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 存一下状态</span><br>            ListNode* l1next = l1-&gt;next;<br>            ListNode* l2next = l2-&gt;next;<br>            l1-&gt;next = l2;<br>            <span class="hljs-keyword">if</span> (!l1next) &#123;  <span class="hljs-comment">// 如果空了就结束 后面也不用操作了</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            l2-&gt;next = l1next;<br>            l1 = l1next;<br>            l2 = l2next;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span>;<br>        ListNode* slow = head, * fast = head, * pre;<br>        <span class="hljs-comment">// 找中点分裂两者</span><br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>            pre = slow;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        pre-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//此时 slow是下一组节点的头 如果是奇数个的话后面更多 前面少</span><br>        <span class="hljs-comment">// l1 为head l2 为slow 反转l2</span><br>        ListNode* l2 = <span class="hljs-built_in">reverse</span>(slow);<br>        <span class="hljs-comment">// 合并</span><br>        <span class="hljs-built_in">merge</span>(head, l2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="109-有序链表转换二叉搜索树"><a class="markdownIt-Anchor" href="#109-有序链表转换二叉搜索树"></a> 109、有序链表转换二叉搜索树</h3><p>这道题的关键在于找到根节点的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (!head-&gt;next)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(head-&gt;val);<br>        ListNode* pre = <span class="hljs-built_in">getRoot</span>(head), * cur = pre-&gt;next; <span class="hljs-comment">// 获得中间节点就是根</span><br>        pre-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 分开左边和右边 // 左头为head 右头为cur-&gt;next</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(cur-&gt;val);<br>        root-&gt;left = <span class="hljs-built_in">sortedListToBST</span>(head);<br>        root-&gt;right = <span class="hljs-built_in">sortedListToBST</span>(cur-&gt;next);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-comment">// 获得中间节点的</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">getRoot</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* slow = head, * fast = head, * pre;<br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>            pre = slow;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1233-删除子文件夹"><a class="markdownIt-Anchor" href="#1233-删除子文件夹"></a> 1233、删除子文件夹</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span>&#123;</span><br>        <span class="hljs-keyword">private</span>:<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span> &#123;</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span>* <span class="hljs-title">branch</span>[26];</span> <span class="hljs-comment">// 每一个节点有26个分支</span><br>                <span class="hljs-keyword">bool</span> isleaf; <span class="hljs-comment">//是否是叶子</span><br>            &#125;* root;<br>        <span class="hljs-keyword">public</span>:<br>            <span class="hljs-built_in">Trie</span>() &#123;<br>                root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>(); <span class="hljs-comment">// 作为每次处理的起点</span><br>            &#125;<br>            <span class="hljs-comment">// [&quot;/a/b/c&quot;,&quot;/a/b/ca&quot;,&quot;/a/b/d&quot;]</span><br>            <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">insert</span><span class="hljs-params">(string s)</span> </span>&#123;  <span class="hljs-comment">// 这里是将插入和判断是否是前缀联系在一起了</span><br>                TrieNode* node = root;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                    <span class="hljs-keyword">char</span> c = s[i];<br>                    <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-keyword">if</span> (!node-&gt;branch[c - <span class="hljs-string">&#x27;a&#x27;</span>]) &#123; <span class="hljs-comment">// 如果这个路径上字符没有遇到过</span><br>                        node-&gt;branch[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>                    &#125;<br>                    node = node-&gt;branch[c - <span class="hljs-string">&#x27;a&#x27;</span>];  <span class="hljs-comment">// 走入到下一层</span><br>                    <span class="hljs-keyword">if</span> (s[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;/&#x27;</span> &amp;&amp; node-&gt;isleaf) &#123; <span class="hljs-comment">// 说明了还有 并且 已经到了之前的子串的结尾了 已经找到了当前情况的子串【只有下一个是‘/’且没有比完的时候才有意义】</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>                node-&gt;isleaf = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 成功插入了</span><br>            &#125;<br>    &#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">removeSubfolders</span><span class="hljs-params">(vector&lt;string&gt;&amp; folder)</span> </span>&#123;<br>        Trie* trie = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>        <span class="hljs-built_in">sort</span>(folder.<span class="hljs-built_in">begin</span>(), folder.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 排序为了让小的短的 在前</span><br>        vector&lt;string&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> f : folder) &#123;<br>            <span class="hljs-keyword">if</span> (trie-&gt;<span class="hljs-built_in">insert</span>(f)) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(f);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202205221409758.png" alt="截屏2022-05-22 下午2.08.57" /></p><p>sort的意义</p>]]></content>
    
    
    <categories>
      
      <category>算法练习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Leecode Top200</title>
    <link href="/2022/03/09/leecode/"/>
    <url>/2022/03/09/leecode/</url>
    
    <content type="html"><![CDATA[<h1 id="算法思想"><a class="markdownIt-Anchor" href="#算法思想"></a> 算法思想</h1><h2 id="一-双指针"><a class="markdownIt-Anchor" href="#一-双指针"></a> 一、双指针</h2><h3 id="1-有序数组的two-sum"><a class="markdownIt-Anchor" href="#1-有序数组的two-sum"></a> 1、有序数组的Two Sum</h3><blockquote><p>Input: numbers={2, 7, 11, 15}, target=9<br />Output: index1=1, index2=2</p></blockquote><p><strong>题目描述</strong>：在有序数组中找出两个数，使它们的和为 target。</p><p>使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p><ul><li>如果两个指针指向元素的和 sum == target，那么得到要求的结果；</li><li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li><li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li></ul><p>数组中的元素最多遍历一次，时间复杂度为 O(N)。只使用了两个额外变量，空间复杂度为 O(1)。</p><p><strong>思路及代码：</strong></p><p>双指针<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-keyword">int</span> cur = numbers[l] + numbers[r];<br>            <span class="hljs-keyword">if</span>(cur &gt; target) r--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur &lt; target) l++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> &#123;l + <span class="hljs-number">1</span>, r + <span class="hljs-number">1</span>&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>顺序遍历+二分查找<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-built_in">size</span>(); ++i)&#123; <span class="hljs-comment">// 从头一步步查找</span><br>            <span class="hljs-keyword">int</span> t = target - numbers[i];  <span class="hljs-comment">// 记录当前需要找的另一个的数值</span><br>            <span class="hljs-keyword">int</span> l = i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 因为不可能是当前这个了</span><br>            <span class="hljs-keyword">int</span> r = numbers.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>                <span class="hljs-keyword">int</span> mid = (r + l) &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(numbers[mid] == t) <span class="hljs-keyword">return</span> &#123;i + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>&#125;; <span class="hljs-comment">// i为开始选择的 mid为最后得到的</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[mid] &gt; t) r = mid;<br>                <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同第二个方法，已知一个数然后求他的对立解<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.<span class="hljs-built_in">size</span>(); ++i)&#123; <span class="hljs-comment">// 如果是第一个也不会马上就酸楚</span><br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(target - numbers[i])) <span class="hljs-keyword">return</span>&#123;m[target - numbers[i]] + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>&#125;;<br>            m[numbers[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-两数平方和"><a class="markdownIt-Anchor" href="#2-两数平方和"></a> 2、两数平方和</h3><p><strong>题目描述</strong>：判断一个非负整数是否为两个整数的平方和。</p><p>可以看成是在元素为 0~target 的有序数组中查找两个数，使得这两个数的平方和为 target，如果能找到，则返回 true，表示 target 是两个整数的平方和。</p><p>本题和 167. Two Sum II - Input array is sorted 类似，只有一个明显区别：一个是和为 target，一个是平方和为 target。本题同样可以使用双指针得到两个数，使其平方和为 target。</p><p>本题的关键是右指针的初始化，实现剪枝，从而降低时间复杂度。设右指针为 x，左指针固定为 0，为了使 02 + x2 的值尽可能接近 target，我们可以将 x 取为 sqrt(target)。</p><p>因为最多只需要遍历一次 0~sqrt(target)，所以时间复杂度为 O(sqrt(target))。又因为只使用了两个额外的变量，因此空间复杂度为 O(1)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judgeSquareSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123; <span class="hljs-comment">// 简单题注意位数问题 避免bug</span><br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-built_in">sqrt</span>(c)); <span class="hljs-comment">// 非负整数包括0, 记住double sqrt返回值是double</span><br>        <span class="hljs-keyword">while</span>(l &lt;= r)&#123; <span class="hljs-comment">// 两个数可以重复</span><br>            <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> cur = l * l + r * r;<br>            <span class="hljs-keyword">if</span>(cur == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur &lt; c) l++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur &gt; c) r--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-反转字符串中的元音字符"><a class="markdownIt-Anchor" href="#3-反转字符串中的元音字符"></a> 3、反转字符串中的元音字符</h3><p>使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符。</p><p>为了快速判断一个字符是不是元音字符，我们将全部元音字符添加到集合 HashSet 中，从而以 O(1) 的时间复杂度进行该操作。</p><ul><li>时间复杂度为 O(N)：只需要遍历所有元素一次</li><li>空间复杂度 O(1)：只需要使用两个额外变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Judge</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> c == <span class="hljs-string">&#x27;a&#x27;</span> || c == <span class="hljs-string">&#x27;e&#x27;</span> || c== <span class="hljs-string">&#x27;i&#x27;</span> || c == <span class="hljs-string">&#x27;o&#x27;</span> || c == <span class="hljs-string">&#x27;u&#x27;</span> || c == <span class="hljs-string">&#x27;A&#x27;</span> || c == <span class="hljs-string">&#x27;E&#x27;</span> || c== <span class="hljs-string">&#x27;I&#x27;</span> || c == <span class="hljs-string">&#x27;O&#x27;</span> || c == <span class="hljs-string">&#x27;U&#x27;</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseVowels</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Judge</span>(s[r]) &amp;&amp; <span class="hljs-built_in">Judge</span>(s[l]))&#123;<br>                <span class="hljs-keyword">char</span> temp = s[r];<br>                s[r] = s[l];<br>                s[l] = temp;<br>                r--;<br>                l++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Judge</span>(s[r])) r--;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Judge</span>(s[l])) l++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-回文字符串"><a class="markdownIt-Anchor" href="#4-回文字符串"></a> 4、回文字符串</h3><p><strong>题目描述</strong>：可以<u>删除</u>一个字符，判断是否能构成回文字符串。</p><p>所谓的回文字符串，是指具有左右对称特点的字符串，例如 “abcba” 就是一个回文字符串。</p><p>使用双指针可以很容易判断一个字符串是否是回文字符串：令一个指针从左到右遍历，一个指针从右到左遍历，这两个指针同时移动一个位置，每次都判断两个指针指向的字符是否相同，如果都相同，字符串才是具有左右对称性质的回文字符串。</p><p>本题的关键是处理删除一个字符。在使用双指针遍历字符串时，如果出现两个指针指向的字符不相等的情况，我们就试着删除一个字符，再判断删除完之后的字符串是否是回文字符串。</p><p>在判断是否为回文字符串时，我们不需要判断整个字符串，因为左指针左边和右指针右边的字符之前已经判断过具有对称性质，所以只需要判断中间的子字符串即可。</p><p>在试着删除字符时，我们既可以删除左指针指向的字符，也可以删除右指针指向的字符。</p><p>这个题主要是反向思考一下复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; j; ++i, --j)&#123; <span class="hljs-comment">// 通过判断不正确的</span><br>            <span class="hljs-keyword">if</span>(s[i] != s[j])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">isP</span>(s, i++, j) || <span class="hljs-built_in">isP</span>(s, i, j--);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isP</span><span class="hljs-params">(string s, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>            <span class="hljs-keyword">if</span>(s[i++] != s[j--])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>Input:<br />nums1 = [1,2,3,0,0,0], m = 3<br />nums2 = [2,5,6],       n = 3</p><p>Output: [1,2,2,3,5,6]</p></blockquote><h3 id="5-归并两个有序数组"><a class="markdownIt-Anchor" href="#5-归并两个有序数组"></a> 5、归并两个有序数组</h3><p><strong>题目描述</strong>：把归并结果存到第一个数组上。</p><p>需要从尾开始遍历，否则在 nums1 上归并得到的值会覆盖还未进行归并比较的值。</p><p>正常思路</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-keyword">int</span> m, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> idx1 = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> idx2 = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> len = m + n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(len &gt;= <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 用len判断是否全体走完 前两个判断是否有走空的 后面的判断大小，从后往前看</span><br>            <span class="hljs-keyword">if</span>(idx1 &lt; <span class="hljs-number">0</span>)&#123;<br>                nums1[len--] = nums2[idx2--];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(idx2 &lt; <span class="hljs-number">0</span>)&#123;<br>                nums1[len--] = nums1[idx1--];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums1[idx1] &lt;= nums2[idx2])&#123;<br>                nums1[len--] = nums2[idx2--];<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums1[idx1] &gt; nums2[idx2])&#123;<br>                nums1[len--] = nums1[idx1--];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>c++语言中，multiset是<set>库中一个非常有用的类型，它可以看成一个序列，插入一个数，删除一个数都能够在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的时间内完成，而且他能时刻保证序列中的数是有序的，而且序列中可以存在重复的数。用这个方法可以简单完成这个任务</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, <span class="hljs-keyword">int</span> m, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        multiset&lt;<span class="hljs-keyword">int</span>&gt; s;<br>        multiset&lt;<span class="hljs-keyword">int</span>&gt; :: iterator it;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i)&#123;<br>            s.<span class="hljs-built_in">insert</span>(nums1[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>            s.<span class="hljs-built_in">insert</span>(nums2[i]);<br>        &#125;<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); ++it)&#123;<br>            nums1[idx++] = *it;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-判断链表是否存在环"><a class="markdownIt-Anchor" href="#6-判断链表是否存在环"></a> 6、判断链表是否存在环</h3><p>使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        ListNode* slow = head;<br>        ListNode* fast = head-&gt;next;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-keyword">if</span>(slow == fast)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-字典中的最长子序列"><a class="markdownIt-Anchor" href="#7-字典中的最长子序列"></a> 7、字典中的最长子序列</h3><p><strong>题目描述</strong>：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。</p><p>通过删除字符串 s 中的一个字符能得到字符串 t，可以认为 t 是 s 的子序列，我们可以使用双指针来判断一个字符串是否为另一个字符串的子序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">findLongestWord</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; dictionary)</span> </span>&#123;<br>        string ans; <span class="hljs-comment">// 用于存储正确答案</span><br>        <span class="hljs-built_in">sort</span>(dictionary.<span class="hljs-built_in">begin</span>(), dictionary.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 因为题目中需要从小到大所以我们进行一下排序</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dictionary.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isSub</span>(s, dictionary[i]))&#123;<br>                ans = dictionary[i].<span class="hljs-built_in">size</span>() &gt; ans.<span class="hljs-built_in">size</span>() ? dictionary[i]:ans; <span class="hljs-comment">// 通过比较长度可以取长的部分为所求</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSub</span><span class="hljs-params">(string s, string word)</span></span>&#123; <span class="hljs-comment">// 双指针检测</span><br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i)&#123; <span class="hljs-comment">//直接按照模版遍历，然后去检验待测试word就好</span><br>            <span class="hljs-keyword">if</span>(s[i] == word[j]) j++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> j == word.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二-排序"><a class="markdownIt-Anchor" href="#二-排序"></a> 二、排序</h2><h3 id="1-kth-element"><a class="markdownIt-Anchor" href="#1-kth-element"></a> 1、Kth Element</h3><blockquote><p>Input: [3,2,1,5,6,4] and k = 2<br />Output: 5</p></blockquote><p><strong>题目描述</strong>：找到倒数第 k 个的元素。</p><p><strong>排序</strong> ：时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-keyword">return</span> nums[k - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>用于求解 <strong>TopK Elements</strong> 问题，也就是 K 个最小元素的问题。使用最小堆来实现 TopK 问题，最小堆使用大顶堆来实现，大顶堆的堆顶元素为当前堆的最大元素。实现过程：不断地往大顶堆中插入新元素，当堆中元素的数量大于 k 时，移除堆顶元素，也就是当前堆中最大的元素，剩下的元素都为当前添加过的元素中最小的 K 个元素。插入和移除堆顶元素的时间复杂度都为 log2N。</p><p>堆也可以用于求解 Kth Element 问题，得到了大小为 K 的最小堆之后，因为使用了大顶堆来实现，因此堆顶元素就是第 K 大的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; h;<span class="hljs-comment">//建立小顶堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            h.<span class="hljs-built_in">push</span>(nums[i]);<br>            <span class="hljs-keyword">if</span>(h.<span class="hljs-built_in">size</span>() &gt; k)&#123;<br>                h.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> h.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>PS：大顶堆小顶堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//对于基础类型 默认是大顶堆</span><br>priority_queue&lt;<span class="hljs-keyword">int</span>&gt; a; <br><span class="hljs-comment">//降序队列</span><br><span class="hljs-comment">//等同于 priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;</span><br><br><span class="hljs-comment">//升序队列 （小根堆）</span><br>priority_queue &lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; q;<br><br><span class="hljs-comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span><br></code></pre></td></tr></table></figure><p><strong>二分法边界详解(再也不迷路了)</strong> <a href="https://zhuanlan.zhihu.com/p/25906225">https://zhuanlan.zhihu.com/p/25906225</a></p><p>快速选择（最好就在一个函数里实现要不然出现多个出口麻烦）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">partition</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>() - k);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> pivot = arr[l];<br>        <span class="hljs-keyword">int</span> i = l, j = h;<br>        <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>            <span class="hljs-keyword">for</span>(;i &lt; j &amp;&amp; arr[j] &gt;= pivot;j--); <span class="hljs-comment">// 必须取等号否则在数组两头（初状态）相等时会陷入死循环</span><br>            arr[i] = arr[j];<br>            <span class="hljs-keyword">for</span>(;i &lt; j &amp;&amp; arr[i] &lt;= pivot;i++);<br>            arr[j] = arr[i];<br>        &#125;<br>        arr[i] = pivot;<br>        <span class="hljs-keyword">if</span>(i &lt; k)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">partition</span>(arr, i + <span class="hljs-number">1</span>, h, k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &gt; k)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">partition</span>(arr, l, i - <span class="hljs-number">1</span>, k);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> arr[i];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-出现最多的k个元素桶排序"><a class="markdownIt-Anchor" href="#2-出现最多的k个元素桶排序"></a> 2、出现最多的k个元素（桶排序）</h3><blockquote><p>Given [1,1,1,2,2,3] and k = 2, return [1,2]</p></blockquote><p>设置若干个桶，每个桶存储出现频率相同的数。桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i。</p><p>把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m; <span class="hljs-comment">// 用这个hash容器存储</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n: nums)&#123;<br>            m[n]++;<br>        &#125;<br>        <span class="hljs-comment">//转换一下</span><br>        vector&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">v</span>(m.<span class="hljs-built_in">begin</span>(), m.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(v[i].first);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; a, pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>PS:map与unordered_map的区别</strong> <a href="https://www.cnblogs.com/yimeixiaobai1314/p/14375195.html">https://www.cnblogs.com/yimeixiaobai1314/p/14375195.html</a></p><h3 id="3-按照字符出现次数对字符串排序"><a class="markdownIt-Anchor" href="#3-按照字符出现次数对字符串排序"></a> 3、按照字符出现次数对字符串排序</h3><blockquote><p>Input:<br />“tree”</p><p>Output:<br />“eert”</p><p>Explanation:<br />‘e’ appears twice while ‘r’ and ‘t’ both appear once.<br />So ‘e’ must appear before both ‘r’ and ‘t’. Therefore “eetr” is also a valid answer.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">frequencySort</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; m; <span class="hljs-comment">// map自动按照key从小到大排序，所以只需要处理后面的就可以</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:s)&#123;<br>            m[c]++;<br>        &#125;<br>        vector&lt;pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">v</span>(m.<span class="hljs-built_in">begin</span>(), m.<span class="hljs-built_in">end</span>()); <br>        <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; v[i].second; ++j)&#123;<br>                s[k++] = v[i].first;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; a, pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a.second &gt; b.second;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-荷兰国旗问题按照颜色进行排序"><a class="markdownIt-Anchor" href="#4-荷兰国旗问题按照颜色进行排序"></a> 4、荷兰国旗问题（按照颜色进行排序）</h3><p>荷兰国旗包含三种颜色：红、白、蓝。</p><p>有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。</p><p>偷跑（doge</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>normal method</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="hljs-comment">//因为考虑到只有0 1 2 所以我们采用switch</span><br>        <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>, mid = <span class="hljs-number">0</span>, high = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(mid &lt;= high)&#123; <span class="hljs-comment">// 1走完了到了2的边界</span><br>            <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(nums[mid])&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-built_in">swap</span>(nums[low++], nums[mid++]); <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 这就相当于左边被装在好了就去下一个</span><br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: mid++; <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-built_in">swap</span>(nums[high--], nums[mid]); <span class="hljs-keyword">break</span>; <span class="hljs-comment">//mid不用动因为只是把预留好的位置放在后面</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="三-贪心思想"><a class="markdownIt-Anchor" href="#三-贪心思想"></a> 三、贪心思想</h2><h3 id="1-分配饼干"><a class="markdownIt-Anchor" href="#1-分配饼干"></a> 1、分配饼干</h3><blockquote><p>Input: grid[1,3], size[1,2,4]<br />Output: 2</p></blockquote><p><strong>题目描述</strong>：每个孩子都有一个满足度 grid，每个饼干都有一个大小 size，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。</p><ol><li>给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。</li><li>因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。</li></ol><p>在以上的解法中，我们只在每次分配时饼干时选择一种看起来是当前最优的分配方法，但无法保证这种局部最优的分配方法最后能得到全局最优解。我们假设能得到全局最优解，并使用反证法进行证明，即假设存在一种比我们使用的贪心策略更优的最优策略。如果不存在这种最优策略，表示贪心策略就是最优策略，得到的解也就是全局最优解。</p><p>证明：假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，可以给该孩子分配第 n 个饼干，并且 m &lt; n。我们可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; g, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-comment">//先排序有助于一个个遍历</span><br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; j &lt; g.<span class="hljs-built_in">size</span>(); ++i)&#123; <span class="hljs-comment">// 用s去找需要满足的g</span><br>            <span class="hljs-keyword">if</span>(s[i] &gt;= g[j]) ++j;<br>        &#125;<br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-不重叠的区间个数"><a class="markdownIt-Anchor" href="#2-不重叠的区间个数"></a> 2、不重叠的区间个数</h3><blockquote><p>Input: [ [1,2], [1,2], [1,2] ]</p><p>Output: 2</p><p>Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping.</p></blockquote><blockquote><p>Input: [ [1,2], [2,3] ]</p><p>Output: 0</p><p>Explanation: You don’t need to remove any of the intervals since they’re already non-overlapping.</p></blockquote><p><strong>题目描述</strong>：计算让一组区间不重叠所需要移除的区间个数。</p><p>先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。</p><p>在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面能够选择的区间个数也就越大。</p><p>按区间的结尾进行排序，每次选择结尾最小，并且和前一个区间不重叠的区间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;<br>        <span class="hljs-comment">// 找重复区间（找出不满足的区间）</span><br>        <span class="hljs-keyword">if</span>(intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp); <span class="hljs-comment">// 按照结尾越小来存储</span><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>, right = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &gt;= right)&#123; <span class="hljs-comment">// 不重叠</span><br>                right = intervals[i][<span class="hljs-number">1</span>];<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - count;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; a, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; b)</span></span>&#123; <span class="hljs-comment">// 添加引用符号就可以</span><br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-投飞镖刺破气球"><a class="markdownIt-Anchor" href="#3-投飞镖刺破气球"></a> 3、 投飞镖刺破气球</h3><blockquote><p>Input:<br />[[10,16], [2,8], [1,6], [7,12]]</p><p>Output:<br />2</p></blockquote><p><strong>题目描述</strong>：气球在一个水平数轴上摆放，可以重叠，飞镖垂直投向坐标轴，使得路径上的气球都被刺破。求解最小的投飞镖次数使所有气球都被刺破。</p><p>也是计算不重叠的区间个数，不过和 Non-overlapping Intervals 的区别在于，[1, 2] 和 [2, 3] 在本题中算是重叠区间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-comment">// 这个题就是为了找有几个重复区间 如果都是连着的话 那就是要一根针就行 也就是count++那个条件不会满足</span><br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>, end = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">0</span>] &gt; end)&#123; <span class="hljs-comment">//找出不重复的 1 2 2 3 算是重复的</span><br>                end = points[i][<span class="hljs-number">1</span>];<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;a, vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-根据身高和序号重组队列"><a class="markdownIt-Anchor" href="#4-根据身高和序号重组队列"></a> 4、根据身高和序号重组队列</h3><blockquote><p>Input:<br />[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</p><p>Output:<br />[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</p></blockquote><p><strong>题目描述</strong>：一个学生用两个分量 (h, k) 描述，h 表示身高，k 表示排在前面的有 k 个学生的身高比他高或者和他一样高。</p><p>为了使插入操作不影响后续的操作，身高较高的学生应该先做插入操作，否则身高较小的学生原先正确插入的第 k 个位置可能会变成第 k+1 个位置。</p><p>身高 h 降序、个数 k 值升序，然后将某个学生插入队列的第 k 个位置中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; people) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; ans;<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p : people)&#123;<br>            ans.<span class="hljs-built_in">insert</span>(ans.<span class="hljs-built_in">begin</span>() + p[<span class="hljs-number">1</span>], p);<span class="hljs-comment">// 这种插入可以让他们按照组进行放入</span><br>            <span class="hljs-comment">// insert(0,2) 为 1 2 -&gt; 2 1 2</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;a, vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;b)</span></span>&#123; <span class="hljs-comment">// 因为先放就会被放后，所以就按照大到小排序</span><br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>] ? a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>] : a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-买卖股票最大的收益"><a class="markdownIt-Anchor" href="#5-买卖股票最大的收益"></a> 5、买卖股票最大的收益</h3><p><strong>题目描述</strong>：一次股票交易包含买入和卖出，只进行一次交易，求最大收益。</p><p>只要记录前面的最小价格，将这个最小价格作为买入价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> cost = <span class="hljs-number">0xffff</span>, profit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            cost = <span class="hljs-built_in">min</span>(prices[i], cost);<br>            profit = <span class="hljs-built_in">max</span>(profit, prices[i] - cost);<br>        &#125;<br>        <span class="hljs-keyword">return</span> profit;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-买卖股票的最大收益-ii"><a class="markdownIt-Anchor" href="#6-买卖股票的最大收益-ii"></a> 6、买卖股票的最大收益 II</h3><p><strong>题目描述</strong>：可以进行多次交易，多次交易之间不能交叉进行，可以进行多次交易。</p><p>对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加到收益中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//其实就是求间距</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(prices[i] &gt; prices[i - <span class="hljs-number">1</span>])<br>                ans += prices[i] - prices[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-种植花朵"><a class="markdownIt-Anchor" href="#7-种植花朵"></a> 7、种植花朵</h3><blockquote><p>Input: flowerbed = [1,0,0,0,1], n = 1<br />Output: True</p></blockquote><p><strong>题目描述</strong>：flowerbed 数组中 1 表示已经种下了花朵。花朵之间至少需要一个单位的间隔，求解是否能种下 n 朵花。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canPlaceFlowers</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; f, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; f.<span class="hljs-built_in">size</span>() &amp;&amp; n &gt; <span class="hljs-number">0</span>; ++i)&#123;<br>            <span class="hljs-keyword">if</span>(f[i] == <span class="hljs-number">0</span> &amp;&amp; (i == <span class="hljs-number">0</span> || f[i - <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &amp;&amp; (i == f.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> || f[i + <span class="hljs-number">1</span>] == <span class="hljs-number">0</span>))&#123;<br>                n--;<br>                f[i] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="8-判断是否为子序列"><a class="markdownIt-Anchor" href="#8-判断是否为子序列"></a> 8、 判断是否为子序列</h3><blockquote><p>s = “abc”, t = “ahbgdc”<br />Return true.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubsequence</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(s[idx] == t[i])&#123;<br>                idx++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> idx == s.<span class="hljs-built_in">size</span>() ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="9-修改一个数成为非递减数组"><a class="markdownIt-Anchor" href="#9-修改一个数成为非递减数组"></a> 9、修改一个数成为非递减数组</h3><blockquote><p>Input: [4,2,3]<br />Output: True<br />Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</p></blockquote><p><strong>题目描述</strong>：判断一个数组是否能只修改一个数就成为非递减数组。</p><p>在出现 nums[i] &lt; nums[i - 1] 时，需要考虑的是应该修改数组的哪个数，使得本次修改能使 i 之前的数组成为非递减数组，并且 <strong>不影响后续的操作</strong> 。优先考虑令 nums[i - 1] = nums[i]，因为如果修改 nums[i] = nums[i - 1] 的话，那么 nums[i] 这个数会变大，就有可能比 nums[i + 1] 大，从而影响了后续操作。还有一个比较特别的情况就是 nums[i] &lt; nums[i - 2]，修改 nums[i - 1] = nums[i] 不能使数组成为非递减数组，只能修改 nums[i] = nums[i - 1]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">checkPossibility</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt;= nums[i - <span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            cnt++;<br>            <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">2</span> &amp;&amp; nums[i - <span class="hljs-number">2</span>] &gt; nums[i])&#123;<br>                nums[i] = nums[i - <span class="hljs-number">1</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;   <br>        cout &lt;&lt; cnt &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> cnt &lt;= <span class="hljs-number">1</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="10-子数组最大的和"><a class="markdownIt-Anchor" href="#10-子数组最大的和"></a> 10、子数组最大的和</h3><blockquote><p>For example, given the array [-2,1,-3,4,-1,2,1,-5,4],<br />the contiguous subarray [4,-1,2,1] has the largest sum = 6.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">-0xffff</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            sum = sum &lt; <span class="hljs-number">0</span> ? nums[i] : nums[i] + sum;<br>            ans = <span class="hljs-built_in">max</span>(ans, sum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="11-分隔字符串使同种字符出现在一起"><a class="markdownIt-Anchor" href="#11-分隔字符串使同种字符出现在一起"></a> 11、分隔字符串使同种字符出现在一起</h3><blockquote><p>Input: S = “ababcbacadefegdehijhklij”<br />Output: [9,7,8]<br />Explanation:<br />The partition is “ababcbaca”, “defegde”, “hijhklij”.<br />This is a partition so that each letter appears in at most one part.<br />A partition like “ababcbacadefegde”, “hijhklij” is incorrect, because it splits S into less parts.</p></blockquote><p><strong>学习了大神的思路如下</strong>：</p><p>这道题给了我们一个字符串S，然我们将其尽可能多的分割为子字符串，条件是每种字符最多只能出现在一个子串中。比如题目汇总的例子，字符串S中有多个a，这些a必须只能在第一个子串中，再比如所有的字母e值出现在了第二个子串中。那么这道题的难点就是如何找到字符串的断点，即拆分成为子串的位置。我们仔细观察题目中的例子，可以发现一旦某个字母多次出现了，那么其最后一个出现位置必须要在当前子串中，字母a，e，和j，分别是三个子串中的结束字母。所以我们关注的是每个字母最后的出现位置，我们可以使用一个 HashMap 来建立字母和其最后出现位置之间的映射，那么对于题目中的例子来说，我们可以得到如下映射：</p><p>a -&gt; 8<br />b -&gt; 5<br />c -&gt; 7<br />d -&gt; 14<br />e -&gt; 15<br />f -&gt; 11<br />g -&gt; 13<br />h -&gt; 19<br />i -&gt; 22<br />j -&gt; 23<br />k -&gt; 20<br />l -&gt; 21</p><p>建立好映射之后，就需要开始遍历字符串S了，我们维护一个 start 变量，是当前子串的起始位置，还有一个 last 变量，是当前子串的结束位置，每当我们遍历到一个字母，我们需要在 HashMap 中提取出其最后一个位置，因为一旦当前子串包含了一个字母，其必须包含所有的相同字母，所以我们要不停的用当前字母的最后一个位置来更新 last 变量，只有当i和 last 相同了，即当 i = 8 时，当前子串包含了所有已出现过的字母的最后一个位置，即之后的字符串里不会有之前出现过的字母了，此时就应该是断开的位置，我们将长度9加入结果 res 中，同理类推，我们可以找出之后的断开的位置，参见代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) m[s[i]] = i; <span class="hljs-comment">// 更新每一个字符的最后位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            end = <span class="hljs-built_in">max</span>(end, m[s[i]]);<br>            <span class="hljs-keyword">if</span>(i == end)&#123; <span class="hljs-comment">// 只有当i和last重合时 才是代表到这个位置 该字符不会出现了</span><br>                ans.<span class="hljs-built_in">push_back</span>(end - start + <span class="hljs-number">1</span>);<br>                start = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="四-二分查找"><a class="markdownIt-Anchor" href="#四-二分查找"></a> 四、二分查找</h2><h3 id="1-求开方"><a class="markdownIt-Anchor" href="#1-求开方"></a> 1、求开方</h3><blockquote><p>Input : [1,2,3,4,5]<br />key : 3<br />return the index : 2</p></blockquote><p>一个数 x 的开方 sqrt 一定在 0 ~ x 之间，并且满足 sqrt == x / sqrt。可以利用二分查找在 0 ~ x 之间查找 sqrt。对于 x = 8，它的开方是 2.82842…，最后应该返回 2 而不是 3。在循环条件为 l &lt;= h 并且循环退出时，h 总是比 l 小 1，也就是说 h = 2，l = 3，因此最后的返回值应该为 h 而不是 l。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, h = x, sqrt;<br>        <span class="hljs-keyword">while</span>(l &lt;= h)&#123;<br>            <span class="hljs-keyword">int</span> mid = l + (h - l) / <span class="hljs-number">2</span>;<br>            sqrt = x / mid;<br>            <span class="hljs-keyword">if</span>(sqrt == mid) <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sqrt &gt; mid) l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sqrt &lt; mid) h = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">// mid 大了 说明数大了得封顶</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-大于给定元素的最小元素"><a class="markdownIt-Anchor" href="#2-大于给定元素的最小元素"></a> 2、大于给定元素的最小元素</h3><blockquote><p>Input:<br />letters = [“c”, “f”, “j”]<br />target = “d”<br />Output: “f”</p><p>Input:<br />letters = [“c”, “f”, “j”]<br />target = “k”<br />Output: “c”</p></blockquote><p><strong>题目描述</strong>：给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">nextGreatestLetter</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">char</span>&gt;&amp; letters, <span class="hljs-keyword">char</span> target)</span> </span>&#123; <span class="hljs-comment">// 和二分法唯一区别就是cur==target也要+1</span><br>        <span class="hljs-keyword">int</span> n = letters.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt;= h)&#123;<br>            <span class="hljs-keyword">int</span> mid = l + (h - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(letters[mid] &lt;= target) l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> h = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l &lt; n ? letters[l] : letters[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-有序数组的-single-element"><a class="markdownIt-Anchor" href="#3-有序数组的-single-element"></a> 3、有序数组的 Single Element</h3><blockquote><p>Input: [1, 1, 2, 3, 3, 4, 4, 8, 8]<br />Output: 2</p></blockquote><p><strong>题目描述</strong>：一个有序数组只有一个数不出现两次，找出这个数。</p><p>要求以 O(logN) 时间复杂度进行求解，因此不能遍历数组并进行异或操作来求解，这么做的时间复杂度为 O(N)。</p><p>令 index 为 Single Element 在数组中的位置。在 index 之后，数组中原来存在的成对状态被改变。如果 m 为偶数，并且 m + 1 &lt; index，那么 nums[m] == nums[m + 1]；m + 1 &gt;= index，那么 nums[m] != nums[m + 1]。</p><p>从上面的规律可以知道，如果 nums[m] == nums[m + 1]，那么 index 所在的数组位置为 [m + 2, h]，此时令 l = m + 2；如果 nums[m] != nums[m + 1]，那么 index 所在的数组位置为 [l, m]，此时令 h = m。</p><p>因为 h 的赋值表达式为 h = m，那么循环条件也就只能使用 l &lt; h 这种形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNonDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123; <span class="hljs-comment">// 这道题简单只检测double</span><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; h)&#123;<br>            <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(m % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//保证m是偶数， 即检测奇数位</span><br>                m--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[m] == nums[m + <span class="hljs-number">1</span>])&#123;  <span class="hljs-comment">// 如果nums[m] ！= nums[m + 1] 说明l到m中有问题 如果没问题 都应该满足nums[m] == nums[m + 1]， 所以当满足时 只可能出现在m + 2 ~ h中</span><br>                l = m + <span class="hljs-number">2</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                h = m;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[l];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-第一个错误的版本"><a class="markdownIt-Anchor" href="#4-第一个错误的版本"></a> 4、第一个错误的版本</h3><p><strong>题目描述</strong>：给定一个元素 n 代表有 [1, 2, …, n] 版本，在第 x 位置开始出现错误版本，导致后面的版本都错误。可以调用 isBadVersion(int x) 知道某个版本是否错误，要求找到第一个错误的版本。</p><p>如果第 m 个版本出错，则表示第一个错误的版本在 [l, m] 之间，令 h = m；否则第一个错误的版本在 [m + 1, h] 之间，令 l = m + 1。</p><p>因为 h 的赋值表达式为 h = m，因此循环条件为 l &lt; h。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// The API isBadVersion is defined for you.</span><br><span class="hljs-comment">// bool isBadVersion(int version);</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstBadVersion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123; <span class="hljs-comment">// 如果第m个出问题 那么第一个一定出现子l 到 m中 反之 m没出问题 那么出问题一定在m + 1 到 h 中</span><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = n;<br>        <span class="hljs-keyword">while</span>(l &lt; h)&#123;<br>            <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isBadVersion</span>(m))&#123;<br>                h = m;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-旋转数组的最小数字"><a class="markdownIt-Anchor" href="#5-旋转数组的最小数字"></a> 5、旋转数组的最小数字</h3><blockquote><p>Input: [3,4,5,1,2],<br />Output: 1</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123; <span class="hljs-comment">// 旋转矩阵比较最后一位</span><br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; h)&#123;<br>            <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[m] &gt; nums[h]) l = m + <span class="hljs-number">1</span>; <span class="hljs-comment">//如果nums[m] &gt; nums[h] 说明在m + 1 到 h中 反之在 l 到 m 中</span><br>            <span class="hljs-keyword">else</span> h = m;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[l];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-查找区间"><a class="markdownIt-Anchor" href="#6-查找区间"></a> 6、查找区间</h3><blockquote><p>Input: nums = [5,7,7,8,8,10], target = 8<br />Output: [3,4]</p><p>Input: nums = [5,7,7,8,8,10], target = 6<br />Output: [-1,-1]</p></blockquote><p><strong>题目描述</strong>：给定一个有序数组 nums 和一个目标 target，要求找到 target 在 nums 中的第一个位置和最后一个位置。可以用二分查找找出第一个位置和最后一个位置，但是寻找的方法有所不同，需要实现两个二分查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-built_in">binarySearch</span>(nums, target, <span class="hljs-string">&#x27;f&#x27;</span>), <span class="hljs-built_in">binarySearch</span>(nums, target, <span class="hljs-string">&#x27;s&#x27;</span>)&#125;;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">char</span> mode)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt;= h)&#123;<br>            <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">int</span> cur = nums[m];<br>            <span class="hljs-keyword">if</span>(cur &lt; target)&#123;<br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur &gt; target)&#123;<br>                h = m - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur == target)&#123;<br>                ans = m;<br>                (mode == <span class="hljs-string">&#x27;f&#x27;</span>) ? h = m - <span class="hljs-number">1</span> : l = m + <span class="hljs-number">1</span>; <span class="hljs-comment">// 借用大神的理解 这里太妙了 直接按照二分查找找边界</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="五-分治"><a class="markdownIt-Anchor" href="#五-分治"></a> 五、分治</h2><h3 id="1-给表达式加括号"><a class="markdownIt-Anchor" href="#1-给表达式加括号"></a> 1、给表达式加括号</h3><blockquote><p>Input: “2-1-1”.</p><p>((2-1)-1) = 0<br />(2-(1-1)) = 2</p><p>Output : [0, 2]</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">diffWaysToCompute</span><span class="hljs-params">(string expression)</span> </span>&#123; <span class="hljs-comment">// 只有+ - *</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; result; <span class="hljs-comment">//主要无限拆分符号两边的数</span><br>        <span class="hljs-keyword">int</span> n = expression.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>            <span class="hljs-keyword">char</span> c = expression[i]; <span class="hljs-comment">//获取当前字符</span><br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span> || c == <span class="hljs-string">&#x27;*&#x27;</span>)&#123; <span class="hljs-comment">// 分治法无限拆分递归</span><br>                vector&lt;<span class="hljs-keyword">int</span>&gt; res1 = <span class="hljs-built_in">diffWaysToCompute</span>(expression.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i));<br>                vector&lt;<span class="hljs-keyword">int</span>&gt; res2 = <span class="hljs-built_in">diffWaysToCompute</span>(expression.<span class="hljs-built_in">substr</span>(i + <span class="hljs-number">1</span>, n));<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n1: res1)&#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n2: res2)&#123;<br>                        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(c)&#123;<br>                            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: result.<span class="hljs-built_in">push_back</span>(n1 + n2); <span class="hljs-keyword">break</span>;<br>                            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: result.<span class="hljs-built_in">push_back</span>(n1 - n2); <span class="hljs-keyword">break</span>;<br>                            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: result.<span class="hljs-built_in">push_back</span>(n1 * n2); <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">if</span>(result.<span class="hljs-built_in">empty</span>())&#123; <span class="hljs-comment">// 说明当前只是数字</span><br>            result.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">atoi</span>(expression.<span class="hljs-built_in">c_str</span>()));<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-不同的二叉搜索树"><a class="markdownIt-Anchor" href="#2-不同的二叉搜索树"></a> 2、不同的二叉搜索树</h3><p>给定一个数字 n，要求生成所有值为 1…n 的二叉搜索树。</p><blockquote><p>Input: 3<br />Output:<br />[<br />[1,null,3,2],<br />[3,2,null,1],<br />[3,1,null,null,2],<br />[2,1,3],<br />[1,null,2,null,3]<br />]<br />Explanation:<br />The above output corresponds to the 5 unique BST’s shown below:</p><p>1         3     3      2      1<br />\       /     /      / \      <br />3     2     1      1   3      2<br />/     /       \                 <br />2     1         2                 3</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        vector&lt;TreeNode*&gt; ans;<br>        <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">generateSubTrees</span>(<span class="hljs-number">1</span>, n);<br>    &#125;<br>    <br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">generateSubTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> e)</span></span>&#123;<br>        vector&lt;TreeNode*&gt; ans;<br>        <span class="hljs-keyword">if</span>(s &gt; e)&#123;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = s; i &lt;= e; ++i)&#123;<br>            vector&lt;TreeNode*&gt; left = <span class="hljs-built_in">generateSubTrees</span>(s, i - <span class="hljs-number">1</span>);<br>            vector&lt;TreeNode*&gt; right = <span class="hljs-built_in">generateSubTrees</span>(i + <span class="hljs-number">1</span>, e);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> l: left)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> r: right)&#123;<br>                    TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(i, l, r); <span class="hljs-comment">//生成当前根 放入</span><br>                    ans.<span class="hljs-built_in">push_back</span>(root);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="六-搜索"><a class="markdownIt-Anchor" href="#六-搜索"></a> 六、搜索</h2><h3 id="1-bfs"><a class="markdownIt-Anchor" href="#1-bfs"></a> 1、BFS</h3><h4 id="1计算在网格中从原点到特定点的最短路径长度"><a class="markdownIt-Anchor" href="#1计算在网格中从原点到特定点的最短路径长度"></a> 1）计算在网格中从原点到特定点的最短路径长度</h4><blockquote><p>[[1,1,0,1],<br />[1,0,1,0],<br />[1,1,1,1],<br />[1,0,1,1]]</p></blockquote><p><strong>题目描述</strong>：0 表示可以经过某个位置，求解从左上角到右下角的最短路径长度。</p><p>复杂bfs版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">State</span>&#123;</span><br>        <span class="hljs-keyword">int</span> x, y;<br>        <span class="hljs-keyword">int</span> step; <span class="hljs-comment">// 搜查步数</span><br>    &#125;;<br>    <span class="hljs-keyword">bool</span> vis[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>]; <span class="hljs-comment">// 设置访问数组</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CheckState</span><span class="hljs-params">(State s, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span></span>&#123; <span class="hljs-comment">// 判断当前状态</span><br>        <span class="hljs-keyword">if</span>(s.x &gt;= <span class="hljs-number">0</span> &amp;&amp; s.y &gt;= <span class="hljs-number">0</span> &amp;&amp; s.x &lt; grid.<span class="hljs-built_in">size</span>() &amp;&amp; s.y &lt; grid.<span class="hljs-built_in">size</span>() &amp;&amp; <br>           !vis[s.x][s.y] &amp;&amp; grid[s.x][s.y] == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shortestPathBinaryMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = grid.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 确定行和列</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> dir[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;; <span class="hljs-comment">// 初始化方向</span><br>        queue&lt;State&gt; Q;<br>        State now, next; <span class="hljs-comment">// 设置当前和下一个</span><br>        now.x = <span class="hljs-number">0</span>;<br>        now.y = <span class="hljs-number">0</span>;<br>        now.step = <span class="hljs-number">1</span>;<br>        vis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        Q.<span class="hljs-built_in">push</span>(now);<br>        <span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())&#123;<br>            now = Q.<span class="hljs-built_in">front</span>();<br>            <span class="hljs-keyword">if</span>(now.x == n - <span class="hljs-number">1</span> &amp;&amp; now.y == n - <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> now.step;<br>            &#125;<br>            cout &lt;&lt; now.x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; now.y &lt;&lt; endl;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i)&#123;<br>                next.x = now.x + dir[i][<span class="hljs-number">0</span>];<br>                next.y = now.y + dir[i][<span class="hljs-number">1</span>];<br>                next.step = now.step + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">CheckState</span>(next, grid))&#123;<br>                    Q.<span class="hljs-built_in">push</span>(next);<br>                    vis[next.x][next.y] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            Q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><p>大神simple版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> dir[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;&#125;; <span class="hljs-comment">// 初始化方向</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shortestPathBinaryMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        queue&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &gt; q;<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>        grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">auto</span> cur = q.<span class="hljs-built_in">front</span>();<br>            <span class="hljs-keyword">int</span> x = cur.first, y = cur.second;<br>            <span class="hljs-keyword">if</span>(x == n - <span class="hljs-number">1</span> &amp;&amp; y == n - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> grid[x][y];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i)&#123;<br>                <span class="hljs-keyword">int</span> nx = x + dir[i][<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">int</span> ny = y + dir[i][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">if</span>(nx &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] == <span class="hljs-number">0</span>)&#123;<br>                    grid[nx][ny] = grid[x][y] + <span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(nx, ny));<br>                &#125;<br>            &#125;<br>            q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2组成整数的最小平方数数量"><a class="markdownIt-Anchor" href="#2组成整数的最小平方数数量"></a> 2）组成整数的最小平方数数量</h4><blockquote><p>For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</p></blockquote><p>可以将每个整数看成图中的一个节点，如果两个整数之差为一个平方数，那么这两个整数所在的节点就有一条边。要求解最小的平方数数量，就是求解从节点 n 到节点 0 的最短路径。本题也可以用动态规划求解，在之后动态规划部分中会再次出现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-keyword">int</span>&gt; vis; <span class="hljs-comment">// 为了让出了可以充当元素的值以外的元素均为过程值</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; num;<br>        queue&lt;<span class="hljs-keyword">int</span>&gt; q; <span class="hljs-comment">// 用于BFS的队列</span><br>        <span class="hljs-keyword">int</span> step = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i * i &lt;= n; ++i)&#123;<br>            <span class="hljs-keyword">if</span>(i * i == n) <span class="hljs-keyword">return</span> step;<br>            vis.<span class="hljs-built_in">insert</span>(i * i);<br>            num.<span class="hljs-built_in">push_back</span>(i * i);<br>            q.<span class="hljs-built_in">push</span>(i * i);<br>        &#125;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            step++; <span class="hljs-comment">//处理当前层</span><br>            <span class="hljs-keyword">int</span> size = q.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 以后切记注意queue的size可能会改变 所以一定需要提前获取一下</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)&#123;<br>                <span class="hljs-keyword">int</span> cur = q.<span class="hljs-built_in">front</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k: num)&#123;<br>                    <span class="hljs-keyword">int</span> sum = cur + k;<br>                    <span class="hljs-keyword">if</span>(sum == n) <span class="hljs-keyword">return</span> step;<br>                    <span class="hljs-keyword">if</span>(sum &lt; n &amp;&amp; !vis.<span class="hljs-built_in">count</span>(sum))&#123;<br>                        q.<span class="hljs-built_in">push</span>(sum);<br>                        vis.<span class="hljs-built_in">insert</span>(sum);<br>                    &#125;<br>                &#125;<br>                q.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3最短单词路径"><a class="markdownIt-Anchor" href="#3最短单词路径"></a> 3）最短单词路径</h4><blockquote><p>Input:<br />beginWord = “hit”,<br />endWord = “cog”,<br />wordList = [“hot”,“dot”,“dog”,“lot”,“log”,“cog”]</p><p>Output: 5</p><p>Explanation: As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br />return its length 5.</p></blockquote><blockquote><p>Input:<br />beginWord = “hit”<br />endWord = “cog”<br />wordList = [“hot”,“dot”,“dog”,“lot”,“log”]</p><p>Output: 0</p><p>Explanation: The endWord “cog” is not in wordList, therefore no possible transformation.</p></blockquote><p><strong>题目描述</strong>：找出一条从 beginWord 到 endWord 的最短路径，每次移动规定为改变一个字符，并且改变之后的字符串必须在 wordList 中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ladderLength</span><span class="hljs-params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123; <span class="hljs-comment">// 全是小写字母</span><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">count</span>(wordList.<span class="hljs-built_in">begin</span>(), wordList.<span class="hljs-built_in">end</span>(), endWord))<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果不在wordlist中 直接就无</span><br>        unordered_set&lt;string&gt; s; <span class="hljs-comment">// 准备分支元素（All the words in wordList are unique）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> w : wordList)&#123;<br>            s.<span class="hljs-built_in">insert</span>(w);<br>        &#125;<br>        queue&lt;string&gt; q; <span class="hljs-comment">// BFS框架</span><br>        q.<span class="hljs-built_in">push</span>(beginWord); <span class="hljs-comment">// 将第一个图节点放入队列</span><br>        <span class="hljs-keyword">int</span> step = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">int</span> size = q.<span class="hljs-built_in">size</span>();<br>            step++; <span class="hljs-comment">//记录该层的步数</span><br>            <span class="hljs-keyword">while</span>(size--)&#123;<br>                string cur = q.<span class="hljs-built_in">front</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cur.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>                    string temp = cur;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; ++c)&#123; <span class="hljs-comment">// 为每一位替换a到z</span><br>                        temp[i] = c;<br>                        <span class="hljs-keyword">if</span>(temp == cur) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//剪枝</span><br>                        <span class="hljs-keyword">if</span>(temp == endWord) <span class="hljs-comment">// 结束条件</span><br>                            <span class="hljs-keyword">return</span> step + <span class="hljs-number">1</span>; <span class="hljs-comment">// endWord已经检验存在，所以要是相等等于进入下一层</span><br>                        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">count</span>(temp))&#123;<span class="hljs-comment">// 说明当前改变后的单词存在与wordlist中</span><br>                            q.<span class="hljs-built_in">push</span>(temp);<br>                            s.<span class="hljs-built_in">erase</span>(temp);<br>                            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 找到一个说明可以进入下一个图了 嘻嘻我在大神的方法上又剪枝啦:) 更快咯</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>                q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//完全退出当前分支</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-dfs"><a class="markdownIt-Anchor" href="#2-dfs"></a> 2、DFS</h3><h4 id="1查找最大的连通面积"><a class="markdownIt-Anchor" href="#1查找最大的连通面积"></a> 1）查找最大的连通面积</h4><p>You are given an <code>m x n</code> binary matrix <code>grid</code>. An island is a group of <code>1</code>'s (representing land) connected <strong>4-directionally</strong> (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p><p>The <strong>area</strong> of an island is the number of cells with a value <code>1</code> in the island.</p><p>Return <em>the maximum <strong>area</strong> of an island in</em> <code>grid</code>. If there is no island, return <code>0</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-comment">//     m == grid.length</span><br><span class="hljs-comment">//     n == grid[i].length</span><br><span class="hljs-comment">//     1 &lt;= m, n &lt;= 50</span><br><span class="hljs-comment">//     grid[i][j] is either 0 or 1.</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;; <span class="hljs-comment">//建立四个方向</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> row = grid.<span class="hljs-built_in">size</span>(), col = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 获取长宽</span><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j)&#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">dfs</span>(grid, i, j));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; grid, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> row = grid.<span class="hljs-built_in">size</span>(), col = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 获取长宽</span><br>        <span class="hljs-keyword">if</span>(r &lt; <span class="hljs-number">0</span> || c &lt; <span class="hljs-number">0</span> || r &gt;= row || c &gt;= col || grid[r][c] == <span class="hljs-number">0</span>) <span class="hljs-comment">//不满足边界</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        grid[r][c] = <span class="hljs-number">0</span>;  <span class="hljs-comment">//走过设置为0，防止重复</span><br>        <span class="hljs-keyword">int</span> area = <span class="hljs-number">1</span>; <span class="hljs-comment">// 该岛屿为1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> d: dir)&#123;<br>            area += <span class="hljs-built_in">dfs</span>(grid, r + d[<span class="hljs-number">0</span>], c + d[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> area;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2矩阵中的连通分量数目"><a class="markdownIt-Anchor" href="#2矩阵中的连通分量数目"></a> 2）矩阵中的连通分量数目</h4><blockquote><p>Input:<br />11000<br />11000<br />00100<br />00011</p><p>Output: 3</p></blockquote><p>可以将矩阵表示看成一张有向图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;; <span class="hljs-comment">//建立四个方向</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> row = grid.<span class="hljs-built_in">size</span>(), col = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 获取长宽</span><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123; <span class="hljs-comment">// 清楚1</span><br>                    <span class="hljs-built_in">dfs</span>(grid, i, j);<br>                    ans++;<br>                &#125;  <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp; grid, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span></span>&#123; <span class="hljs-comment">// </span><br>        <span class="hljs-keyword">int</span> row = grid.<span class="hljs-built_in">size</span>(), col = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 获取长宽</span><br>        <span class="hljs-keyword">if</span>(r &lt; <span class="hljs-number">0</span> || c &lt; <span class="hljs-number">0</span> || r &gt;= row || c &gt;= col || grid[r][c] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-comment">//不满足边界</span><br>            <span class="hljs-keyword">return</span>;<br>        grid[r][c] = <span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-comment">//走过设置为0，防止重复</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> d: dir)&#123;<br>            <span class="hljs-built_in">dfs</span>(grid, r + d[<span class="hljs-number">0</span>], c + d[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3好友关系的连通分量数目"><a class="markdownIt-Anchor" href="#3好友关系的连通分量数目"></a> 3）好友关系的连通分量数目</h4><blockquote><p>Input:<br />[[1,1,0],<br />[1,1,0],<br />[0,0,1]]</p><p>Output: 2</p><p>Explanation:The 0th and 1st students are direct friends, so they are in a friend circle.<br />The 2nd student himself is in a friend circle. So return 2.</p></blockquote><p><strong>题目描述</strong>：好友关系可以看成是一个无向图，例如第 0 个人与第 1 个人是好友，那么 M[0][1] 和 M[1][0] 的值都为 1。</p><p>这一题和上一题异曲同工，就是该成通过填充以为vis数组 几次填充完就有几个环，上一题是直接在图中填图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 无向图邻接矩阵遍历</span><br>    <span class="hljs-keyword">bool</span> vis[<span class="hljs-number">100</span>];<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = grid.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 获取长度</span><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123; <span class="hljs-comment">// 按照行一行行检测就行了:)</span><br>            <span class="hljs-keyword">if</span>(!vis[i])&#123; <span class="hljs-comment">// 看看这个无向图这个点是否使用过</span><br>                <span class="hljs-built_in">dfs</span>(grid, i);<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; grid, <span class="hljs-keyword">int</span> num)</span></span>&#123; <span class="hljs-comment">// 通过vis记录是否走过这个点</span><br>        vis[num] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">//走过设置为0，防止重复</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; grid.<span class="hljs-built_in">size</span>(); ++i)&#123; <span class="hljs-comment">// 按照列扫</span><br>            <span class="hljs-keyword">if</span>(!vis[i] &amp;&amp; grid[num][i] == <span class="hljs-number">1</span>)<br>                <span class="hljs-built_in">dfs</span>(grid, i);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4-填充封闭区域"><a class="markdownIt-Anchor" href="#4-填充封闭区域"></a> 4、填充封闭区域</h4><blockquote><p>For example,<br />X X X X<br />X O O X<br />X X O X<br />X O X X</p><p>After running your function, the board should be:<br />X X X X<br />X X X X<br />X X X X<br />X O X X</p></blockquote><p><strong>题目描述</strong>：使被 ‘X’ 包围的 ‘O’ 转换为 ‘X’。</p><p>先填充最外侧，剩下的就是里侧了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:  <span class="hljs-comment">// dfs遍历加修改图重新标记重新填图</span><br>    <span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;; <span class="hljs-comment">//建立四个方向</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> row = board.<span class="hljs-built_in">size</span>(), col = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 获取长宽</span><br>        <span class="hljs-comment">//边界处理</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i)&#123;<br>            <span class="hljs-built_in">dfs</span>(board, i, <span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">dfs</span>(board, i, col - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j)&#123;<br>            <span class="hljs-built_in">dfs</span>(board, <span class="hljs-number">0</span>, j);<br>            <span class="hljs-built_in">dfs</span>(board, row - <span class="hljs-number">1</span>, j);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j)&#123;<br>                <span class="hljs-keyword">if</span>(board[i][j] == <span class="hljs-string">&#x27;F&#x27;</span>)&#123; <span class="hljs-comment">// F 变 O </span><br>                    board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span>)&#123; <span class="hljs-comment">// 出了T就是符合要求的全是X</span><br>                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp; board, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span></span>&#123; <span class="hljs-comment">// </span><br>        <span class="hljs-keyword">int</span> row = board.<span class="hljs-built_in">size</span>(), col = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 获取长宽</span><br>        <span class="hljs-keyword">if</span>(r &lt; <span class="hljs-number">0</span> || c &lt; <span class="hljs-number">0</span> || r &gt;= row || c &gt;= col || board[r][c] != <span class="hljs-string">&#x27;O&#x27;</span>) <span class="hljs-comment">//结束条件</span><br>            <span class="hljs-keyword">return</span>;<br>        board[r][c] = <span class="hljs-string">&#x27;F&#x27;</span>;  <span class="hljs-comment">//检测边界中是否有O 如果有做标记之后不需要变成X</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> d: dir)&#123;<br>            <span class="hljs-built_in">dfs</span>(board, r + d[<span class="hljs-number">0</span>], c + d[<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="5能到达的太平洋和大西洋的区域"><a class="markdownIt-Anchor" href="#5能到达的太平洋和大西洋的区域"></a> 5）能到达的太平洋和大西洋的区域</h4><blockquote><p>Given the following 5x5 matrix:</p><dl><dt>Pacific ~   ~   ~   ~   ~</dt><dd>1   2   2   3  (5) *</dd><dd>3   2   3  (4) (4) *</dd><dd>2   4  (5)  3   1  *</dd><dd>(6) (7)  1   4   5  *</dd><dd>(5)  1   1   2   4  *<ul><li><ul><li><ul><li><ul><li><ul><li>Atlantic</li></ul></li></ul></li></ul></li></ul></li></ul></dd></dl><p>Return:<br />[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).</p></blockquote><p>左边和上边是太平洋，右边和下边是大西洋，内部的数字代表海拔，海拔高的地方的水能够流到低的地方，求解水能够流到太平洋和大西洋的所有位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;; <span class="hljs-comment">//建立四个方向</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; heights) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; res;<br>        <span class="hljs-keyword">int</span> row = heights.<span class="hljs-built_in">size</span>(), col = heights[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 获取长宽</span><br>        <span class="hljs-comment">// 不同的水流可以到达的地方</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt; &gt; <span class="hljs-built_in">reachP</span>(<span class="hljs-number">210</span>, vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">210</span>)); <br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt; &gt; <span class="hljs-built_in">reachA</span>(<span class="hljs-number">210</span>, vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">210</span>));<br>        <span class="hljs-comment">//边界处理</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i)&#123;<br>            <span class="hljs-built_in">dfs</span>(heights, i, <span class="hljs-number">0</span>, reachP);<br>            <span class="hljs-built_in">dfs</span>(heights, i, col - <span class="hljs-number">1</span>, reachA);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j)&#123;<br>            <span class="hljs-built_in">dfs</span>(heights, <span class="hljs-number">0</span>, j, reachP);<br>            <span class="hljs-built_in">dfs</span>(heights, row - <span class="hljs-number">1</span>, j, reachA);<br>        &#125;<br>        <span class="hljs-comment">//汇总</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j)&#123;<br>                <span class="hljs-keyword">if</span>(reachP[i][j] &amp;&amp; reachA[i][j])&#123; <span class="hljs-comment">// 找到交汇处</span><br>                    res.<span class="hljs-built_in">push_back</span>(&#123;i, j&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; heights, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c, vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt; &gt;&amp; reach)</span></span>&#123; <span class="hljs-comment">// </span><br>        <span class="hljs-keyword">int</span> row = heights.<span class="hljs-built_in">size</span>(), col = heights[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 获取长宽</span><br>        reach[r][c] = <span class="hljs-literal">true</span>;  <span class="hljs-comment">//检测边界中是否有O 如果有做标记之后不需要变成X</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> d: dir)&#123;<br>            <span class="hljs-keyword">int</span> nr = r + d[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> nc = c + d[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(nr &lt; <span class="hljs-number">0</span> || nc &lt; <span class="hljs-number">0</span> || nr &gt;= row || nc &gt;= col || heights[r][c] &gt; heights[nr][nc] || reach[nr][nc])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">dfs</span>(heights, nr, nc, reach);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-回溯backtracking"><a class="markdownIt-Anchor" href="#3-回溯backtracking"></a> 3、回溯Backtracking</h3><h4 id="1数字键盘组合"><a class="markdownIt-Anchor" href="#1数字键盘组合"></a> 1）数字键盘组合</h4><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202203210954783.png" alt="截屏2022-03-21 上午9.53.56" style="zoom:50%;" /><blockquote><p>Input:Digit string “23”<br />Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; key&#123;&#123;<span class="hljs-string">&quot;abc&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;def&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;ghi&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;jkl&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;mno&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;pqrs&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;tuv&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;wxyz&quot;</span>&#125;&#125;; <span class="hljs-comment">// 键位映射</span><br>    vector&lt;string&gt; res; <span class="hljs-comment">// 存储最终结果</span><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(digits == <span class="hljs-string">&quot;&quot;</span> ) <span class="hljs-keyword">return</span> res;<br>        string temp;<br>        <span class="hljs-built_in">btr</span>(digits, <span class="hljs-number">0</span>, temp);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">btr</span><span class="hljs-params">(string&amp; digits, <span class="hljs-keyword">int</span> i, string&amp; temp)</span></span>&#123; <span class="hljs-comment">// 回溯求解 i 为当前处理第几位</span><br>        <span class="hljs-keyword">if</span>(i == digits.<span class="hljs-built_in">size</span>()) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 到个数了回溯</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c: key[digits[i] - <span class="hljs-string">&#x27;2&#x27;</span>])&#123; <span class="hljs-comment">// 遍历该层的键位</span><br>            temp.<span class="hljs-built_in">push_back</span>(c);<br>            <span class="hljs-built_in">btr</span>(digits, i + <span class="hljs-number">1</span>, temp); <span class="hljs-comment">// 进入下一位的选择</span><br>            temp.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 退一层选择</span><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-ip-地址划分"><a class="markdownIt-Anchor" href="#2-ip-地址划分"></a> 2） IP 地址划分</h4><blockquote><p>Given “25525511135”,<br />return [“255.255.11.135”, “255.255.111.35”].</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> res;<br>        <span class="hljs-built_in">getResult</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 不能出现‘0x几几’</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">stoi</span>(s) &lt; <span class="hljs-number">0</span> || <span class="hljs-built_in">stoi</span>(s) &gt; <span class="hljs-number">255</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 值不在范围</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getResult</span><span class="hljs-params">(string s, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> dot, string temp, vector&lt;string&gt;&amp; res)</span></span>&#123; <span class="hljs-comment">// i为开始的索引， dot为点的索引</span><br>        <span class="hljs-keyword">if</span>(dot == <span class="hljs-number">3</span>)&#123; <span class="hljs-comment">//划分好了三个点</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s.<span class="hljs-built_in">substr</span>(i)))&#123;<br>                res.<span class="hljs-built_in">push_back</span>(temp + s.<span class="hljs-built_in">substr</span>(i));<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &lt; s.<span class="hljs-built_in">size</span>(); ++j)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(s.<span class="hljs-built_in">substr</span>(i, j - i + <span class="hljs-number">1</span>)))&#123; <span class="hljs-comment">// 检测加入当前数字是否满足一个ip的一部分</span><br>                <span class="hljs-comment">// 0. 用途：一种构造string的方法</span><br>                <span class="hljs-comment">// 1. 形式：s.substr(pos, n)</span><br>                <span class="hljs-comment">// 2. 解释：返回一个string，包含s中从pos开始的n个字符的拷贝（pos的默认值是0，n的默认值是s.size() - pos，即不加参数会默认拷贝整个s）</span><br>                <span class="hljs-comment">// 3. 补充：若pos的值超过了string的大小，则substr函数会抛出一个out_of_range异常；若pos+n的值超过了string的大小，则substr会调整n的值，只拷贝到string的末尾</span><br>                temp.<span class="hljs-built_in">push_back</span>(s[j]); <span class="hljs-comment">// 一个数字一个数字加入</span><br>                temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>                <span class="hljs-built_in">getResult</span>(s, j + <span class="hljs-number">1</span>, dot + <span class="hljs-number">1</span>, temp, res); <span class="hljs-comment">// 进入下一层</span><br>                temp.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯清除点就好了 然后再加入新的数字</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3在矩阵中寻找字符串"><a class="markdownIt-Anchor" href="#3在矩阵中寻找字符串"></a> 3）在矩阵中寻找字符串</h4><blockquote><p>For example,<br />Given board =<br />[<br />[‘A’,‘B’,‘C’,‘E’],<br />[‘S’,‘F’,‘C’,‘S’],<br />[‘A’,‘D’,‘E’,‘E’]<br />]<br />word = “ABCCED”, -&gt; returns true,<br />word = “SEE”, -&gt; returns true,<br />word = “ABCB”, -&gt; returns false.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-keyword">bool</span> vis[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> row = board.<span class="hljs-built_in">size</span>(), col = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board, i, j, word, <span class="hljs-number">0</span>))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp; board, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c, string word, <span class="hljs-keyword">int</span> i)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(word.<span class="hljs-built_in">size</span>() == i)&#123; <span class="hljs-comment">// 满足条件</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;  <br>        <span class="hljs-keyword">int</span> row = board.<span class="hljs-built_in">size</span>(), col = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(r &lt; <span class="hljs-number">0</span> || c &lt; <span class="hljs-number">0</span> || r &gt;= row || c &gt;= col || vis[r][c] || word[i] != board[r][c])&#123; <span class="hljs-comment">// 失败条件</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;      <br>        vis[r][c] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 表示我来了</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> d : dir)&#123;<br>            <span class="hljs-keyword">int</span> nr = r + d[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> nc = c + d[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(board, nr, nc, word, i + <span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        vis[r][c] = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 表示我走了</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4输出二叉树中所有从根到叶子的路径"><a class="markdownIt-Anchor" href="#4输出二叉树中所有从根到叶子的路径"></a> 4）输出二叉树中所有从根到叶子的路径</h4><blockquote><p>1<br />/  <br />2    3<br /><br />5</p><p>[“1-&gt;2-&gt;5”, “1-&gt;3”]</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-built_in">f</span>(root, <span class="hljs-built_in">to_string</span>(root-&gt;val), res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(TreeNode* root, string s, vector&lt;string&gt;&amp; res)</span></span>&#123; <span class="hljs-comment">// s存储当前结果</span><br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123; <span class="hljs-comment">// 到了叶子</span><br>            res.<span class="hljs-built_in">push_back</span>(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;left) <span class="hljs-built_in">f</span>(root-&gt;left, s + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-built_in">to_string</span>(root-&gt;left-&gt;val), res);<br>        <span class="hljs-keyword">if</span>(root-&gt;right) <span class="hljs-built_in">f</span>(root-&gt;right, s + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-built_in">to_string</span>(root-&gt;right-&gt;val), res);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="5排列"><a class="markdownIt-Anchor" href="#5排列"></a> 5）排列</h4><blockquote><p>[1,2,3] have the following permutations:<br />[<br />[1,2,3],<br />[1,3,2],<br />[2,1,3],<br />[2,3,1],<br />[3,1,2],<br />[3,2,1]<br />]</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">100</span>); <span class="hljs-comment">// 检查是否遍历过</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; res; <span class="hljs-comment">//结果数组</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>        <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>, res, temp);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> len, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; res, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; temp)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == len)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(!vis[i])&#123; <span class="hljs-comment">// 如果该点没有遍历</span><br>                vis[i] = <span class="hljs-literal">true</span>;<br>                temp.<span class="hljs-built_in">push_back</span>(nums[i]); <span class="hljs-comment">// 进入下一状态</span><br>                <span class="hljs-built_in">dfs</span>(nums, len + <span class="hljs-number">1</span>, res, temp);<br>                temp.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回退一下</span><br>                vis[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="6含有相同元素求排列"><a class="markdownIt-Anchor" href="#6含有相同元素求排列"></a> 6）含有相同元素求排列</h4><blockquote><p>[1,1,2] have the following unique permutations:<br />[[1,1,2], [1,2,1], [2,1,1]]</p></blockquote><p>数组元素可能含有相同的元素，进行排列时就有可能出现重复的排列，要求重复的排列只返回一个。</p><p>在实现上，和 Permutations 不同的是要先排序，然后在添加一个元素时，判断这个元素是否等于前一个元素，如果等于，并且前一个元素还未访问，那么就跳过这个元素。</p><p>在上一题上偷鸡</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">100</span>); <span class="hljs-comment">// 检查是否遍历过</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; res; <span class="hljs-comment">//结果数组</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>        <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>, res, temp);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> len, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; res, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; temp)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == len &amp;&amp; !<span class="hljs-built_in">count</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>(), temp))&#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(!vis[i])&#123; <span class="hljs-comment">// 如果该点没有遍历</span><br>                vis[i] = <span class="hljs-literal">true</span>;<br>                temp.<span class="hljs-built_in">push_back</span>(nums[i]); <span class="hljs-comment">// 进入下一状态</span><br>                <span class="hljs-built_in">dfs</span>(nums, len + <span class="hljs-number">1</span>, res, temp);<br>                temp.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回退一下</span><br>                vis[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>正确答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">100</span>); <span class="hljs-comment">// 检查是否遍历过</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; res; <span class="hljs-comment">//结果数组</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>        <span class="hljs-comment">//为了防止3303无法检测出来所以采用排序让相同的贴在一起</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>, res, temp);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> len, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; res, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; temp)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == len)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i] &amp;&amp; !vis[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 防止反回来是一样的 </span><br>            <span class="hljs-keyword">if</span>(!vis[i])&#123; <span class="hljs-comment">// 如果该点没有遍历</span><br>                vis[i] = <span class="hljs-literal">true</span>;<br>                temp.<span class="hljs-built_in">push_back</span>(nums[i]); <span class="hljs-comment">// 进入下一状态</span><br>                <span class="hljs-built_in">dfs</span>(nums, len + <span class="hljs-number">1</span>, res, temp);<br>                temp.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回退一下</span><br>                vis[i] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="7组合"><a class="markdownIt-Anchor" href="#7组合"></a> 7）组合</h4><blockquote><p>If n = 4 and k = 2, a solution is:<br />[<br />[2,4],<br />[3,4],<br />[2,3],<br />[1,2],<br />[1,3],<br />[1,4],<br />]</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; res;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; cur;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, n, k, res, cur);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; res, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; cur)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(cur.<span class="hljs-built_in">size</span>() == k)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(cur);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = s; i &lt;= n; ++i)&#123;<br>            cur.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, n, k, res, cur);<br>            cur.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="8组合求和"><a class="markdownIt-Anchor" href="#8组合求和"></a> 8）组合求和</h4><blockquote><p>given candidate set [2, 3, 6, 7] and target 7,<br />A solution set is:<br />[[7],[2, 2, 3]]</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; candidates, <span class="hljs-keyword">int</span> target) &#123; <span class="hljs-comment">//这道题综合了前几道题</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; res;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 需要按顺序</span><br>        <span class="hljs-built_in">dfs</span>(candidates, target, res, temp, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; res, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; temp, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> s)</span></span>&#123;<br>        <span class="hljs-comment">// t为当前数值， temp为当前数组</span><br>        <span class="hljs-keyword">if</span>(target == t)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = s; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(t + nums[i] &lt;= target)&#123;<br>                temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-built_in">dfs</span>(nums, target, res, temp, t + nums[i], s);<br>                s++; <span class="hljs-comment">// 当我需要选择下一个的时候 必须从下一个数本身开始不允许回溯</span><br>                temp.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<span class="hljs-keyword">else</span>&#123; <br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>      <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="9含有相同元素的组合求和"><a class="markdownIt-Anchor" href="#9含有相同元素的组合求和"></a> 9）含有相同元素的组合求和</h4><blockquote><p>For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,<br />A solution set is:<br />[<br />[1, 7],<br />[1, 2, 5],<br />[2, 6],<br />[1, 1, 6]<br />]</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">150</span>);<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; candidates, <span class="hljs-keyword">int</span> target) &#123; <span class="hljs-comment">//这道题综合了前几道题</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; res;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(), candidates.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 需要按顺序</span><br>        <span class="hljs-built_in">dfs</span>(candidates, target, res, temp, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; res, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; temp, <span class="hljs-keyword">int</span> t, <span class="hljs-keyword">int</span> s)</span></span>&#123;<br>        <span class="hljs-comment">// t为当前数值， temp为当前数组</span><br>        <span class="hljs-keyword">if</span>(target &lt; t) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 剪枝 加速</span><br>        <span class="hljs-keyword">if</span>(target == t)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = s; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span> &amp;&amp; !vis[i - <span class="hljs-number">1</span>] &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i]) <span class="hljs-keyword">continue</span>;<br>            vis[i] = <span class="hljs-literal">true</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">dfs</span>(nums, target, res, temp, t + nums[i], i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            vis[i] = <span class="hljs-literal">false</span>;<br>        &#125; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="101-9-数字的组合求和"><a class="markdownIt-Anchor" href="#101-9-数字的组合求和"></a> 10）1-9 数字的组合求和</h4><blockquote><p>Input: k = 3, n = 9</p><p>Output:</p><p>[[1,2,6], [1,3,5], [2,3,4]]</p></blockquote><p>从 1-9 数字中选出 k 个数不重复的数，使得它们的和为 n。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">100</span>);<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; res;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>        <span class="hljs-built_in">dfs</span>(k, n, res, temp, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> target, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; res, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; temp, <span class="hljs-keyword">int</span> curVal, <span class="hljs-keyword">int</span> s)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(curVal &gt; target) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 剪枝</span><br>        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == k &amp;&amp; curVal == target)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = s; i &lt;= <span class="hljs-number">9</span>; ++i)&#123; <span class="hljs-comment">// 最多使用1～9一次</span><br>            <span class="hljs-keyword">if</span>(vis[i]) <span class="hljs-keyword">continue</span>;<br>            vis[i] = <span class="hljs-literal">true</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">dfs</span>(k, target, res, temp, curVal + i, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            vis[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>最新的simple method</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; res;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n) &#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>        <span class="hljs-built_in">dfs</span>(k, n, <span class="hljs-number">0</span>, temp, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> t, vector&lt;<span class="hljs-keyword">int</span>&gt; temp, <span class="hljs-keyword">int</span> s)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(t == n &amp;&amp; temp.<span class="hljs-built_in">size</span>() == k)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = s; i &lt;= <span class="hljs-number">9</span>; ++i)&#123;<br>            <span class="hljs-keyword">if</span>(t + i &gt; n) <span class="hljs-keyword">return</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-built_in">dfs</span>(k, n, t + i, temp, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="11子集"><a class="markdownIt-Anchor" href="#11子集"></a> 11）子集</h4><p>找出集合的所有子集，子集不能重复，[1, 2] 和 [2, 1] 这种子集算重复</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; res;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> s)</span></span>&#123;<br>        res.<span class="hljs-built_in">push_back</span>(temp);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = s; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">dfs</span>(nums, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="12含有相同元素求子集"><a class="markdownIt-Anchor" href="#12含有相同元素求子集"></a> 12）含有相同元素求子集</h4><blockquote><p>For example,<br />If nums = [1,2,2], a solution is:</p><p>[<br />[2],<br />[1],<br />[1,2,2],<br />[2,2],<br />[1,2],<br />[]<br />]</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; res;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; temp;<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">100</span>);<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> s)</span></span>&#123;<br>        res.<span class="hljs-built_in">push_back</span>(temp);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = s; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] == nums[i] &amp;&amp; !vis[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(vis[i]) <span class="hljs-keyword">continue</span>;<br>            vis[i] = <span class="hljs-literal">true</span>;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">dfs</span>(nums, i + <span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>            vis[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="13-分割字符串使得每个部分都是回文数挺不错的变种题"><a class="markdownIt-Anchor" href="#13-分割字符串使得每个部分都是回文数挺不错的变种题"></a> 13） 分割字符串使得每个部分都是回文数（挺不错的变种题）</h4><blockquote><p>For example, given s = “aab”,<br />Return</p><p>[<br />[“aa”,“b”],<br />[“a”,“a”,“b”]<br />]</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt; &gt; res;<br>    vector&lt;string&gt; temp;<br>    <br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-built_in">dfs</span>(s);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string s)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>            res.<span class="hljs-built_in">push_back</span>(temp); <span class="hljs-comment">// s光了 说明temp中存入了足够的</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i)&#123; <span class="hljs-comment">// 直接截断 </span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isPalindrome</span>(s, <span class="hljs-number">0</span>, i))&#123;<br>                temp.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, i + <span class="hljs-number">1</span>)); <span class="hljs-comment">// 说明0到i符合</span><br>                <span class="hljs-built_in">dfs</span>(s.<span class="hljs-built_in">substr</span>(i + <span class="hljs-number">1</span>)); <span class="hljs-comment">// 将剩下的部分扔给后面处理</span><br>                temp.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(string s, <span class="hljs-keyword">int</span> begin, <span class="hljs-keyword">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(begin &lt; end)&#123;<br>            <span class="hljs-keyword">if</span>(s[begin++] != s[end--])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="14数独"><a class="markdownIt-Anchor" href="#14数独"></a> 14）数独</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123; <span class="hljs-comment">// 这道题整体思路可以学习，但是部分的思路就按照公式走</span><br>        <span class="hljs-built_in">fill</span>(board); <span class="hljs-comment">// starting！！！</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp; board, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, <span class="hljs-keyword">char</span> c)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i)&#123;<br>            <span class="hljs-keyword">if</span>(board[row][i] == c || board[i][col] == c) <span class="hljs-comment">// 按照列和行扫发现时候有问题</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(board[<span class="hljs-number">3</span>*(row/<span class="hljs-number">3</span>) + i/<span class="hljs-number">3</span>][<span class="hljs-number">3</span>*(col/<span class="hljs-number">3</span>) + i%<span class="hljs-number">3</span>] == c) <span class="hljs-comment">// 检测一圈</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">fill</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt; &gt;&amp; board)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; ++j)&#123;<br>                <span class="hljs-keyword">if</span>(board[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>)&#123; <span class="hljs-comment">// 如果这里是空的</span><br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;1&#x27;</span>; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; ++c)&#123; <span class="hljs-comment">// 从0到9开始尝试</span><br>                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(board, i, j, c))&#123; <span class="hljs-comment">// 如果满足这个可以防止字符c</span><br>                            board[i][j] = c; <span class="hljs-comment">// 修改</span><br>                            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fill</span>(board)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 加入了c进入下一决策树状态检测</span><br>                            <span class="hljs-keyword">else</span> board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>; <span class="hljs-comment">//如果检测失败了该回溯一下</span><br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 都放不了那就false放弃这个分支</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 都填完毕了</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="15n皇后"><a class="markdownIt-Anchor" href="#15n皇后"></a> 15）N皇后</h4><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202203222113752.png" alt="截屏2022-03-22 下午9.12.36" /></p><p>在 n*n 的矩阵中摆放 n 个皇后，并且每个皇后不能在同一行，同一列，同一对角线上，求所有的 n 皇后的解。</p><p>一行一行地摆放，在确定一行中的那个皇后应该摆在哪一列时，需要用三个标记数组来确定某一列是否合法，这三个标记数组分别为：列标记数组、45 度对角线标记数组和 135 度对角线标记数组。</p><p>45 度对角线标记数组的长度为 2 * n - 1，通过下图可以明确 (r, c) 的位置所在的数组下标为 r + c。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202203222114140.png" alt="截屏2022-03-22 下午9.12.43" /></p><p>135 度对角线标记数组的长度也是 2 * n - 1，(r, c) 的位置所在的数组下标为 n - 1 - (r - c)。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202203222113391.png" alt="截屏2022-03-22 下午9.12.53" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt; &gt; res;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-keyword">int</span> n) &#123;<br>        vector&lt;string&gt; cur;<br>        string t = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            t.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;.&#x27;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            cur.<span class="hljs-built_in">push_back</span>(t);<br>        <span class="hljs-built_in">nqueen</span>(cur, <span class="hljs-number">0</span>, n);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nqueen</span><span class="hljs-params">(vector&lt;string&gt;&amp; temp, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(r == n)&#123; <span class="hljs-comment">//说明该行填满了</span><br>            res.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(temp, r, i))&#123;<br>                temp[r][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>                <span class="hljs-built_in">nqueen</span>(temp, r + <span class="hljs-number">1</span>, n);<br>                temp[r][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(vector&lt;string&gt;&amp; temp, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> x = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(x &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(temp[x--][j] == <span class="hljs-string">&#x27;Q&#x27;</span>) <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//上方不可以有</span><br>        &#125;<br>        <span class="hljs-comment">//检测斜左上方</span><br>        x = i - <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">int</span> y = j - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(temp[x--][y--] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//检测斜右上方</span><br>        x = i - <span class="hljs-number">1</span>, y = j + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; temp.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(temp[x--][y++] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="七-动态规划"><a class="markdownIt-Anchor" href="#七-动态规划"></a> 七、动态规划</h2><h3 id="1-斐波那契数列"><a class="markdownIt-Anchor" href="#1-斐波那契数列"></a> 1、斐波那契数列</h3><h4 id="1爬楼梯"><a class="markdownIt-Anchor" href="#1爬楼梯"></a> 1）爬楼梯</h4><p><strong>题目描述</strong>：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。</p><p>定义一个数组 dp 存储上楼梯的方法数（为了方便讨论，数组下标从 1 开始），dp[i] 表示走到第 i 个楼梯的方法数目。</p><p>第 i 个楼梯可以从第 i-1 和 i-2 个楼梯再走一步到达，走到第 i 个楼梯的方法数为走到第 i-1 和第 i-2 个楼梯的方法数之和。</p><p><a href="https://camo.githubusercontent.com/e338c14ea6c9d3835eb3abf116ac03c237f13514d69046be87a5ca9a4bb695e9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31346665316537312d383531382d343538662d613232302d3131363030333036316138332e706e67"><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202203230822041.png" alt="img" /></a></p><p>考虑到 dp[i] 只与 dp[i - 1] 和 dp[i - 2] 有关，因此可以只用两个变量来存储 dp[i - 1] 和 dp[i - 2]，使得原来的 O(N) 空间复杂度优化为 O(1) 复杂度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <span class="hljs-keyword">int</span> pre1 = <span class="hljs-number">1</span>, pre2 = <span class="hljs-number">2</span>, cur;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; ++i)&#123;<br>            cur = pre1 + pre2;<br>            pre1 = pre2;<br>            pre2 = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>需要空间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">50</span>)</span></span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; ++i)&#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2强盗抢劫"><a class="markdownIt-Anchor" href="#2强盗抢劫"></a> 2）强盗抢劫</h4><p><strong>题目描述</strong>：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。</p><p>定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。</p><p>由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dp[i] = max(dp[i - 2] + num[i], dp[i - 1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">2</span>] + nums[i], dp[i - <span class="hljs-number">1</span>]); <span class="hljs-comment">// 如果要获取当前这个 也只能是空一格的前一个才能取， 要不然就是什么都不加</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3强盗在环形街区抢劫"><a class="markdownIt-Anchor" href="#3强盗在环形街区抢劫"></a> 3）强盗在环形街区抢劫</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123; <span class="hljs-comment">// 循环圈的意思就是会有一个错位的问题 将问题拆成两部分就行了</span><br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 取0 不取 size - 2 取 1 不取 size - 1 这样头尾就差2</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">robDp</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>), <span class="hljs-built_in">robDp</span>(nums, <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">robDp</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> pre1 = <span class="hljs-number">0</span>, pre2 = <span class="hljs-number">0</span>; <span class="hljs-comment">// 存储两个之前的可能状态</span><br>        <span class="hljs-keyword">int</span> best;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start; i &lt;= end; ++i)&#123;<br>            best = <span class="hljs-built_in">max</span>(pre1 + nums[i], pre2); <br>            pre1 = pre2;                      <br>            pre2 = best;                      <br>        &#125;<br>        <span class="hljs-keyword">return</span> best;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4信件错排"><a class="markdownIt-Anchor" href="#4信件错排"></a> 4）信件错排</h4><p><strong>题目描述</strong>：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。</p><p>定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：</p><ul><li>i==k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。</li><li>i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。</li></ul><p>综上所述，错误装信数量方式数量为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>∗</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = (i - 2) *dp[i - 2] + (i - 1) * dp[i - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></p><h4 id="5母牛生产"><a class="markdownIt-Anchor" href="#5母牛生产"></a> 5）母牛生产</h4><p><strong>题目描述</strong>：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。</p><p>dp[i] 代表第i年成熟的牛的数量</p><p>所以就是去年的成熟牛 加上三年前生的牛成熟的数量相加就是所求</p><p>第 i 年成熟的牛的数量为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>3</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[i - 1] + dp[i - 3]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">]</span></span></span></span></span></p><h3 id="2-矩阵路径"><a class="markdownIt-Anchor" href="#2-矩阵路径"></a> 2、矩阵路径</h3><h4 id="1矩阵的最小路径和"><a class="markdownIt-Anchor" href="#1矩阵的最小路径和"></a> 1）矩阵的最小路径和</h4><blockquote><p>[[1,3,1],<br />[1,5,1],<br />[4,2,1]]<br />Given the above grid map, return 7. Because the path 1→3→1→1→1 minimizes the sum.</p></blockquote><p><strong>题目描述</strong>：求从矩阵的左上角到右下角的最小路径和，每次只能向右和向下移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = grid.<span class="hljs-built_in">size</span>(), n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)&#123;<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 第一列的话只能向下</span><br>                    dp[j] += grid[i][j];<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 第一行只能向右走</span><br>                    dp[j] = dp[j - <span class="hljs-number">1</span>] + grid[i][j];<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j != <span class="hljs-number">0</span>)&#123;<br>                    dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - <span class="hljs-number">1</span>]) + grid[i][j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2矩阵的总路径数"><a class="markdownIt-Anchor" href="#2矩阵的总路径数"></a> 2）矩阵的总路径数</h4><p><strong>题目描述</strong>：统计从矩阵左上角到右下角的路径总数，每次只能向右或者向下移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>            dp[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; ++j)&#123;<br>                dp[j] += dp[j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>也可以直接用数学公式求解，这是一个组合问题。机器人总共移动的次数 S=m+n-2，向下移动的次数 D=m-1，那么问题可以看成从 S 中取出 D 个位置的组合数量，这个问题的解为 C(S, D)。</p><p>S = m - 1 + n - 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> S = m + n - <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> D = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">long</span> ret = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= D; ++i)&#123;<br>            ret = ret * (S - D + i) / i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-数组区间"><a class="markdownIt-Anchor" href="#3-数组区间"></a> 3、数组区间</h3><h4 id="1数组区间和"><a class="markdownIt-Anchor" href="#1数组区间和"></a> 1）数组区间和</h4><blockquote><p>Given nums = [-2, 0, 3, -5, 2, -1]</p><p>sumRange(0, 2) -&gt; 1<br />sumRange(2, 5) -&gt; -1<br />sumRange(0, 5) -&gt; -3</p></blockquote><p>求区间 i ~ j 的和，可以转换为 sum[j + 1] - sum[i]，其中 sum[i] 为 0 ~ i - 1 的和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NumArray</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; sum; <span class="hljs-comment">// 用和做差来代表区间长度 注意区分left 为 0 时和 left不为0 时的结果</span><br>    <span class="hljs-comment">//因为比如1 到 2 的话 需要求的是 1 2 所以是 sum[2] - sum[0]</span><br>    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            cur += nums[i];<br>            sum.<span class="hljs-built_in">push_back</span>(cur);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> sum[right];<br>        <span class="hljs-keyword">return</span> sum[right] - sum[left - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your NumArray object will be instantiated and called as such:</span><br><span class="hljs-comment"> * NumArray* obj = new NumArray(nums);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;sumRange(left,right);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h4 id="2数组中等差递增子区间的个数"><a class="markdownIt-Anchor" href="#2数组中等差递增子区间的个数"></a> 2）数组中等差递增子区间的个数</h4><blockquote><p>A = [0, 1, 2, 3, 4]</p><p>return: 6, for 3 arithmetic slices in A:</p><p>[0, 1, 2],<br />[1, 2, 3],<br />[0, 1, 2, 3],<br />[0, 1, 2, 3, 4],<br />[ 1, 2, 3, 4],<br />[2, 3, 4]</p></blockquote><p>dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。</p><p>当 A[i] - A[i-1] == A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。</p><blockquote><p>dp[2] = 1<br />[0, 1, 2]<br />dp[3] = dp[2] + 1 = 2<br />[0, 1, 2, 3], // [0, 1, 2] 之后加一个 3<br />[1, 2, 3]     // 新的递增子区间<br />dp[4] = dp[3] + 1 = 3<br />[0, 1, 2, 3, 4], // [0, 1, 2, 3] 之后加一个 4<br />[1, 2, 3, 4],    // [1, 2, 3] 之后加一个 4<br />[2, 3, 4]        // 新的递增子区间</p></blockquote><p>综上，在 A[i] - A[i-1] == A[i-1] - A[i-2] 时，dp[i] = dp[i-1] + 1。</p><p>因为递增子区间不一定以最后一个元素为结尾，可以是任意一个元素结尾，因此需要返回 dp 数组累加的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; dp = vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">5001</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numberOfArithmeticSlices</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] - nums[i - <span class="hljs-number">1</span>] == nums[i - <span class="hljs-number">1</span>] - nums[i - <span class="hljs-number">2</span>])&#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<span class="hljs-comment">// 因为每一个状态下的子序列都长的不一样所以和为累积和</span><br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> d: dp)&#123;<br>            cnt += d;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-分割整数"><a class="markdownIt-Anchor" href="#4-分割整数"></a> 4、分割整数</h3><h4 id="1分割整数的最大乘积"><a class="markdownIt-Anchor" href="#1分割整数的最大乘积"></a> 1）分割整数的最大乘积</h4><p><strong>题目描述</strong>：For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; dp = vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">60</span>);<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; ++j)&#123;<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], <span class="hljs-built_in">max</span>(j * dp[i - j], j * (i - j))); <span class="hljs-comment">// 一个是i - j目前分解的最大 还是整个i - j 最大</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2按平方数分割整数不同上面的bfs这里用dp"><a class="markdownIt-Anchor" href="#2按平方数分割整数不同上面的bfs这里用dp"></a> 2）按平方数分割整数（不同上面的BFS这里用dp）</h4><p><strong>题目描述</strong>：For example, given n = 12, return 3 because 12 = 4 + 4 + 4; given n = 13, return 2 because 13 = 4 + 9.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123; <span class="hljs-comment">// 不是他自己 就是 减去当前下一个平方差</span><br>        vector&lt;<span class="hljs-keyword">int</span>&gt; dp = vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">10001</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)&#123;<br>            dp[i] = i; <span class="hljs-comment">// 相当于全是1</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>; j * j &lt;= i; ++j)&#123;<br>                dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i - j * j] + <span class="hljs-number">1</span>); <span class="hljs-comment">// +1 就是 当前这个可能性加上</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3分割整数构成字母字符串"><a class="markdownIt-Anchor" href="#3分割整数构成字母字符串"></a> 3）分割整数构成字母字符串</h4><p><strong>题目描述</strong>：Given encoded message “12”, it could be decoded as “AB” (1 2) or “L” (12).</p><p>处理当前的i的时候只需要看第i - 1 或者i - 2 的个数就行了，因为当前这个东西分割完不会增加分割的方法的个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(string s)</span> </span>&#123; <span class="hljs-comment">// 只需要分两种一种是0~9字符 一种是10 ～ 26字符</span><br>        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; dp = vector&lt;<span class="hljs-keyword">int</span>&gt;(n);<br>        dp[<span class="hljs-number">0</span>] = s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>; <span class="hljs-comment">// 为了防止s contains only digits and may contain leading zero(s).</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)&#123;<br>            <span class="hljs-keyword">int</span> one = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">int</span> two = s[i] - <span class="hljs-string">&#x27;0&#x27;</span> + (<span class="hljs-number">10</span> * (s[i - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>));<br>            <span class="hljs-keyword">if</span>(one &gt;= <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 1 到 9  </span><br>                dp[i] += dp[i - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">10</span> &lt;= two &amp;&amp; two &lt;= <span class="hljs-number">26</span>)&#123;<br>                dp[i] += i &gt;= <span class="hljs-number">2</span> ? dp[i - <span class="hljs-number">2</span>] : <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果回到前两个的话 说明需要吞掉前一个，也就是说不需要+1</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-最长递增子序列"><a class="markdownIt-Anchor" href="#5-最长递增子序列"></a> 5、最长递增子序列</h3><p>已知一个序列 {S1, S2,…,Sn}，取出若干数组成新的序列 {Si1, Si2,…, Sim}，其中 i1、i2 … im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个 <strong>子序列</strong> 。</p><p>如果在子序列中，当下标 ix &gt; iy 时，Six &gt; Siy，称子序列为原序列的一个 <strong>递增子序列</strong> 。</p><p>定义一个数组 dp 存储最长递增子序列的长度，dp[n] 表示以 Sn 结尾的序列的最长递增子序列长度。对于一个递增子序列 {Si1, Si2,…,Sim}，如果 im &lt; n 并且 Sim &lt; Sn，此时 {Si1, Si2,…, Sim, Sn} 为一个递增子序列，递增子序列的长度增加 1。满足上述条件的递增子序列中，长度最长的那个递增子序列就是要找的，在长度最长的递增子序列上加上 Sn 就构成了以 Sn 为结尾的最长递增子序列。因此 dp[n] = max{ dp[i]+1 | Si &lt; Sn &amp;&amp; i &lt; n} 。</p><p>因为在求 dp[n] 时可能无法找到一个满足条件的递增子序列，此时 {Sn} 就构成了递增子序列，需要对前面的求解方程做修改，令 dp[n] 最小为 1，即：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn><mi mathvariant="normal">∣</mi><msub><mi>S</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>S</mi><mi>n</mi></msub><mi mathvariant="normal">&amp;</mi><mi mathvariant="normal">&amp;</mi><mi>i</mi><mo>&lt;</mo><mi>n</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">dp[n] = max\{1, dp[i] + 1| S_i &lt; S_n \&amp;\&amp; i &lt; n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">&amp;</span><span class="mord">&amp;</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">}</span></span></span></span></span></p><p>对于一个长度为 N 的序列，最长递增子序列并不一定会以 Sn 为结尾，因此 dp[N] 不是序列的最长递增子序列的长度，需要遍历 dp 数组找出最大值才是所要的结果，max{ dp[i] | 1 &lt;= i &lt;= N} 即为所求。</p><h4 id="1最长递增子序列"><a class="markdownIt-Anchor" href="#1最长递增子序列"></a> 1）最长递增子序列</h4><p>复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; dp = vector&lt;<span class="hljs-keyword">int</span>&gt;(nums.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            dp[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j])&#123;<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">-0xffff</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> d:dp)&#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, d);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以使用二分查找将时间复杂度降低为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlog_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><p>定义一个 tails 数组，其中 tails[i] 存储长度为 i + 1 的最长递增子序列的最后一个元素。对于一个元素 x，</p><ul><li>如果它大于 tails 数组所有的值，那么把它添加到 tails 后面，表示最长递增子序列长度加 1；</li><li>如果 tails[i-1] &lt; x &lt;= tails[i]，那么更新 tails[i] = x。</li></ul><p>例如对于数组 [4,3,6,5]，有：</p><blockquote><p>tails      len      num<br />[]         0        4<br />[4]        1        3<br />[3]        1        6<br />[3,6]      2        5<br />[3,5]      2        null</p></blockquote><p>可以看出 tails 数组保持有序，因此在查找 Si 位于 tails 数组的位置时就可以使用二分查找。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">tail</span><span class="hljs-params">(nums.size(), <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n: nums)&#123;<br>            <span class="hljs-keyword">int</span> idx = <span class="hljs-built_in">binarySearch</span>(tail, len, n);<br>            tail[idx] = n; <span class="hljs-comment">// 如果tail[len - 1] &lt; x &lt; tail[len] 则更新tail[idx] idx == len 也就是出界了</span><br>            <span class="hljs-keyword">if</span>(idx == len)&#123;<br>                len++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> curLen, <span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = curLen;<br>        <span class="hljs-keyword">while</span>(l &lt; h)&#123;<br>            <span class="hljs-keyword">int</span> m = l + (h - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[m] == key)&#123;<br>                <span class="hljs-keyword">return</span> m;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[m] &gt; key)&#123;<br>                h = m; <span class="hljs-comment">// 这样最后的返回index才可以是最后一个</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[m] &lt; key)&#123;<br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2一组整数对能够构成的最长链"><a class="markdownIt-Anchor" href="#2一组整数对能够构成的最长链"></a> 2）一组整数对能够构成的最长链</h4><blockquote><p>Input: [[1,2], [2,3], [3,4]]<br />Output: 2<br />Explanation: The longest chain is [1,2] -&gt; [3,4]</p></blockquote><p><strong>题目描述</strong>：对于 (a, b) 和 (c, d) ，如果 b &lt; c，则它们可以构成一条链。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLongestChain</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = pairs.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(pairs.<span class="hljs-built_in">begin</span>(), pairs.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 每个情况最起码都有一个</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j)&#123;<br>                <span class="hljs-keyword">if</span>(pairs[i][<span class="hljs-number">0</span>] &gt; pairs[j][<span class="hljs-number">1</span>])<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; a, vector&lt;<span class="hljs-keyword">int</span>&gt; b)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3最长摆动子序列"><a class="markdownIt-Anchor" href="#3最长摆动子序列"></a> 3）最长摆动子序列</h4><blockquote><p>Input: [1,7,4,9,2,5]<br />Output: 6<br />The entire sequence is a wiggle sequence.</p><p>Input: [1,17,5,10,13,15,10,5,16,8]<br />Output: 7<br />There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].</p><p>Input: [1,2,3,4,5,6,7,8,9]<br />Output: 2</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123; <span class="hljs-comment">// 返回最长的震动子序列</span><br>        <span class="hljs-keyword">int</span> up = <span class="hljs-number">1</span>, down = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始子串</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i - <span class="hljs-number">1</span>] &lt; nums[i])<br>                up = down + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i - <span class="hljs-number">1</span>] &gt; nums[i])<br>                down = up + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> up &gt; down ? up : down;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-最长公共子序列"><a class="markdownIt-Anchor" href="#6-最长公共子序列"></a> 6、最长公共子序列</h3><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202203241813017.png" alt="截屏2022-03-24 下午6.13.45" /></p><h4 id="1-最长公共子序列"><a class="markdownIt-Anchor" href="#1-最长公共子序列"></a> 1） 最长公共子序列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = text1.<span class="hljs-built_in">size</span>(), m = text2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(m + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j)&#123;<br>                <span class="hljs-keyword">if</span>(text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>])&#123; <span class="hljs-comment">// i j 表示的是真实坐标 但是 数组需要 - 1</span><br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//当不同的时候一定是从一方减少一个开始才能找到最长子序列</span><br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]); <span class="hljs-comment">// 这里不需要加一 因为还没有匹配成功</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-0-1背包"><a class="markdownIt-Anchor" href="#7-0-1背包"></a> 7、0-1背包</h3><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202203250825565.png" alt="截屏2022-03-25 上午8.25.45" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// W 为背包总体积</span><br><span class="hljs-comment">// N 为物品数量</span><br><span class="hljs-comment">// weights 数组存储 N 个物品的重量</span><br><span class="hljs-comment">// values 数组存储 N 个物品的价值</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> W, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span>[] weights, <span class="hljs-keyword">int</span>[] values)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N + <span class="hljs-number">1</span>][W + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-keyword">int</span> w = weights[i - <span class="hljs-number">1</span>], v = values[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= W; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= w) &#123;<br>                dp[i][j] = Math.<span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i - <span class="hljs-number">1</span>][j - w] + v);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[N][W];<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202203250913901.png" alt="截屏2022-03-25 上午9.13.09" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> W, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span>[] weights, <span class="hljs-keyword">int</span>[] values)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[W + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-keyword">int</span> w = weights[i - <span class="hljs-number">1</span>], v = values[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = W; j &gt;= <span class="hljs-number">1</span>; j--) &#123;<br>            <span class="hljs-keyword">if</span> (j &gt;= w) &#123;<br>                dp[j] = Math.<span class="hljs-built_in">max</span>(dp[j], dp[j - w] + v);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[W];<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202203250951785.png" alt="截屏2022-03-25 上午9.50.57" /></p><p><a href="https://blog.csdn.net/mch2869253130/article/details/81906962">https://blog.csdn.net/mch2869253130/article/details/81906962</a></p><h4 id="1划分数组为和相等的两部分"><a class="markdownIt-Anchor" href="#1划分数组为和相等的两部分"></a> 1）划分数组为和相等的两部分</h4><blockquote><p>Input: [1, 5, 11, 5]</p><p>Output: true</p><p>Explanation: The array can be partitioned as [1, 5, 5] and [11].</p></blockquote><p>可以看成一个背包大小为 sum/2 的 0-1 背包问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k: nums)&#123;<br>            sum += k;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 如果和不是偶数的话那就错了</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> W = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(W + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 因为没有东西就当可以了</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = W; j &gt;= num; --j)&#123;<br>                dp[j] = dp[j] || dp[j - num]; <span class="hljs-comment">//不能装或者可以装 </span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[W];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2改变一组数的正负号使得它们的和为一给定数"><a class="markdownIt-Anchor" href="#2改变一组数的正负号使得它们的和为一给定数"></a> 2）改变一组数的正负号使得它们的和为一给定数</h4><blockquote><p>Input: nums is [1, 1, 1, 1, 1], S is 3.<br />Output: 5<br />Explanation:</p><p>-1+1+1+1+1 = 3<br />+1-1+1+1+1 = 3<br />+1+1-1+1+1 = 3<br />+1+1+1-1+1 = 3<br />+1+1+1+1-1 = 3</p><p>There are 5 ways to assign symbols to make the sum of nums be target 3.</p></blockquote><p>该问题可以转换为 Subset Sum 问题，从而使用 0-1 背包的方法来求解。</p><p>可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，有以下推导：</p><blockquote><p>sum§ - sum(N) = target</p><p>sum§ + sum(N) + sum§ - sum(N) = target + sum§ + sum(N)<br />2 * sum§ = target + sum(nums)</p></blockquote><p>因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2，就证明存在解。</p><p>看成一个包裹大小为(target + sum(nums))/2的0-1背包</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num: nums)&#123;<br>            sum += num;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum &lt; <span class="hljs-built_in">abs</span>(target) ||  (target + sum) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 加绝对值 防止[100] -200</span><br>        <span class="hljs-keyword">int</span> W = (target + sum) / <span class="hljs-number">2</span>;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; dp = vector&lt;<span class="hljs-keyword">int</span>&gt;(W + <span class="hljs-number">1</span>);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 0 的时候代表 正好装满</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = W; j &gt;= num; --j)&#123;<br>                dp[j] += dp[j - num]; <span class="hljs-comment">// 因为是统计有多少种情况，所以是放不放的数量都放进去</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[W];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>DFS的解法（很容易超时）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>, target);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> val)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == len)&#123;<span class="hljs-comment">//如果用了所有的数</span><br>            <span class="hljs-keyword">return</span> val == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果都减光了 那就是0</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(nums, len + <span class="hljs-number">1</span>, val - nums[len]) + <span class="hljs-built_in">dfs</span>(nums, len + <span class="hljs-number">1</span>, val + nums[len]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="301-字符构成最多的字符串"><a class="markdownIt-Anchor" href="#301-字符构成最多的字符串"></a> 3）01 字符构成最多的字符串</h4><blockquote><p>Input: Array = {“10”, “0001”, “111001”, “1”, “0”}, m = 5, n = 3<br />Output: 4</p><p>Explanation: There are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10”,“0001”,“1”,“0”</p></blockquote><p>这是一个多维费用的 0-1 背包问题，有两个背包大小，0 的数量和 1 的数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-comment">// m 个 0， n 个 1</span><br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> str: strs)&#123;<br>            <span class="hljs-keyword">int</span> zeros = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> ones = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c: str)&#123;<br>                <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;0&#x27;</span>) zeros++;<br>                <span class="hljs-keyword">else</span> ones++;<br>            &#125;<br>            <span class="hljs-comment">// 相当于两个背包 这原本是一个三维背包</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = m; i &gt;= zeros; --i)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = n; j &gt;= ones; --j)&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - zeros][j - ones] + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4找零钱的最少硬币数"><a class="markdownIt-Anchor" href="#4找零钱的最少硬币数"></a> 4）找零钱的最少硬币数</h4><blockquote><p>Example 1:<br />coins = [1, 2, 5], amount = 11<br />return 3 (11 = 5 + 5 + 1)</p><p>Example 2:<br />coins = [2], amount = 3<br />return -1.</p></blockquote><p><strong>题目描述</strong>：给一些面额的硬币，要求用这些硬币来组成给定面额的钱数，并且使得硬币数量最少。硬币可以重复使用。</p><ul><li>物品：硬币</li><li>物品大小：面额</li><li>物品价值：数量</li></ul><p>因为硬币可以重复使用，因此这是一个完全背包问题。完全背包只需要将 0-1 背包的逆序遍历 dp 数组改为正序遍历即可。</p><p>PS：完全背包可以正序遍历的原因在于他的数组可以动态多更新，尽量多的放当前着一种。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123; <br>        <span class="hljs-keyword">if</span>(amount == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 边界单独处理</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> coin: coins)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = coin; j &lt;= amount; ++j)&#123;<br>                <span class="hljs-keyword">if</span>(j == coin)&#123; <span class="hljs-comment">//袋子里正好只能装当前这颗小硬币</span><br>                    dp[j] = <span class="hljs-number">1</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[j] == <span class="hljs-number">0</span> &amp;&amp; dp[j - coin] != <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 说明这个状态还没有初始化过 并且需要袋子</span><br>                    <span class="hljs-comment">//dp[j - coin] != 0 代表我之前已经装过硬币了，不会出现硬币放入后不能满足最终结果的情况比如[2] 3 是非法的</span><br>                    dp[j] = dp[j - coin] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dp[j - coin] != <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 说明当前这个袋子装过至少一种币了</span><br>                    dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j - coin] + <span class="hljs-number">1</span>);<br>                &#125;   <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount] == <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="5找零钱的硬币数组合"><a class="markdownIt-Anchor" href="#5找零钱的硬币数组合"></a> 5）找零钱的硬币数组合</h4><blockquote><p>Input: amount = 5, coins = [1, 2, 5]<br />Output: 4<br />Explanation: there are four ways to make up the amount:<br />5=5<br />5=2+2+1<br />5=2+1+1+1<br />5=1+1+1+1+1</p></blockquote><p>完全背包问题，使用 dp 记录可达成目标的组合数目。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> amount, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; coins)</span> </span>&#123; <span class="hljs-comment">// 是一个完全背包问题</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount + <span class="hljs-number">1</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 正好装满时为一种</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> coin: coins)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = coin; i &lt;= amount; ++i)&#123;<br>                dp[i] += dp[i - coin]; <span class="hljs-comment">// 加上不放这个东西 实现该价值 以及 放上这个东西实现该价值的方法</span><br>            &#125;            <br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[amount];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="6字符串按单词列表分割"><a class="markdownIt-Anchor" href="#6字符串按单词列表分割"></a> 6）字符串按单词列表分割</h4><blockquote><p>s = “leetcode”,<br />dict = [“leet”, “code”].<br />Return true because “leetcode” can be segmented as “leet code”.</p></blockquote><p>dict 中的单词没有使用次数的限制，因此这是一个完全背包问题。</p><p>该问题涉及到字典中单词的使用顺序，也就是说物品必须按一定顺序放入背包中，例如下面的 dict 就不够组成字符串 “leetcode”：</p><blockquote><p>[“lee”, “tc”, “cod”]</p></blockquote><p>求解顺序的完全背包问题时，对物品的迭代应该放在最里层，对背包的迭代放在外层，只有这样才能让物品按一定顺序放入背包中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-keyword">bool</span>&gt; dp = vector&lt;<span class="hljs-keyword">bool</span>&gt;(n + <span class="hljs-number">1</span>); <span class="hljs-comment">// 必须得内层按照顺序检验</span><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> word : wordDict)&#123;<br>                <span class="hljs-keyword">int</span> len = word.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 获取当前字符长度</span><br>                <span class="hljs-comment">//substr（startIndex,lenth）： 第二个参数是截取字符串的长度（从起始点截取某个长度的字符串）</span><br>                <span class="hljs-keyword">if</span>(i &gt;= len &amp;&amp; word == s.<span class="hljs-built_in">substr</span>(i - len, len))&#123;<br>                    dp[i] = dp[i] || dp[i - len]; <span class="hljs-comment">// 传递状态</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="7组合总和"><a class="markdownIt-Anchor" href="#7组合总和"></a> 7）组合总和</h4><blockquote><p>nums = [1, 2, 3]<br />target = 4</p><p>The possible combination ways are:<br />(1, 1, 1, 1)<br />(1, 1, 2)<br />(1, 2, 1)<br />(1, 3)<br />(2, 1, 1)<br />(2, 2)<br />(3, 1)</p><p>Note that different sequences are counted as different combinations.</p><p>Therefore the output is 7.</p></blockquote><p>涉及顺序的完全背包。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123; <span class="hljs-comment">// 有顺序的完全背包</span><br>        vector&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt; dp = vector&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt;(target + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= target; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)&#123;<br>                <span class="hljs-keyword">if</span>(i &gt;= num)&#123;<br>                     dp[i] += dp[i - num];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="8-股票交易"><a class="markdownIt-Anchor" href="#8-股票交易"></a> 8、股票交易</h3><h4 id="1需要冷却期的股票交易"><a class="markdownIt-Anchor" href="#1需要冷却期的股票交易"></a> 1）需要冷却期的股票交易</h4><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202203280849285.png" alt="截屏2022-03-28 上午8.49.33" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-comment">// dp[i][0] 第i天持有股票 dp[i][1] 第i天不持有股票</span><br>        <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, i - <span class="hljs-number">2</span>)][<span class="hljs-number">1</span>] - prices[i]); <span class="hljs-comment">// 当前刚买或者没卖</span><br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i]);  <span class="hljs-comment">//一直没买 或者是 当前刚卖</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 最后肯定没有持股</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2需要交易费用的股票交易"><a class="markdownIt-Anchor" href="#2需要交易费用的股票交易"></a> 2）需要交易费用的股票交易</h4><blockquote><p>Input: prices = [1, 3, 2, 8, 4, 9], fee = 2<br />Output: 8<br />Explanation: The maximum profit can be achieved by:<br />Buying at prices[0] = 1<br />Selling at prices[3] = 8<br />Buying at prices[4] = 4<br />Selling at prices[5] = 9<br />The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</p></blockquote><p>题目描述：每交易一次，都要支付一定的费用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices, <span class="hljs-keyword">int</span> fee)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">2</span>));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - prices[i]);<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i] - fee); <span class="hljs-comment">// 只需要剪一个费用</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>空间压缩一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices, <span class="hljs-keyword">int</span> fee)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> hold = -prices[<span class="hljs-number">0</span>], unhold = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)&#123;<br>            hold = <span class="hljs-built_in">max</span>(hold, unhold - prices[i]);<br>            unhold = <span class="hljs-built_in">max</span>(unhold, hold + prices[i] - fee); <span class="hljs-comment">// 只需要剪一个费用</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> unhold;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3只能进行两次的股票交易"><a class="markdownIt-Anchor" href="#3只能进行两次的股票交易"></a> 3）只能进行两次的股票交易</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-comment">//用四个变量来控制四个时间点下的利润</span><br>        <span class="hljs-keyword">int</span> firstBuy = <span class="hljs-number">-0xffff</span>, firstSell = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> secondBuy = <span class="hljs-number">-0xffff</span>, secondSell = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> price : prices)&#123;<br>            firstBuy = <span class="hljs-built_in">max</span>(firstBuy, -price);<br>            firstSell = <span class="hljs-built_in">max</span>(firstSell, firstBuy + price);<br>            secondBuy = <span class="hljs-built_in">max</span>(secondBuy, firstSell - price);;<br>            secondSell = <span class="hljs-built_in">max</span>(secondSell, secondBuy + price);<br>        &#125;<br>        <span class="hljs-keyword">return</span> secondSell;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4只能进行-k-次的股票交易"><a class="markdownIt-Anchor" href="#4只能进行-k-次的股票交易"></a> 4）只能进行 k 次的股票交易</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123; <span class="hljs-comment">// 可以卖k次</span><br>        <span class="hljs-keyword">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//当k 大于 总数一半的时候我们就退化成了普通的股票问题</span><br>        <span class="hljs-keyword">if</span>(k &gt;= n / <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)&#123;<br>                <span class="hljs-keyword">if</span>(prices[i] &gt; prices[i - <span class="hljs-number">1</span>])&#123;<br>                    ans += prices[i] - prices[i - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">buy</span><span class="hljs-params">(k + <span class="hljs-number">1</span>, <span class="hljs-number">-0xffff</span>)</span>, <span class="hljs-title">sell</span><span class="hljs-params">(k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> price : prices)&#123; <span class="hljs-comment">// 这里就是从只能进行两次交易那个方法迁移过来的</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i)&#123; <span class="hljs-comment">// 代表第i次交易的利润状态</span><br>                buy[i] = <span class="hljs-built_in">max</span>(buy[i], sell[i - <span class="hljs-number">1</span>] - price);<br>                sell[i] = <span class="hljs-built_in">max</span>(sell[i], buy[i] + price);<br>            &#125; <br>        &#125;<br>        <span class="hljs-keyword">return</span> sell[k];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="9-字符串编辑"><a class="markdownIt-Anchor" href="#9-字符串编辑"></a> 9、字符串编辑</h3><h4 id="1删除两个字符串的字符使它们相等"><a class="markdownIt-Anchor" href="#1删除两个字符串的字符使它们相等"></a> 1）删除两个字符串的字符使它们相等</h4><blockquote><p>Input: “sea”, “eat”<br />Output: 2<br />Explanation: You need one step to make “sea” to “ea” and another step to make “eat” to “ea”.</p></blockquote><p>可以转换为求两个字符串的最长公共子序列问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123; <span class="hljs-comment">// 直接当作求最大公共子序列</span><br>        <span class="hljs-keyword">int</span> m = word1.<span class="hljs-built_in">size</span>(), n = word2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j)&#123;<br>                <span class="hljs-keyword">if</span>(word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>])&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> m + n - <span class="hljs-number">2</span> * dp[m][n]; <span class="hljs-comment">// 就是算一下除了相同的部分剩余不同的部分一共有多少</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2编辑距离"><a class="markdownIt-Anchor" href="#2编辑距离"></a> 2）编辑距离</h4><blockquote><p>Example 1:</p><p>Input: word1 = “horse”, word2 = “ros”<br />Output: 3<br />Explanation:<br />horse -&gt; rorse (replace ‘h’ with ‘r’)<br />rorse -&gt; rose (remove ‘r’)<br />rose -&gt; ros (remove ‘e’)<br />Example 2:</p><p>Input: word1 = “intention”, word2 = “execution”<br />Output: 5<br />Explanation:<br />intention -&gt; inention (remove ‘t’)<br />inention -&gt; enention (replace ‘i’ with ‘e’)<br />enention -&gt; exention (replace ‘n’ with ‘x’)<br />exention -&gt; exection (replace ‘n’ with ‘c’)<br />exection -&gt; execution (insert ‘u’)</p></blockquote><p><strong>题目描述</strong>：修改一个字符串成为另一个字符串，使得修改次数最少。一次修改操作包括：插入一个字符、删除一个字符、替换一个字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = word1.<span class="hljs-built_in">size</span>(), n = word2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 这部分也就是一个有 一个无 就等于需要改变另一个有的数量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = j;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j)&#123;<br>                <span class="hljs-keyword">if</span>(word1[i - <span class="hljs-number">1</span>] == word2[j - <span class="hljs-number">1</span>])&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];  <span class="hljs-comment">// 不需要修改</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-comment">// dp[i - 1][j - 1] 就等于替换 dp[i - 1][j] 等于删除了一个</span><br>                    <span class="hljs-comment">// dp[i][j] 等于插入一个新的</span><br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>])) + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3复制粘贴字符"><a class="markdownIt-Anchor" href="#3复制粘贴字符"></a> 3）复制粘贴字符</h4><p><strong>题目描述</strong>：最开始只有一个字符 A，问需要多少次操作能够得到 n 个字符 A，每次操作可以复制当前所有的字符，或者粘贴。</p><blockquote><p>Input: 3<br />Output: 3<br />Explanation:<br />Intitally, we have one character ‘A’.<br />In step 1, we use Copy All operation.<br />In step 2, we use Paste operation to get ‘AA’.<br />In step 3, we use Paste operation to get ‘AAA’.</p></blockquote><p><a href="https://www.cnblogs.com/grandyang/p/7439616.html">https://www.cnblogs.com/grandyang/p/7439616.html</a></p><p>分治法处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSteps</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(n); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> i + <span class="hljs-built_in">minSteps</span>(n / i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>dp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSteps</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)&#123;<br>            dp[i] = i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">1</span>; --j)&#123;<br>                <span class="hljs-keyword">if</span>(i % j == <span class="hljs-number">0</span>)&#123;<br>                    dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[j] + i / j); <span class="hljs-comment">// 就是加上我弄成的i/j组需要i/j次和j组里的dp[j]个需要多少次</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="八-数学"><a class="markdownIt-Anchor" href="#八-数学"></a> 八、数学</h2><h3 id="1-素数"><a class="markdownIt-Anchor" href="#1-素数"></a> 1、素数</h3><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202203311025152.png" alt="截屏2022-03-31 上午10.24.43" style="zoom:50%;" /><h4 id="1生成素数数列"><a class="markdownIt-Anchor" href="#1生成素数数列"></a> 1）生成素数数列</h4><p>埃拉托斯特尼筛法在每次找到一个素数时，将能被素数整除的数排除掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">notPrime</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i)&#123; <span class="hljs-comment">// n 不用看</span><br>            <span class="hljs-keyword">if</span>(notPrime[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            count++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> j = (<span class="hljs-keyword">long</span>)i * (<span class="hljs-keyword">long</span>)i; j &lt; n; j += i)&#123;<br>                notPrime[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2最大公约数"><a class="markdownIt-Anchor" href="#2最大公约数"></a> 2）最大公约数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br></code></pre></td></tr></table></figure><p>最小公倍数为两数的乘积除以最大公约数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a * b / <span class="hljs-built_in">gcd</span>(a, b);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3使用位操作和减法求解最大公约数"><a class="markdownIt-Anchor" href="#3使用位操作和减法求解最大公约数"></a> 3）使用位操作和减法求解最大公约数</h4><p>这里就是直接记吧，我暂时也没有看懂他是什么理论。</p><p>对于 a 和 b 的最大公约数 f(a, b)，有：</p><ul><li>如果 a 和 b 均为偶数，f(a, b) = 2*f(a/2, b/2);</li><li>如果 a 是偶数 b 是奇数，f(a, b) = f(a/2, b);</li><li>如果 b 是偶数 a 是奇数，f(a, b) = f(a, b/2);</li><li>如果 a 和 b 均为奇数，f(a, b) = f(b, a-b);</li></ul><p>乘 2 和除 2 都可以转换为移位操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; b) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(b, a);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    boolean isAEven = <span class="hljs-built_in">isEven</span>(a), isBEven = <span class="hljs-built_in">isEven</span>(b);<br>    <span class="hljs-keyword">if</span> (isAEven &amp;&amp; isBEven) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-built_in">gcd</span>(a &gt;&gt; <span class="hljs-number">1</span>, b &gt;&gt; <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isAEven &amp;&amp; !isBEven) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(a &gt;&gt; <span class="hljs-number">1</span>, b);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isAEven &amp;&amp; isBEven) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(a, b &gt;&gt; <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(b, a - b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-进制转换"><a class="markdownIt-Anchor" href="#2-进制转换"></a> 2、进制转换</h3><h4 id="1-7-进制"><a class="markdownIt-Anchor" href="#1-7-进制"></a> 1） 7 进制</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convertToBase7</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        <span class="hljs-keyword">bool</span> sign = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">0</span>)&#123;<br>            num *= <span class="hljs-number">-1</span>;<br>            sign = <span class="hljs-literal">true</span>;<br>        &#125; <br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(num != <span class="hljs-number">0</span>)&#123;<br>            ans += (<span class="hljs-keyword">char</span>)(<span class="hljs-number">48</span> + num % <span class="hljs-number">7</span>);<br>            num /= <span class="hljs-number">7</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sign) ans += <span class="hljs-string">&#x27;-&#x27;</span>;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="216-进制"><a class="markdownIt-Anchor" href="#216-进制"></a> 2）16 进制</h4><blockquote><p>Input:<br />26</p><p>Output:<br />“1a”</p><p>Input:<br />-1</p><p>Output:<br />“ffffffff”</p></blockquote><p>负数要用它的补码形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">toHex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">char</span> map[] = &#123;<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>,<br>                   <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>&#125;;<br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> n = num;<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>            ans += map[n % <span class="hljs-number">16</span>];<br>            n /= <span class="hljs-number">16</span>;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="326进制"><a class="markdownIt-Anchor" href="#326进制"></a> 3）26进制</h4><blockquote><p>1 -&gt; A<br />2 -&gt; B<br />3 -&gt; C<br />…<br />26 -&gt; Z<br />27 -&gt; AA<br />28 -&gt; AB</p></blockquote><p>因为是从 1 开始计算的，而不是从 0 开始，因此需要对 n 执行 -1 操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">convertToTitle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> columnNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(columnNumber == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        columnNumber--; <span class="hljs-comment">// 本身是从0开始的但是从1开始计算</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">convertToTitle</span>(columnNumber / <span class="hljs-number">26</span>) + (<span class="hljs-keyword">char</span>)(columnNumber % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;A&#x27;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-阶乘"><a class="markdownIt-Anchor" href="#3-阶乘"></a> 3、阶乘</h3><h4 id="1统计阶乘尾部有多少个-0"><a class="markdownIt-Anchor" href="#1统计阶乘尾部有多少个-0"></a> 1）统计阶乘尾部有多少个 0</h4><p>尾部的 0 由 2 * 5 得来，2 的数量明显多于 5 的数量，因此只要统计有多少个 5 即可。</p><p>对于一个数 N，它所包含 5 的个数为：N/5 + N/52 + N/53 + …，其中 N/5 表示不大于 N 的数中 5 的倍数贡献一个 5，N/52 表示不大于 N 的数中 52 的倍数再贡献一个 5 …。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trailingZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : n / <span class="hljs-number">5</span> + <span class="hljs-built_in">trailingZeroes</span>(n / <span class="hljs-number">5</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果统计的是 N! 的二进制表示中最低位 1 的位置，只要统计有多少个 2 即可，该题目出自 [编程之美：2.2](<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode">https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode</a> 题解 - <a href="http://xn--48s96u.md">数学.md</a>#) 。和求解有多少个 5 一样，2 的个数为 N/2 + N/22 + N/23 + …</p><h3 id="4-字符串加减法"><a class="markdownIt-Anchor" href="#4-字符串加减法"></a> 4、字符串加减法</h3><h4 id="1二进制加法"><a class="markdownIt-Anchor" href="#1二进制加法"></a> 1）二进制加法</h4><blockquote><p>a = “11”<br />b = “1”<br />Return “100”.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addBinary</span><span class="hljs-params">(string a, string b)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> fa = a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> fb = b.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(fa &gt;= <span class="hljs-number">0</span> || fb &gt;= <span class="hljs-number">0</span> || carry)&#123;<br>            <span class="hljs-keyword">if</span>(fa &gt;= <span class="hljs-number">0</span>)&#123;<br>                carry += a[fa--] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(fb &gt;= <span class="hljs-number">0</span>)&#123;<br>                carry += b[fb--] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            ans += (carry % <span class="hljs-number">2</span> + <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">// 字母转数字</span><br>            carry /= <span class="hljs-number">2</span>; <span class="hljs-comment">// 为了消除一位</span><br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2字符串加法"><a class="markdownIt-Anchor" href="#2字符串加法"></a> 2）字符串加法</h4><p>字符串的值为非负整数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">addStrings</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n1 = num1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> n2 = num2.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        string ans = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n1 &gt;= <span class="hljs-number">0</span> || n2 &gt;= <span class="hljs-number">0</span> || carry &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(n1 &gt;= <span class="hljs-number">0</span>)&#123;<br>                carry += num1[n1--] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(n2 &gt;= <span class="hljs-number">0</span>)&#123;<br>                carry += num2[n2--] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            ans += carry % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;<br>            carry /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-相遇问题"><a class="markdownIt-Anchor" href="#5-相遇问题"></a> 5、相遇问题</h3><h4 id="1改变数组元素使所有的数组元素都相等"><a class="markdownIt-Anchor" href="#1改变数组元素使所有的数组元素都相等"></a> 1）改变数组元素使所有的数组元素都相等</h4><blockquote><p>Input:<br />[1,2,3]</p><p>Output:<br />2</p><p>Explanation:<br />Only two moves are needed (remember each move increments or decrements one element):</p><p>[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]</p></blockquote><p>每次可以对一个数组元素加一或者减一，求最小的改变次数。</p><p>这是个典型的相遇问题，移动距离最小的方式是所有元素都移动到中位数。理由如下：</p><p>设 m 为中位数。a 和 b 是 m 两边的两个元素，且 b &gt; a。要使 a 和 b 相等，它们总共移动的次数为 b - a，这个值等于 (b - m) + (m - a)，也就是把这两个数移动到中位数的移动次数。</p><p>设数组长度为 N，则可以找到 N/2 对 a 和 b 的组合，使它们都移动到 m 的位置。</p><p><strong>解法 1</strong></p><p>先排序，时间复杂度：O(NlogN)</p><p>这个方法是我的，顺序看</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minMoves2</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> flag = nums[n / <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)&#123;<br>            ans += <span class="hljs-built_in">abs</span>(num - flag);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>还有大神解法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minMoves2</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// b - a == (b - m) + (m - a)</span><br>        <span class="hljs-keyword">while</span>(l &lt;= h)&#123;<br>            ans += nums[h--] - nums[l++];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>解法 2</strong></p><p>使用快速选择找到中位数，时间复杂度 O(N)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minMoves2</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> mid = <span class="hljs-built_in">kth</span>(nums, nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 也就是排序成了mid左边都比mid小 右边都比mid大 然后结果也能找到mid 最后算结果</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)&#123;<br>            ans += <span class="hljs-built_in">abs</span>(num - mid);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, h = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> m;<br>        <span class="hljs-keyword">while</span>(l &lt; h)&#123;<br>            m = <span class="hljs-built_in">partition</span>(nums, l, h);<br>            <span class="hljs-keyword">if</span>(m == k) <span class="hljs-keyword">return</span> nums[m];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m &lt; k) l = m + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m &gt; k) h = m - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[l];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> h)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i = l, j = h;<br>        <span class="hljs-keyword">int</span> pivot = nums[l];<br>        <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>            <span class="hljs-keyword">while</span>(nums[j] &gt;= pivot &amp;&amp; i &lt; j) j--;<br>            nums[i] = nums[j];<br>            <span class="hljs-keyword">while</span>(nums[i] &lt;= pivot &amp;&amp; i &lt; j) i++;<br>            nums[j] = nums[i];<br>        &#125;<br>        nums[i] = pivot;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-多数投票问题"><a class="markdownIt-Anchor" href="#6-多数投票问题"></a> 6、多数投票问题</h3><h4 id="1数组中出现次数多于-n-2-的元素"><a class="markdownIt-Anchor" href="#1数组中出现次数多于-n-2-的元素"></a> 1）数组中出现次数多于 n / 2 的元素</h4><p>排序之后找中心就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。可以这么理解该算法：使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素不相等时，令 cnt–。如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2，因为如果多于 i / 2 的话 cnt 就一定不会为 0。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>, majority = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)&#123;<br>            majority = cnt == <span class="hljs-number">0</span> ? num : majority;<br>            num == majority ? cnt++ : cnt--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> majority;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-其它"><a class="markdownIt-Anchor" href="#7-其它"></a> 7、其它</h3><h4 id="1平方数"><a class="markdownIt-Anchor" href="#1平方数"></a> 1）平方数</h4><blockquote><p>Input: 16<br />Returns: True</p></blockquote><p>平方序列：1,4,9,16,…</p><p>间隔：3,5,7,…</p><p>间隔为等差数列，使用这个特性可以得到从 1 开始的平方序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(num &gt; <span class="hljs-number">0</span>)&#123;<br>            num -= temp;<br>            temp += <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="23-的-n-次方"><a class="markdownIt-Anchor" href="#23-的-n-次方"></a> 2）3 的 n 次方</h4><p>递归解法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">3</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isPowerOfThree</span>(n / <span class="hljs-number">3</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>最简单办法 用最大的数来做检验</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> (n &gt; <span class="hljs-number">0</span>) &amp;&amp; ((<span class="hljs-keyword">int</span>)<span class="hljs-built_in">pow</span>(<span class="hljs-number">3</span>, <span class="hljs-number">19</span>) % n == <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3乘积数组"><a class="markdownIt-Anchor" href="#3乘积数组"></a> 3）乘积数组</h4><blockquote><p>For example, given [1,2,3,4], return [24,12,8,6].</p></blockquote><p>给定一个数组，创建一个新数组，新数组的每个元素为原始数组中除了该位置上的元素之外所有元素的乘积。</p><p>要求时间复杂度为 O(N)，并且不能使用除法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, temp = <span class="hljs-number">1</span>; i &lt; n; temp *= nums[i++])&#123;<br>            ans[i] *= temp;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>, temp = <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; temp *= nums[i--])&#123;<br>            ans[i] *= temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4找出数组中的乘积最大的三个数"><a class="markdownIt-Anchor" href="#4找出数组中的乘积最大的三个数"></a> 4）找出数组中的乘积最大的三个数</h4><blockquote><p>Input: [1,2,3,4]<br />Output: 24</p></blockquote><p>先排序在弄，防止有负数，所以有两种解答，第二种为了抵消负号（负数越小，绝对值越大）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maximumProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[n - <span class="hljs-number">1</span>] * nums[n - <span class="hljs-number">2</span>] * nums[n - <span class="hljs-number">3</span>], nums[<span class="hljs-number">0</span>] * nums[<span class="hljs-number">1</span>] * nums[n - <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>非排序办法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maximumProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-comment">// 按序存储</span><br>        <span class="hljs-keyword">int</span> max1 = <span class="hljs-number">-0xffff</span>, max2 = <span class="hljs-number">-0xffff</span>, max3 = <span class="hljs-number">-0xffff</span>, min1 = <span class="hljs-number">0xffff</span>, min2 = <span class="hljs-number">0xffff</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)&#123;<br>            <span class="hljs-keyword">if</span>(num &gt; max1)&#123;<br>                max3 = max2;<br>                max2 = max1;<br>                max1 = num;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num &gt; max2)&#123;<br>                max3 = max2;<br>                max2 = num;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num &gt; max3)&#123;<br>                max3 = num;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(num &lt; min1)&#123;<br>                min2 = min1;<br>                min1 = num;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num &lt; min2)&#123;<br>                min2 = num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(max1 * max2 * max3, min1 * min2 * max1);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="数据结构相关"><a class="markdownIt-Anchor" href="#数据结构相关"></a> 数据结构相关</h1><h2 id="一-链表"><a class="markdownIt-Anchor" href="#一-链表"></a> 一、链表</h2><h3 id="1-找出两个链表的交点"><a class="markdownIt-Anchor" href="#1-找出两个链表的交点"></a> 1、找出两个链表的交点</h3><p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p><p>当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</p><p>如果不存在交点，那么 a + b = b + a，以下实现代码中 l1 和 l2 会同时为 null，从而退出循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode* l1 = headA, * l2 = headB;<br>        <span class="hljs-keyword">while</span>(l1 != l2)&#123;<br>            l1 = l1 == <span class="hljs-literal">NULL</span> ? headB : l1-&gt;next;<br>            l2 = l2 == <span class="hljs-literal">NULL</span> ? headA : l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果只是判断是否存在交点，那么就是另一个问题。有两种解法：</p><ul><li>把第一个链表的结尾连接到第二个链表的开头，看第二个链表是否存在环；</li><li>或者直接比较两个链表的最后一个节点是否相同。</li></ul><h3 id="2-链表反转"><a class="markdownIt-Anchor" href="#2-链表反转"></a> 2、链表反转</h3><p>递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode* next = head-&gt;next;<br>        ListNode* newHead = <span class="hljs-built_in">reverseList</span>(head-&gt;next); <span class="hljs-comment">// 这个头就是正常传递</span><br>        <span class="hljs-comment">// </span><br>        next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>头插法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* newHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            ListNode* next = head-&gt;next;<br>            head-&gt;next = newHead-&gt;next;<br>            newHead-&gt;next = head;<br>            head = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-归并两个有序的链表"><a class="markdownIt-Anchor" href="#3-归并两个有序的链表"></a> 3、归并两个有序的链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        <span class="hljs-comment">//谁没了就接谁</span><br>        <span class="hljs-keyword">if</span>(!list1) <span class="hljs-keyword">return</span> list2;<br>        <span class="hljs-keyword">if</span>(!list2) <span class="hljs-keyword">return</span> list1;<br>        <span class="hljs-keyword">if</span>(list1-&gt;val &lt; list2-&gt;val)&#123;<br>            list1-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(list1-&gt;next, list2);<span class="hljs-comment">//谁小这波就用谁</span><br>            <span class="hljs-keyword">return</span> list1;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            list2-&gt;next = <span class="hljs-built_in">mergeTwoLists</span>(list1, list2-&gt;next);<span class="hljs-comment">//谁小就用谁然后把状态推进下一轮</span><br>            <span class="hljs-keyword">return</span> list2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-从有序链表中删除重复节点"><a class="markdownIt-Anchor" href="#4-从有序链表中删除重复节点"></a> 4、从有序链表中删除重复节点</h3><blockquote><p>Given 1-&gt;1-&gt;2, return 1-&gt;2.<br />Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        head-&gt;next = <span class="hljs-built_in">deleteDuplicates</span>(head-&gt;next); <span class="hljs-comment">// 获得我下一个符合要求的地方</span><br>        <span class="hljs-keyword">return</span> head-&gt;next-&gt;val == head-&gt;val ? head-&gt;next : head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-删除链表的倒数第-n-个节点"><a class="markdownIt-Anchor" href="#5-删除链表的倒数第-n-个节点"></a> 5、删除链表的倒数第 n 个节点</h3><blockquote><p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.<br />After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//这个方法就是我替你走一步 你就少走一步</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span>(n--&gt;<span class="hljs-number">0</span>)&#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!fast) <span class="hljs-keyword">return</span> head-&gt;next; <span class="hljs-comment">// 删除倒数第n个也就是删除第一个</span><br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span>(fast-&gt;next)&#123;<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-交换链表中的相邻结点"><a class="markdownIt-Anchor" href="#6-交换链表中的相邻结点"></a> 6、交换链表中的相邻结点</h3><p>弄一个头，作为固定记录点，然后设置两个变量作为中间交换用的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        ListNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        node-&gt;next = head;<br>        ListNode* pre = node;<br>        <span class="hljs-keyword">while</span>(pre-&gt;next &amp;&amp; pre-&gt;next-&gt;next)&#123;<br>            ListNode* l1 = pre-&gt;next, *l2 = pre-&gt;next-&gt;next;<br>            l1-&gt;next = l2-&gt;next;<br>            l2-&gt;next = l1;<br>            pre-&gt;next = l2;<br>            pre = l1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>递归方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        ListNode* newHead = head-&gt;next;<br>        head-&gt;next = <span class="hljs-built_in">swapPairs</span>(head-&gt;next-&gt;next);<span class="hljs-comment">//接下一个状态的脚本</span><br>        newHead-&gt;next = head; <span class="hljs-comment">// 反指当前的点</span><br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-链表求和"><a class="markdownIt-Anchor" href="#7-链表求和"></a> 7、链表求和</h3><blockquote><p>Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br />Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</p></blockquote><p>题目要求：不能修改原始链表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; s1, s2;<br>        s1 = <span class="hljs-built_in">Build_stack</span>(l1);<br>        s2 = <span class="hljs-built_in">Build_stack</span>(l2);<br>        ListNode* newHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(!s1.<span class="hljs-built_in">empty</span>() || !s2.<span class="hljs-built_in">empty</span>() || cur)&#123;<br>            <span class="hljs-keyword">if</span>(!s1.<span class="hljs-built_in">empty</span>())&#123;<br>                cur += s1.<span class="hljs-built_in">top</span>();<br>                s1.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!s2.<span class="hljs-built_in">empty</span>())&#123;<br>                cur += s2.<span class="hljs-built_in">top</span>();<br>                s2.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            ListNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(cur % <span class="hljs-number">10</span>);<br>            cur /= <span class="hljs-number">10</span>;<br>            newNode-&gt;next = newHead-&gt;next;<br>            newHead-&gt;next = newNode;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newHead-&gt;next;<br>    &#125;<br>    <br>    stack &lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">Build_stack</span>(ListNode* l)&#123;<br>        stack &lt;<span class="hljs-keyword">int</span>&gt; s;<br>        <span class="hljs-keyword">while</span>(l)&#123;<br>            s.<span class="hljs-built_in">push</span>(l-&gt;val);<br>            l = l-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>或者不用stack直接用reverse反转链表再对齐计算</p><h3 id="8-回文链表"><a class="markdownIt-Anchor" href="#8-回文链表"></a> 8、回文链表</h3><p><strong>题目要求</strong>：以 O(1) 的空间复杂度来求解。</p><p>切成两半，把后半段反转，然后比较两半是否相等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 以下操作背下来就行了属于是快慢指针模版了</span><br>        ListNode* slow = head, *fast = head-&gt;next;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            slow = slow-&gt;next; <br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fast) slow = slow-&gt;next; <span class="hljs-comment">// 当fast不空的时候也就是偶数的时候需要移动一下</span><br>        <span class="hljs-comment">// 切两半</span><br>        ListNode* p1 = head;<br>        <span class="hljs-keyword">while</span>(p1-&gt;next != slow) p1 = p1-&gt;next;<br>        p1-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 切完了</span><br>        <span class="hljs-comment">//反转链表</span><br>        ListNode* part2 = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(slow)&#123;<br>            ListNode* next = slow-&gt;next;<br>            slow-&gt;next = part2;<br>            part2 = slow;<br>            slow = next;<br>        &#125;<br>        <span class="hljs-comment">//反转完成</span><br>        <span class="hljs-comment">//开始检测</span><br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            <span class="hljs-keyword">if</span>(head-&gt;val != part2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            head = head-&gt;next;<br>            part2 = part2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="9-分隔链表"><a class="markdownIt-Anchor" href="#9-分隔链表"></a> 9、分隔链表</h3><blockquote><p>Input:<br />root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3<br />Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]<br />Explanation:<br />The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.</p></blockquote><p><strong>题目描述</strong>：把链表分隔成 k 部分，每部分的长度都应该尽可能相同，排在前面的长度应该大于等于后面的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;ListNode*&gt; <span class="hljs-title">splitListToParts</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        vector&lt;ListNode* &gt; ans = vector&lt;ListNode* &gt; (k);<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-built_in">getLen</span>(head);<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">group</span><span class="hljs-params">(k, l / k)</span></span>;<br>        <span class="hljs-keyword">int</span> temp = l % k;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(temp--)&#123;<br>            group[i++]++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> g : group)&#123;<br>            ans[idx++] = head;<br>            <span class="hljs-keyword">while</span>(g &gt; <span class="hljs-number">1</span>) &#123;<br>                head = head-&gt;next;<br>                g--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(head)&#123;<br>                ListNode* next = head-&gt;next;<br>                head-&gt;next = <span class="hljs-literal">NULL</span>;<br>                head = next;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLen</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            len++;<br>            head = head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="10-链表元素按奇偶聚集"><a class="markdownIt-Anchor" href="#10-链表元素按奇偶聚集"></a> 10、链表元素按奇偶聚集</h3><blockquote><p>Example:<br />Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,<br />return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL.</p></blockquote><p>先分奇偶个数进行单独存储，讲偶数头单独存起来，最后和奇数最后一个拼起来，返回head</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        ListNode *odd = head, *even = head-&gt;next, *evenHead = even;<br>        <span class="hljs-keyword">while</span>(even &amp;&amp; even-&gt;next)&#123;<br>            odd-&gt;next = even-&gt;next;<br>            even-&gt;next = odd-&gt;next-&gt;next;<br>            odd = odd-&gt;next;<br>            even = even-&gt;next;<br>        &#125;<br>        odd-&gt;next = evenHead;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二-树"><a class="markdownIt-Anchor" href="#二-树"></a> 二、树</h2><h3 id="1-递归"><a class="markdownIt-Anchor" href="#1-递归"></a> 1、递归</h3><h4 id="1树的高度"><a class="markdownIt-Anchor" href="#1树的高度"></a> 1）树的高度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2平衡树"><a class="markdownIt-Anchor" href="#2平衡树"></a> 2）平衡树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">bool</span> res = <span class="hljs-literal">true</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">isB</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isB</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-built_in">isB</span>(root-&gt;left);<br>        <span class="hljs-keyword">int</span> r = <span class="hljs-built_in">isB</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span> &lt; <span class="hljs-built_in">abs</span>(l - r))&#123;<br>            res = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(l, r);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3两节点的最长路径"><a class="markdownIt-Anchor" href="#3两节点的最长路径"></a> 3）两节点的最长路径</h4><blockquote><p>Input:</p><pre><code>     1    / \   2  3  / \ 4   5</code></pre><p>Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>: <span class="hljs-comment">// 本质是求左右子树的高度和</span><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">sumSub</span>(root);<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumSub</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-built_in">sumSub</span>(root-&gt;left);<br>        <span class="hljs-keyword">int</span> r = <span class="hljs-built_in">sumSub</span>(root-&gt;right);<br>        sum = <span class="hljs-built_in">max</span>(sum, l + r);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(l, r);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4反转二叉树"><a class="markdownIt-Anchor" href="#4反转二叉树"></a> 4）反转二叉树</h4><p>无交换版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//这里最好用后续遍历 前中序遍历会出现问题 因为可能造成遍历覆盖的问题</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> root;<br>        TreeNode* L = root-&gt;left; <span class="hljs-comment">// 为了防止先处理的left被覆盖</span><br>        root-&gt;left = <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        root-&gt;right = <span class="hljs-built_in">invertTree</span>(L);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>交换版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<span class="hljs-comment">//这里最好用后续遍历 前中序遍历会出现问题 因为可能造成遍历覆盖的问题</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        <span class="hljs-built_in">swap</span>(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        TreeNode* temp = root-&gt;left;<br>        root-&gt;left = root-&gt;right;<br>        root-&gt;right = temp;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="5归并两棵树"><a class="markdownIt-Anchor" href="#5归并两棵树"></a> 5）归并两棵树</h4><blockquote><p>Input:<br />Tree 1                     Tree 2<br />1                         2<br />/ \                       / <br />3   2                     1   3<br />/                           \   <br />5                             4   7</p><p>Output:<br />3<br />/ <br />4   5<br />/ \   <br />5   4   7</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root1 &amp;&amp; !root2) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(!root1) <span class="hljs-keyword">return</span> root2;<br>        <span class="hljs-keyword">if</span>(!root2) <span class="hljs-keyword">return</span> root1;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(root1-&gt;val + root2-&gt;val);<br>        root-&gt;left = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);<br>        root-&gt;right = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="6判断路径和是否等于一个数"><a class="markdownIt-Anchor" href="#6判断路径和是否等于一个数"></a> 6）判断路径和是否等于一个数</h4><blockquote><p>Given the below binary tree and sum = 22,</p><pre><code>          5         / \        4   8       /   / \      11  13  4     /  \      \    7    2      1</code></pre><p>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p></blockquote><p>路径和定义为从 root 到 leaf 的所有节点的和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; targetSum == root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) || <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="7统计路径和等于一个数的路径数量"><a class="markdownIt-Anchor" href="#7统计路径和等于一个数的路径数量"></a> 7）统计路径和等于一个数的路径数量</h4><blockquote><p>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</p><pre><code>  10 /  \5   -3</code></pre><p>/ \    <br />3   2   11<br />/ \   <br />3  -2   1</p><p>Return 3. The paths that sum to 8 are:</p><ol><li>5 -&gt; 3</li><li>5 -&gt; 2 -&gt; 1</li><li>-3 -&gt; 11</li></ol></blockquote><p>路径不一定以 root 开头，也不一定以 leaf 结尾，但是必须连续。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 分三种情况：从根节点开始，从根左节点开始，从根右节点开始</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pathSumRoot</span>(root, targetSum) + <span class="hljs-built_in">pathSum</span>(root-&gt;left, targetSum) + <span class="hljs-built_in">pathSum</span>(root-&gt;right, targetSum);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pathSumRoot</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> target)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(target == root-&gt;val) ret++; <span class="hljs-comment">// 这里之所以放过去是因为如果这个之后还有可以计算得到结果的就得不到了</span><br>        ret += <span class="hljs-built_in">pathSumRoot</span>(root-&gt;left, target - root-&gt;val) + <span class="hljs-built_in">pathSumRoot</span>(root-&gt;right, target - root-&gt;val);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="8子树"><a class="markdownIt-Anchor" href="#8子树"></a> 8）子树</h4><blockquote><p>Given tree s:<br />3<br />/ <br />4   5<br />/ <br />1   2</p><p>Given tree t:<br />4<br />/ <br />1   2</p><p>Return true, because t has the same structure and node values with a subtree of s.</p><p>Given tree s:</p><p>​    3<br />​    / \</p><p>4   5<br />/ <br />1   2<br />/<br />0</p><p>Given tree t:<br />4<br />/ <br />1   2</p><p>Return false.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubtree</span><span class="hljs-params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubTreeRoot</span>(root, subRoot) || <span class="hljs-built_in">isSubtree</span>(root-&gt;left, subRoot) || <span class="hljs-built_in">isSubtree</span>(root-&gt;right, subRoot);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSubTreeRoot</span><span class="hljs-params">(TreeNode* r, TreeNode* s)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!r &amp;&amp; !s) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(!r || !s) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(r-&gt;val != s-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubTreeRoot</span>(r-&gt;left, s-&gt;left) &amp;&amp; <span class="hljs-built_in">isSubTreeRoot</span>(r-&gt;right, s-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="9树的对称"><a class="markdownIt-Anchor" href="#9树的对称"></a> 9）树的对称</h4><blockquote><p>​    1</p><p>/ <br />2   2<br />/ \ / <br />3  4 4  3</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSym</span>(root-&gt;left, root-&gt;right);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSym</span><span class="hljs-params">(TreeNode* l, TreeNode* r)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!l &amp;&amp; !r) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(!l || !r) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(l-&gt;val != r-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSym</span>(l-&gt;left, r-&gt;right) &amp;&amp; <span class="hljs-built_in">isSym</span>(l-&gt;right, r-&gt;left); <span class="hljs-comment">// 找对称位置所以这里是互换的</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="10最小路径"><a class="markdownIt-Anchor" href="#10最小路径"></a> 10）最小路径</h4><p>树的根节点到叶子节点的最小路径长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">minDepth</span>(root-&gt;left);<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">minDepth</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> left + right + <span class="hljs-number">1</span>; <span class="hljs-comment">// 说明是单分分支节点，需要取另一边</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(left, right) + <span class="hljs-number">1</span>; <span class="hljs-comment">//这里的+1都代表的是当前节点层</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="11统计左叶子节点的和"><a class="markdownIt-Anchor" href="#11统计左叶子节点的和"></a> 11）统计左叶子节点的和</h4><blockquote><pre><code>3</code></pre><p>/ <br />9  20<br />/  <br />15   7</p><p>There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 如果发现了左叶子那就记录一下那个大小 并且从右边继续找</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isLeaf</span>(root-&gt;left)) <span class="hljs-keyword">return</span> root-&gt;left-&gt;val + <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;right);<br>        <span class="hljs-comment">// 如果没有找到左边的树节点叶子，那么就是该状态下的左右去找</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;left) + <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;right);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isLeaf</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> !root-&gt;left &amp;&amp; !root-&gt;right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="12相同节点值的最大路径长度"><a class="markdownIt-Anchor" href="#12相同节点值的最大路径长度"></a> 12）相同节点值的最大路径长度</h4><blockquote><pre><code>         1        / \       4   5      / \   \     4   4   5</code></pre><p>Output : 2</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> path = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestUnivaluePath</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-keyword">int</span> l = (root-&gt;left &amp;&amp; root-&gt;left-&gt;val == root-&gt;val) ? left + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> r = (root-&gt;right &amp;&amp; root-&gt;right-&gt;val == root-&gt;val) ? right + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        path = <span class="hljs-built_in">max</span>(path, l + r);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(l, r);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="13间隔遍历"><a class="markdownIt-Anchor" href="#13间隔遍历"></a> 13）间隔遍历</h4><blockquote><pre><code> 3/ \</code></pre><p>2   3<br />\   <br />3   1<br />Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    unordered_map &lt;TreeNode*, <span class="hljs-keyword">int</span> &gt; dp; <span class="hljs-comment">// 为了防止出现连续求值的结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(dp.<span class="hljs-built_in">count</span>(root)) <span class="hljs-keyword">return</span> dp[root]; <span class="hljs-comment">// 返回跳跃的那个值（先检测跳跃部分）</span><br>        <span class="hljs-keyword">int</span> skip = root-&gt;val, noSkip = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;left)&#123;<br>            skip += <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;left);<br>            skip += <span class="hljs-built_in">rob</span>(root-&gt;left-&gt;right);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root-&gt;right)&#123;<br>            skip += <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;left);<br>            skip += <span class="hljs-built_in">rob</span>(root-&gt;right-&gt;right);<br>        &#125;<br>        noSkip += <span class="hljs-built_in">rob</span>(root-&gt;left);<br>        noSkip += <span class="hljs-built_in">rob</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> dp[root] = <span class="hljs-built_in">max</span>(skip, noSkip);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="14找出二叉树中第二小的节点"><a class="markdownIt-Anchor" href="#14找出二叉树中第二小的节点"></a> 14）找出二叉树中第二小的节点</h4><blockquote><p>Input:<br />2<br />/ <br />2   5<br />/ <br />5  7</p><p>Output: 5</p></blockquote><p>一个节点要么具有 0 个或 2 个子节点，如果有子节点，那么根节点是最小的节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    set&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findSecondMinimumValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">begin</span>();<br>        it++;<br>        <span class="hljs-keyword">return</span> *it;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        s.<span class="hljs-built_in">insert</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-层次遍历"><a class="markdownIt-Anchor" href="#2-层次遍历"></a> 2、层次遍历</h3><h4 id="1一棵树每层节点的平均数"><a class="markdownIt-Anchor" href="#1一棵树每层节点的平均数"></a> 1）一棵树每层节点的平均数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">double</span>&gt; ans;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> ans;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">int</span> n = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>                TreeNode* cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                sum += cur-&gt;val;<br>                <span class="hljs-keyword">if</span>(cur-&gt;left) q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right) q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(sum / n);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2得到左下角的节点"><a class="markdownIt-Anchor" href="#2得到左下角的节点"></a> 2）得到左下角的节点</h4><blockquote><p>Input:</p><pre><code>    1   / \  2   3 /   / \4   5   6   /  7</code></pre><p>Output:<br />7</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 就用层次遍历 但是从右边先走这样最后就是左边</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode* &gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            root = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(root-&gt;right) q.<span class="hljs-built_in">push</span>(root-&gt;right);<br>            <span class="hljs-keyword">if</span>(root-&gt;left) q.<span class="hljs-built_in">push</span>(root-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root-&gt;val;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-前中后序遍历"><a class="markdownIt-Anchor" href="#3-前中后序遍历"></a> 3、前中后序遍历</h3><h4 id="1非递归实现前序遍历"><a class="markdownIt-Anchor" href="#1非递归实现前序遍历"></a> 1）非递归实现前序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> res;<br>        stack&lt;TreeNode* &gt; s;<br>        s.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* cur = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-keyword">if</span>(cur-&gt;right) s.<span class="hljs-built_in">push</span>(cur-&gt;right); <span class="hljs-comment">// 因为stack是先进后出 所以我们反着弄</span><br>            <span class="hljs-keyword">if</span>(cur-&gt;left) s.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>        &#125; <br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2非递归实现后序遍历"><a class="markdownIt-Anchor" href="#2非递归实现后序遍历"></a> 2）非递归实现后序遍历</h4><p>前序遍历为 root -&gt; left -&gt; right，后序遍历为 left -&gt; right -&gt; root。可以修改前序遍历成为 root -&gt; right -&gt; left，那么这个顺序就和后序遍历正好相反。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> res;<br>        stack&lt;TreeNode* &gt; s;<br>        s.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* cur = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            res.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>            <span class="hljs-keyword">if</span>(cur-&gt;left) s.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>            <span class="hljs-keyword">if</span>(cur-&gt;right) s.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3非递归实现二叉树的中序遍历"><a class="markdownIt-Anchor" href="#3非递归实现二叉树的中序遍历"></a> 3）非递归实现二叉树的中序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// LTR 就是一直向左 左边没了中间输出一下再往右找一下 再继续向左</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> res;<br>        stack&lt;TreeNode* &gt; s;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span>(cur || !s.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">while</span>(cur)&#123;<br>                s.<span class="hljs-built_in">push</span>(cur);<br>                cur = cur-&gt;left;<br>            &#125;<br>            TreeNode* node = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            cur = node-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-bst"><a class="markdownIt-Anchor" href="#4-bst"></a> 4、BST</h3><p>二叉查找树（BST）：根节点大于等于左子树所有节点，小于等于右子树所有节点。</p><p>二叉查找树中序遍历有序。</p><h4 id="1修剪查找二叉树"><a class="markdownIt-Anchor" href="#1修剪查找二叉树"></a> 1）修剪查找二叉树</h4><blockquote><p>Input:</p><pre><code>3</code></pre><p>/ <br />0   4<br /><br />2<br />/<br />1</p><p>L = 1<br />R = 3</p><p>Output:</p><pre><code>  3 /</code></pre><p>2<br />/<br />1</p></blockquote><p>题目描述：只保留值在 L ~ R 之间的节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 如果可以就保留这个 不可以就找下一个满足的地方</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">// 如果有问题的话那就是这样</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; high) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; low) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-comment">// 如果没有问题的话那就是</span><br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2寻找二叉查找树的第-k-个元素"><a class="markdownIt-Anchor" href="#2寻找二叉查找树的第-k-个元素"></a> 2）寻找二叉查找树的第 k 个元素</h4><p>中序遍历解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// BST的中序遍历可以有顺序</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">inorder</span>(root, k);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;left, k);<br>        cnt++;<br>        <span class="hljs-keyword">if</span>(cnt == k)<br>            ans = root-&gt;val;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;right, k);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>递归解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode() &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="hljs-comment"> *         this.val = val;</span><br><span class="hljs-comment"> *         this.left = left;</span><br><span class="hljs-comment"> *         this.right = right;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> leftCnt = count(root.left);<br>        <span class="hljs-keyword">if</span> (leftCnt == k - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root.val; <span class="hljs-comment">// -1 是因为不包含当前这个节点</span><br>        <span class="hljs-keyword">if</span> (leftCnt &gt; k - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> kthSmallest(root.left, k); <span class="hljs-comment">// 如果不够 那就是还在左边呢</span><br>        <span class="hljs-keyword">return</span> kthSmallest(root.right, k - leftCnt - <span class="hljs-number">1</span>);<span class="hljs-comment">// 进入到右边这个区域来找</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + count(node.left) + count(node.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3把二叉查找树每个节点的值都加上比它大的节点的值"><a class="markdownIt-Anchor" href="#3把二叉查找树每个节点的值都加上比它大的节点的值"></a> 3）把二叉查找树每个节点的值都加上比它大的节点的值</h4><blockquote><p>Input: The root of a Binary Search Tree like this:</p><pre><code>          5        /   \       2     13</code></pre><p>Output: The root of a Greater Tree like this:</p><pre><code>         18        /   \      20     13</code></pre></blockquote><p>先遍历右子树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//按照右根左的顺序这样可以从大到小计算，然后通过存储的值就可以得到结果</span><br>    <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">trip</span>(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trip</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">trip</span>(root-&gt;right);<br>        temp += root-&gt;val; <span class="hljs-comment">// 将中途的值进行累计</span><br>        root-&gt;val = temp; <span class="hljs-comment">// 赋值一下就ok</span><br>        <span class="hljs-built_in">trip</span>(root-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4二叉查找树的最近公共祖先"><a class="markdownIt-Anchor" href="#4二叉查找树的最近公共祖先"></a> 4）二叉查找树的最近公共祖先</h4><blockquote><pre><code>    _______6______  /                \</code></pre><p>_<strong>2</strong>             _<strong>8</strong><br />/      \           /      <br />0        4         7        9<br />/  <br />3   5</p><p>For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-comment">// 比两个都大了 那我就往左找</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        <span class="hljs-comment">// 比两个都小了 那我就往右找</span><br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-comment">// 如果不可以优化了 那就是当前root</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="5二叉树的最近公共祖先"><a class="markdownIt-Anchor" href="#5二叉树的最近公共祖先"></a> 5）二叉树的最近公共祖先</h4><blockquote><pre><code>   _______3______  /              \</code></pre><p>_<strong>5</strong>           _<strong>1</strong><br />/      \         /      <br />6        2       0        8<br />/  <br />7    4</p><p>For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//只要是找到了就会有东西返回，如果没找到就没有东西返回</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root || root == q || root == p) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">return</span> !left ? right : !right ? left : root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="6从有序数组中构造二叉查找树"><a class="markdownIt-Anchor" href="#6从有序数组中构造二叉查找树"></a> 6）从有序数组中构造二叉查找树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">createBST</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">createBST</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> e)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(s &gt; e) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">int</span> m = s + (e - s) / <span class="hljs-number">2</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[m]);<br>        root-&gt;left = <span class="hljs-built_in">createBST</span>(nums, s, m - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">createBST</span>(nums, m + <span class="hljs-number">1</span>, e);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="7-根据有序链表构造平衡的二叉查找树"><a class="markdownIt-Anchor" href="#7-根据有序链表构造平衡的二叉查找树"></a> 7、根据有序链表构造平衡的二叉查找树</h4><blockquote><p>Given the sorted linked list: [-10,-3,0,5,9],</p><p>One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</p><pre><code>  0 / \</code></pre><p>-3   9<br />/   /<br />-10  5</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(!head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(head-&gt;val);<br>        ListNode* t = <span class="hljs-built_in">getTail</span>(head);<br>        ListNode* mid = t-&gt;next;<br>        t-&gt;next = <span class="hljs-literal">NULL</span>;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(mid-&gt;val);<br>        root-&gt;left = <span class="hljs-built_in">sortedListToBST</span>(head);<br>        root-&gt;right = <span class="hljs-built_in">sortedListToBST</span>(mid-&gt;next);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function">ListNode* <span class="hljs-title">getTail</span><span class="hljs-params">(ListNode* node)</span></span>&#123;<br>        ListNode* slow = node;<br>        ListNode* fast = node-&gt;next;<br>        ListNode* pre = node; <span class="hljs-comment">// 留一个pre的话这样可以存储到前一段部分的最后一个对于奇数个数列</span><br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            pre = slow;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="8-在二叉查找树中寻找两个节点使它们的和为一个给定值"><a class="markdownIt-Anchor" href="#8-在二叉查找树中寻找两个节点使它们的和为一个给定值"></a> 8、在二叉查找树中寻找两个节点，使它们的和为一个给定值</h4><blockquote><p>Input:</p><pre><code>5</code></pre><p>/ <br />3   6<br />/ \   <br />2   4   7</p><p>Target = 9</p><p>Output: True</p></blockquote><p>使用中序遍历得到有序数组之后，再利用双指针对数组进行查找。</p><p>应该注意到，这一题不能用分别在左右子树两部分来处理这种思想，因为两个待求的节点可能分别在左右子树中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">inOrder</span>(root);<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = v.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-keyword">int</span> cur = v[l] + v[r];<br>            <span class="hljs-keyword">if</span>(cur == k) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur &lt; k) l++;<br>            <span class="hljs-keyword">else</span> r--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123; <span class="hljs-comment">// 中序遍历获得</span><br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;left);<br>        v.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="9-在二叉查找树中查找两个节点之差的最小绝对值"><a class="markdownIt-Anchor" href="#9-在二叉查找树中查找两个节点之差的最小绝对值"></a> 9、在二叉查找树中查找两个节点之差的最小绝对值</h4><blockquote><p>Input:</p><p>1<br /><br />3<br />/<br />2</p><p>Output:</p><p>1</p></blockquote><p>利用二叉查找树的中序遍历为有序的性质，计算中序遍历中临近的两个节点之差的绝对值，取最小值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0xffff</span>;<br>    TreeNode* pre;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">inOrder</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span>(pre) ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">abs</span>(root-&gt;val - pre-&gt;val));<br>        pre = root;<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="10-寻找二叉查找树中出现次数最多的值"><a class="markdownIt-Anchor" href="#10-寻找二叉查找树中出现次数最多的值"></a> 10、寻找二叉查找树中出现次数最多的值</h4><blockquote><p>1<br /><br />2<br />/<br />2</p><p>return [2].</p></blockquote><p>答案可能不止一个，也就是有多个值出现的次数一样多。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-keyword">int</span> maxcnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;<br>    TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">inOrder</span>(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span>(pre)&#123;<br>            <span class="hljs-keyword">if</span>(pre-&gt;val == root-&gt;val) cnt++; <span class="hljs-comment">// 如果满足相等，因为BST中序遍历是按顺序的</span><br>            <span class="hljs-keyword">else</span> cnt = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 不相等的时候就重置一下</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt &gt; maxcnt)&#123;<br>            maxcnt = cnt; <span class="hljs-comment">// 更新一下</span><br>            res.<span class="hljs-built_in">clear</span>();<br>            res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            pre = root;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cnt == maxcnt)&#123; <span class="hljs-comment">// 当答案相同时就一起放进去</span><br>            res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        &#125;<br>        pre = root;<br>        <span class="hljs-built_in">inOrder</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-trie截屏2022-04-10-下午41913"><a class="markdownIt-Anchor" href="#5-trie截屏2022-04-10-下午41913"></a> 5、Trie<img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202204101619535.png" alt="截屏2022-04-10 下午4.19.13" /></h3><h4 id="1实现一个-trie"><a class="markdownIt-Anchor" href="#1实现一个-trie"></a> 1）实现一个 Trie</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//就是有26个分支的字典树</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span>&#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span>* <span class="hljs-title">dic</span>[26];</span><br>        <span class="hljs-keyword">bool</span> isLeaf; <span class="hljs-comment">// 是不是最后一个节点</span><br>    &#125;;<br>    TrieNode* node;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Trie</span>() &#123;<br>        node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>(); <span class="hljs-comment">// 定义一个根节点</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        TrieNode* cur = node; <span class="hljs-comment">// 处理当前根 有 26个分支</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : word)&#123;<br>            <span class="hljs-keyword">if</span>(!cur-&gt;dic[c - <span class="hljs-string">&#x27;a&#x27;</span>]) cur-&gt;dic[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>(); <span class="hljs-comment">// 如果有东西那就给他创造一个新的分支</span><br>            cur = cur-&gt;dic[c - <span class="hljs-string">&#x27;a&#x27;</span>]; <span class="hljs-comment">// 不管怎么说 如果能找到一样的那就直接前进一个 如果没有那也是前进 只不过是久的分支</span><br>        &#125;<br>        cur-&gt;isLeaf = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        TrieNode* cur = node; <span class="hljs-comment">// 处理当前根 有 26个分支</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : word)&#123;<br>            <span class="hljs-keyword">if</span>(!cur-&gt;dic[c - <span class="hljs-string">&#x27;a&#x27;</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果有东西那就给他创造一个新的分支</span><br>            cur = cur-&gt;dic[c - <span class="hljs-string">&#x27;a&#x27;</span>]; <span class="hljs-comment">// 不管怎么说 如果能找到一样的那就直接前进一个 如果没有那也是前进 只不过是久的分支</span><br>        &#125;<br>        <span class="hljs-keyword">if</span>(cur-&gt;isLeaf) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果按照序列走到最后</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>        TrieNode* cur = node; <span class="hljs-comment">// 处理当前根 有 26个分支</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : prefix)&#123;<br>            <span class="hljs-keyword">if</span>(!cur-&gt;dic[c - <span class="hljs-string">&#x27;a&#x27;</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果有东西那就给他创造一个新的分支</span><br>            cur = cur-&gt;dic[c - <span class="hljs-string">&#x27;a&#x27;</span>]; <span class="hljs-comment">// 不管怎么说 如果能找到一样的那就直接前进一个 如果没有那也是前进 只不过是久的分支</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 只要前面对应的是对的就是可以的</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Trie* obj = new Trie();</span><br><span class="hljs-comment"> * obj-&gt;insert(word);</span><br><span class="hljs-comment"> * bool param_2 = obj-&gt;search(word);</span><br><span class="hljs-comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h4 id="2实现一个-trie用来求前缀和"><a class="markdownIt-Anchor" href="#2实现一个-trie用来求前缀和"></a> 2）实现一个 Trie，用来求前缀和</h4><blockquote><p>Input: insert(“apple”, 3), Output: Null<br />Input: sum(“ap”), Output: 3<br />Input: insert(“app”, 2), Output: Null<br />Input: sum(“ap”), Output: 5</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapSum</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;string, <span class="hljs-keyword">int</span>&gt; m;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MapSum</span>() &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string key, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        m[key] = val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [key, val] : m) <span class="hljs-keyword">if</span>(key.<span class="hljs-built_in">find</span>(prefix) == <span class="hljs-number">0</span>) sum += val; <span class="hljs-comment">// 这个就是如果这个东西是这个词的前缀 那就把值加上去</span><br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MapSum object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MapSum* obj = new MapSum();</span><br><span class="hljs-comment"> * obj-&gt;insert(key,val);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;sum(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="三-栈和队列"><a class="markdownIt-Anchor" href="#三-栈和队列"></a> 三、栈和队列</h2><h3 id="1-用栈实现队列"><a class="markdownIt-Anchor" href="#1-用栈实现队列"></a> 1、用栈实现队列</h3><p>栈的顺序为后进先出，而队列的顺序为先进先出。使用两个栈实现队列，一个元素需要经过两个栈才能出队列，在经过第一个栈时元素顺序被反转，经过第二个栈时再次被反转，此时就是先进先出顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> &#123;</span><br>    stack&lt;<span class="hljs-keyword">int</span>&gt; in;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; out;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        in.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">transfor</span>();<br>        <span class="hljs-keyword">int</span> val = out.<span class="hljs-built_in">top</span>();<br>        out.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">transfor</span>();<br>        <span class="hljs-keyword">return</span> out.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transfor</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(out.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">while</span>(!in.<span class="hljs-built_in">empty</span>())&#123;<br>                out.<span class="hljs-built_in">push</span>(in.<span class="hljs-built_in">top</span>());<br>                in.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> in.<span class="hljs-built_in">empty</span>() &amp;&amp; out.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue* obj = new MyQueue();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;peek();</span><br><span class="hljs-comment"> * bool param_4 = obj-&gt;empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="2-用队列实现栈"><a class="markdownIt-Anchor" href="#2-用队列实现栈"></a> 2、用队列实现栈</h3><p>在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStack</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyStack</span>() &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        q.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">int</span> n = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(n--&gt;<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 把新放进来的放到队头 这样顺序就全返过来了</span><br>            <span class="hljs-keyword">int</span> val = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            q.<span class="hljs-built_in">push</span>(val);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> val = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">front</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack* obj = new MyStack();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * bool param_4 = obj-&gt;empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="3-最小值栈"><a class="markdownIt-Anchor" href="#3-最小值栈"></a> 3、最小值栈</h3><p><a href="https://blog.csdn.net/weixin_44338712/article/details/108051943">https://blog.csdn.net/weixin_44338712/article/details/108051943</a></p><p>记录各个取值的最大值最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; min; <span class="hljs-comment">// 用来记录状态</span><br>    <span class="hljs-keyword">int</span> m = INT_MAX;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        m = m &lt; val ? m : val;<br>        s.<span class="hljs-built_in">push</span>(val);<br>        min.<span class="hljs-built_in">push</span>(m);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 注意出栈的话需要</span><br>        s.<span class="hljs-built_in">pop</span>();<br>        min.<span class="hljs-built_in">pop</span>();<br>        m = min.<span class="hljs-built_in">empty</span>() ? INT_MAX : min.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> min.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack* obj = new MinStack();</span><br><span class="hljs-comment"> * obj-&gt;push(val);</span><br><span class="hljs-comment"> * obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * int param_4 = obj-&gt;getMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>这道题还可以有无数种解法，用各种数据结构都可以的话</p><p><strong>对于实现最小值队列问题，可以先将队列使用栈来实现，然后就将问题转换为最小值栈</strong>。</p><h3 id="4-用栈实现括号匹配"><a class="markdownIt-Anchor" href="#4-用栈实现括号匹配"></a> 4、用栈实现括号匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-keyword">char</span>&gt; t;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : s)&#123;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;[&#x27;</span> || c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;<br>                t.<span class="hljs-built_in">push</span>(c);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(t.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果直接来了一个右符号那肯定不对</span><br>            <span class="hljs-keyword">char</span> temp = t.<span class="hljs-built_in">top</span>();<br>            t.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">bool</span> b1 = temp == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;]&#x27;</span>;<br>            <span class="hljs-keyword">bool</span> b2 = temp == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>            <span class="hljs-keyword">bool</span> b3 = temp == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; c == <span class="hljs-string">&#x27;)&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(!b1 &amp;&amp; !b2 &amp;&amp; !b3)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> t.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-数组中元素与下一个比它大的元素之间的距离"><a class="markdownIt-Anchor" href="#5-数组中元素与下一个比它大的元素之间的距离"></a> 5、数组中元素与下一个比它大的元素之间的距离</h3><blockquote><p>Input: [73, 74, 75, 71, 69, 72, 76, 73]<br />Output: [1, 1, 4, 2, 1, 1, 0, 0]</p></blockquote><p>在遍历数组时用栈把数组中的数存起来，如果当前遍历的数比栈顶元素来的大，说明栈顶元素的下一个比它大的数就是当前元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = temperatures.<span class="hljs-built_in">size</span>();<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; s; <span class="hljs-comment">// 用来存储状态索引</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 用来存储答案</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>; cur&lt; n; ++cur)&#123;<br>            <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[cur] &gt; temperatures[s.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-keyword">int</span> pre = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                res[pre] = cur - pre;<br>            &#125;<br>            s.<span class="hljs-built_in">push</span>(cur);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-循环数组中比当前元素大的下一个元素"><a class="markdownIt-Anchor" href="#6-循环数组中比当前元素大的下一个元素"></a> 6、循环数组中比当前元素大的下一个元素</h3><blockquote><p>Input: [1,2,1]<br />Output: [2,-1,2]<br />Explanation: The first 1’s next greater number is 2;<br />The number 2 can’t find next greater number;<br />The second 1’s next greater number needs to search circularly, which is also 2.</p></blockquote><p>与 739. Daily Temperatures (Medium) 不同的是，数组是循环数组，并且最后要求的不是距离而是下一个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        stack&lt;<span class="hljs-keyword">int</span>&gt; s;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 没有比他大的数 显示-1 如果比他大那么就是那个数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; ++i)&#123; <span class="hljs-comment">// 因为是循环数组 所以需要转两圈</span><br>            <span class="hljs-keyword">int</span> cur = i % n; <span class="hljs-comment">// 获取当前的索引值</span><br>            <span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[cur] &gt; nums[s.<span class="hljs-built_in">top</span>()])&#123;<br>                <span class="hljs-keyword">int</span> pre = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                res[pre] = nums[cur];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i &lt; n)&#123;<br>                s.<span class="hljs-built_in">push</span>(i); <span class="hljs-comment">// 存入当前的遍历过的之前的值</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="四-哈希表"><a class="markdownIt-Anchor" href="#四-哈希表"></a> 四、哈希表</h2><h3 id="1-数组中两个数的和为给定值"><a class="markdownIt-Anchor" href="#1-数组中两个数的和为给定值"></a> 1、数组中两个数的和为给定值</h3><p>可以先对数组进行排序，然后使用双指针方法或者二分查找方法。这样做的时间复杂度为 O(NlogN)，空间复杂度为 O(1)。</p><p>用 HashMap 存储数组元素和索引的映射，在访问到 nums[i] 时，判断 HashMap 中是否存在 target - nums[i]，如果存在说明 target - nums[i] 所在的索引和 i 就是要找的两个数。该方法的时间复杂度为 O(N)，空间复杂度为 O(N)，使用空间来换取时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n ; ++i)&#123;<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(target - nums[i])) <span class="hljs-keyword">return</span> &#123;m[target - nums[i]], i&#125;;<br>            m[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-判断数组是否含有重复元素"><a class="markdownIt-Anchor" href="#2-判断数组是否含有重复元素"></a> 2、判断数组是否含有重复元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-keyword">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num: nums)&#123;<br>            s.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">size</span>() &lt; nums.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-最长和谐序列"><a class="markdownIt-Anchor" href="#3-最长和谐序列"></a> 3、最长和谐序列</h3><blockquote><p>Input: [1,3,2,2,5,2,3,7]<br />Output: 5<br />Explanation: The longest harmonious subsequence is [3,2,2,2,3].</p></blockquote><p>和谐序列中最大数和最小数之差正好为 1，应该注意的是序列的元素不一定是数组的连续元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLHS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num: nums)&#123;<br>            m[num]++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> longest = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)&#123;<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(num + <span class="hljs-number">1</span>)) <span class="hljs-comment">// 保证和它相差一的数是存在的</span><br>                longest = <span class="hljs-built_in">max</span>(longest, m[num] + m[num + <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> longest;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-最长连续序列"><a class="markdownIt-Anchor" href="#4-最长连续序列"></a> 4、最长连续序列</h3><blockquote><p>Given [100, 4, 200, 1, 3, 2],<br />The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.</p></blockquote><p>要求以 O(N) 的时间复杂度求解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)&#123;<br>            m[num] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [key, value]: m)&#123;<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(key + <span class="hljs-number">1</span>)) cnt++;<br>            <span class="hljs-keyword">else</span>&#123;<br>                ans = <span class="hljs-built_in">max</span>(cnt, ans);<br>                cnt = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="五-字符串"><a class="markdownIt-Anchor" href="#五-字符串"></a> 五、字符串</h2><h3 id="1-字符串循环移位包含"><a class="markdownIt-Anchor" href="#1-字符串循环移位包含"></a> 1、字符串循环移位包含</h3><blockquote><p>s1 = AABCD, s2 = CDAA<br />Return : true</p></blockquote><p><strong>查找子串用find函数</strong></p><p>在string对象中，查找参数string类型的字符串是否存在。如果存在，返回起始位置（string::size_type类型）；不存在则返回 string::npos。</p><p>给定两个字符串 s1 和 s2，要求判定 s2 是否能够被 s1 做循环移位得到的字符串包含。</p><p>s1 进行循环移位的结果是 s1s1 的子字符串，因此只要判断 s2 是否是 s1s1 的子字符串即可。</p><h3 id="2-字符串循环移位"><a class="markdownIt-Anchor" href="#2-字符串循环移位"></a> 2、字符串循环移位</h3><blockquote><p>s = “abcd123” k = 3<br />Return “123abcd”</p></blockquote><p>将字符串向右循环移动 k 位。</p><p>将 abcd123 中的 abcd 和 123 单独翻转，得到 dcba321，然后对整个字符串进行翻转，得到 123abcd。</p><h3 id="3-字符串中单词的翻转"><a class="markdownIt-Anchor" href="#3-字符串中单词的翻转"></a> 3、字符串中单词的翻转</h3><blockquote><p>s = “I am a student”<br />Return “student a am I”</p></blockquote><p>将每个单词翻转，然后将整个字符串翻转。</p><h3 id="4-两个字符串包含的字符是否完全相同"><a class="markdownIt-Anchor" href="#4-两个字符串包含的字符是否完全相同"></a> 4、两个字符串包含的字符是否完全相同</h3><blockquote><p>s = “anagram”, t = “nagaram”, return true.<br />s = “rat”, t = “car”, return false.</p></blockquote><p>可以用 HashMap 来映射字符与出现次数，然后比较两个字符串出现的字符数量是否相同。</p><p>由于本题的字符串只包含 26 个小写字符，因此可以使用长度为 26 的整型数组对字符串出现的字符进行统计，不再使用 HashMap。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : s)&#123;<br>            a[c - <span class="hljs-string">&#x27;a&#x27;</span>]++; <span class="hljs-comment">// 记录一下有啥</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : t)&#123;<br>            a[c - <span class="hljs-string">&#x27;a&#x27;</span>]--; <span class="hljs-comment">// 跟之前那个抵消</span><br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> k : a)&#123;<br>            <span class="hljs-keyword">if</span>(k != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-计算一组字符集合可以组成的回文字符串的最大长度"><a class="markdownIt-Anchor" href="#5-计算一组字符集合可以组成的回文字符串的最大长度"></a> 5、计算一组字符集合可以组成的回文字符串的最大长度</h3><blockquote><p>Input : “abccccdd”<br />Output : 7<br />Explanation : One longest palindrome that can be built is “dccaccd”, whose length is 7.</p></blockquote><p>使用长度为 256 的整型数组来统计每个字符出现的个数，每个字符有偶数个可以用来构成回文字符串。</p><p>因为回文字符串最中间的那个字符可以单独出现，所以如果有单独的字符就把它放到最中间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">map</span><span class="hljs-params">(<span class="hljs-number">256</span>, <span class="hljs-number">0</span>)</span></span>; <span class="hljs-comment">// 用256可以吧他们都装下</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : s)&#123;<br>            map[c]++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> m : map)&#123;<br>            res += (m / <span class="hljs-number">2</span>) * <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(res &lt; s.<span class="hljs-built_in">size</span>())&#123; <span class="hljs-comment">// 说明有上面 / 2 的时候消去的单数</span><br>            res++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-字符串同构"><a class="markdownIt-Anchor" href="#6-字符串同构"></a> 6、字符串同构</h3><blockquote><p>Given “egg”, “add”, return true.<br />Given “foo”, “bar”, return false.<br />Given “paper”, “title”, return true.</p></blockquote><p>记录一个字符上次出现的位置，如果两个字符串中的字符上次出现的位置一样，那么就属于同构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-comment">// s.size() == t.size()</span><br>        <span class="hljs-comment">// 256能存下所有</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">map_s</span><span class="hljs-params">(<span class="hljs-number">256</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">map_t</span><span class="hljs-params">(<span class="hljs-number">256</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">char</span> sc = s[i], tc = t[i];<br>            <span class="hljs-keyword">if</span>(map_s[sc] != <span class="hljs-keyword">map_t</span>[tc])&#123;<span class="hljs-comment">// 换一个角度进行比较 比较该字符出现的位置</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            map_s[sc] = i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 这里加一为了区别第一次和第二次</span><br>            <span class="hljs-keyword">map_t</span>[tc] = i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-回文子字符串个数"><a class="markdownIt-Anchor" href="#7-回文子字符串个数"></a> 7、回文子字符串个数</h3><blockquote><p>Input: “aaa”<br />Output: 6<br />Explanation: Six palindromic strings: “a”, “a”, “a”, “aa”, “aa”, “aaa”.</p></blockquote><p>从字符串的某一位开始，尝试着去扩展子字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 这道题就是一个扫描</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-built_in">scan</span>(s, i, i); <span class="hljs-comment">// 奇数检查</span><br>            <span class="hljs-built_in">scan</span>(s, i, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 偶数检查</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scan</span><span class="hljs-params">(string s, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(start &gt;= <span class="hljs-number">0</span> &amp;&amp; end &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[start] == s[end])&#123;<br>            start--;<br>            end++;<br>            cnt++;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="8-判断一个整数是否是回文数"><a class="markdownIt-Anchor" href="#8-判断一个整数是否是回文数"></a> 8、判断一个整数是否是回文数</h3><p>要求不能使用额外空间，也就不能将整数转换为字符串进行判断。</p><p>将整数分成左右两部分，右边那部分需要转置，然后判断这两部分是否相等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//1234321</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || x % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x &gt; r)&#123;<br>            r = r * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span>;<br>            x /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x == r || x == r / <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="9-统计二进制字符串中连续-1-和连续-0-数量相同的子字符串个数"><a class="markdownIt-Anchor" href="#9-统计二进制字符串中连续-1-和连续-0-数量相同的子字符串个数"></a> 9、统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数</h3><blockquote><p>Input: “00110011”<br />Output: 6<br />Explanation: There are 6 substrings that have equal number of consecutive 1’s and 0’s: “0011”, “01”, “1100”, “10”, “0011”, and “01”.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countBinarySubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> cur = <span class="hljs-number">1</span>, pre = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)&#123;<br>            <span class="hljs-keyword">if</span>(s[i] == s[i - <span class="hljs-number">1</span>])&#123;<br>                cur++;<br>            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 如果不相等那就存一下状态</span><br>                pre = cur;<br>                cur = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(pre &gt;= cur)&#123; <span class="hljs-comment">// 只要是pre &gt; cur 就比如 0001 这样可以组成0 1 最大可以到 000111 这样的情况所以在这个期间只要有1就可以加一个</span><br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="六-数组与矩阵"><a class="markdownIt-Anchor" href="#六-数组与矩阵"></a> 六、数组与矩阵</h2><h3 id="1-把数组中的0移到末尾"><a class="markdownIt-Anchor" href="#1-把数组中的0移到末尾"></a> 1、把数组中的0移到末尾</h3><blockquote><p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != <span class="hljs-number">0</span>)&#123;<br>                nums[idx++] = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(idx &lt; n)&#123;<br>            nums[idx++] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-改变矩阵维度"><a class="markdownIt-Anchor" href="#2-改变矩阵维度"></a> 2、改变矩阵维度</h3><blockquote><p>Input:<br />nums =<br />[[1,2],<br />[3,4]]<br />r = 1, c = 4</p><p>Output:<br />[[1,2,3,4]]</p><p>Explanation:<br />The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">matrixReshape</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; mat, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c) &#123;<br>        <span class="hljs-keyword">int</span> m = mat.<span class="hljs-built_in">size</span>(), n = mat[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">res</span>(r, vector&lt;<span class="hljs-keyword">int</span>&gt;(c));<br>        <span class="hljs-keyword">if</span>(r * c != m * n) <span class="hljs-keyword">return</span> mat;<br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; <span class="hljs-comment">// index作为索引可以遍历用</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; c; ++j)&#123;<br>                res[i][j] = mat[index / n][index % n];<br>                index++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">matrixReshape</span>(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; mat, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c) &#123;<br>        <span class="hljs-keyword">int</span> m = mat.<span class="hljs-built_in">size</span>(), n = mat[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; <span class="hljs-built_in">res</span>(r, vector&lt;<span class="hljs-keyword">int</span>&gt;(c));<br>        <span class="hljs-keyword">if</span>(r * c != m * n) <span class="hljs-keyword">return</span> mat;<br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; <span class="hljs-comment">// index作为索引可以遍历用</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r * c; ++i)&#123;<br>            res[i / c][i % c] = mat[i / n][i % n];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-找出数组中最长的连续-1"><a class="markdownIt-Anchor" href="#3-找出数组中最长的连续-1"></a> 3、找出数组中最长的连续 1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findMaxConsecutiveOnes</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)&#123;<br>            t = num == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : t + <span class="hljs-number">1</span>;<br>            ans = <span class="hljs-built_in">max</span>(ans, t);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-有序矩阵查找"><a class="markdownIt-Anchor" href="#4-有序矩阵查找"></a> 4、有序矩阵查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>, c = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(r &lt; matrix.<span class="hljs-built_in">size</span>() &amp;&amp; c &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">int</span> cur = matrix[r][c];<br>            <span class="hljs-keyword">if</span>(cur &gt; target) c--;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur &lt; target) r++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-有序矩阵的-kth-element"><a class="markdownIt-Anchor" href="#5-有序矩阵的-kth-element"></a> 5、有序矩阵的 Kth Element</h3><blockquote><p>matrix = [<br />[ 1,  5,  9],<br />[10, 11, 13],<br />[12, 13, 15]<br />],<br />k = 8,</p><p>return 13.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        priority_queue&lt;<span class="hljs-keyword">int</span>&gt; maxHeap;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; matrix[i].<span class="hljs-built_in">size</span>(); ++j)&#123;<br>                maxHeap.<span class="hljs-built_in">push</span>(matrix[i][j]);<br>                <span class="hljs-keyword">if</span>(maxHeap.<span class="hljs-built_in">size</span>() &gt; k) maxHeap.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxHeap.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>二分法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = matrix.<span class="hljs-built_in">size</span>(), n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> low = matrix[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], high = matrix[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span>(low &lt;= high)&#123;<br>            <span class="hljs-keyword">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n &amp;&amp; matrix[i][j] &lt;= mid; ++j)&#123;<br>                    idx++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(idx &lt; k) low = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> high = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-一个数组元素在-1-n-之间其中一个数被替换为另一个数找出重复的数和丢失的数"><a class="markdownIt-Anchor" href="#6-一个数组元素在-1-n-之间其中一个数被替换为另一个数找出重复的数和丢失的数"></a> 6、一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数</h3><blockquote><p>Input: nums = [1,2,2,4]<br />Output: [2,3]</p></blockquote><blockquote><p>Input: nums = [1,2,2,4]<br />Output: [2,3]</p></blockquote><p>最直接的方法是先对数组进行排序，这种方法时间复杂度为 O(NlogN)。本题可以以 O(N) 的时间复杂度、O(1) 空间复杂度来求解。</p><p>主要思想是通过交换数组元素，使得数组上的元素在正确的位置上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findErrorNums</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">while</span>(nums[i] != i + <span class="hljs-number">1</span> &amp;&amp; nums[nums[i] - <span class="hljs-number">1</span>] != nums[i])&#123;<br>                <span class="hljs-built_in">swap</span>(nums, i, nums[i] - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != i + <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> &#123;nums[i], i + <span class="hljs-number">1</span>&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> temp = nums[i];<br>        nums[i] = nums[j];<br>        nums[j] = temp;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findErrorNums</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> sum = n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 记录全部和</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">flag</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)&#123;<br>            <span class="hljs-keyword">if</span>(!flag[num])&#123; <span class="hljs-comment">// 如果这个数没出现过，那就从综合去除</span><br>                sum -= num;<br>                flag[num] = <span class="hljs-literal">true</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res = num; <span class="hljs-comment">// 如果重复出现那么我们就找到了重复出现的那个</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;res, sum&#125;; <span class="hljs-comment">//因为不管是重复还是丢失，都会最后剩下那个该填写的数</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-找出数组中重复的数数组值在-1-n-之间"><a class="markdownIt-Anchor" href="#7-找出数组中重复的数数组值在-1-n-之间"></a> 7、找出数组中重复的数，数组值在 [1, n] 之间</h3><p>先排序再做</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i - <span class="hljs-number">1</span>] == nums[i])<br>                <span class="hljs-keyword">return</span> nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>用set</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-keyword">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)&#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">count</span>(num)) <span class="hljs-keyword">return</span> num;<br>            <span class="hljs-keyword">else</span> s.<span class="hljs-built_in">insert</span>(num);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>只要和他原本该去位置不是重复的那就一直交换，0位置用来检测，其他位置为直接放。比如1 就放在索引1的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(nums[<span class="hljs-number">0</span>] != nums[nums[<span class="hljs-number">0</span>]])&#123;<br>            <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>], nums[nums[<span class="hljs-number">0</span>]]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="8-数组相邻差值的个数"><a class="markdownIt-Anchor" href="#8-数组相邻差值的个数"></a> 8、数组相邻差值的个数</h3><blockquote><p>Input: n = 3, k = 2<br />Output: [1, 3, 2]<br />Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.</p></blockquote><p><strong>题目描述</strong>：数组元素为 1~n 的整数，要求构建数组，使得相邻元素的差值不相同的个数为 k。</p><p>让前 k+1 个元素构建出 k 个不相同的差值，序列为：1 k+1 2 k 3 k-1 … k/2 k/2+1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">constructArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">int</span> s = <span class="hljs-number">1</span>, e = n;<br>        <span class="hljs-keyword">while</span>(s &lt;= e)&#123;<br>            <span class="hljs-keyword">if</span>(k &gt; <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">int</span> cur = k % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? s++ : e--;<br>                res.<span class="hljs-built_in">push_back</span>(cur);<br>                k--;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                res.<span class="hljs-built_in">push_back</span>(e--);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="9-数组的度"><a class="markdownIt-Anchor" href="#9-数组的度"></a> 9、数组的度</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Input</span>:<span class="hljs-meta"> [1,2,2,3,1,4,2]</span><br><span class="hljs-attribute">Output</span>: <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>题目描述</strong>：数组的度定义为元素出现的最高频率，例如上面的数组度为 3。要求找到一个最小的子数组，这个子数组的度和原数组一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findShortestSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; m;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> len = INT_MAX; <span class="hljs-comment">// 因为要找的是最小</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>            m[nums[i]].<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 给对应的位置记录好索引</span><br>        &#125;<br>        <span class="hljs-keyword">int</span> du = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = m.<span class="hljs-built_in">begin</span>(); it != m.<span class="hljs-built_in">end</span>(); ++it)&#123;<br>            <span class="hljs-keyword">if</span>(it-&gt;second.<span class="hljs-built_in">size</span>() &gt; du)&#123;<br>                du = it-&gt;second.<span class="hljs-built_in">size</span>();<br>                len = it-&gt;second[du - <span class="hljs-number">1</span>] - it-&gt;second[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(it-&gt;second.<span class="hljs-built_in">size</span>() == du)&#123;<br>                len = <span class="hljs-built_in">min</span>(len, it-&gt;second[du - <span class="hljs-number">1</span>] - it-&gt;second[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="10-对角元素相等的矩阵"><a class="markdownIt-Anchor" href="#10-对角元素相等的矩阵"></a> 10、对角元素相等的矩阵</h3><blockquote><p>1234<br />5123<br />9512</p><p>In the above grid, the diagonals are “[9]”, “[5, 5]”, “[1, 1, 1]”, “[2, 2, 2]”, “[3, 3]”, “[4]”, and in each diagonal all elements are the same, so the answer is True.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isToeplitzMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">check</span>(matrix, matrix[i][<span class="hljs-number">0</span>], i, <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">check</span>(matrix, matrix[<span class="hljs-number">0</span>][i], <span class="hljs-number">0</span>, i)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;&amp; matrix, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> c)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(r &gt;= matrix.<span class="hljs-built_in">size</span>() || c &gt;= matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(matrix[r][c] != target)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(matrix, target, r + <span class="hljs-number">1</span>, c + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="11-嵌套数组"><a class="markdownIt-Anchor" href="#11-嵌套数组"></a> 11、嵌套数组</h3><blockquote><p>Input: A = [5,4,0,3,1,6,2]<br />Output: 4<br />Explanation:<br />A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.</p><p>One of the longest S[K]:<br />S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}</p></blockquote><p><strong>题目描述</strong>：S[i] 表示一个集合，集合的第一个元素是 A[i]，第二个元素是 A[A[i]]，如此嵌套下去。求最大的 S[i]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">arrayNesting</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123; <span class="hljs-comment">// 这个题不需要考虑反向，因为如果反向是这个的话会成换就循环起来了</span><br>        <span class="hljs-keyword">int</span> cur, pre, res = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != <span class="hljs-number">-1</span>)&#123;<br>                cnt = <span class="hljs-number">0</span>;<br>                cur = nums[i];<br>                nums[i] = <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">while</span>(cur != <span class="hljs-number">-1</span>)&#123;<br>                    pre = cur;<br>                    cur = nums[pre];<br>                    nums[pre] = <span class="hljs-number">-1</span>;<br>                    cnt++;<br>                &#125;<br>            &#125;<br>            res = <span class="hljs-built_in">max</span>(res, cnt);  <br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="12-分隔数组"><a class="markdownIt-Anchor" href="#12-分隔数组"></a> 12、分隔数组</h3><blockquote><p>Input: arr = [1,0,2,3,4]<br />Output: 4<br />Explanation:<br />We can split into two chunks, such as [1, 0], [2, 3, 4].<br />However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.</p></blockquote><p><strong>题目描述</strong>：给一个长度为 n 的数组, 其元素的值也是从 0 ~ n - 1 的一个排列, 我们将这个数组分为若干部分, 将这些部分独自地排序, 然后将这些部分连接起来, 这个结果和将原数组直接排序的结果相同.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxChunksToSorted</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>&#123; <span class="hljs-comment">// 从小到大是顺序, 这个数组必须是每个数全都存在的</span><br>        <span class="hljs-keyword">int</span> right = arr[<span class="hljs-number">0</span>], res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            right = <span class="hljs-built_in">max</span>(arr[i], right);<br>            <span class="hljs-keyword">if</span>(right == i) res++; <span class="hljs-comment">// 说明了我当前最大数的边界刚到自己的位置，这个时候切分，我左边的一定比我小且一定可以排满，</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="七-图"><a class="markdownIt-Anchor" href="#七-图"></a> 七、图</h2><h3 id="1-二分图"><a class="markdownIt-Anchor" href="#1-二分图"></a> 1、二分图</h3><p>如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么这个图就是二分图。</p><h4 id="1判断是否为二分图"><a class="markdownIt-Anchor" href="#1判断是否为二分图"></a> 1）判断是否为二分图</h4><blockquote><p>Input: [[1,3], [0,2], [1,3], [0,2]]<br />Output: true<br />Explanation:<br />The graph looks like this:<br />0----1<br />|    |<br />|    |<br />3----2<br />We can divide the vertices into two groups: {0, 2} and {1, 3}.</p></blockquote><blockquote><p>Example 2:<br />Input: [[1,2,3], [0,2], [0,1,3], [0,2]]<br />Output: false<br />Explanation:<br />The graph looks like this:<br />0----1<br />| \  |<br />|  \ |<br />3----2<br />We cannot find a way to divide the set of nodes into two independent subsets.</p></blockquote><p>就是BFS然后遍历之后不是单纯的设立是否遍历过，而是遍判断条件，以及设立相邻节点不同颜色的限制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; G;<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">101</span>);<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; color = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">101</span>); <span class="hljs-comment">// 反正都是0 1就是</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        G = graph; <span class="hljs-comment">// 赋值一下（主要是懒 后面懒得写） 这个矩阵的意思就是第一行就是</span><br>        <span class="hljs-keyword">int</span> n = graph.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 记录有多少个节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>            <span class="hljs-keyword">if</span>(!vis[i])&#123;<br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">bfs</span>(i))&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span>&#123; <span class="hljs-comment">// 如果是连通图 遍历一边就可以结束 </span><br>        vis[s] = <span class="hljs-literal">true</span>;<br>        queue&lt;<span class="hljs-keyword">int</span>&gt; q;<br>        q.<span class="hljs-built_in">push</span>(s);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">int</span> cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            vis[cur] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> node : G[cur])&#123;<br>                <span class="hljs-keyword">if</span>(!vis[node])&#123;<br>                    q.<span class="hljs-built_in">push</span>(node);<br>                    color[node] =! color[cur]; <span class="hljs-comment">// 相邻节点获得反向颜色</span><br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(color[node] == color[cur])&#123; <span class="hljs-comment">// 相邻节点是相同颜色了 那就错了</span><br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-拓扑排序"><a class="markdownIt-Anchor" href="#2-拓扑排序"></a> 2、拓扑排序</h3><p>常用于在具有先序关系的任务规划中。</p><h4 id="1课程安排的合法性"><a class="markdownIt-Anchor" href="#1课程安排的合法性"></a> 1）课程安排的合法性</h4><blockquote><p>2, [[1,0]]<br />return true</p></blockquote><blockquote><p>2, [[1,0],[0,1]]<br />return false</p></blockquote><p><strong>题目描述</strong>：一个课程可能会先修课程，判断给定的先修课程规定是否合法。</p><p>本题不需要使用拓扑排序，只需要检测有向图是否存在环即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">10001</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 用于剪支加速用的vis</span><br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; dfsvis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">10001</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// dfs用于记录是否走过的vis</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; M[<span class="hljs-number">10001</span>];<br>    <span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p : prerequisites)&#123;<br>            M[p[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(p[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; ++i)&#123;<br>            <span class="hljs-keyword">if</span>(!vis[i])<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span>&#123;<br>        vis[s] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 这个用于剪支 防止重复</span><br>        dfsvis[s] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 这个用于检测环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> edge : M[s])&#123;<br>            <span class="hljs-keyword">if</span>(!vis[edge])&#123;<span class="hljs-comment">// 如果这个分支没走过那就dfs一下</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(edge)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <br>                <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dfsvis[edge])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-comment">// 如果这个节点在当前dfs过程中发现了环 就取消所有</span><br>        &#125;<br>        dfsvis[s] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2课程安排的顺序"><a class="markdownIt-Anchor" href="#2课程安排的顺序"></a> 2）课程安排的顺序</h4><blockquote><p>4, [[1,0],[2,0],[3,1],[3,2]]<br />There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].</p></blockquote><p>使用 DFS 来实现拓扑排序，使用一个栈存储后序遍历结果，这个栈的逆序结果就是拓扑排序结果。</p><p>证明：对于任何先序关系：v-&gt;w，后序遍历结果可以保证 w 先进入栈中，因此栈的逆序结果中 v 会在 w 之前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; M[<span class="hljs-number">2001</span>];<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; vis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">2001</span>);<br>    vector&lt;<span class="hljs-keyword">bool</span>&gt; dfsvis = vector&lt;<span class="hljs-keyword">bool</span>&gt;(<span class="hljs-number">2001</span>);<br>    <span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        n = numCourses;<br>        <span class="hljs-keyword">if</span>(prerequisites.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                res.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">return</span> res;<br>        &#125; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p : prerequisites)&#123;<br>            M[p[<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(p[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>            <span class="hljs-keyword">if</span>(!vis[i])&#123;<br>                <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i))&#123; <span class="hljs-comment">// 如果有环</span><br>                    <span class="hljs-keyword">return</span> &#123; &#125;;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span>&#123;<br>        vis[s] = <span class="hljs-literal">true</span>;<br>        dfsvis[s] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> next : M[s])&#123;<br>            <span class="hljs-keyword">if</span>(!vis[next])&#123;<br>                <span class="hljs-built_in">dfs</span>(next);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(dfsvis[next])&#123;  <span class="hljs-comment">// 检测出现有环</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        res.<span class="hljs-built_in">push_back</span>(s); <span class="hljs-comment">// 退栈时存储 等于逆拓扑序列</span><br>        dfsvis[s] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() == n) &#123;<br>            <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 因为逆拓扑需要反转</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-并查集"><a class="markdownIt-Anchor" href="#3-并查集"></a> 3、并查集</h3><p>并查集可以动态地连通两个点，并且可以非常快速地判断两个点是否连通。</p><h4 id="1冗余连接"><a class="markdownIt-Anchor" href="#1冗余连接"></a> 1）冗余连接</h4><blockquote><p>Input: [[1,2], [1,3], [2,3]]<br />Output: [2,3]<br />Explanation: The given undirected graph will be like this:<br />1<br />/ <br />2 - 3</p></blockquote><p><strong>题目描述</strong>：有一系列的边连成的图，找出一条边，移除它之后该图能够成为一棵树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find_set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> parent[])</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(parent[i] == <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// 如果没有找到他的父亲节点 那就返回他自己</span><br>        &#125;<br>        <span class="hljs-keyword">int</span> p = <span class="hljs-built_in">find_set</span>(parent[i], parent); <span class="hljs-comment">// 找到当前节点最上层的父亲节点</span><br>        parent[i] = p;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">union_set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> parent[], <span class="hljs-keyword">int</span> rank[])</span></span>&#123; <span class="hljs-comment">// 合并两个点集</span><br>        <span class="hljs-keyword">int</span> p1 = <span class="hljs-built_in">find_set</span>(i, parent); <span class="hljs-comment">// 找到i的老大</span><br>        <span class="hljs-keyword">int</span> p2 = <span class="hljs-built_in">find_set</span>(j, parent); <span class="hljs-comment">// 找到j的老大</span><br>        <span class="hljs-keyword">if</span>(rank[p1] &lt; rank[p2])&#123; <span class="hljs-comment">//i点集大小 比 j点集大小要小，所以需要将p1的大boss当作跟节点与p2点集联系一起</span><br>            parent[p1] = p2; <br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            parent[p2] = p1;<br>            <span class="hljs-keyword">if</span>(rank[p1] == rank[p2])&#123;<br>                rank[p1]++; <span class="hljs-comment">// 只有当两个秩一样时 才会有秩的改变</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; ans;<br>        <span class="hljs-keyword">int</span> n = edges.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> *rank = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> *parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>]; <span class="hljs-comment">//只是为了辅助我们去找到那个父亲节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)&#123;<br>            rank[i] = <span class="hljs-number">1</span>;<br>            parent[i] = <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> edge : edges)&#123;<br>            <span class="hljs-keyword">int</span> i = edge[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> j = edge[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> p1 = <span class="hljs-built_in">find_set</span>(i, parent);<br>            <span class="hljs-keyword">int</span> p2 = <span class="hljs-built_in">find_set</span>(j, parent);<br>            <span class="hljs-keyword">if</span>(p1 != p2)&#123; <span class="hljs-comment">// 说明了两个点集不属于同一个结点</span><br>                <span class="hljs-built_in">union_set</span>(i, j, parent, rank);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> &#123;i, j&#125;;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="八-位运算"><a class="markdownIt-Anchor" href="#八-位运算"></a> 八、位运算</h2><h3 id="1-统计两个数的二进制表示有多少位不同"><a class="markdownIt-Anchor" href="#1-统计两个数的二进制表示有多少位不同"></a> 1、统计两个数的二进制表示有多少位不同</h3><blockquote><p>Input: x = 1, y = 4</p><p>Output: 2</p><p>Explanation:<br />1   (0 0 0 1)<br />4   (0 1 0 0)<br />↑   ↑</p><p>The above arrows point to positions where the corresponding bits are different.</p></blockquote><p>对两个数进行异或操作，位级表示不同的那一位为 1，统计有多少个 1 即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingDistance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> z = x ^ y;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(z)&#123;<br>            <span class="hljs-keyword">if</span>((z &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) cnt++; <span class="hljs-comment">// 检测最后一位是否是1</span><br>            z = z &gt;&gt; <span class="hljs-number">1</span>; <br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用 z&amp;(z-1) 去除 z 位级表示最低的那一位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hammingDistance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> z = x ^ y;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(z)&#123;<br>            z &amp;= (z - <span class="hljs-number">1</span>); <span class="hljs-comment">// 使用 z&amp;(z-1) 去除 z 位级表示最低的那一位。</span><br>            cnt++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-数组中唯一一个不重复的元素"><a class="markdownIt-Anchor" href="#2-数组中唯一一个不重复的元素"></a> 2、数组中唯一一个不重复的元素</h3><blockquote><p>Input: [4,1,2,1,2]<br />Output: 4</p></blockquote><p>两个相同的数异或的结果为 0，对所有数进行异或操作，最后的结果就是单独出现的那个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>; <span class="hljs-comment">//一直异或的话可以求取最终结果，只要是有相同的部分异或就是0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)&#123;<br>            ans ^= num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-找出数组中缺失的那个数"><a class="markdownIt-Anchor" href="#3-找出数组中缺失的那个数"></a> 3、找出数组中缺失的那个数</h3><blockquote><p>Input: [3,0,1]<br />Output: 2</p></blockquote><p><strong>题目描述</strong>：数组元素在 0-n 之间，但是有一个数是缺失的，要求找到这个缺失的数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>            ans ^= i ^ nums[i]; <span class="hljs-comment">//这里相当于我给你创造出应该有的标准模版，如果没有对应就会剩下那个没有的</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ans ^ n; <span class="hljs-comment">// 因为数组只有三 但是 如果是0～n 那就是有n + 1个 所以最后一位需要单独弄一下n那个模版</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-数组中不重复的两个元素"><a class="markdownIt-Anchor" href="#4-数组中不重复的两个元素"></a> 4、数组中不重复的两个元素</h3><p>两个不相等的元素在位级表示上必定会有一位存在不同。</p><p>将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。</p><p>diff &amp;= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)&#123;<br>            cur ^= num;<br>        &#125;<br>        <span class="hljs-comment">// cur 为 数组中两个不同元素的异或结果</span><br>        cur &amp;= -cur; <span class="hljs-comment">// 找到最右的第一位1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num : nums)&#123;<br>            <span class="hljs-keyword">if</span>((cur &amp; num) == <span class="hljs-number">0</span>) ans[<span class="hljs-number">0</span>] ^= num;<br>            <span class="hljs-keyword">else</span> ans[<span class="hljs-number">1</span>] ^= num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-翻转一个数的比特位"><a class="markdownIt-Anchor" href="#5-翻转一个数的比特位"></a> 5、翻转一个数的比特位</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">uint32_t</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i)&#123;<br>            ans &lt;&lt;= <span class="hljs-number">1</span>;<br>            ans |= (n &amp; <span class="hljs-number">1</span>); <span class="hljs-comment">// 因为或运算就是0 就是0 如果是1 就得到1 n &amp; 1代表提取最后一位</span><br>            n &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-不用额外变量交换两个整数"><a class="markdownIt-Anchor" href="#6-不用额外变量交换两个整数"></a> 6、不用额外变量交换两个整数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">a ^= b;<br>b ^= a;<br>a ^= b;<br></code></pre></td></tr></table></figure><h3 id="7-判断一个数是不是-2-的-n-次方"><a class="markdownIt-Anchor" href="#7-判断一个数是不是-2-的-n-次方"></a> 7、判断一个数是不是 2 的 n 次方</h3><p>二进制表示只有一个 1 存在。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="8-判断一个数是不是-4-的-n-次方"><a class="markdownIt-Anchor" href="#8-判断一个数是不是-4-的-n-次方"></a> 8、判断一个数是不是 4 的 n 次方</h3><p>这种数在二进制表示中有且只有一个奇数位为 1，例如 16（10000）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPowerOfFour</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span> &amp;&amp; (n &amp; <span class="hljs-number">0b01010101010101010101010101010101010101</span>) != <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="9-判断一个数的位级表示是否不会出现连续的-0-和-1"><a class="markdownIt-Anchor" href="#9-判断一个数的位级表示是否不会出现连续的-0-和-1"></a> 9、判断一个数的位级表示是否不会出现连续的 0 和 1</h3><blockquote><p>Input: 10<br />Output: True<br />Explanation:<br />The binary representation of 10 is: 1010.</p><p>Input: 11<br />Output: False<br />Explanation:<br />The binary representation of 11 is: 1011.</p></blockquote><p>对于 1010 这种位级表示的数，把它向右移动 1 位得到 101，这两个数每个位都不同，因此异或得到的结果为 1111。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasAlternatingBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> k = n ^ (n &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> (k &amp; (k + <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="10-求一个数的补码"><a class="markdownIt-Anchor" href="#10-求一个数的补码"></a> 10、求一个数的补码</h3><blockquote><p>Input: 5<br />Output: 2<br />Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</p></blockquote><p><strong>题目描述</strong>：不考虑二进制表示中的首 0 部分。</p><p>对于 00000101，要求补码可以将它与 00000111 进行异或操作。那么问题就转换为求掩码 00000111。（我个人理解这道题是让我们求反转）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findComplement</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br>        <span class="hljs-keyword">while</span>((mask &amp; num) == <span class="hljs-number">0</span>) mask &gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// 找到最左边第一个1</span><br>        mask = (mask &lt;&lt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>; <span class="hljs-comment">//如101 制作出 mask 111</span><br>        <span class="hljs-keyword">return</span> mask ^ num; <span class="hljs-comment">// 异或求取最后结果</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="11-实现整数的加法"><a class="markdownIt-Anchor" href="#11-实现整数的加法"></a> 11、实现整数的加法</h3><p>a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。</p><p>递归会终止的原因是 (a &amp; b) &lt;&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。</p><p>第一轮相当于 a + b 进位忽略 进位位，剩下的就是中间结果与进位位相加</p><p>这里unsigned int 为了处理负数 （只是针对位运算，最后结果转换成int）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">getSum</span>(a ^ b, (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>傻瓜做法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="12-字符串数组最大乘积"><a class="markdownIt-Anchor" href="#12-字符串数组最大乘积"></a> 12、 字符串数组最大乘积</h3><blockquote><p>Given [“abcw”, “baz”, “foo”, “bar”, “xtfn”, “abcdef”]<br />Return 16<br />The two words can be “abcw”, “xtfn”.</p></blockquote><p><strong>题目描述</strong>：字符串数组的字符串只含有小写字符。求解字符串数组中两个字符串长度的最大乘积，要求这两个字符串不能含有相同字符。</p><p>本题主要问题是判断两个字符串是否含相同字符，由于字符串只含有小写字符，总共 26 位，因此可以用一个 32 位的整数来存储每个字符是否出现过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = words.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">m</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c : words[i])&#123;<br>                m[i] |= <span class="hljs-number">1</span> &lt;&lt; (c - <span class="hljs-string">&#x27;a&#x27;</span>); <span class="hljs-comment">// ｜= 等于给他添加对应的值 1 &lt;&lt; c - &#x27;a&#x27; 先运算 找到对应标志的位置</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j)&#123;<br>                <span class="hljs-keyword">if</span>((m[i] &amp; m[j]) == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 说明这俩字符串没有相同的地方</span><br>                    <span class="hljs-keyword">int</span> cur = words[i].<span class="hljs-built_in">size</span>() * words[j].<span class="hljs-built_in">size</span>();<br>                    res = res &lt; cur ? cur : res;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="13-统计从-0-~-n-每个数的二进制表示中-1-的个数"><a class="markdownIt-Anchor" href="#13-统计从-0-~-n-每个数的二进制表示中-1-的个数"></a> 13、统计从 0 ~ n 每个数的二进制表示中 1 的个数</h3><p>对于数字 6(110)，它可以看成是 4(100) 再加一个 2(10)，因此 dp[i] = dp[i&amp;(i-1)] + 1;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; dp = vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)&#123;<br>            dp[i] = dp[i &amp; (i - <span class="hljs-number">1</span>)] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法练习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法课作业</title>
    <link href="/2021/11/23/%E5%AD%A6%E6%A0%A1%E7%AE%97%E6%B3%95%E8%AF%BE%E4%BD%9C%E4%B8%9A/"/>
    <url>/2021/11/23/%E5%AD%A6%E6%A0%A1%E7%AE%97%E6%B3%95%E8%AF%BE%E4%BD%9C%E4%B8%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="学校算法课作业"><a class="markdownIt-Anchor" href="#学校算法课作业"></a> 学校算法课作业</h1><h2 id="一-贪心"><a class="markdownIt-Anchor" href="#一-贪心"></a> 一、贪心</h2><h3 id="1-合并果子"><a class="markdownIt-Anchor" href="#1-合并果子"></a> 1、合并果子</h3><p><strong>题目描述</strong>：</p><p>  在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。<br />  每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。<br />  因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。<br />  例如有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以多多总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。</p><p><strong>思路</strong>：</p><p>  每次合并都找最小的两个合并，可以利用最小堆来维护。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    multiset &lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span>&gt; set;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> temp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>        cin &gt;&gt; temp;<br>        set.<span class="hljs-built_in">insert</span>(temp);<br>    &#125;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> value;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(set.<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span>)&#123;<br>        value = <span class="hljs-number">0</span>;<br>        value += *set.<span class="hljs-built_in">begin</span>();<br>        set.<span class="hljs-built_in">erase</span>(set.<span class="hljs-built_in">begin</span>());<br>        value += *set.<span class="hljs-built_in">begin</span>();<br>        set.<span class="hljs-built_in">erase</span>(set.<span class="hljs-built_in">begin</span>());<br>        set.<span class="hljs-built_in">insert</span>(value);<br>        sum += value;<br>    &#125;<br>    cout &lt;&lt; sum;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-最小差距"><a class="markdownIt-Anchor" href="#2-最小差距"></a> 2、最小差距</h3><p><strong>题目描述</strong>：</p><p>  给定一些不同的一位数字，你可以从这些数字中选择若干个，并将它们按一定顺序排列，组成一个整数，把剩下的数字按一定顺序排列，组成另一个整数。组成的整数不能以0开头（除非这个整数只有1位）。<br />  例如，给定6个数字，0,1,2,4,6,7，你可以用它们组成一对数10和2467，当然，还可以组成其他的很多对数，比如210和764，204和176。这些对数中两个数差的绝对值最小的是204和176，为28。<br />  给定N个不同的0~9之间的数字，请你求出用这些数字组成的每对数中，差的绝对值最小的一对（或多对）数的绝对值是多少？</p><p><strong>思路</strong>：</p><p>  一共三种情况：（1）只有两个数（2）奇数个（3）偶数个（整体的思想就是让大的数更小，小的数更大），都需要选择最小非零数作为第一位。</p><p>（2）需要我们进行升序排列，然后因为是奇数个，一定是不平均的，所以可以给前一部分多分一个，这样可以符合上述规则</p><p>（3）偶数也是左右选，一个从左往右选第一个非零，再从右往左挑，这样可以保证小的数更大；反之找到大的数更小</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> group = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> a[<span class="hljs-number">15</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">abs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">0</span> ? x : -x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">situation1</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//奇数个</span><br>    <span class="hljs-keyword">if</span>(a[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) <span class="hljs-built_in">swap</span>(a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">int</span> s1 = <span class="hljs-number">0</span>, s2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; ++i) s1 = s1 * <span class="hljs-number">10</span> + a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n; i &gt;= n / <span class="hljs-number">2</span> + <span class="hljs-number">2</span>; --i) s2 = s2 * <span class="hljs-number">10</span> + a[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(s1 - s2);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">situation2</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">// 偶数个</span><br>    <span class="hljs-keyword">int</span> s1, s2;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0xffffff</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)&#123;<br>        <span class="hljs-keyword">if</span>(a[i - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">15</span>)</span></span>;<br>            vis[i - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>            vis[i] = <span class="hljs-number">1</span>;<br>            s1 = a[i];<br>            s2 = a[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = n;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= (n - <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>; ++j) &#123;  <span class="hljs-comment">// 排除了选出来的两个头</span><br>                <span class="hljs-keyword">while</span> (vis[l]) l++;<br>                <span class="hljs-keyword">while</span> (vis[r]) r--;<br>                vis[r] = <span class="hljs-number">1</span>, vis[l] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 选择没有遍历过的，遍历过都做标记</span><br>                s1 = s1 * <span class="hljs-number">10</span> + a[l], s2 = s2 * <span class="hljs-number">10</span> + a[r];<br>            &#125;<br>            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">abs</span>(s1 - s2));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; group;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; group; ++i)&#123;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j)&#123;<br>            cin &gt;&gt; a[j];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)&#123;<br>            cout &lt;&lt; <span class="hljs-built_in">abs</span>(a[<span class="hljs-number">2</span>] - a[<span class="hljs-number">1</span>]) &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + n + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            cout &lt;&lt; <span class="hljs-built_in">situation1</span>() &lt;&lt; endl;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout &lt;&lt; <span class="hljs-built_in">situation2</span>() &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-上帝的爱好"><a class="markdownIt-Anchor" href="#3-上帝的爱好"></a> 3、上帝的爱好</h3><p><strong>题目描述</strong>：</p><p>  我们知道，词都是按照词牌来填的，上帝为了考验小杉，只给了他四种词牌，但只要压韵就算符合词牌。小杉已经想好了N个意境优美的句子，每个句子都有一个韵脚。符合要求的词的句式应当有如下四种&quot; XXYY&quot; ，&quot; XYXY&quot; ，&quot; XYYX&quot; ，&quot; XXXX&quot; ，其中X或Y表示韵脚。现在小杉想知道，从他想的N个句子之中，最多能按顺序挑选出几首符合条件的词。并且词的句子间不能交错，比如你选了1 4 6 8做为一首诗，那么7你就不能再选了。</p><p><strong>思路</strong>：</p><p>  从这个句式中，我们最主要能够发现的规律是只要找到两组相同的数就行；为了不会有交错我们就直接每次满足之后走到上一个位置结束的下一个位置就好。为了不重复我们需要赋值为-1就可以当作遍历数组的作用。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector &lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">a</span>(<span class="hljs-number">4001</span>);<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> N;<br>    cin &gt;&gt; N;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)&#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>; <span class="hljs-comment">// 用于记录当前所可以开始遍历的地方</span><br>    <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)&#123;<span class="hljs-comment">// 记录上界</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = temp; j &lt; i; ++j)&#123;<br>            <span class="hljs-keyword">if</span>(a[i] == a[j])&#123;<br>                c++;<br>                a[i] = <span class="hljs-number">-1</span>, a[j] = <span class="hljs-number">-1</span>; <span class="hljs-comment">//用过不需要用了</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(c == <span class="hljs-number">2</span>)&#123;<br>            sum++;<br>            c = <span class="hljs-number">0</span>;<br>            temp = i; <span class="hljs-comment">//更新下界</span><br>        &#125;<br>    &#125;<br>    cout &lt;&lt; sum;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-任务调度问题"><a class="markdownIt-Anchor" href="#4-任务调度问题"></a> 4、任务调度问题</h3><p><strong>题目描述</strong>：</p><p>  一个单位时间任务是恰好需要一个单位时间完成的任务。给定一个单位时间任务的有限集S。关于S 的一个时间表用于描述S 中单位时间任务的执行次序。时间表中第1 个任务从时间0 开始执行直至时间1 结束，第2 个任务从时间1 开始执行至时间2 结束，…，第n个任务从时间n-1 开始执行直至时间n结束。具有截止时间和误时惩罚的单位时间任务时间表问题可描述如下：<img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111240920691.png" style="zoom:50%;" /></p><p><strong>思路</strong>：</p><p>  最主要的就是按照惩罚时间排序，这样就尽量先把惩罚时间长的先做完。如果有任务是同一个时刻结束，并且都是先遍历到了 如 4（30）4（20）3（10）这个时候，我们就先放好第一个4，然后在放第二4到3的位置，然后3就不放了，惩罚时间为10。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> t; <span class="hljs-comment">//完成时间</span><br>    <span class="hljs-keyword">int</span> pun; <span class="hljs-comment">//惩罚时间</span><br>&#125;;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;Node&gt; <span class="hljs-title">T</span><span class="hljs-params">(<span class="hljs-number">1005</span>)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">1005</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node &amp;a, Node &amp;b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.pun != b.pun) <span class="hljs-keyword">return</span> a.pun &gt; b.pun;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.t &gt; b.t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">int</span> N;<br>    cin &gt;&gt; N;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; ++i)&#123;<br>        cin &gt;&gt; T[i].t;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; ++i)&#123;<br>        cin &gt;&gt; T[i].pun;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(T.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, T.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span> + N, cmp);<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; ++i)&#123;<br>        <span class="hljs-keyword">if</span>(!vis[T[i].t])&#123;<br>            vis[T[i].t] = <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">int</span> cnt = T[i].t;<br>            <span class="hljs-keyword">while</span>(vis[cnt] &amp;&amp; cnt)&#123;<br>                cnt--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">0</span>)<br>                sum += T[i].pun;<br>            <span class="hljs-keyword">else</span><br>                vis[cnt] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; sum &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong>：</p><blockquote><p>7<br />4 2 4 3 1 4 6<br />70 60 50 40 30 20 10<br />ans:50</p></blockquote><p>这里的50，是30 20（1 4）相加得到的结果。</p><h3 id="5-锡纸烫"><a class="markdownIt-Anchor" href="#5-锡纸烫"></a> 5、锡纸烫</h3><p><strong>题目描述</strong>：</p><p>  前不久 sqy 老师花了大价钱，去做了一个帅气的锡纸烫。有着商业眼光的 sqy 一下子发现了大商机，于是他自己开了一家美容美发店。</p><p>  sqy 找了刚刚做完纹理烫的大预言家 cbj 预测了未来，发现每个顾客都只在白天来美发店，并且第一次来店里的时候都会充一次价值 xi 的卡，然后从<strong>第二天</strong>开始，每天白天都会来这里打理头发，而 sqy 仅收取成本价 1 元钱来吸引顾客，直到把卡掏空为止，这个顾客就再也不会回来。</p><p>  黑心商人 sqy 找大预言家要来了每个顾客的充卡时间和充值金额，他准备在某一天<strong>晚上</strong>跑路，他想知道自己最多能卷走多少钱。</p><p><strong>思路</strong>：</p><p>  这个题主要是靠维护一个差分数组来得到结果，这个数组主要可以记录整体的增量控制，从而达到记录得到每个状态下的值，最终遍历选取最大的值就可以得到结果。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a[<span class="hljs-number">1000010</span>], b[<span class="hljs-number">1000010</span>];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000010</span>; ++i) a[i] = b[i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, x, y; i &lt;= n; ++i)&#123;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        a[x] += y;  <span class="hljs-comment">// 用来记录所有的值</span><br>        b[x + <span class="hljs-number">1</span>]--;  <span class="hljs-comment">// 这个值最后相当于积累一个每天减少的减少2量，一个人就是总数-1 两个人就是-2</span><br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> r = <span class="hljs-built_in">min</span>((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)<span class="hljs-number">1000010</span>, x + y + <span class="hljs-number">1</span>);<br>        b[r]++;<span class="hljs-comment">//这里代表还原减少的量，因为第x + y + 1 天的时候就不再减少了</span><br>    &#125;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> des = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000000</span>; ++i)&#123;<br>        des += b[i];<br>        sum += des + a[i];<br>        ans = <span class="hljs-built_in">max</span>(ans, sum);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer</title>
    <link href="/2021/11/21/%E5%89%91%E6%8C%87offer/"/>
    <url>/2021/11/21/%E5%89%91%E6%8C%87offer/</url>
    
    <content type="html"><![CDATA[<h1 id="潘潘剑指offer题目练习"><a class="markdownIt-Anchor" href="#潘潘剑指offer题目练习"></a> 潘潘剑指Offer题目练习</h1><h2 id="一-数组与矩阵"><a class="markdownIt-Anchor" href="#一-数组与矩阵"></a> 一、数组与矩阵</h2><h3 id="3-数组中的重复数字"><a class="markdownIt-Anchor" href="#3-数组中的重复数字"></a> 3、数组中的重复数字</h3><p><strong>题目描述</strong>：</p><p>  在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</p><blockquote><p>Input:<br />{2, 3, 1, 0, 2, 5}</p><p>Output:<br />2</p></blockquote><p><strong>思路</strong>：</p><p>  要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。</p><p>  对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。在调整过程中，如果第 i 位置上已经有一个值为 i 的元素，就可以知道 i 值重复。</p><p>  以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112061217399.png" style="zoom:50%;" /><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> numbers int整型一维数组 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> int整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">duplicate</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.length; ++i)&#123;<br>            <span class="hljs-keyword">while</span>(i != numbers[i])&#123;<br>                <span class="hljs-keyword">if</span>(numbers[i] == numbers[numbers[i]])<br>                    <span class="hljs-keyword">return</span> numbers[i];<br>                swap(numbers, i, numbers[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> temp = numbers[i];<br>        numbers[i] = numbers[j];<br>        numbers[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-二维数组中的查找"><a class="markdownIt-Anchor" href="#4-二维数组中的查找"></a> 4、二维数组中的查找</h3><p><strong>题目描述</strong>：</p><p>  给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。</p><blockquote><p>Consider the following matrix:<br />[<br />[1,   4,  7, 11, 15],<br />[2,   5,  8, 12, 19],<br />[3,   6,  9, 16, 22],<br />[10, 13, 14, 17, 24],<br />[18, 21, 23, 26, 30]<br />]</p><p>Given target = 5, return true.<br />Given target = 20, return false.</p></blockquote><p><strong>思路</strong>：</p><p>  要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。</p><p>  该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来快速地缩小查找区间，每次减少一行或者一列的元素。当前元素的查找区间为左下角的所有元素。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> [][] array)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(array == <span class="hljs-keyword">null</span> || array.length == <span class="hljs-number">0</span> || array[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">int</span> row = array.length;<br>        <span class="hljs-keyword">int</span> col = array[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = col - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(i &lt; row &amp;&amp; j &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">int</span> cur = array[i][j];<br>            <span class="hljs-keyword">if</span>(cur == target)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur &lt; target)&#123;<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-替换空格"><a class="markdownIt-Anchor" href="#5-替换空格"></a> 5、替换空格</h3><p><strong>题目描述</strong>：</p><p>  将一个字符串中的空格替换成 “%20”。</p><p><strong>思路</strong>：</p><p>① 在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），所以当遍历到一个空格时，需要在尾部填充两个任意字符。</p><p>② 令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。</p><p>③ 当 P2 遇到 P1 时（P2 &lt;= P1），或者遍历结束（P1 &lt; 0），退出。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112070851919.png" style="zoom:50%;" /><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s string字符串 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> string字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">replaceSpace</span> <span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        StringBuffer SB = <span class="hljs-keyword">new</span> StringBuffer(s);<br>        <span class="hljs-keyword">int</span> P1 = s.length() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= P1; i++)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                SB.append(<span class="hljs-string">&quot;  &quot;</span>); <span class="hljs-comment">// 添加两空格</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> P2 = SB.length() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 新的尾指针</span><br>        <span class="hljs-keyword">while</span>(P1 != P2)&#123;<br>            <span class="hljs-keyword">char</span> cur = SB.charAt(P1--);<br>            <span class="hljs-keyword">if</span>(cur != <span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                SB.setCharAt(P2--, cur);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                SB.setCharAt(P2--, <span class="hljs-string">&#x27;0&#x27;</span>);<br>                SB.setCharAt(P2--, <span class="hljs-string">&#x27;2&#x27;</span>);<br>                SB.setCharAt(P2--, <span class="hljs-string">&#x27;%&#x27;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> SB.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="29-顺时针打印矩阵"><a class="markdownIt-Anchor" href="#29-顺时针打印矩阵"></a> 29、顺时针打印矩阵</h3><p><strong>题目描述</strong>：</p><p>  按顺时针的方向，从外到里打印矩阵的值。下图的矩阵打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112070906543.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>  一层一层从外到里打印，观察可知每一层打印都有相同的处理步骤，唯一不同的是上下左右的边界不同了。因此使用四个变量 r1, r2, c1, c2 分别存储上下左右边界值，从而定义当前最外层。打印当前最外层的顺序：从左到右打印最上一行-&gt;从上到下打印最右一行-&gt;从右到左打印最下一行-&gt;从下到上打印最左一行。应当注意只有在 r1 != r2 时才打印最下一行，也就是在当前最外层的行数大于 1 时才打印最下一行，这是因为当前最外层只有一行时，继续打印最下一行，会导致重复打印。打印最左一行也要做同样处理。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112070907655.png" style="zoom:50%;" /><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">printMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [][] matrix)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> r1 = <span class="hljs-number">0</span>, r2 = matrix.length - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 上下边界</span><br>        <span class="hljs-keyword">int</span> c1 = <span class="hljs-number">0</span>, c2 = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 左右边界</span><br>        <span class="hljs-keyword">while</span>(r1 &lt;= r2 &amp;&amp; c1 &lt;= c2)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = c1; j &lt;= c2; ++j)&#123;<br>                ans.add(matrix[r1][j]);<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = r1 + <span class="hljs-number">1</span>; i &lt;= r2; ++i)&#123;<br>                ans.add(matrix[i][c2]);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(r1 == r2) <span class="hljs-comment">// 防止打印多余的数</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = c2 - <span class="hljs-number">1</span>; j &gt;= c1; --j)&#123;<br>                ans.add(matrix[r2][j]);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(c1 == c2)  <span class="hljs-comment">// 防止打印多余数</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = r2 - <span class="hljs-number">1</span>; i &gt;= r1 + <span class="hljs-number">1</span>; --i)&#123;<br>                ans.add(matrix[i][c1]);<br>            &#125;<br>            r2--; c2--; r1++; c1++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="50-第一个只出现一次的字符位置"><a class="markdownIt-Anchor" href="#50-第一个只出现一次的字符位置"></a> 50、第一个只出现一次的字符位置</h3><p><strong>题目描述</strong>：</p><p>  在一个字符串中找到第一个只出现一次的字符，并返回它的位置。字符串只包含 ASCII 码字符。</p><blockquote><p>Input: abacc<br />Output: b</p></blockquote><p><strong>思路&amp;代码</strong>：</p><p>  最直观的解法是使用 HashMap 对出现次数进行统计：字符做为 key，出现次数作为 value，遍历字符串每次都将 key 对应的 value 加 1。最后再遍历这个 HashMap 就可以找出出现次数为 1 的字符。</p><p>  考虑到要统计的字符范围有限，也可以使用整型数组代替 HashMap。ASCII 码只有 128 个字符，因此可以使用长度为 128 的整型数组来存储每个字符出现的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">FirstNotRepeatingChar</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); ++i)&#123;<br>            map[str.charAt(i)]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(map[str.charAt(i)] == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上实现的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用两个比特位就能存储这些信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.BitSet;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">FirstNotRepeatingChar</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        BitSet bs1 = <span class="hljs-keyword">new</span> BitSet(<span class="hljs-number">128</span>);  <span class="hljs-comment">//第一位</span><br>        BitSet bs2 = <span class="hljs-keyword">new</span> BitSet(<span class="hljs-number">128</span>);  <span class="hljs-comment">//第二位</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c: str.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(!bs1.get(c) &amp;&amp; !bs2.get(c))&#123;<br>                bs2.set(c);  <span class="hljs-comment">// 0 0 -&gt; 0 1</span><br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!bs1.get(c) &amp;&amp; bs2.get(c))&#123;<br>                bs1.set(c);  <span class="hljs-comment">// 0 1 -&gt; 1 1</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; str.length(); ++i)&#123;<br>            <span class="hljs-keyword">char</span> c = str.charAt(i);<br>            <span class="hljs-keyword">if</span>(!bs1.get(c) &amp;&amp; bs2.get(c))&#123;<br>                <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二-栈队列堆"><a class="markdownIt-Anchor" href="#二-栈队列堆"></a> 二、栈队列堆</h2><h3 id="9-用两个栈实现队列"><a class="markdownIt-Anchor" href="#9-用两个栈实现队列"></a> 9、用两个栈实现队列</h3><p><strong>题目描述</strong>：</p><p>  用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。</p><p><strong>思路</strong>：</p><p>  in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112081426883.png" style="zoom:50%;" /><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Stack;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Stack&lt;Integer&gt; stack1 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>    Stack&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span>&#123;<br>        stack1.push(node);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(stack2.empty())&#123; <span class="hljs-comment">// 只有第二个栈是空的才进行导入</span><br>            <span class="hljs-keyword">while</span>(!stack1.empty())&#123;<br>                stack2.push(stack1.pop());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack2.pop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="30-包含min函数的栈"><a class="markdownIt-Anchor" href="#30-包含min函数的栈"></a> 30、包含min函数的栈</h3><p><strong>题目描述</strong>：</p><p>  实现一个包含 min() 函数的栈，该方法返回当前栈中最小的值。</p><p><strong>思路</strong>：</p><p>  使用一个额外的 minStack，栈顶元素为当前栈中最小的值。在对栈进行 push 入栈和 pop 出栈操作时，同样需要对 minStack 进行入栈出栈操作，从而使 minStack 栈顶元素一直为当前栈中最小的值。在进行 push 操作时，需要比较入栈元素和当前栈中最小值，将值较小的元素 push 到 minStack 中。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112090913005.png" style="zoom:50%;" /><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Stack;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Stack&lt;Integer&gt; s = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Stack&lt;Integer&gt; min = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span>&#123;<br>        s.push(node);<br>        <span class="hljs-keyword">if</span>(min.empty()) min.push(node);<br>        <span class="hljs-keyword">else</span>&#123;<br>            min.push(Math.min(min.peek(), node));<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 共同进退</span><br>        s.pop();<br>        min.pop();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> s.peek();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> min.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="31-栈的压入-弹出序列"><a class="markdownIt-Anchor" href="#31-栈的压入-弹出序列"></a> 31、栈的压入、弹出序列</h3><p><strong>题目描述</strong>：</p><p>  输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。</p><p>  例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。</p><p><strong>思路</strong>：</p><p>  使用一个栈来模拟压入弹出操作。每次入栈一个元素后，都要判断一下栈顶元素是不是当前出栈序列 popSequence 的第一个元素，如果是的话则执行出栈操作并将 popSequence 往后移一位，继续进行判断。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">IsPopOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] pushA,<span class="hljs-keyword">int</span> [] popA)</span> </span>&#123;<br>        Stack&lt;Integer&gt; S = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        <span class="hljs-keyword">int</span> len = pushA.length;<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i)&#123;<br>            S.push(pushA[i]);<br>            <span class="hljs-keyword">while</span>(!S.isEmpty() &amp;&amp; S.peek() == popA[idx])&#123;<br>                S.pop();<br>                idx++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> S.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="40-最小的k个数"><a class="markdownIt-Anchor" href="#40-最小的k个数"></a> 40、最小的k个数</h3><p><strong>题目描述</strong>：</p><p>  找出最小的k个数。</p><p><strong>思路&amp;代码</strong>：</p><h4 id="大小为-k-的最小堆"><a class="markdownIt-Anchor" href="#大小为-k-的最小堆"></a> 大小为 K 的最小堆</h4><ul><li>复杂度：O(NlogK) + O(K)</li><li>特别适合处理海量数据</li></ul><p>  维护一个大小为 K 的最小堆过程如下：使用大顶堆。在添加一个元素之后，如果大顶堆的大小大于 K，那么将大顶堆的堆顶元素去除，也就是将当前堆中值最大的元素去除，从而使得留在堆中的元素都比被去除的元素来得小。</p><p>  应该使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。</p><p>  Java 的 PriorityQueue 实现了堆的能力，PriorityQueue 默认是小顶堆，可以在在初始化时使用 Lambda 表达式 (o1, o2) -&gt; o2 - o1 来实现大顶堆。其它语言也有类似的堆数据结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">// 大顶堆的peek()输出最大的数，poll()删除堆顶的数，</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] input, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(k &lt;= <span class="hljs-number">0</span> || k &gt; input.length)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; input.length; ++i)&#123;<br>            maxHeap.offer(input[i]);<br>            <span class="hljs-keyword">if</span>(maxHeap.size() &gt; k)&#123;<br>                maxHeap.poll();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(maxHeap);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="快速选择"><a class="markdownIt-Anchor" href="#快速选择"></a> 快速选择</h4><ul><li>复杂度：O(N) + O(1)</li><li>只有当允许修改数组元素时才可以使用</li></ul><p>快速排序的 partition() 方法，会返回一个整数 j 使得 a[l…j-1] 小于等于 a[j]，且 a[j+1…h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 K 个元素，这种找第 K 个元素的算法称为快速选择算法。</p><p><em>因为没有要求顺序所以可以这么求</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] input, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(k &lt;= <span class="hljs-number">0</span> || k &gt; input.length)<br>            <span class="hljs-keyword">return</span> ans;<br>        findKthNumber(input, <span class="hljs-number">0</span>, input.length - <span class="hljs-number">1</span>, k);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i)&#123;<br>            ans.add(input[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Paritition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> pivot = arr[low];<br>        <span class="hljs-keyword">while</span>(low &lt; high)&#123;<br>            <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; arr[high] &gt;= pivot) high--;<br>            arr[low] = arr[high];<br>            <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; arr[low] &lt;= pivot) low++;<br>            arr[high] = arr[low];<br>        &#125;<br>        arr[low] = pivot;<br>        <span class="hljs-keyword">return</span> low;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findKthNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(low &lt; high)&#123;<br>            <span class="hljs-comment">// 为什么底下是+1 和 -1 因为当我们经过Paritition后得到的轴是一定不满足的所以我们只需要在左边一个或者右边一个找就好了</span><br>            <span class="hljs-keyword">int</span> pivot = Paritition(arr, low, high);<br>            <span class="hljs-keyword">if</span>(pivot &lt; k - <span class="hljs-number">1</span>)&#123;<br>                low = pivot + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pivot &gt; k - <span class="hljs-number">1</span>)&#123;<br>                high = pivot - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="411-数据流中的中位数"><a class="markdownIt-Anchor" href="#411-数据流中的中位数"></a> 41.1、数据流中的中位数</h3><p><strong>题目描述</strong>：</p><p>  如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p><strong>思路</strong>：</p><p>  需要我们通过两个堆，一个最大堆一个最小堆来维护得到中间的两个数。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> PriorityQueue&lt;Integer&gt; left = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);<span class="hljs-comment">//左边放最大堆</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> PriorityQueue&lt;Integer&gt; right = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<span class="hljs-comment">//右边放最小堆</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(Integer num)</span> </span>&#123;<br>        N++;<br>        <span class="hljs-keyword">if</span>(N % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123; <span class="hljs-comment">// 如果是奇数</span><br>            left.offer(num);<br>            right.offer(left.poll());<br>        &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 如果是偶数 这样</span><br>            right.offer(num);<br>            left.offer(right.poll());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">GetMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(N % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">// 如果是奇数 答案在右边</span><br>            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)right.peek();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 如果是偶数 答案在中间两个数的平均</span><br>            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">double</span>)(right.peek() + left.peek()) / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="412-字符流中第一个不重复的字符"><a class="markdownIt-Anchor" href="#412-字符流中第一个不重复的字符"></a> 41.2、字符流中第一个不重复的字符</h3><p><strong>题目描述</strong>：</p><p>  请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 “go” 时，第一个只出现一次的字符是 “g”。当从该字符流中读出前六个字符“google&quot; 时，第一个只出现一次的字符是 “l”。</p><p><strong>思路</strong>：</p><p>  使用统计数组来统计每个字符出现的次数，本题涉及到的字符为都为 ASCII 码，因此使用一个大小为 128 的整型数组就能完成次数统计任务。</p><p>  使用队列来存储到达的字符，并在每次有新的字符从字符流到达时移除队列头部那些出现次数不再是一次的元素。因为队列是先进先出顺序，因此队列头部的元素为第一次只出现一次的字符。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] cnts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];<br><span class="hljs-keyword">private</span> Queue&lt;Character&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch)</span> </span>&#123;<br>    cnts[ch]++;<br>    queue.add(ch);<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty() &amp;&amp; cnts[queue.peek()] &gt; <span class="hljs-number">1</span>)<br>        queue.poll();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">FirstAppearingOnce</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> queue.isEmpty() ? <span class="hljs-string">&#x27;#&#x27;</span> : queue.peek();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="59-滑动窗口的最大值"><a class="markdownIt-Anchor" href="#59-滑动窗口的最大值"></a> 59、滑动窗口的最大值</h3><p><strong>题目描述</strong>：</p><p>  给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。</p><p>  例如，如果输入数组 {2, 3, 4, 2, 6, 2, 5, 1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4, 4, 6, 6, 6, 5}。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112140925614.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>  维护一个大小为窗口大小的大顶堆，顶堆元素则为当前窗口的最大值。</p><p>  假设窗口的大小为 M，数组的长度为 N。在窗口向右移动时，需要先在堆中删除离开窗口的元素，并将新到达的元素添加到堆中，这两个操作的时间复杂度都为 log2M，因此算法的时间复杂度为 O(Nlog2M)，空间复杂度为 O(M)。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">maxInWindows</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] num, <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(size &lt;= <span class="hljs-number">0</span> || size &gt; num.length)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>        &#125;<br>        ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 初始化窗口</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)&#123;<br>            maxHeap.offer(num[i]);<br>        &#125;<br>        ans.add(maxHeap.peek());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = size; j &lt; num.length; ++i, ++j)&#123;<br>            maxHeap.remove(num[i]);<br>            maxHeap.offer(num[j]);<br>            ans.add(maxHeap.peek());<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三-双指针"><a class="markdownIt-Anchor" href="#三-双指针"></a> 三、双指针</h2><h3 id="571-和为-s-的两个数字"><a class="markdownIt-Anchor" href="#571-和为-s-的两个数字"></a> 57.1、和为 S 的两个数字</h3><p><strong>题目描述</strong>：</p><p>  在有序数组中找出两个数，使得和为给定的数 S。如果有多对数字的和等于 S，输出两个数的乘积最小的。</p><p><strong>思路</strong>：</p><p>  使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p><ul><li>如果两个指针指向元素的和 sum == target，那么这两个元素即为所求。</li><li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li><li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li></ul><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">FindNumbersWithSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] array,<span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = array.length - <span class="hljs-number">1</span>; i &lt; j;)&#123;<br>            <span class="hljs-keyword">int</span> cur = array[i] + array[j];<br>            <span class="hljs-keyword">if</span>(cur == sum)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(array[i], array[j]));<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur &lt; sum)&#123;<br>                i++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="572-和为-s-的连续正数序列"><a class="markdownIt-Anchor" href="#572-和为-s-的连续正数序列"></a> 57.2、和为 S 的连续正数序列</h3><p><strong>题目描述</strong>：</p><p>  输出所有和为 S 的连续正数序列。例如和为 100 的连续序列有：</p><blockquote><p>[9, 10, 11, 12, 13, 14, 15, 16]<br />[18, 19, 20, 21, 22]</p></blockquote><p><strong>思路</strong>：</p><p>  像一个毛毛虫一样往前爬，并检查。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt; ();<br>    <span class="hljs-keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="hljs-keyword">int</span> sum) &#123;<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">1</span>, end = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> curSum = start + end;<br>        <span class="hljs-keyword">while</span>(end &lt; sum)&#123; <span class="hljs-comment">// 当最后一个大于sum则不能组成序列</span><br>            <span class="hljs-keyword">if</span>(curSum &lt; sum)&#123;<br>                end++;<br>                curSum += end;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(curSum &gt; sum)&#123;<br>                curSum -= start;<br>                start++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ArrayList&lt;Integer&gt; C = <span class="hljs-keyword">new</span> ArrayList&lt;&gt; ();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start; i &lt;= end; ++i)&#123;<br>                    C.add(i);<br>                &#125;<br>                ans.add(C);<br>                start++;<br>                end = start + <span class="hljs-number">1</span>;<br>                curSum = start + end;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="581-翻转单词顺序列"><a class="markdownIt-Anchor" href="#581-翻转单词顺序列"></a> 58.1、翻转单词顺序列</h3><p><strong>题目描述</strong>：</p><p>  如题。</p><p><strong>思路</strong>：</p><p>  先翻转每个单词，再翻转整个字符串。</p><p>  题目应该有一个隐含条件，就是不能用额外的空间。虽然 Java 的题目输入参数为 String 类型，需要先创建一个字符数组使得空间复杂度为 O(N)，但是正确的参数类型应该和原书一样，为字符数组，并且只能使用该字符数组的空间。任何使用了额外空间的解法在面试时都会大打折扣，包括递归解法。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] characters;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">ReverseSentence</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(str == <span class="hljs-keyword">null</span> || str.length() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        characters = str.toCharArray();<br>        <span class="hljs-keyword">int</span> n = str.length();<br>        <span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>, tail = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(tail &lt;= n)&#123;<br>            <span class="hljs-keyword">if</span>(tail == n || characters[tail] == <span class="hljs-string">&#x27; &#x27;</span>)&#123; <span class="hljs-comment">// 不动空格</span><br>                reverse(characters, head, tail - <span class="hljs-number">1</span>);<br>                head = tail + <span class="hljs-number">1</span>;<br>            &#125;<br>            tail++;<br>        &#125;<br>        reverse(characters, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(characters);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] chars, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>            swap(chars, i++, j--);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] chars, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-keyword">char</span> temp = chars[i];<br>        chars[i] = chars[j];<br>        chars[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="582-左旋转字符串"><a class="markdownIt-Anchor" href="#582-左旋转字符串"></a> 58.2、左旋转字符串</h3><p><strong>题目描述</strong>：</p><p>  将字符串 S 从第 K 位置分隔成两个子字符串，并交换这两个子字符串的位置。</p><blockquote><p>Input:<br />S=“abcXYZdef”<br />K=3</p><p>Output:<br />“XYZdefabc”</p></blockquote><p><strong>思路</strong>：</p><p>  先将 “abc” 和 “XYZdef” 分别翻转，得到 “cbafedZYX”，然后再把整个字符串翻转得到 “XYZdefabc”。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">LeftRotateString</span><span class="hljs-params">(String str,<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(str == <span class="hljs-keyword">null</span> || str.length() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">char</span>[] chars = str.toCharArray();<br>        <span class="hljs-keyword">int</span> len = chars.length;<br>        n %= len; <span class="hljs-comment">// 注意处理超出限制的</span><br>        reverse(chars, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>        reverse(chars, n, len - <span class="hljs-number">1</span>);<br>        reverse(chars, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(chars);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] chars, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>            swap(chars, i++, j--);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] chars, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-keyword">char</span> temp = chars[i];<br>        chars[i] = chars[j];<br>        chars[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四-链表"><a class="markdownIt-Anchor" href="#四-链表"></a> 四、链表</h2><h3 id="6-从尾到头打印链表"><a class="markdownIt-Anchor" href="#6-从尾到头打印链表"></a> 6、从尾到头打印链表</h3><p><strong>题目描述</strong>：</p><p>  输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</p><p><strong>思路&amp;代码</strong>：</p><p>  从尾到头反过来打印出每个结点的值。</p><p><strong>插在头上</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*    public class ListNode &#123;</span><br><span class="hljs-comment">*        int val;</span><br><span class="hljs-comment">*        ListNode next = null;</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*        ListNode(int val) &#123;</span><br><span class="hljs-comment">*            this.val = val;</span><br><span class="hljs-comment">*        &#125;</span><br><span class="hljs-comment">*    &#125;</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode listNode)</span> </span>&#123;<br>        ListNode p = listNode;<br>        ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-keyword">null</span>)&#123;<br>            ans.add(<span class="hljs-number">0</span>, p.val);<br>            p = p.next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*    public class ListNode &#123;</span><br><span class="hljs-comment">*        int val;</span><br><span class="hljs-comment">*        ListNode next = null;</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*        ListNode(int val) &#123;</span><br><span class="hljs-comment">*            this.val = val;</span><br><span class="hljs-comment">*        &#125;</span><br><span class="hljs-comment">*    &#125;</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode listNode)</span> </span>&#123;<br>        Stack &lt;Integer&gt; s = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        ListNode p = listNode;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-keyword">null</span>)&#123;<br>            s.push(p.val);<br>            p = p.next;<br>        &#125;<br>        ArrayList &lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(!s.isEmpty())&#123;<br>            ans.add(s.pop());<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>头插法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*    public class ListNode &#123;</span><br><span class="hljs-comment">*        int val;</span><br><span class="hljs-comment">*        ListNode next = null;</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*        ListNode(int val) &#123;</span><br><span class="hljs-comment">*            this.val = val;</span><br><span class="hljs-comment">*        &#125;</span><br><span class="hljs-comment">*    &#125;</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">printListFromTailToHead</span><span class="hljs-params">(ListNode listNode)</span> </span>&#123;<br>        ListNode newHead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span>(listNode != <span class="hljs-keyword">null</span>)&#123;<br>            ListNode next = listNode.next;<br>            listNode.next = newHead.next;<br>            newHead.next = listNode;<br>            listNode = next;<br>        &#125;<br>        ArrayList &lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        ListNode p = newHead.next;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-keyword">null</span>)&#123;<br>            ans.add(p.val);<br>            p = p.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="181-在-o1-时间内删除链表节点"><a class="markdownIt-Anchor" href="#181-在-o1-时间内删除链表节点"></a> 18.1、在 O(1) 时间内删除链表节点</h3><p><strong>题目描述</strong>：</p><p>  如题。</p><p><strong>思路</strong>：</p><p>① 如果该节点不是尾节点，那么可以直接将下一个节点的值赋给该节点，然后令该节点指向下下个节点，再删除下一个节点，时间复杂度为 O(1)。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112201946166.png" style="zoom:50%;" /><p>② 否则，就需要先遍历链表，找到节点的前一个节点，然后让前一个节点指向 null，时间复杂度为 O(N)。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112201947332.png" style="zoom:50%;" /><p>综上，如果进行 N 次操作，那么大约需要操作节点的次数为 N-1+N=2N-1，其中 N-1 表示 N-1 个不是尾节点的每个节点以 O(1) 的时间复杂度操作节点的总次数，N 表示 1 个尾节点以 O(N) 的时间复杂度操作节点的总次数。(2N-1)/N ~ 2，因此该算法的平均时间复杂度为 O(1)。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode head, ListNode tobeDelete)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || tobeDelete == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (tobeDelete.next != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 要删除的节点不是尾节点</span><br>        ListNode next = tobeDelete.next;<br>        tobeDelete.val = next.val;<br>        tobeDelete.next = next.next;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == tobeDelete)<br>             <span class="hljs-comment">// 只有一个节点</span><br>            head = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            ListNode cur = head;<br>            <span class="hljs-keyword">while</span> (cur.next != tobeDelete)<br>                cur = cur.next;<br>            cur.next = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="182-删除链表中重复的结点"><a class="markdownIt-Anchor" href="#182-删除链表中重复的结点"></a> 18.2、删除链表中重复的结点</h3><p><strong>题目描述</strong>：</p><p>  如题。</p><p><strong>思路</strong>：</p><p>  如果相同则往里递归，如果不同则链接。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> public class ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    ListNode next = null;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    ListNode(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplication</span><span class="hljs-params">(ListNode pHead)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead == <span class="hljs-keyword">null</span> || pHead.next == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> pHead;<br>        ListNode next = pHead.next;<br>        <span class="hljs-keyword">if</span>(next.val == pHead.val)&#123;<br>            <span class="hljs-keyword">while</span>(next != <span class="hljs-keyword">null</span> &amp;&amp; pHead.val == next.val)&#123; <span class="hljs-comment">// 没有走到底，以及有等值</span><br>                next = next.next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> deleteDuplication(next);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            pHead.next = deleteDuplication(next);<br>            <span class="hljs-keyword">return</span> pHead;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="22-链表中倒数第-k-个结点"><a class="markdownIt-Anchor" href="#22-链表中倒数第-k-个结点"></a> 22、链表中倒数第 K 个结点</h3><p><strong>题目描述</strong>：</p><p>  如题。</p><p><strong>思路</strong>：</p><p>  设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K 个节点处，该位置就是倒数第 K 个节点。</p><h2 id="img-srchttpscdnjsdelivrnetgh18612849621picture_bedmainpicture202112212251062png-stylezoom50"><a class="markdownIt-Anchor" href="#img-srchttpscdnjsdelivrnetgh18612849621picture_bedmainpicture202112212251062png-stylezoom50"></a> <img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112212251062.png" style="zoom:50%;" /></h2><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *   int val;</span><br><span class="hljs-comment"> *   ListNode next = null;</span><br><span class="hljs-comment"> *   public ListNode(int val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *   &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pHead ListNode类 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> k int整型 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">FindKthToTail</span> <span class="hljs-params">(ListNode pHead, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(pHead == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        ListNode p1 = pHead, p2 = pHead;<br>        <span class="hljs-keyword">while</span>(p2 != <span class="hljs-keyword">null</span> &amp;&amp; k--&gt;<span class="hljs-number">0</span>)&#123;<br>            p2 = p2.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(k &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(p2 != <span class="hljs-keyword">null</span>)&#123;<br>                p2 = p2.next;<br>                p1 = p1.next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> p1;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="23-链表中环的入口结点"><a class="markdownIt-Anchor" href="#23-链表中环的入口结点"></a> 23、链表中环的入口结点</h3><p><strong>题目描述</strong>：</p><p>  一个链表中包含环，请找出该链表的环的入口结点。要求不能使用额外的空间。</p><p><strong>思路</strong>：</p><p>使用双指针，一个快指针 fast 每次移动两个节点，一个慢指针 slow 每次移动一个节点。因为存在环，所以两个指针必定相遇在环中的某个节点上。</p><p>假设环入口节点为 y1，相遇所在节点为 z1。</p><p>假设快指针 fast 在圈内绕了 N 圈，则总路径长度为 x+Ny+(N-1)z。z 为 (N-1) 倍是因为快慢指针最后已经在 z1 节点相遇了，后面就不需要再走了。</p><p>而慢指针 slow 总路径长度为 x+y。</p><p>因为快指针是慢指针的两倍，因此 x+Ny+(N-1)z = 2(x+y)。</p><p>我们要找的是环入口节点 y1，也可以看成寻找长度 x 的值，因此我们先将上面的等值分解为和 x 有关：x=(N-2)y+(N-1)z。</p><p>上面的等值没有很强的规律，但是我们可以发现 y+z 就是圆环的总长度，因此我们将上面的等式再分解：x=(N-2)(y+z)+z。这个等式左边是从起点x1 到环入口节点 y1 的长度，而右边是在圆环中走过 (N-2) 圈，再从相遇点 z1 再走过长度为 z 的长度。此时我们可以发现如果让两个指针同时从起点 x1 和相遇点 z1 开始，每次只走过一个距离，那么最后他们会在环入口节点相遇。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112221205361.png" style="zoom:50%;" /><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> public class ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    ListNode next = null;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    ListNode(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">EntryNodeOfLoop</span><span class="hljs-params">(ListNode pHead)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead == <span class="hljs-keyword">null</span> || pHead.next == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        ListNode fast = pHead, slow = pHead;<br><span class="hljs-comment">//         while(fast != null &amp;&amp; slow != null &amp;&amp; fast != slow)&#123;</span><br><span class="hljs-comment">//             fast = fast.next.next;</span><br><span class="hljs-comment">//             slow = slow.next;</span><br><span class="hljs-comment">//         &#125;//这里不能这么写因为没法既保证快指针的速度是二倍且同时出发</span><br>        <span class="hljs-keyword">do</span>&#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>        &#125;<span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; slow != <span class="hljs-keyword">null</span> &amp;&amp; fast != slow);<br>        <span class="hljs-keyword">if</span>(fast == <span class="hljs-keyword">null</span> || slow == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        slow = pHead;<br>        <span class="hljs-keyword">while</span>(slow != fast)&#123;<br>            slow = slow.next;<br>            fast = fast.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> fast;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="24-反转链表"><a class="markdownIt-Anchor" href="#24-反转链表"></a> 24、反转链表</h3><p><strong>题目描述</strong>：</p><p>  如题。</p><p><strong>思路&amp;代码</strong>：</p><p><strong>递归</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">public class ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    ListNode next = null;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    ListNode(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode next = head.next;<br>        head.next = <span class="hljs-keyword">null</span>;<br>        ListNode newHead = ReverseList(next); <span class="hljs-comment">// 设一个新脑袋就存储最后一个尾巴</span><br>        next.next = head;   <span class="hljs-comment">// 下一个回指当前这个</span><br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>迭代</strong></p><p>使用头插法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">public class ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    ListNode next = null;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    ListNode(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        ListNode newHead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>)&#123;<br>            ListNode next = head.next;<br>            head.next = newHead.next;<br>            newHead.next = head;<br>            head = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="25-合并两个排序的链表"><a class="markdownIt-Anchor" href="#25-合并两个排序的链表"></a> 25、合并两个排序的链表</h3><p><strong>题目描述</strong>：</p><p>  <img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112230940382.png" style="zoom:50%;" /></p><p><strong>思路&amp;代码</strong>：</p><p><strong>递归</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">public class ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    ListNode next = null;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    ListNode(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode list1,ListNode list2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(list1 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(list2 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125;<br>        <span class="hljs-comment">//谁小谁当头</span><br>        <span class="hljs-keyword">if</span>(list1.val &gt; list2.val)&#123;<br>            list2.next = Merge(list1, list2.next);<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            list1.next = Merge(list1.next, list2);<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>非递归</strong></p><p>  需要单独申请空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">public class ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    ListNode next = null;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    ListNode(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">Merge</span><span class="hljs-params">(ListNode list1,ListNode list2)</span> </span>&#123;<br>        ListNode newHead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>        ListNode p = newHead;<br>        <span class="hljs-keyword">while</span>(list1 != <span class="hljs-keyword">null</span> &amp;&amp; list2 != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(list1.val &lt; list2.val)&#123;<br>                p.next = list1;<br>                list1 = list1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                p.next = list2;<br>                list2 = list2.next;<br>            &#125;<br>            p = p.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(list1 != <span class="hljs-keyword">null</span>)&#123;<br>            p.next = list1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(list2 != <span class="hljs-keyword">null</span>)&#123;<br>            p.next = list2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newHead.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="35-复杂链表的复制"><a class="markdownIt-Anchor" href="#35-复杂链表的复制"></a> 35、复杂链表的复制</h3><p><strong>题目描述</strong>：</p><p>  输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomListNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> label;<br>    RandomListNode next = <span class="hljs-keyword">null</span>;<br>    RandomListNode random = <span class="hljs-keyword">null</span>;<br><br>    RandomListNode(<span class="hljs-keyword">int</span> label) &#123;<br>        <span class="hljs-keyword">this</span>.label = label;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112230957705.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>第一步，在每个节点的后面插入复制的节点。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112230958795.png" style="zoom:50%;" /><p>第二步，对复制节点的 random 链接进行赋值。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112230958582.png" style="zoom:50%;" /><p>第三步，拆分。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112230959704.png" style="zoom:50%;" /><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">public class RandomListNode &#123;</span><br><span class="hljs-comment">    int label;</span><br><span class="hljs-comment">    RandomListNode next = null;</span><br><span class="hljs-comment">    RandomListNode random = null;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    RandomListNode(int label) &#123;</span><br><span class="hljs-comment">        this.label = label;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RandomListNode <span class="hljs-title">Clone</span><span class="hljs-params">(RandomListNode pHead)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pHead == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 插入新节点</span><br>        RandomListNode p = pHead;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-keyword">null</span>)&#123;<br>            RandomListNode newNode = <span class="hljs-keyword">new</span> RandomListNode(p.label);<br>            newNode.next = p.next;<br>            p.next = newNode;<br>            p = newNode.next;<br>        &#125;<br>        <span class="hljs-comment">// 建立 random 链接</span><br>        p = pHead;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-keyword">null</span>)&#123;<br>            RandomListNode next = p.next;<br>            <span class="hljs-keyword">if</span>(p.random != <span class="hljs-keyword">null</span>)<br>                next.random = p.random.next;<br>            p = next.next;<br>        &#125;<br>        <span class="hljs-comment">// 拆分</span><br>        p = pHead;<br>        RandomListNode pCloneHead = pHead.next;<br>        <span class="hljs-keyword">while</span>(p.next != <span class="hljs-keyword">null</span>)&#123;<br>            RandomListNode next = p.next;<br>            p.next = next.next;<br>            p = next;<br>        &#125;<span class="hljs-comment">//这里很巧妙 他是一个来回交替拆解的过程</span><br>        <span class="hljs-keyword">return</span> pCloneHead;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="52-两个链表的第一个公共结点"><a class="markdownIt-Anchor" href="#52-两个链表的第一个公共结点"></a> 52、两个链表的第一个公共结点</h3><p><strong>题目描述</strong>：</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112231035273.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p><p>当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">public class ListNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    ListNode next = null;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    ListNode(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">FindFirstCommonNode</span><span class="hljs-params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;<br>        ListNode l1 = pHead1, l2 = pHead2;<br>        <span class="hljs-keyword">while</span>(l1 != l2)&#123;<br>            l1 = (l1 == <span class="hljs-keyword">null</span>) ? pHead2 : l1.next;<br>            l2 = (l2 == <span class="hljs-keyword">null</span>) ? pHead1 : l2.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> l1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五-树"><a class="markdownIt-Anchor" href="#五-树"></a> 五、树</h2><h3 id="7-重建二叉树"><a class="markdownIt-Anchor" href="#7-重建二叉树"></a> 7、重建二叉树</h3><p><strong>题目描述</strong>：</p><p>  根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112241112506.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>  前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。然后分别对左右子树递归地求解。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for binary tree</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">//为了找到中序遍历的索引与数的对应</span><br>    <span class="hljs-keyword">private</span> HashMap&lt;Integer, Integer&gt; inOrderSeq = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">reConstructBinaryTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] pre,<span class="hljs-keyword">int</span> [] vin)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pre.length; ++i)&#123;<br>            inOrderSeq.put(vin[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> creaTree(pre, <span class="hljs-number">0</span>, pre.length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">creaTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] pre, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> inL)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(pre[left]);<br>        <span class="hljs-keyword">int</span> inIdx = inOrderSeq.get(root.val);<br>        <span class="hljs-keyword">int</span> disL = inIdx - inL;<br>        root.left = creaTree(pre, left + <span class="hljs-number">1</span>, left + disL, inL); <span class="hljs-comment">//左边界+1表示第一个作为根自己找个例子推一下就懂</span><br>        root.right = creaTree(pre, left + disL + <span class="hljs-number">1</span>, right, inL + disL + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-二叉树的下一个结点"><a class="markdownIt-Anchor" href="#8-二叉树的下一个结点"></a> 8、二叉树的下一个结点</h3><p><strong>题目描述</strong>：</p><p>  给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回 。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeLinkNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> val;<br>    TreeLinkNode left = <span class="hljs-keyword">null</span>;<br>    TreeLinkNode right = <span class="hljs-keyword">null</span>;<br>    TreeLinkNode next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 指向父结点的指针</span><br><br>    TreeLinkNode(<span class="hljs-keyword">int</span> val) &#123;<br>        <span class="hljs-keyword">this</span>.val = val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思路</strong>：</p><p>中序遍历的过程：先遍历树的左子树，再遍历根节点，最后再遍历右子树。所以最左节点是中序遍历的第一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>    traverse(root.left);<br>    visit(root);<br>    traverse(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><p>① 如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112241128254.png" style="zoom:50%;" /><p>② 否则，向上找第一个左链接指向的树包含该节点的祖先节点。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112241129044.png" style="zoom:50%;" /><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">public class TreeLinkNode &#123;</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    TreeLinkNode left = null;</span><br><span class="hljs-comment">    TreeLinkNode right = null;</span><br><span class="hljs-comment">    TreeLinkNode next = null;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    TreeLinkNode(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeLinkNode <span class="hljs-title">GetNext</span><span class="hljs-params">(TreeLinkNode pNode)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pNode.right != <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//如果右子树不为空</span><br>            pNode = pNode.right; <span class="hljs-comment">// 右子树的最左节点</span><br>            <span class="hljs-keyword">while</span>(pNode.left != <span class="hljs-keyword">null</span>)&#123;<br>                pNode = pNode.left;<br>            &#125;<br>            <span class="hljs-keyword">return</span> pNode;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 祖先节点指向该节点所在分支</span><br>            <span class="hljs-keyword">while</span>(pNode.next != <span class="hljs-keyword">null</span>)&#123;<br>                TreeLinkNode parent = pNode.next;<br>                <span class="hljs-keyword">if</span>(parent.left == pNode)&#123;<br>                    <span class="hljs-keyword">return</span> parent;<br>                &#125;<br>                pNode = pNode.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="26-树的子结构"><a class="markdownIt-Anchor" href="#26-树的子结构"></a> 26、树的子结构</h3><p><strong>题目描述</strong>：</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112260826192.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>  递归查找。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">public class TreeNode &#123;</span><br><span class="hljs-comment">    int val = 0;</span><br><span class="hljs-comment">    TreeNode left = null;</span><br><span class="hljs-comment">    TreeNode right = null;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public TreeNode(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">HasSubtree</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root1 == <span class="hljs-keyword">null</span> || root2 == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> isSubTree(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSubTree</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root2 == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">// 模版走完了就当做完成了</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root1 == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">// 没有匹配成功</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root1.val != root2.val)&#123;<span class="hljs-comment">//不仅结构需要一直数值也需要一致</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">//左右两边都需要匹配</span><br>        <span class="hljs-keyword">return</span> isSubTree(root1.left, root2.left) &amp;&amp; isSubTree(root1.right, root2.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="27-二叉树的镜像"><a class="markdownIt-Anchor" href="#27-二叉树的镜像"></a> 27、二叉树的镜像</h3><p><strong>题目描述</strong>：</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112260910011.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>  需要使用后序遍历，然后在最后LRD到D的时候交换一下左右子树。或者用先序遍历也行，主要是先走根。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *   int val = 0;</span><br><span class="hljs-comment"> *   TreeNode left = null;</span><br><span class="hljs-comment"> *   TreeNode right = null;</span><br><span class="hljs-comment"> *   public TreeNode(int val) &#123;</span><br><span class="hljs-comment"> *     this.val = val;</span><br><span class="hljs-comment"> *   &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pRoot TreeNode类 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> TreeNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">Mirror</span> <span class="hljs-params">(TreeNode pRoot)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(pRoot == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        Mirror(pRoot.left);<br>        Mirror(pRoot.right);<br>        TreeNode temp = pRoot.left;<br>        pRoot.left = pRoot.right;<br>        pRoot.right = temp;<br>        <span class="hljs-keyword">return</span> pRoot;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="28-对称的二叉树"><a class="markdownIt-Anchor" href="#28-对称的二叉树"></a> 28、对称的二叉树</h3><p><strong>题目描述</strong>：</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112260918127.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>  递归测试。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">public class TreeNode &#123;</span><br><span class="hljs-comment">    int val = 0;</span><br><span class="hljs-comment">    TreeNode left = null;</span><br><span class="hljs-comment">    TreeNode right = null;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public TreeNode(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetrical</span><span class="hljs-params">(TreeNode pRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pRoot == <span class="hljs-keyword">null</span>)&#123; <span class="hljs-comment">// 定义空树为对称的</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> isMirror(pRoot.left, pRoot.right);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isMirror</span><span class="hljs-params">(TreeNode left, TreeNode right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>) <span class="hljs-comment">// 说明结构上是对称的(因为后面的if判断数值了所以这里当作是也满足数值对称，但其实也可以把数值判断写在这里)</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span> || right == <span class="hljs-keyword">null</span>)&#123; <span class="hljs-comment">// 判断结构上是不对称的</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left.val != right.val)&#123; <span class="hljs-comment">// 说明数值上是不对称的</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> isMirror(left.left, right.right) &amp;&amp; isMirror(left.right, right.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="321-从上往下打印二叉树"><a class="markdownIt-Anchor" href="#321-从上往下打印二叉树"></a> 32.1、从上往下打印二叉树</h3><p><strong>题目描述</strong>：</p><p>  从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><p>  例如，以下二叉树层次遍历的结果为：1,2,3,4,5,6,7</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112260926689.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>  使用队列来进行层次遍历。</p><p>  不需要使用两个队列分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">public class TreeNode &#123;</span><br><span class="hljs-comment">    int val = 0;</span><br><span class="hljs-comment">    TreeNode left = null;</span><br><span class="hljs-comment">    TreeNode right = null;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public TreeNode(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Queue&lt;TreeNode&gt; Q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayList&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">PrintFromTopToBottom</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        Q.offer(root);<br>        <span class="hljs-keyword">while</span>(!Q.isEmpty())&#123;<br>            TreeNode p = Q.poll();<br>            ans.add(p.val);<br>            <span class="hljs-keyword">if</span>(p.left != <span class="hljs-keyword">null</span>)&#123;<br>                Q.offer(p.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(p.right != <span class="hljs-keyword">null</span>)&#123;<br>                Q.offer(p.right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="322-把二叉树打印成多行"><a class="markdownIt-Anchor" href="#322-把二叉树打印成多行"></a> 32.2、把二叉树打印成多行</h3><p><strong>题目描述</strong>：</p><p>  如题。</p><p><strong>思路</strong>：</p><p>  非常类似32.1，但是需要架设一个变量来控制每一行的输出。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">public class TreeNode &#123;</span><br><span class="hljs-comment">    int val = 0;</span><br><span class="hljs-comment">    TreeNode left = null;</span><br><span class="hljs-comment">    TreeNode right = null;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public TreeNode(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Queue&lt;TreeNode&gt; Q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode root)&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        Q.offer(root);<br>        <span class="hljs-keyword">while</span>(!Q.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> layerNum = Q.size(); <span class="hljs-comment">// 记录当前层的个数</span><br>            ArrayList &lt;Integer&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">while</span>(layerNum --&gt; <span class="hljs-number">0</span>)&#123;<br>                TreeNode p = Q.poll();<br>                ret.add(p.val);<br>                <span class="hljs-keyword">if</span>(p.left != <span class="hljs-keyword">null</span>)&#123;<br>                    Q.offer(p.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(p.right != <span class="hljs-keyword">null</span>)&#123;<br>                    Q.offer(p.right);<br>                &#125;<br>            &#125;<br>            ans.add(ret);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="323-按之字形顺序打印二叉树"><a class="markdownIt-Anchor" href="#323-按之字形顺序打印二叉树"></a> 32.3、按之字形顺序打印二叉树</h3><p><strong>题目描述</strong>：</p><p>  请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><p><strong>思路</strong>：</p><p>  在上一道题的基础上加一个反转变量就行。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">public class TreeNode &#123;</span><br><span class="hljs-comment">    int val = 0;</span><br><span class="hljs-comment">    TreeNode left = null;</span><br><span class="hljs-comment">    TreeNode right = null;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public TreeNode(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Queue&lt;TreeNode&gt; Q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode root) &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <span class="hljs-keyword">boolean</span> reverse = <span class="hljs-keyword">false</span>;<br>        Q.offer(root);<br>        <span class="hljs-keyword">while</span>(!Q.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> layerNum = Q.size(); <span class="hljs-comment">// 记录当前层的个数</span><br>            ArrayList &lt;Integer&gt; ret = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">while</span>(layerNum --&gt; <span class="hljs-number">0</span>)&#123;<br>                TreeNode p = Q.poll();<br>                ret.add(p.val);<br>                <span class="hljs-keyword">if</span>(p.left != <span class="hljs-keyword">null</span>)&#123;<br>                    Q.offer(p.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(p.right != <span class="hljs-keyword">null</span>)&#123;<br>                    Q.offer(p.right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(reverse)&#123;  <span class="hljs-comment">//添加一个反转过程</span><br>                Collections.reverse(ret);<br>            &#125;<br>            reverse = !reverse;<br>            ans.add(ret);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="33-二叉搜索树的后序遍历序列"><a class="markdownIt-Anchor" href="#33-二叉搜索树的后序遍历序列"></a> 33、二叉搜索树的后序遍历序列</h3><p><strong>题目描述</strong>：</p><p>  输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。假设输入的数组的任意两个数字都互不相同。</p><p>例如，下图是后序遍历序列 1,3,2 所对应的二叉搜索树。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111211946077.png" style="zoom:50%;" /><p><strong>思路</strong>:</p><p>  因为是后序遍历，所以一定是LRT这个顺序，根在最后。二叉搜索树，左子树比根节点小，右子树比根节点大。</p><p>  然后分解子问题，就是将每一次递归的序列从头遍历，看到有大于的结点之后，再重新判断一次之后的结点有没有还是小于根节点的就可以得到最终结果，每次按照最后两部分进行递归。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">VerifySquenceOfBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] sequence)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(sequence == <span class="hljs-keyword">null</span> || sequence.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> Verify(sequence, <span class="hljs-number">0</span>, sequence.length - <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">Verify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] sequence, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(start &gt;= end) <span class="hljs-comment">// 剩最后一个</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">int</span> root = sequence[end];<br>        <span class="hljs-keyword">int</span> cur = start;<br>        <span class="hljs-keyword">while</span>(cur &lt; end &amp;&amp; sequence[cur] &lt; root)&#123;<br>            cur++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> mid = cur;<br>        <span class="hljs-keyword">while</span>(cur &lt; end)&#123;<br>            <span class="hljs-keyword">if</span>(sequence[cur++] &lt; root)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Verify(sequence, start, mid - <span class="hljs-number">1</span>) &amp;&amp; Verify(sequence, mid, end - <span class="hljs-number">1</span>); <span class="hljs-comment">// end-1 不算根节点 mid-1因为cur++的时候在第一个while中退出的状态是第一个大于根节点的值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="34-二叉树中和为某一值的路径"><a class="markdownIt-Anchor" href="#34-二叉树中和为某一值的路径"></a> 34、二叉树中和为某一值的路径</h3><p><strong>题目描述</strong>:</p><p>  输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><p>  下图的二叉树有两条和为 22 的路径：10, 5, 7 和 10, 12</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111221142303.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>  使用二叉树的遍历，并记录每次遍历到此节点的路径以及和，如果满足要求就记录路径，反之继续。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="hljs-keyword">int</span> expectNumber) &#123;<br>        scanner(root, expectNumber, <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt; ());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scanner</span><span class="hljs-params">(TreeNode node, <span class="hljs-keyword">int</span> target, ArrayList&lt;Integer&gt; path)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> curVal = node.val; <span class="hljs-comment">// 记录当前节点</span><br>        path.add(curVal); <span class="hljs-comment">//记录路径</span><br>        target -= curVal; <span class="hljs-comment">//通过减法来记录</span><br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span> &amp;&amp; node.left == <span class="hljs-keyword">null</span> &amp;&amp; node.right == <span class="hljs-keyword">null</span>)&#123;  <span class="hljs-comment">// 必须是到叶子结点</span><br>            ans.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(path));  <span class="hljs-comment">// 为什么要加new 是因为 arraylist中存入的是对象的引用而不是对象本身，值会随着后面而改变的</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            scanner(node.left, target, path);<br>            scanner(node.right, target, path);<br>        &#125;<br>        path.remove(path.size() - <span class="hljs-number">1</span>); <span class="hljs-comment">//因为java中的函数相当于引用，所以值会改变的。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="36-二叉搜索树与双向链表"><a class="markdownIt-Anchor" href="#36-二叉搜索树与双向链表"></a> 36、二叉搜索树与双向链表</h3><p><strong>题目描述</strong>：</p><p>  输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111250941719.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>  这个题是二叉排序树，所以需要使用中序遍历可以得到一个有序的双向链表，然后通过记录和更新当前的前结点来进行连接。给头节点一开始设置为空这样有助于遇到遍历的第一个结点进行头节点赋值。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TreeNode pre = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TreeNode head = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">Convert</span><span class="hljs-params">(TreeNode pRootOfTree)</span> </span>&#123;<br>        inOrder(pRootOfTree);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        inOrder(node.left);<br>        node.left = pre;<br>        <span class="hljs-keyword">if</span>(pre != <span class="hljs-keyword">null</span>)  <span class="hljs-comment">// 变换操作全部放在上一个节点去操作</span><br>            pre.right = node;<br>        pre = node; <span class="hljs-comment">// 当前节点成为上一个节点</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)<br>            head = node;<br>        inOrder(node.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="37-序列化二叉树"><a class="markdownIt-Anchor" href="#37-序列化二叉树"></a> 37、序列化二叉树</h3><p><strong>题目描述</strong>：</p><p>  请实现两个函数，分别用来序列化和反序列化二叉树。</p><p><strong>思路</strong>：</p><p>  将二叉树按照某种方式遍历，用符号记录当前遍历的结果。然后再用这个序列求解出生成树。（先序遍历最简单）</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">public class TreeNode &#123;</span><br><span class="hljs-comment">    int val = 0;</span><br><span class="hljs-comment">    TreeNode left = null;</span><br><span class="hljs-comment">    TreeNode right = null;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public TreeNode(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 用于反序列化的时候记录当前的位置</span><br>    <span class="hljs-function">String <span class="hljs-title">Serialize</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        StringBuffer S = <span class="hljs-keyword">new</span> StringBuffer();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            S.append(<span class="hljs-string">&quot;#,&quot;</span>);<br>            <span class="hljs-keyword">return</span> S.toString();<br>        &#125;<br>        S.append(root.val + <span class="hljs-string">&quot;,&quot;</span>); <span class="hljs-comment">//加逗号是为了可以区分多位数</span><br>        S.append(Serialize(root.left));<br>        S.append(Serialize(root.right));<br>        <span class="hljs-keyword">return</span> S.toString();<br>    &#125;<br>    <span class="hljs-function">TreeNode <span class="hljs-title">Deserialize</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        index++;<br>        <span class="hljs-keyword">if</span>(index &gt;= str.length()) <span class="hljs-comment">//超出了序列范围了则做一个小封口</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        TreeNode node = <span class="hljs-keyword">null</span>;<br>        String[] S = str.split(<span class="hljs-string">&quot;,&quot;</span>); <span class="hljs-comment">//使用逗号作为分割</span><br>        <span class="hljs-keyword">while</span>(!S[index].equals(<span class="hljs-string">&quot;#&quot;</span>))&#123; <span class="hljs-comment">// 判断是否是空结点</span><br>            node = <span class="hljs-keyword">new</span> TreeNode(Integer.valueOf(S[index])); <span class="hljs-comment">//传入值</span><br>            node.left = Deserialize(str);<br>            node.right = Deserialize(str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="54-二叉查找树的第-k-个结点"><a class="markdownIt-Anchor" href="#54-二叉查找树的第-k-个结点"></a> 54、二叉查找树的第 K 个结点</h3><p><strong>题目描述</strong>：</p><p>  如题</p><p><strong>思路</strong>：</p><p>  利用二叉查找树+中序遍历得到结果。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> TreeNode ret;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">KthNode</span><span class="hljs-params">(TreeNode pRoot, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    inOrder(pRoot, k);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || cnt &gt;= k)<br>        <span class="hljs-keyword">return</span>;<br>    inOrder(root.left, k);<br>    cnt++;<br>    <span class="hljs-keyword">if</span> (cnt == k)<br>        ret = root;<br>    inOrder(root.right, k);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="551-二叉树的深度"><a class="markdownIt-Anchor" href="#551-二叉树的深度"></a> 55.1、二叉树的深度</h3><p><strong>题目描述</strong>：</p><p>  从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><p><strong>思路</strong>：</p><p>  一道非常经典的递归题目。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">public class TreeNode &#123;</span><br><span class="hljs-comment">    int val = 0;</span><br><span class="hljs-comment">    TreeNode left = null;</span><br><span class="hljs-comment">    TreeNode right = null;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    public TreeNode(int val) &#123;</span><br><span class="hljs-comment">        this.val = val;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">TreeDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> root == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : Math.max(TreeDepth(root.left), TreeDepth(root.right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="552-平衡二叉树"><a class="markdownIt-Anchor" href="#552-平衡二叉树"></a> 55.2、平衡二叉树</h3><p><strong>题目描述</strong>：</p><p>  平衡二叉树左右子树高度差不超过 1。</p><p><strong>思路</strong>：</p><p>  通过上一道题中的高度来进行判断。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> ans = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">IsBalanced_Solution</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        Judge(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Judge</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> left = Judge(root.left);<br>        <span class="hljs-keyword">int</span> right = Judge(root.right);<br>        <span class="hljs-keyword">if</span>(Math.abs(left - right) &gt; <span class="hljs-number">1</span>)<br>            ans = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> Math.max(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="68-树中两个节点的最低公共祖先"><a class="markdownIt-Anchor" href="#68-树中两个节点的最低公共祖先"></a> 68、 树中两个节点的最低公共祖先</h3><h4 id="681-二叉查找树"><a class="markdownIt-Anchor" href="#681-二叉查找树"></a> 68.1 二叉查找树</h4><p><strong>题目描述</strong>：</p><p>  在二叉查找树中，找到两个节点的最低公共祖先。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111251119934.png" style="zoom:50%;"/><p><strong>思路</strong>：</p><p>  在二叉查找树中，两个节点 p, q 的公共祖先 root 满足 root.val &gt;= p.val &amp;&amp; root.val &lt;= q.val。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.left, p, q);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;<br>            <span class="hljs-keyword">return</span> lowestCommonAncestor(root.right, p, q);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="682-普通二叉树"><a class="markdownIt-Anchor" href="#682-普通二叉树"></a> 68.2 普通二叉树</h4><p><strong>题目描述</strong>：</p><p>  在普通二叉树中，找到两个节点的最低公共祖先。</p><p><strong>思路</strong>：</p><p>  在左右子树中查找是否存在 p 或者 q，如果 p 和 q 分别在两个子树中，那么就说明根节点就是最低公共祖先。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span> || root == p || root == q)<br>            <span class="hljs-keyword">return</span> root;<br>        TreeNode left = lowestCommonAncestor(root.left, p, q);<br>        TreeNode right = lowestCommonAncestor(root.right, p, q);<br>        <span class="hljs-keyword">return</span> left == <span class="hljs-keyword">null</span> ? right : right == <span class="hljs-keyword">null</span> ? left : root; <span class="hljs-comment">// 如果没有在左子树找到答案那就是一定在右边，反之；如果两遍都找到了 那就说明此时根节点是答案</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六-贪心算法"><a class="markdownIt-Anchor" href="#六-贪心算法"></a> 六、贪心算法</h2><h3 id="14-剪绳子"><a class="markdownIt-Anchor" href="#14-剪绳子"></a> 14、剪绳子</h3><p><strong>题目描述</strong>：</p><p>  把一根绳子剪成多段，并且使得每段的长度乘积最大。</p><p><strong>思路</strong>：</p><p>  尽可能得多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。以下为证明过程。</p><p>将绳子拆成 1 和 n-1，则 1(n-1)-n=-1&lt;0，即拆开后的乘积一定更小，所以不能出现长度为 1 的绳子。</p><p>将绳子拆成 2 和 n-2，则 2(n-2)-n = n-4，在 n&gt;=4 时这样拆开能得到的乘积会比不拆更大。</p><p>将绳子拆成 3 和 n-3，则 3(n-3)-n = 2n-9，在 n&gt;=5 时效果更好。</p><p>将绳子拆成 4 和 n-4，因为 4=2*2，因此效果和拆成 2 一样。</p><p>将绳子拆成 5 和 n-5，因为 5=2+3，而 5&lt;2*3，所以不能出现 5 的绳子，而是尽可能拆成 2 和 3。</p><p>将绳子拆成 6 和 n-6，因为 6=3+3，而 6&lt;3*3，所以不能出现 6 的绳子，而是拆成 3 和 3。这里 6 同样可以拆成 6=2+2+2，但是 3(n - 3) - 2(n - 2) = n - 5 &gt;= 0，在 n&gt;=5 的情况下将绳子拆成 3 比拆成 2 效果更好。</p><p>  继续拆成更大的绳子可以发现都比拆成 2 和 3 的效果更差，因此我们只考虑将绳子拆成 2 和 3，并且优先拆成 3，当拆到绳子长度 n 等于 4 时，也就是出现 3+1，此时只能拆成 2+2。</p><p><strong>代码</strong>：</p><p><em>贪心</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cutRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> timeOf3 = target / <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span>(target - timeOf3 * <span class="hljs-number">3</span> == <span class="hljs-number">1</span>)<br>            timeOf3--;<br>        <span class="hljs-keyword">int</span> timeOf2 = (target - timeOf3 * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">2</span>, timeOf2) * (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">3</span>, timeOf3);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>动态规划</em></p><p>dp[i] 表示 当前绳子总长i的情况下 能到的最好值</p><p>转移方程 dp[i] = max(dp[i], max(dp[j] x (i - j), j x (i - j))])</p><p>dp[j] x (i - j) 表示所剪出的部分还可以继续分</p><p>j x (i - j) 表示所剪出的分部分不继续分了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">cutRope</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[target + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= target; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i; ++j)&#123;<br>                dp[i] = Math.max(dp[i], Math.max(dp[j] * (i - j), j * (i - j)));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="63-股票的最大利润"><a class="markdownIt-Anchor" href="#63-股票的最大利润"></a> 63、股票的最大利润</h3><p><strong>题目描述</strong>：</p><p>  可以有一次买入和一次卖出，买入必须在前。求最大收益。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111260934325.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>  使用贪心策略，假设第 i 轮进行卖出操作，买入操作价格应该在 i 之前并且价格最低。因此在遍历数组时记录当前最低的买入价格，并且尝试将每个位置都作为卖出价格，取收益最大的即可。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(prices.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> curBuy = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; ++i)&#123;<br>            curBuy = Math.min(curBuy, prices[i]);<br>            ans = Math.max(ans, prices[i] - curBuy);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="七-二分查找"><a class="markdownIt-Anchor" href="#七-二分查找"></a> 七、二分查找</h2><p><strong>题目描述</strong>：</p><p>  把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111260943342.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>  将旋转数组对半分可以得到一个包含最小元素的新旋转数组，以及一个非递减排序的数组。新的旋转数组的长度是原数组的一半，从而将问题规模减少了一半，这种折半性质的算法的时间复杂度为 O(log2N)。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111260950686.png" style="zoom:50%;" /><p>  此时问题的关键在于确定对半分得到的两个数组哪一个是旋转数组，哪一个是非递减数组。我们很容易知道非递减数组的第一个元素一定小于等于最后一个元素。</p><p>通过修改二分查找算法进行求解（l 代表 low，m 代表 mid，h 代表 high）：</p><ul><li>当 nums[m] &lt;= nums[h] 时，表示 [m, h] 区间内的数组是非递减数组，[l, m] 区间内的数组是旋转数组，此时令 h = m；</li><li>否则 [m + 1, h] 区间内的数组是旋转数组，令 l = m + 1。</li></ul><p>  如果数组元素允许重复，会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minNumberInRotateArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] array)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = array.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-keyword">int</span> m = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(array[m] == array[l] &amp;&amp; array[m] == array[r])<br>                <span class="hljs-keyword">return</span> find(array);<br>            <span class="hljs-keyword">if</span>(array[m] &lt;= array[r])&#123; <span class="hljs-comment">//如果最右边的值要是大，那一定是还在左边</span><br>                r = m;<br>            &#125;<span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">// 如果中间值大于最右边 说明一定是在右边</span><br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> array[l];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length; ++i)&#123;<br>            min = Math.min(min, array[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="53-数字在排序数组中出现的次数"><a class="markdownIt-Anchor" href="#53-数字在排序数组中出现的次数"></a> 53、数字在排序数组中出现的次数</h3><p><strong>题目描述</strong>：</p><blockquote><p>Input:<br />nums = 1, 2, 3, 3, 3, 3, 4, 6<br />K = 3</p><p>Output:<br />4</p></blockquote><p><strong>思路</strong>：</p><p>  因为是有序的数组，所以我们采用二分法进行提取。找到之后在左右顺序查找就行。（当然可以直接二分法找到比他大的那个数和比他小的那个数，然后索引相减，不过我这里只实现第一种方法。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">GetNumberOfK</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] array , <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(array.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(array.length == <span class="hljs-number">1</span> &amp;&amp; k == array[<span class="hljs-number">0</span>])  <span class="hljs-comment">// 当只有一个的时候没必要二分法 直接判断</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = array.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-keyword">int</span> m = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(array[m] &gt; k)&#123;<br>                r = m;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(array[m] &lt; k)&#123;<br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">int</span> start, end;<br>                <span class="hljs-keyword">for</span>(start = m; start &gt;= <span class="hljs-number">0</span> &amp;&amp; array[start] == k; --start); <span class="hljs-comment">//注意边界条件</span><br>                <span class="hljs-keyword">for</span>(end = m; end &lt;= array.length - <span class="hljs-number">1</span> &amp;&amp; array[end] == k; ++end); <span class="hljs-comment">// 注意边界条件</span><br>                ans = end - start - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="八-分治"><a class="markdownIt-Anchor" href="#八-分治"></a> 八、分治</h2><h3 id="16-数值的整数次方"><a class="markdownIt-Anchor" href="#16-数值的整数次方"></a> 16、数值的整数次方</h3><p><strong>题目描述</strong>：</p><p>  给定一个 double 类型的浮点数 x和 int 类型的整数 n，求 x 的 n 次方。</p><p><strong>思路</strong>：</p><p>  最直观的解法是将 x 重复乘 n 次，x<em>x</em>x…<em>x，那么时间复杂度为 O(N)。因为乘法是可交换的，所以可以将上述操作拆开成两半 (x</em>x…<em>x)</em> (x*x…*x)，两半的计算是一样的，因此只需要计算一次。而且对于新拆开的计算，又可以继续拆开。这就是分治思想，将原问题的规模拆成多个规模较小的子问题，最后子问题的解合并起来。</p><p>  本题中子问题是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">x^{n / 2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>，在将子问题合并时将子问题的解乘于自身相乘即可。但如果 n 不为偶数，那么拆成两半还会剩下一个 x，在将子问题合并时还需要需要多乘于一个 x。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.24999999999999992em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msup><mi>x</mi><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>∗</mo><msup><mi>x</mi><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>n</mi><mi mathvariant="normal">%</mi><mn>2</mn><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msup><mi>x</mi><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>∗</mo><msup><mi>x</mi><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup><mo>∗</mo><mi>x</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>n</mi><mi mathvariant="normal">%</mi><mn>2</mn><mo>=</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">x^n=\left\{\begin{aligned}x^{n / 2} * x^{n / 2} &amp;&amp; n \% 2 = 0\\x^{n / 2} * x^{n / 2} * x &amp;&amp; n \% 2 = 1 \end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7143919999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.196em;vertical-align:-1.348em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.848em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-2.3120000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.348em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.848em;"><span style="top:-3.848em;"><span class="pstrut" style="height:2.9379999999999997em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.9379999999999997em;"></span><span class="mord"><span class="mord"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.348em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.848em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mord">%</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.3120000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mord">%</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.348em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>  因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">x^{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span> 可以通过递归求解，并且每次递归 n 都减小一半，因此整个算法的时间复杂度为 O(logN)。</p><p><em>其中一定要注意分类n可能小于0</em>。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isNegative = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">Power</span><span class="hljs-params">(<span class="hljs-keyword">double</span> base, <span class="hljs-keyword">int</span> exponent)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(exponent &lt; <span class="hljs-number">0</span>)&#123;<br>            exponent *= -<span class="hljs-number">1</span>;<br>            isNegative = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> isNegative ? <span class="hljs-number">1</span> / pow(base, exponent) : pow(base, exponent);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-keyword">double</span> base, <span class="hljs-keyword">int</span> exp)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(exp == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(exp == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> base;<br>        <span class="hljs-keyword">double</span> temp = pow(base, exp / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">double</span> ret = temp * temp;<br>        <span class="hljs-keyword">if</span>(exp % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> ret * base;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="九-搜索"><a class="markdownIt-Anchor" href="#九-搜索"></a> 九、搜索</h2><h3 id="12-矩阵中的路径"><a class="markdownIt-Anchor" href="#12-矩阵中的路径"></a> 12、矩阵中的路径</h3><p><strong>题目描述</strong>：</p><p>  判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</p><p>  例如下面的矩阵包含了一条 bfce 路径。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111261117344.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>  简单DFS。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> matrix string字符串 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> rows int整型 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cols int整型 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> str string字符串 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[][] dir = &#123;&#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[][] Map;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] Str;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> rows;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> cols;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPath</span> <span class="hljs-params">(String matrix, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols, String str)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">this</span>.rows = rows;<br>        <span class="hljs-keyword">this</span>.cols = cols;<br>        <span class="hljs-keyword">this</span>.Map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[rows][cols];<br>        <span class="hljs-keyword">this</span>.Str = str.toCharArray();<br>        <span class="hljs-keyword">boolean</span>[][] vis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];<br>        createMap(matrix);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; ++j)&#123;<br>               <span class="hljs-keyword">if</span>(DFS(vis, i, j, <span class="hljs-number">0</span>))<br>                   <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(String matrix)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; ++j)&#123;<br>                Map[i][j] = matrix.charAt(idx++);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span>[][] vis, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> pathLen)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(Str.length == pathLen)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= rows || j &gt;= cols || vis[i][j] || Str[pathLen] != Map[i][j])<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        vis[i][j] = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] next: dir)&#123;<br>            <span class="hljs-keyword">if</span>(DFS(vis, i + next[<span class="hljs-number">0</span>], j + next[<span class="hljs-number">1</span>], pathLen + <span class="hljs-number">1</span>))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        vis[i][j] = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-机器人的运动范围"><a class="markdownIt-Anchor" href="#13-机器人的运动范围"></a> 13、机器人的运动范围</h3><p><strong>题目描述</strong>：</p><p>  地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。</p><p>  例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？</p><p><strong>思路</strong>：</p><p>  使用深度优先搜索（Depth First Search，DFS）方法进行求解。回溯是深度优先搜索的一种特例，它在一次搜索过程中需要设置一些本次搜索过程的局部状态，并在本次搜索结束之后清除状态。而普通的深度优先搜索并不需要使用这些局部状态，虽然还是有可能设置一些全局状态。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[][] dir = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> rows;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> cols;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span>[][] vis;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> threshold;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> threshold, <span class="hljs-keyword">int</span> rows, <span class="hljs-keyword">int</span> cols)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.threshold = threshold;<br>        <span class="hljs-keyword">this</span>.rows = rows;<br>        <span class="hljs-keyword">this</span>.cols = cols;<br>        <span class="hljs-keyword">this</span>.vis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[rows][cols];<br>        DFS(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;<br>            sum += n % <span class="hljs-number">10</span>;<br>            n /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x == -<span class="hljs-number">1</span> || y == -<span class="hljs-number">1</span> || x == rows || y == cols || vis[x][y] == <span class="hljs-keyword">true</span> || check(x) + check(y) &gt; threshold)<br>            <span class="hljs-keyword">return</span>;<br>        vis[x][y] = <span class="hljs-keyword">true</span>;<br>        ans++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] next: dir)&#123;<br>            DFS(x + next[<span class="hljs-number">0</span>], y + next[<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="38-字符串的排列"><a class="markdownIt-Anchor" href="#38-字符串的排列"></a> 38、字符串的排列</h3><p><strong>题目描述</strong>：</p><p>  输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a, b, c 所能排列出来的所有字符串 abc, acb, bac, bca, cab 和 cba。</p><p><strong>思路</strong>：</p><p>  回溯法</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span>[] vis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;String&gt; <span class="hljs-title">Permutation</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(str.length() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-keyword">char</span>[] chars = str.toCharArray();<br>        Arrays.sort(chars);<br>        back(chars, <span class="hljs-keyword">new</span> StringBuilder());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">back</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] chars, StringBuilder s)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(chars.length == s.length())&#123;<br>            ans.add(<span class="hljs-keyword">new</span> String(s));<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; ++i)&#123;<br>            <span class="hljs-keyword">if</span>(vis[i])<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span> &amp;&amp; chars[i] == chars[i - <span class="hljs-number">1</span>] &amp;&amp; !vis[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            vis[i] = <span class="hljs-keyword">true</span>;<br>            s.append(chars[i]);<br>            back(chars, s);<br>            s.deleteCharAt(s.length() - <span class="hljs-number">1</span>);<br>            vis[i] = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十-排序"><a class="markdownIt-Anchor" href="#十-排序"></a> 十、排序</h2><h3 id="21-调整数组顺序使奇数位于偶数前面"><a class="markdownIt-Anchor" href="#21-调整数组顺序使奇数位于偶数前面"></a> 21、调整数组顺序使奇数位于偶数前面</h3><p><strong>题目描述</strong>：</p><p>  需要保证奇数和奇数，偶数和偶数之间的相对位置不变，这和书本不太一样。例如对于 [1,2,3,4,5]，调整后得到 [1,3,5,2,4]，而不能是 {5,1,3,4,2} 这种相对位置改变的结果。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111290954135.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>方法一：创建一个新数组，时间复杂度 O(N)，空间复杂度 O(N)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array int整型一维数组 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> int整型一维数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] ans;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] reOrderArray (<span class="hljs-keyword">int</span>[] array) &#123;<br>        <span class="hljs-comment">// write code here</span><br>        ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[array.length];<br>        <span class="hljs-keyword">int</span> oddNum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n: array)&#123;<br>            <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>                oddNum++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = oddNum;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n: array)&#123;<br>            <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>                ans[i++] = n;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ans[j++] = n;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：使用冒泡思想，每次都将当前偶数上浮到当前最右边。时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)，空间复杂度 O(1)，时间换空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array int整型一维数组 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> int整型一维数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] reOrderArray (<span class="hljs-keyword">int</span>[] array) &#123;<br>        <span class="hljs-comment">// i必须从后往前，因为如果前n个如果都是偶数的话，就会造成最后面的奇数不能到前面去</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = array.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j)&#123;<br>                <span class="hljs-keyword">if</span>(isEven(array[j]) &amp;&amp; !isEven(array[j + <span class="hljs-number">1</span>]))&#123;<br>                    swap(array, j, j + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> temp = array[i];<br>        array[i] = array[j];<br>        array[j] = temp;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEven</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="45-把数组排成最小的数"><a class="markdownIt-Anchor" href="#45-把数组排成最小的数"></a> 45、把数组排成最小的数</h3><p><strong>题目描述</strong>：</p><p>  输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321}，则打印出这三个数字能排成的最小数字为 321323。</p><p><strong>思路</strong>：</p><p>  可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，应该比较的是 S1+S2 和 S2+S1 的大小，如果 S1+S2 &lt; S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> StringBuilder s = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">PrintMinNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] numbers)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(numbers.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        String[] chars = <span class="hljs-keyword">new</span> String[numbers.length];<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n: numbers)&#123;<br>            chars[i++] = n + <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        Arrays.sort(chars, (s1, s2) -&gt; (s1 + s2).compareTo(s2 + s1));<br>      <span class="hljs-comment">// compareTo就是按照规则全部排序，排序之后整个序列都是满足的</span><br>        <span class="hljs-keyword">for</span>(String str: chars)&#123;<br>            s.append(str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="51-数组中的逆序对"><a class="markdownIt-Anchor" href="#51-数组中的逆序对"></a> 51、数组中的逆序对</h3><p><strong>题目描述</strong>：</p><p>  在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><p><strong>思路</strong>：</p><p>  利用归并分治法。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">InversePairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] array)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(array == <span class="hljs-keyword">null</span> || array.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[array.length];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length; ++i)&#123;<br>            copy[i] = array[i];<br>        &#125;<br>        <span class="hljs-keyword">int</span> count = InversePairsCore(array, copy, <span class="hljs-number">0</span>, array.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> count;<br>        <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">InversePairsCore</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array,<span class="hljs-keyword">int</span>[] copy,<span class="hljs-keyword">int</span> low,<span class="hljs-keyword">int</span> high)</span></span><br><span class="hljs-function">   </span>&#123;<br>        <span class="hljs-keyword">if</span>(low &gt;= high)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> mid = (low + high) &gt;&gt; <span class="hljs-number">1</span>;<br>      <span class="hljs-comment">// 这里很巧妙copy数组与array数组进行了交换，为了把交换的数组结果导出来</span><br>        <span class="hljs-keyword">int</span> leftcount = InversePairsCore(copy, array, low, mid) % <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-keyword">int</span> rightcount = InversePairsCore(copy, array, mid + <span class="hljs-number">1</span>, high) % <span class="hljs-number">1000000007</span>;<br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> i = mid;<br>        <span class="hljs-keyword">int</span> j = high;<br>        <span class="hljs-keyword">int</span> locCopy = high;<br>        <span class="hljs-keyword">while</span>(i &gt;= low &amp;&amp; j &gt; mid)&#123;<br>            <span class="hljs-keyword">if</span>(array[i] &gt; array[j])&#123;<br>                count += j - mid; <span class="hljs-comment">// 这里是因为array[mid] 到 array [j] 均小于array[i] （mid + 1 - i 不全）</span><br>                copy[locCopy--] = array[i--];<br>                <span class="hljs-keyword">if</span>(count &gt;= <span class="hljs-number">1000000007</span>)<span class="hljs-comment">//数值过大求余 j-mid 可能超过范围</span><br>                &#123;<br>                    count %= <span class="hljs-number">1000000007</span>;<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                copy[locCopy--] = array[j--];<br>            &#125;<br>        &#125;<br>      <span class="hljs-comment">//把剩下的数字小的放回原处</span><br>        <span class="hljs-keyword">while</span>(i &gt;= low)&#123;<br>            copy[locCopy--] = array[i--];<br>        &#125;<br>         <span class="hljs-keyword">while</span>(j &gt; mid)&#123;<br>            copy[locCopy--] = array[j--];<br>        &#125;<br>        <span class="hljs-keyword">return</span> (leftcount + rightcount + count) % <span class="hljs-number">1000000007</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十一-动态规划"><a class="markdownIt-Anchor" href="#十一-动态规划"></a> 十一、动态规划</h2><h3 id="101-斐波那契数列"><a class="markdownIt-Anchor" href="#101-斐波那契数列"></a> 10.1 斐波那契数列</h3><p><strong>题目描述</strong>：</p><p>  求斐波那契数列的第 n 项，n &lt;= 39。</p><p><strong>代码</strong>：</p><p>最偷鸡的办法就是因为知道了n &lt;= 39所以我们直接算了前40项的，然后直接索引得到结果。</p><p>最简单的就是递归</p><p>这里写出两种dp方法</p><p>方法一：空间复杂度O（n） 时间复杂度O（n）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; ++i)&#123;<br>            dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：空间复杂度O（1） 时间复杂度O（n）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pre1 = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> pre2 = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> cur = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; ++i)&#123;<br>            cur = pre1 + pre2;<br>            pre2 = pre1;<br>            pre1 = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="102-矩形覆盖"><a class="markdownIt-Anchor" href="#102-矩形覆盖"></a> 10.2、矩形覆盖</h3><p><strong>题目描述</strong>：</p><p>  我们可以用 2x1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2x1 的小矩形无重叠地覆盖一个 2xn 的大矩形，总共有多少种方法？</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111291149979.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>当 n 为 1 时，只有一种覆盖方法：</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111291150969.png" style="zoom:50%;" /><p>当 n 为 2 时，有两种覆盖方法：</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111291151526.png" style="zoom:50%;" /><p>要覆盖 2xn 的大矩形，可以先覆盖 2x1 的矩形，再覆盖 2x(n-1) 的矩形；或者先覆盖 2x2 的矩形，再覆盖 2x(n-2) 的矩形。而覆盖 2x(n-1) 和 2x(n-2) 的矩形可以看成子问题。该问题的递推公式如下：</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111291152176.png" style="zoom:50%;" /><p>其实跟斐波那契数列差不多</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rectCover</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><span class="hljs-comment">//         return rectCover(target - 1) + rectCover(target - 2);</span><br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> pre2 = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> pre1 = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>; i &lt;= target; ++i)&#123;<br>            ans = pre1 + pre2;<br>            pre2 = pre1;<br>            pre1 = ans;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="103-跳台阶"><a class="markdownIt-Anchor" href="#103-跳台阶"></a> 10.3、跳台阶</h3><p><strong>题目描述</strong>：</p><p>  一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p><strong>思路&amp;代码</strong>：</p><p>  完全同10.2。</p><h3 id="104-变态跳台阶"><a class="markdownIt-Anchor" href="#104-变态跳台阶"></a> 10.4、变态跳台阶</h3><p><strong>题目描述</strong>：</p><p>  一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级… 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111291201670.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>  对于你到第n层的，的话就是f(n - 1) + f(n - 2) + f(n - 3) … f(1)。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jumpFloorII</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[target + <span class="hljs-number">1</span>];<br>        Arrays.fill(dp, <span class="hljs-number">1</span>); <span class="hljs-comment">// 每种情形都有本身直接跳到的那种方案，再通过不从第一级直接跳的方式进行dp</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= target; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i - <span class="hljs-number">1</span>; ++j)&#123;<br>                dp[i] += dp[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="42-连续子数组的最大和"><a class="markdownIt-Anchor" href="#42-连续子数组的最大和"></a> 42、连续子数组的最大和</h3><p><strong>题目描述</strong>：</p><p>  {6, -3, -2, 7, -15, 1, 2, 2}，连续子数组的最大和为 8（从第 0 个开始，到第 3 个为止）。</p><p><strong>思路</strong>：</p><p>  遍历数组，如果和小于等于0，就重新标记开始位置计算。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">FindGreatestSumOfSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(array.length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length; ++i)&#123;<br>            sum = sum &gt; <span class="hljs-number">0</span> ? sum + array[i] : array[i];<br>            max = Math.max(sum, max);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="47-礼物的最大价值"><a class="markdownIt-Anchor" href="#47-礼物的最大价值"></a> 47、礼物的最大价值</h3><p><strong>题目描述</strong>：</p><p>  在一个 mxn 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘。</p><blockquote><p>1    10   3    8<br />12   2    9    6<br />5    7    4    11<br />3    7    16   5</p></blockquote><p>礼物的最大价值为 1+12+5+7+7+16+5=53。</p><p><strong>思路</strong>：</p><p>  应该用动态规划求解，而不是深度优先搜索，深度优先搜索过于复杂，不是最优解。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bonus</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMost</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] board)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(board == <span class="hljs-keyword">null</span> || board.length == <span class="hljs-number">0</span> || board[<span class="hljs-number">0</span>].length == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">int</span> n = board[<span class="hljs-number">0</span>].length;<br>            <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] values: board)&#123;<br>                dp[<span class="hljs-number">0</span>] += values[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; n; ++j)&#123;<br>                    dp[j] = Math.max(dp[j], dp[j - <span class="hljs-number">1</span>]) + values[j];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="48-最长不含重复字符的子字符串"><a class="markdownIt-Anchor" href="#48-最长不含重复字符的子字符串"></a> 48、最长不含重复字符的子字符串</h3><p><strong>题目描述</strong>：</p><p>  输入一个字符串（只包含 a~z 的字符），求其最长不含重复字符的子字符串的长度。例如对于 arabcacfr，最长不含重复字符的子字符串为 acfr，长度为 4。</p><p><strong>思路</strong>：</p><p>  看代码</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">longestSubStringWithoutDuplication</span><span class="hljs-params">()</span> </span>&#123;<br>        String str = <span class="hljs-string">&quot;abdefg&quot;</span>;<br><span class="hljs-comment">//        String str = &quot;arabcacfr&quot;;</span><br>        <span class="hljs-keyword">int</span> curLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span>[] preIndex = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>        Arrays.fill(preIndex, -<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> curI = <span class="hljs-number">0</span>; curI &lt; str.length(); ++curI)&#123;<br>            <span class="hljs-keyword">int</span> c = str.charAt(curI) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">int</span> preI = preIndex[c];<br>            <span class="hljs-keyword">if</span>(preI == -<span class="hljs-number">1</span> || curI - preI &gt; curLen)&#123; <span class="hljs-comment">// curI - preI &gt; curLen 表示没出现重复字符的前后索引大于了curlen所以更新当前最大值</span><br>                curLen++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                maxLen = Math.max(maxLen, curLen); <span class="hljs-comment">// 更新一下当前的最大值（因为每次curLen会更新curI - preI需要用maxLen记录一下值</span><br>                curLen = curI - preI;  <span class="hljs-comment">//相当于不是按照每次清零遍历而是每次只记不出现重复字符的前后索引</span><br>            &#125;<br>            preIndex[c] = curI; <span class="hljs-comment">// 更新一下上一次的位置。</span><br>        &#125;<br>        maxLen = Math.max(maxLen, curLen);<br>        System.out.println(maxLen);<br>        System.out.println(curLen);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="49-丑数"><a class="markdownIt-Anchor" href="#49-丑数"></a> 49、丑数</h3><p><strong>题目描述</strong>：</p><p>  把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。</p><p><strong>思路</strong>：</p><p>  相当于制作一个三行并行的流水线，进行处理，如果其中一个被选中了就让他从下一个地方继续。（1-6都是丑数）</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">GetUglyNumber_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index &lt;= <span class="hljs-number">6</span>)<br>            <span class="hljs-keyword">return</span> index;<br>        <span class="hljs-keyword">int</span> i2 = <span class="hljs-number">1</span>, i3 = <span class="hljs-number">1</span>, i5 = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[index + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= index; ++i)&#123;<br>            <span class="hljs-keyword">int</span> next2 = dp[i2] * <span class="hljs-number">2</span>, next3 = dp[i3] * <span class="hljs-number">3</span>, next5 = dp[i5] * <span class="hljs-number">5</span>;<br>            dp[i] = Math.min(next2, Math.min(next3, next5));<br>            <span class="hljs-keyword">if</span>(dp[i] == next2)<br>                i2++;<br>            <span class="hljs-keyword">if</span>(dp[i] == next3)<br>                i3++;<br>            <span class="hljs-keyword">if</span>(dp[i] == next5)<br>                i5++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[index];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="60-n个骰子的点数"><a class="markdownIt-Anchor" href="#60-n个骰子的点数"></a> 60、n个骰子的点数</h3><p><strong>题目描述</strong>：</p><p>  把 n 个骰子扔在地上，求点数和为 s 的概率。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111301116894.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>使用一个二维数组 dp 存储点数出现的次数，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示前 i 个骰子产生点数 j 的次数。</p><p>空间复杂度：O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n an integer</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a list of Map.Entry&lt;sum, probability&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;Map.Entry&lt;Integer, Double&gt;&gt; dicesSum(<span class="hljs-keyword">int</span> n) &#123;<br>        <span class="hljs-comment">// Write your code here</span><br>        <span class="hljs-comment">// Ps. new AbstractMap.SimpleEntry&lt;Integer, Double&gt;(sum, pro)</span><br>        <span class="hljs-comment">// to create the pair</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> face = <span class="hljs-number">6</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> pointNum = face * n; <span class="hljs-comment">// 记录当前最大值</span><br>        <span class="hljs-keyword">long</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[n + <span class="hljs-number">1</span>][pointNum + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= face; ++j)&#123; <span class="hljs-comment">// 初始化只投一个骰子的个数</span><br>            dp[<span class="hljs-number">1</span>][j] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)&#123;<br>            <span class="hljs-comment">// i个骰子最小值为i, 用j记录当前的总值，用k记录当前骰子所扔的值</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &lt;= pointNum; ++j)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= face &amp;&amp; k &lt; j; ++k)&#123;<br>                    dp[i][j] += dp[i - <span class="hljs-number">1</span>][j - k];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> totalNum = Math.pow(<span class="hljs-number">6</span>, n);<br>        List&lt;Map.Entry&lt;Integer, Double&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n; i &lt;= pointNum ; ++i)&#123; <span class="hljs-comment">// n个骰子最小值是n</span><br>            ans.add(<span class="hljs-keyword">new</span> AbstractMap.SimpleEntry&lt;&gt;(i, dp[n][i] / totalNum));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="66-构建乘积数组"><a class="markdownIt-Anchor" href="#66-构建乘积数组"></a> 66、构建乘积数组</h3><p><strong>题目描述</strong>：</p><p>  给定一个数组 A[0, 1,…, n-1]，请构建一个数组 B[0, 1,…, n-1]，其中 B 中的元素 B[i]=A[0]xA[1]x…xA[i-1]xA[i+1]x…xA[n-1]。要求不能使用除法。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111301141498.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>  从左到右乘一遍，再从右向左乘一遍。就是制造一个索引错位，使得当前位不会乘到当前位置。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] multiply(<span class="hljs-keyword">int</span>[] A) &#123;<br>        <span class="hljs-keyword">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[A.length];<br>        Arrays.fill(ans, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, temp = <span class="hljs-number">1</span>; i &lt; A.length; temp *= A[i++])<br>            ans[i] *= temp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = A.length - <span class="hljs-number">1</span>, temp = <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; temp *= A[i--])<br>            ans[i] *= temp;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十二-数学"><a class="markdownIt-Anchor" href="#十二-数学"></a> 十二、数学</h2><h3 id="39-数组中出现次数超过一半的数字"><a class="markdownIt-Anchor" href="#39-数组中出现次数超过一半的数字"></a> 39、数组中出现次数超过一半的数字</h3><p><strong>题目描述</strong>：</p><p>  给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。</p><p><strong>思路</strong>：</p><p>  多数投票问题，可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。</p><p>  使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素相等时，令 cnt++，否则令 cnt–。如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2 ，因为如果多于 i / 2 的话 cnt 就一定不会为 0 。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">MoreThanHalfNum_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] array)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> majority = array[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> cnt = <span class="hljs-number">1</span>, i = <span class="hljs-number">1</span>; i &lt; array.length; ++i)&#123;<br>            cnt = array[i] == majority ? cnt + <span class="hljs-number">1</span> : cnt - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">0</span>)&#123;<br>                majority = array[i];<br>                cnt = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n: array)&#123;<br>            <span class="hljs-keyword">if</span>(majority == n)&#123;<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt &gt; array.length / <span class="hljs-number">2</span> ? majority : <span class="hljs-number">0</span>; <span class="hljs-comment">// 这道题虽然能ac但是没有考虑到像 1 2 这样的情况应该输出0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="62-圆圈最后剩下的数"><a class="markdownIt-Anchor" href="#62-圆圈最后剩下的数"></a> 62、圆圈最后剩下的数</h3><p><strong>题目描述</strong>：</p><p>  让小朋友们围成一个大圈。然后，随机指定一个数 m，让编号为 0 的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续 0…m-1 报数 … 这样下去 … 直到剩下最后一个小朋友，可以不用表演。</p><p><strong>思路</strong>：</p><p>  约瑟夫环，圆圈长度为 n 的解可以看成长度为 n-1 的解再加上报数的长度 m。因为是圆圈，所以最后需要对 n 取余。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">LastRemaining_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 特殊处理</span><br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 填写出口</span><br>        <span class="hljs-keyword">return</span> (LastRemaining_Solution(n - <span class="hljs-number">1</span>, m) + m) % n;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="43-整数中出现1的次数"><a class="markdownIt-Anchor" href="#43-整数中出现1的次数"></a> 43、整数中出现1的次数</h3><p><strong>题目描述</strong>：</p><p>  输入一个整数 n ，求 1～n 这 n 个整数的十进制表示中 1 出现的次数。例如， 1~13 中包含 1 的数字有 1 、 10 、 11 、 12 、 13 因此共出现 6 次</p><p><em>注意：11 这种情况算两次</em></p><p><strong>思路</strong>：</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112011108259.jpeg" style="zoom:50%;" /><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">NumberOf1Between1AndN_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> base = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n &gt;= base)&#123;<br>            <span class="hljs-keyword">int</span> cur = n / base % <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">int</span> a = n / base / <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">int</span> b = n % base;<br>            <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">0</span>)&#123;<br>                ans += a * base;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">1</span>)&#123;<br>                ans += (b + <span class="hljs-number">1</span>) + a * base;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                ans += (a + <span class="hljs-number">1</span>) * base;<br>            &#125;<br>            base *= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十三-位运算"><a class="markdownIt-Anchor" href="#十三-位运算"></a> 十三、位运算</h2><h3 id="15-二进制中1的个数"><a class="markdownIt-Anchor" href="#15-二进制中1的个数"></a> 15、二进制中1的个数</h3><p><strong>题目描述</strong>：</p><p>  输入一个整数，输出该数二进制表示中 1 的个数。</p><p><strong>思路</strong>：</p><p>  n&amp;(n-1) 位运算可以将 n 的位级表示中最低的那一位 1 设置为 0。不断将 1 设置为 0，直到 n 为 0。时间复杂度：O(M)，其中 M 表示 1 的个数。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112011125910.png" style="zoom:50%;" /><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">NumberOf1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n != <span class="hljs-number">0</span>)&#123;<br>            cnt++;<br>            n &amp;= n - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="56-数组中只出现一次的数字"><a class="markdownIt-Anchor" href="#56-数组中只出现一次的数字"></a> 56、数组中只出现一次的数字</h3><p><strong>题目描述</strong>：</p><p>  一个整型数组里除了两个数字之外，其他的数字都出现了两次，找出这两个数。</p><p><strong>思路</strong>：</p><p>  两个相等的元素异或的结果为 0，而 0 与任意数 x 异或的结果都为 x。</p><p>  对本题给的数组的所有元素执行异或操作，得到的是两个不存在重复的元素异或的结果。例如对于数组 [x,x,y,y,z,k]，x<sup>x</sup>y<sup>y</sup>z^k = 0<sup>y</sup>y<sup>z</sup>k = y<sup>y</sup>z^k = 0<sup>z</sup>k = z^k。</p><p>  两个不相等的元素在位级表示上一定会有所不同，因此这两个元素异或得到的结果 diff 一定不为 0。位运算 diff &amp; -diff 能得到 diff 位级表示中最右侧为 1 的位，令 diff = diff &amp; -diff。将 diff 作为区分两个元素的依据，一定有一个元素对 diff 进行异或的结果为 0，另一个结果非 0。设不相等的两个元素分别为 z 和 k，遍历数组所有元素，判断元素与 diff 的异或结果是否为 0，如果是的话将元素与 z 进行异或并赋值给 z，否则与 k 进行异或并赋值给 k。数组中相等的元素一定会同时与 z 或者与 k 进行异或操作，而不是一个与 z 进行异或，一个与 k 进行异或。而且这些相等的元素异或的结果为 0，因此最后 z 和 k 只是不相等的两个元素与 0 异或的结果，也就是不相等两个元素本身。</p><p>  下面的解法中，num1 和 num2 数组的第一个元素是用来保持返回值的… 实际开发中不推荐这种返回值的方式。</p><p>负数的二进制表示：<a href="https://blog.csdn.net/liuweibirthday/article/details/5666724">https://blog.csdn.net/liuweibirthday/article/details/5666724</a></p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array int整型一维数组 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> int整型一维数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] FindNumsAppearOnce (<span class="hljs-keyword">int</span>[] array) &#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">int</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a: array)&#123;<br>            temp ^= a;<br>        &#125;<br>        temp &amp;= -temp;  <span class="hljs-comment">// lowbit 用哪一位不同的flag 在进行一波异或这样可以相当于分两个队列进行统计</span><br>        <span class="hljs-keyword">int</span> z = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a: array)&#123;<br>            <span class="hljs-keyword">if</span>((a &amp; temp) == <span class="hljs-number">0</span>)&#123;<br>                z ^= a;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                k ^= a;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> z &lt; k ? <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;z, k&#125; : <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;k, z&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十四-其他"><a class="markdownIt-Anchor" href="#十四-其他"></a> 十四、其他</h2><h3 id="17-打印从-1-到最大的-n-位数"><a class="markdownIt-Anchor" href="#17-打印从-1-到最大的-n-位数"></a> 17、打印从 1 到最大的 n 位数</h3><p><strong>题目描述</strong>：</p><p>  输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。</p><p><strong>思路</strong>：</p><p>  由于 n 可能会非常大，因此不能直接用 int 表示数字，而是用 char 数组进行存储。使用回溯法得到所有的数。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.panpan.algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        print1ToMaxOfNDigits(<span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print1ToMaxOfNDigits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">char</span>[] number = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[n];<br>        print1ToMaxOfNDigits(number, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print1ToMaxOfNDigits</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] number, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(n == number.length)&#123;<br>            printChar(number);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)&#123;<br>            number[n] = (<span class="hljs-keyword">char</span>)(i + <span class="hljs-string">&#x27;0&#x27;</span>);<br>            print1ToMaxOfNDigits(number, n + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printChar</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] number)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(index &lt; number.length &amp;&amp; number[index] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>            index++;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(index &lt; number.length)&#123;<br>            System.out.print(number[index++]);<br>        &#125;<br>        System.out.println();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="19-正则表达式匹配"><a class="markdownIt-Anchor" href="#19-正则表达式匹配"></a> 19、正则表达式匹配</h3><p><strong>题目描述</strong>：</p><p>  请实现一个函数用来匹配包括 ‘.’ 和 ‘*’ 的正则表达式。模式中的字符 ‘.’ 表示任意一个字符，而&quot;*&quot;表示它前面的字符可以出现任意次（包含 0 次）。</p><p>  在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 “aaa” 与模式 “a.a” 和 “ab<em>ac</em>a” 匹配，但是与 “aa.a” 和 “ab*a” 均不匹配。</p><p><strong>思路</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112020854615.png" style="zoom:50%;"/><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112020855947.png" style="zoom:50%;" /></p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202112020856145.png" alt="" style="zoom:50%;" /><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> str string字符串 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pattern string字符串 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">match</span> <span class="hljs-params">(String str, String pattern)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">int</span> m = str.length(), n = pattern.length();<br>        <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>]; <span class="hljs-comment">// m长的字符串是否能与n长的匹配串匹配</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; ++i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; ++j)&#123;<br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) <span class="hljs-comment">// 初始化状态，空匹配串只有在字符串为空的时候才算匹配</span><br>                    dp[i][j] = (i == <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(pattern.charAt(j - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<span class="hljs-comment">//判断是不是*</span><br>                        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; (str.charAt(i - <span class="hljs-number">1</span>) == pattern.charAt(j - <span class="hljs-number">1</span>) || pattern.charAt(j - <span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;.&#x27;</span>))&#123;<span class="hljs-comment">// 当前字符串与待匹配的串进行同位置比较，或者是匹配串为.</span><br>                            dp[i][j] |= dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                        &#125;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">// 看不看c*</span><br>                        <span class="hljs-keyword">if</span>(j &gt; <span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">//不看c*都不看所以直接是j少了两个字符</span><br>                            dp[i][j] |= dp[i][j - <span class="hljs-number">2</span>];<br>                          <span class="hljs-comment">// j - 2 因为 c*的话需要-2才能找到那个字符</span><br>                            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; (str.charAt(i - <span class="hljs-number">1</span>) == pattern.charAt(j - <span class="hljs-number">2</span>) || pattern.charAt(j - <span class="hljs-number">2</span>) == <span class="hljs-string">&#x27;.&#x27;</span>))&#123;<br>                                dp[i][j] |= dp[i - <span class="hljs-number">1</span>][j]; <span class="hljs-comment">// i-1因为j不动就说名用当前j来匹配多个i</span><br>                            &#125; <br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[m][n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="20-表示数值的字符串"><a class="markdownIt-Anchor" href="#20-表示数值的字符串"></a> 20、表示数值的字符串</h3><p><strong>题目描述</strong>：</p><blockquote><p>true</p><p>“+100”<br />“5e2”<br />“-123”<br />“3.1416”<br />“-1E-16”</p></blockquote><blockquote><p>false</p><p>“12e”<br />“1a3.14”<br />“1.2.3”<br />“±5”<br />“12e+4.3”</p></blockquote><p><strong>思路</strong>：</p><p>  使用正则表达式进行匹配。</p><blockquote><p>[ ]  ： 字符集合<br />( )  ： 分组<br />? ： 重复 0 ~ 1 次</p><p>+ ： 重复 1 ~ n 次</p><p>* ： 重复 0 ~ n 次<br />. ： 任意字符<br />\\.： 转义后的 .<br />\\d ： 数字</p><p>^ :从字符串开头进行匹配</p><p>$ :从字符串末尾进行匹配</p></blockquote><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> str string字符串 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> bool布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isNumeric</span> <span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">return</span> str.matches(<span class="hljs-string">&quot;^[ ]*[+-]?(\\d*\\.\\d+|\\d+(\\.\\d*)?)([eE][+-]?\\d+)?[ ]*$&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="44-数字序列中的某一位数字"><a class="markdownIt-Anchor" href="#44-数字序列中的某一位数字"></a> 44、数字序列中的某一位数字</h3><p><strong>题目描述</strong>：</p><p>  数字以 0123456789101112131415… 的格式序列化到一个字符串中，求这个字符串的第 index 位。</p><p><strong>思路</strong>：</p><p>  划分区域0～9，10～99其中数量分别为 10， 90， 900 ……然后根据开始索引和个数进行单独找寻。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.panpan.algorithm;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(getDigitAtIndex(<span class="hljs-number">12</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDigitAtIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> place = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 当前为第一位</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">int</span> amount = getAmountOfPlace(place);<br>            <span class="hljs-keyword">int</span> totalAmount = amount * place;<br>            <span class="hljs-keyword">if</span>(index &lt; totalAmount)<br>                <span class="hljs-keyword">return</span> getDigitAtIndex(index, place);<br>            index -= totalAmount;<br>            place++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * place 位数的数字组成的字符串长度</span><br><span class="hljs-comment">     * 10, 90, 900, ...</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAmountOfPlace</span><span class="hljs-params">(<span class="hljs-keyword">int</span> place)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(place == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">10</span>, place - <span class="hljs-number">1</span>) * <span class="hljs-number">9</span>;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * place 位数的起始数字</span><br><span class="hljs-comment">     * 0, 10, 100, ...</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBeginNumberOfPlace</span><span class="hljs-params">(<span class="hljs-keyword">int</span> place)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(place == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) Math.pow(<span class="hljs-number">10</span>, place - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在 place 位数组成的字符串中，第 index 个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDigitAtIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> place)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> beginNumber = getBeginNumberOfPlace(place);<br>        <span class="hljs-keyword">int</span> shiftNumber = index / place;  <span class="hljs-comment">// 确定当前区间的第几个数</span><br>        String number = (beginNumber + shiftNumber) + <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-comment">// 组合好当前那个数</span><br>        <span class="hljs-keyword">int</span> indexTrue = index % place;  <span class="hljs-comment">// 选择当前那个数的第几位</span><br>        <span class="hljs-keyword">return</span> number.charAt(indexTrue) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="46-把数字翻译成字符串"><a class="markdownIt-Anchor" href="#46-把数字翻译成字符串"></a> 46、把数字翻译成字符串</h3><p><strong>题目描述</strong>：</p><p>  给定一个数字，按照如下规则翻译成字符串：1 翻译成“a”，2 翻译成“b”… 26 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 abbeh，lbeh，aveh，abyh，lyh。实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p><strong>思路&amp;代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> n = s.length();<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = s.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)&#123;<br>            <span class="hljs-keyword">int</span> one = Integer.valueOf(s.substring(i - <span class="hljs-number">1</span>, i));  <span class="hljs-comment">// 查看当前情况下，1～9能组成的字母</span><br>            <span class="hljs-keyword">if</span>(one != <span class="hljs-number">0</span>)&#123;<br>                dp[i] += dp[i - <span class="hljs-number">1</span>];  <span class="hljs-comment">// 除去当前这一个1～9字母，加上不算这一切能够组成的个数</span><br>            &#125;<br>            <span class="hljs-keyword">int</span> two = Integer.valueOf(s.substring(i - <span class="hljs-number">2</span>, i));  <span class="hljs-comment">// 查看当前情况下，10~26能组成的字母</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">10</span> &lt;= two &amp;&amp; two &lt;= <span class="hljs-number">26</span>)&#123;<br>                dp[i] += dp[i - <span class="hljs-number">2</span>];  <span class="hljs-comment">// 除去当前这一个10~26字母，加上不算这一切能够组成的个数 如果包含了1～9次数判断重复了</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="61-扑克牌顺子"><a class="markdownIt-Anchor" href="#61-扑克牌顺子"></a> 61、扑克牌顺子</h3><p><strong>题目描述</strong>：</p><p>  五张牌，其中大小鬼为癞子，牌面为 0。判断这五张牌是否能组成顺子。</p><img src="../../../Library/Application Support/typora-user-images/截屏2021-12-04 上午9.27.28.png" style="zoom:50%;" /><p><strong>思路</strong>：</p><p>&lt;1&gt; 先对于整个序列排序</p><p>&lt;2&gt; 统计赖子的个数</p><p>&lt;3&gt; 从第一张非赖子的牌开始遍历，如果有两张相似的直接退出，其他的情况就是把赖子总数减去相邻两个的差相减的距离最后赖子数还是大于0就是okk</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">IsContinuous</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] numbers)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(numbers.length &lt; <span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        Arrays.sort(numbers);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num: numbers)&#123;<br>            <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)<br>                cnt++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = cnt; i &lt; numbers.length - <span class="hljs-number">1</span>; ++i)&#123;<br>            <span class="hljs-keyword">if</span>(numbers[i] == numbers[i + <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            cnt -= numbers[i + <span class="hljs-number">1</span>] - numbers[i] - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(cnt &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="64-求123n"><a class="markdownIt-Anchor" href="#64-求123n"></a> 64、求1+2+3+…+n</h3><p><strong>题目描述</strong>：</p><p>  要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句 A ? B : C。</p><p><strong>思路</strong>：</p><p>  使用递归解法最重要的是指定返回条件，但是本题无法直接使用 if 语句来指定返回条件。</p><p>  条件与 &amp;&amp; 具有短路原则，即在第一个条件语句为 false 的情况下不会去执行第二个条件语句。利用这一特性，将递归的返回条件取非然后作为 &amp;&amp; 的第一个条件语句，递归的主体转换为第二个条件语句，那么当递归的返回条件为 true 的情况下就不会执行递归的主体部分，递归返回。</p><p>  本题的递归返回条件为 n &lt;= 0，取非后就是 n &gt; 0；递归的主体部分为 sum += Sum_Solution(n - 1)，转换为条件语句后就是 (sum += Sum_Solution(n - 1)) &gt; 0。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Sum_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = n;<br>        <span class="hljs-keyword">boolean</span> b = (n &gt; <span class="hljs-number">0</span>) &amp;&amp; ((sum += Sum_Solution(n - <span class="hljs-number">1</span>)) &gt; <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="65-不用加减乘除做加法"><a class="markdownIt-Anchor" href="#65-不用加减乘除做加法"></a> 65、不用加减乘除做加法</h3><p><strong>题目描述</strong>：</p><p>  写一个函数，求两个整数之和，要求不得使用 +、-、*、/ 四则运算符号。</p><p><strong>思路</strong>：</p><p>  a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。</p><p>  递归会终止的原因是 (a &amp; b) &lt;&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1,<span class="hljs-keyword">int</span> num2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> num2 == <span class="hljs-number">0</span> ? num1 : Add(num1 ^ num2, (num1 &amp; num2) &lt;&lt; <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 左移一位代表进位</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="67-把字符串转换成整数"><a class="markdownIt-Anchor" href="#67-把字符串转换成整数"></a> 67、把字符串转换成整数</h3><p><strong>题目描述</strong>：</p><p>  将一个字符串转换成一个整数，字符串不是一个合法的数值则返回 0，要求不能使用字符串转换整数的库函数。</p><blockquote><p>Iuput:<br />+2147483647<br />1a33</p><p>Output:<br />2147483647<br />0</p></blockquote><p><strong>思路</strong>：</p><p>  从尾到头开始统计。</p><p><strong>代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">StrToInt</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(str == <span class="hljs-keyword">null</span> || str.length() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> pow = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = str.length() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; --i)&#123;<br>            <span class="hljs-keyword">int</span> cur = str.charAt(i) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt; cur &amp;&amp; cur &lt; <span class="hljs-number">9</span>)&#123;<br>                sum += cur * pow;<br>                pow *= <span class="hljs-number">10</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">char</span> first = str.charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(first == <span class="hljs-string">&#x27;+&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(first == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> -sum;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;0&#x27;</span> &lt;= first &amp;&amp; first &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>            <span class="hljs-keyword">return</span> sum + pow * (first - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法练习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>贪心算法</tag>
      
      <tag>分治算法</tag>
      
      <tag>搜索算法</tag>
      
      <tag>排序算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>视觉里程计</title>
    <link href="/2021/11/19/%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1/"/>
    <url>/2021/11/19/%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="第7讲-视觉里程计"><a class="markdownIt-Anchor" href="#第7讲-视觉里程计"></a> 第7讲 视觉里程计</h1><h2 id="一-2d-2d对极几何"><a class="markdownIt-Anchor" href="#一-2d-2d对极几何"></a> 一、2D-2D：对极几何</h2><h3 id="1-对极约束"><a class="markdownIt-Anchor" href="#1-对极约束"></a> 1、对极约束</h3><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111192037264.png" style="zoom:50%;" /><p>如图7-9，如果我们要求两帧图像<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">I_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">I_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之间的运动，设第一帧到第二帧的运动为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>。</p><p>  两个相机中心分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">O_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">O_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。现在，考虑<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">I_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中有一个特征点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">I_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中对应着特征点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">p_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。如果匹配正确，就可以说明他们是<strong>同一个空间点在两个成像平面上的投影</strong>。</p><p><em>几何关系</em>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><msub><mi>O</mi><mn>1</mn></msub><msub><mi>p</mi><mn>1</mn></msub></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{O_1p_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1607699999999999em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><msub><mi>O</mi><mn>2</mn></msub><msub><mi>p</mi><mn>2</mn></msub></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{O_2p_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1607699999999999em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span>在三维空间中会相交于点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>。由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">O_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">O_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>三个点可以确定一个平面叫<strong>极平面（Epipolar plane）</strong>。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mn>1</mn></msub><msub><mi>O</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">O_1O_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>连线与像平面<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">I_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">I_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的交点分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">e_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">e_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">e_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>称为<strong>极点（Epipoles）</strong>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mn>1</mn></msub><msub><mi>O</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">O_1O_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>被称为<strong>基线</strong>。我们称极平面与两个像平面<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">I_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">I_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之间的相交线<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">l_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>l</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">l_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为<strong>极线（Epipolar line）</strong>。</p><p><em>几何分析</em>：从第一帧的角度看，射线<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><msub><mi>O</mi><mn>1</mn></msub><msub><mi>p</mi><mn>1</mn></msub></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{O_1p_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1607699999999999em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span>是<strong>某个像素可能出现的空间位置</strong>（这个与之前单目针孔相机模型一样，没有深度信息所有射线上的点都会映射在此）则如果我们不知道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>的位置，那么我们在第二幅图像上看到的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><msub><mi>e</mi><mn>2</mn></msub><msub><mi>p</mi><mn>2</mn></msub></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{e_2p_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9084399999999999em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span>也是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>可能出现的投影位置（因为他们在一个平面上，这条线投影出去一定包括点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>，也就是<strong>射线<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><msub><mi>O</mi><mn>1</mn></msub><msub><mi>p</mi><mn>1</mn></msub></mrow><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{O_1p_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1607699999999999em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9663299999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.25233em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span>在第二个相机中的投影</strong>）然后我们通过特征点匹配确定了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">p_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的像素位置，所以能够推断<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>的空间位置，以及相机的运动。</p><p><em>代数分析</em>：</p><p>  在第一帧的坐标系下，设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>的空间位置为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>=</mo><mo stretchy="false">[</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo separator="true">,</mo><mi>Z</mi><msup><mo stretchy="false">]</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">P = [X, Y, Z]^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></p><p><em>个人理解：这里的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>我认为是按照第一帧的相机坐标系坐标</em></p><p>  根据针孔模型我们知道像个像素点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">p_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的像素位置为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub><msub><mi>p</mi><mn>1</mn></msub><mo>=</mo><mi>K</mi><mi>P</mi><mo separator="true">,</mo><mspace width="1em"/><msub><mi>s</mi><mn>2</mn></msub><msub><mi>p</mi><mn>2</mn></msub><mo>=</mo><mi>K</mi><mo stretchy="false">(</mo><mi>R</mi><mi>P</mi><mo>+</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s_1p_1 = KP,\quad s_2p_2 = K(RP+t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>为相机内参矩阵，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>为两个坐标系的相机运动。</p><p>  这里使用了其次坐标表示像素点，在使用齐次坐标时，一个向量将等于它自身乘上任意的非零常数——用以上的方法表达一个投影关系。就像上式中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">s_1p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>成投影关系，他们在齐次坐标的意义下的相等称作为<strong>尺度意义下相等</strong>(equal up to a scale)记作：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>p</mi><mo>≃</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">sp \simeq p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65819em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span></span></p><p>那么上述的投影关系可以写作</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>≃</mo><mi>K</mi><mi>P</mi><mo separator="true">,</mo><mspace width="1em"/><msub><mi>p</mi><mn>2</mn></msub><mo>≃</mo><mi>K</mi><mo stretchy="false">(</mo><mi>R</mi><mi>P</mi><mo>+</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p_1 \simeq KP, \quad p_2 \simeq K(RP+t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65819em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span></span></p><p>现在，取：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><msup><mi>K</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>p</mi><mn>1</mn></msub><mo separator="true">,</mo><mspace width="1em"/><msub><mi>x</mi><mn>2</mn></msub><mo>=</mo><msup><mi>K</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>p</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_1 = K^{-1}p_1,\quad x_2 = K^{-1}p_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.058548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.058548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>这里的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是两个像素点的归一化平面上的坐标。</p><p>代入上式得：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>≃</mo><mi>R</mi><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">x_2\simeq Rx_1 + t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61375em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span></span></p><p>两式子同时左乘<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>t</mi><mo>∧</mo></msup></mrow><annotation encoding="application/x-tex">t^\wedge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∧</span></span></span></span></span></span></span></span></span></span></span>（ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∧</mo></mrow><annotation encoding="application/x-tex">\wedge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∧</span></span></span></span> 相当于外积）。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>t</mi><mo>∧</mo></msup><msub><mi>x</mi><mn>2</mn></msub><mo>≃</mo><msup><mi>t</mi><mo>∧</mo></msup><mi>R</mi><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t^\wedge x_2 \simeq t^\wedge R x_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9518920000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∧</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9518920000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∧</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>然后，两侧同时左乘<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>x</mi><mn>2</mn><mi>T</mi></msubsup></mrow><annotation encoding="application/x-tex">x_2^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0894389999999998em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span></span>：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>x</mi><mn>2</mn><mi>T</mi></msubsup><msup><mi>t</mi><mo>∧</mo></msup><msub><mi>x</mi><mn>2</mn></msub><mo>≃</mo><msubsup><mi>x</mi><mn>2</mn><mi>T</mi></msubsup><msup><mi>t</mi><mo>∧</mo></msup><mi>R</mi><msub><mi>x</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">x_2^Tt^\wedge x_2 \simeq x_2^T t^\wedge Rx_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138331em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∧</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.138331em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∧</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>观察等式左侧，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>t</mi><mo>∧</mo></msup><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t^\wedge{x_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.901892em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∧</span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>是一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>都垂直的向量。</p><p>它再和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">x_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>做内积时，将得到0。</p><p>  由于等式左侧严格为零，乘以任何非零常数之后也等于零，所以我们可以吧<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≃</mo></mrow><annotation encoding="application/x-tex">\simeq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≃</span></span></span></span>写成通常的符号。</p><p>由此得到：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>x</mi><mn>2</mn><mi>T</mi></msubsup><msup><mi>t</mi><mo>∧</mo></msup><mi>R</mi><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x_2^Tt^\wedge Rx_1 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138331em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∧</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><p>重新代入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">p_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，有</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>p</mi><mn>2</mn><mi>T</mi></msubsup><msup><mi>K</mi><mrow><mo>−</mo><mi>T</mi></mrow></msup><msup><mi>t</mi><mo>∧</mo></msup><mi>R</mi><msup><mi>K</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>p</mi><mn>1</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">p_2^TK^{-T}t^\wedge R K^{-1}p_1 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.138331em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.891331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∧</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><p><em>这里的-T代表的是又转置又求逆</em></p><p>以上两个式子都称为<strong>对极约束</strong>。</p><p><em>几何意义：</em><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">O_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">O_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>三者共面，对极约束中同时包括了平移和旋转。其中有两个矩阵：1）基础矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 2）本质矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> 于是进一步简化对极约束</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><msup><mi>t</mi><mo>∧</mo></msup><mi>R</mi><mo separator="true">,</mo><mspace width="1em"/><mi>F</mi><mo>=</mo><msup><mi>K</mi><mrow><mo>−</mo><mi>T</mi></mrow></msup><mi>E</mi><msup><mi>K</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><mspace width="1em"/><msubsup><mi>x</mi><mn>2</mn><mi>T</mi></msubsup><mi>E</mi><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><msubsup><mi>p</mi><mn>2</mn><mi>T</mi></msubsup><mi>F</mi><msub><mi>p</mi><mn>1</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">E = t^\wedge R, \quad F=K^{-T}EK^{-1}, \quad x_2^TEx_1 = p_2^TFp_1 = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∧</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.138331em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.891331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.138331em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><p>对极约束简洁地给出了两个匹配点的空间位置关系。相机位姿估计问题变为以下两步：</p><p>1.根据匹配点的像素位置求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span></p><p>2.根据<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>或者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>。</p><p>实践中：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>只相差了相机内参，而内参在SLAM中通常已知，所以我们往往按照<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>求解。</p><h3 id="2-本质矩阵"><a class="markdownIt-Anchor" href="#2-本质矩阵"></a> 2、本质矩阵</h3><p>本质矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><msup><mi>t</mi><mo>∧</mo></msup><mi>R</mi></mrow><annotation encoding="application/x-tex">E = t^\wedge R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∧</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>，是一个3x3的矩阵，内有9个未知数，满足以下条件：</p><p>（1）本质矩阵是由对极约束定义的。由于对极约束是<strong>等式为零</strong>的约束，所以对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>乘以任意非零常数后，<strong>对极约束依然满足</strong>。我们把这件事情称为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>在不同尺度下是等价的。</p><p>（2）根据<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><msup><mi>t</mi><mo>∧</mo></msup><mi>R</mi></mrow><annotation encoding="application/x-tex">E = t^{\wedge}R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∧</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>，可以证明，本质矩阵的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>的奇异值必定是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>σ</mi><mo separator="true">,</mo><mi>σ</mi><mo separator="true">,</mo><mn>0</mn><msup><mo stretchy="false">]</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">[\sigma,\sigma,0]^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>的形式。这称为<strong>本质矩阵的内在性质</strong>。</p><p>（3）另外，由于平移和旋转各有3个自由度，故<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>t</mi><mo>∧</mo></msup><mi>R</mi></mrow><annotation encoding="application/x-tex">t^{\wedge}R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∧</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>共有6个自由度，但由于尺度等价性，故<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>实际上有5个自由度。（暂时理解为齐次矩阵矩阵那个添加的1那个尺度是一维度变量，但相当于没有影响的自由度）</p><h3 id="3-八点法"><a class="markdownIt-Anchor" href="#3-八点法"></a> 3、八点法</h3><p>  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>具有5个自由度的事实，表明我们最少可以用5对点来求解<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>。由于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>的内在性质是一种非线性性质，在估计时有麻烦，所以可以只考虑<strong>尺度等价性</strong>使用8个点对来估计——<strong>八点法</strong>。八点法只利用了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>的线性性质，因此可以在线性代数框架下求解。下面我们来看八点法是如何工作的。</p><p>（1）举例一对匹配点，归一化坐标为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">[</mo><msub><mi>u</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">]</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">x_1 = [u_1,v_1, 1]^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>=</mo><mo stretchy="false">[</mo><msub><mi>u</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">]</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">x_2=[u_2,v_2,1]^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>。根据对极约束，有</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>u</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>e</mi><mn>1</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>e</mi><mn>2</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>e</mi><mn>3</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>e</mi><mn>4</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>e</mi><mn>5</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>e</mi><mn>6</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>e</mi><mn>7</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>e</mi><mn>8</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>e</mi><mn>9</mn></msub></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>u</mi><mn>1</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>v</mi><mn>1</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(u_2,v_2, 1)\begin{pmatrix}e_1 &amp; e_2 &amp; e_3 \\ e_4 &amp; e_5 &amp; e_6 \\ e_7 &amp; e_8 &amp; e_9 \end{pmatrix} \begin{pmatrix}u_1 \\ v_1 \\ 1\end{pmatrix} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><p>（2）将矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>展开成向量形式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mo>=</mo><msup><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>e</mi><mn>1</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>e</mi><mn>2</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>e</mi><mn>3</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>e</mi><mn>4</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>e</mi><mn>5</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>e</mi><mn>6</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>e</mi><mn>7</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>e</mi><mn>8</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>e</mi><mn>9</mn></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">e = \begin{bmatrix}e_1 &amp; e_2 &amp; e_3 &amp; e_4 &amp; e_5 &amp; e_6 &amp; e_7 &amp; e_8 &amp; e_9\end{bmatrix}^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.431241em;vertical-align:-0.35001em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.081231em;"><span style="top:-3.3029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></p><p>则对极约束可以写成</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111221438939.png" style="zoom:50%;" /><p>再将所有的点代入<img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111221439394.png" style="zoom:50%;" /></p><p>  如上8个方程构成了一个线性方程组。系数矩阵由特征点位置构成，大小为8x9，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span>位于该矩阵的零空间中。如果系数矩阵是秩为8（满秩），则零空间的维数为1（即唯一解），也就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span>构成一条线，这与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span>的尺度的尺度等价性是一致的。满秩（8个不同的“有效”约束）即能求出结果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>。</p><p>（3）得到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>之后，我们接下来该恢复出相机的运动<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>。这个过程是由奇异值分解（SVD）得到的。设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>的SVD为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mi>U</mi><mi mathvariant="normal">Σ</mi><msup><mi>V</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">E = U\Sigma V^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8913309999999999em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord">Σ</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>为正交矩阵，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>为奇异值矩阵。</p><p>（4）根据<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>的内在性质，我们知道<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mi>d</mi><mi>i</mi><mi>a</mi><mi>g</mi><mo stretchy="false">(</mo><mi>σ</mi><mo separator="true">,</mo><mi>σ</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Sigma=diag(\sigma, \sigma, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>。在SVD分解中，对于任意一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>，存在两个可能的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>与它对应：</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111221507666.png" style="zoom:50%;" /><p>其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>z</mi></msub><mo stretchy="false">(</mo><mfrac><mi>π</mi><mn>2</mn></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R_z(\frac{\pi}{2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span>表示沿<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span>轴旋转<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn><msup><mn>0</mn><mi>o</mi></msup></mrow><annotation encoding="application/x-tex">90^o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span></span></span></span></span></span></span></span>得到旋转矩阵。其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">-E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>是等价的，所以任意一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>取符号，也会得到相同的结果。模型分为以下四类：</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111221511103.png" alt="" /></p><p>  <em>工业上来讲，平时会有几十对甚至上百对匹配点，从8对点匹配到5对意义并不有太大区别。而且用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>求解相机运动的方法有些麻烦，所以一般都是用八点法</em>。</p><p>（5）但是如果线性求解出的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>，可能不满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>的内在性质——奇异值不一定为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>的形式，需要调整<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>成为上述样子。</p><p><em>做法</em>：对八点法求得的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>进行SVD，会得到奇异值矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mi>d</mi><mi>i</mi><mi>a</mi><mi>g</mi><mo stretchy="false">(</mo><msub><mi>σ</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>σ</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>σ</mi><mn>3</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Sigma = diag(\sigma_1, \sigma_2, \sigma_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，不妨设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mn>1</mn></msub><mo>≥</mo><msub><mi>σ</mi><mn>2</mn></msub><mo>≥</mo><mi>σ</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">\sigma_1\ge\sigma_2\ge\sigma3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mord">3</span></span></span></span>，取：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mi>U</mi><mi>d</mi><mi>i</mi><mi>a</mi><mi>g</mi><mo stretchy="false">(</mo><mfrac><mrow><msub><mi>σ</mi><mn>1</mn></msub><mo>+</mo><msub><mi>σ</mi><mn>2</mn></msub></mrow><mn>2</mn></mfrac><mo separator="true">,</mo><mfrac><mrow><msub><mi>σ</mi><mn>1</mn></msub><mo>+</mo><msub><mi>σ</mi><mn>2</mn></msub></mrow><mn>2</mn></mfrac><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo><msup><mi>V</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">E = Udiag(\frac{\sigma_1 + \sigma_2}{2}, \frac{\sigma_1 + \sigma_2}{2}, 0)V^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.9463300000000001em;vertical-align:-0.686em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603300000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2603300000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></p><p><em>物理意义</em>：相当于把所求矩阵投影到了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>所在的流行上。</p><p>  更简单的方法直接<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span>取1，直接变成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>a</mi><mi>g</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">diag(1,1,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，由于尺度等价性，这样是十分合理的。</p><h3 id="4-单应矩阵"><a class="markdownIt-Anchor" href="#4-单应矩阵"></a> 4、单应矩阵</h3><p>  如果场景中的特征点都落在同一个平面上（如墙、地面等），则可以通过单应性进行运动估计。</p><p>  单应矩阵通常描述处于共同平面上的一些点在两张图像之间的变换关系。设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">I_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">I_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>有一堆匹配好的特征点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">p_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。这个特征点落在平面<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>上，设这个平面满足方程：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mi>T</mi></msup><mi>P</mi><mo>+</mo><mi>d</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n^TP + d = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9746609999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><p>整理一波</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mfrac><mrow><msup><mi>n</mi><mi>T</mi></msup><mi>P</mi></mrow><mi>d</mi></mfrac><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-\frac{n^TP}{d} = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.204331em;vertical-align:-0.686em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183309999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p>然后联立这个式子</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub><msub><mi>p</mi><mn>1</mn></msub><mo>=</mo><mi>K</mi><mi>P</mi><mo separator="true">,</mo><mspace width="1em"/><msub><mi>s</mi><mn>2</mn></msub><msub><mi>p</mi><mn>2</mn></msub><mo>=</mo><mi>K</mi><mo stretchy="false">(</mo><mi>R</mi><mi>P</mi><mo>+</mo><mi>t</mi><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><msub><mi>p</mi><mn>2</mn></msub><mo>≃</mo><mi>K</mi><mo stretchy="false">(</mo><mi>R</mi><mi>P</mi><mo>+</mo><mi>t</mi><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mo>≃</mo><mi>K</mi><mo stretchy="false">(</mo><mi>R</mi><mi>P</mi><mo>+</mo><mi>t</mi><mo>⋅</mo><mo stretchy="false">(</mo><mo>−</mo><mfrac><mrow><msup><mi>n</mi><mi>T</mi></msup><mi>P</mi></mrow><mi>d</mi></mfrac><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mo>≃</mo><mi>K</mi><mo stretchy="false">(</mo><mi>R</mi><mo>−</mo><mfrac><mrow><mi>t</mi><msup><mi>n</mi><mi>T</mi></msup></mrow><mi>d</mi></mfrac><mo stretchy="false">)</mo><mi>P</mi><mspace linebreak="newline"></mspace><mo>≃</mo><mi>K</mi><mo stretchy="false">(</mo><mi>R</mi><mo>−</mo><mfrac><mrow><mi>t</mi><msup><mi>n</mi><mi>T</mi></msup></mrow><mi>d</mi></mfrac><mo stretchy="false">)</mo><msup><mi>K</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">s_1p_1 = KP,\quad s_2p_2 = K(RP+t)\\p_2 \simeq K(RP+t)\\\simeq K(RP+t\cdot(-\frac{n^TP}{d}))\\\simeq K(R-\frac{tn^T}{d})P \\\simeq K(R-\frac{tn^T}{d})K^{-1}p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.65819em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.204331em;vertical-align:-0.686em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183309999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.204331em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183309999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.204331em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183309999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>  于是我们得到了一个直接描述图像坐标<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">p_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之间的变换，把中间这部分记为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span>，于是：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>2</mn></msub><mo>≃</mo><mi>H</mi><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_2 \simeq Hp_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65819em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>它的定义与旋转、平移及平面参数有关。与基础矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>类似，单应矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span>也是一个3x3的矩阵。</p><p>展开上式得到</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>u</mi><mn>2</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>v</mi><mn>2</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mo>≃</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>h</mi><mn>1</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>h</mi><mn>2</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>h</mi><mn>3</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>h</mi><mn>4</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>h</mi><mn>5</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>h</mi><mn>6</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>h</mi><mn>7</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>h</mi><mn>8</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>h</mi><mn>9</mn></msub></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow><mrow><mo fence="true">(</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>u</mi><mn>1</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>v</mi><mn>1</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{pmatrix}u_2 \\ v_2 \\ 1\end{pmatrix} \simeq \begin{pmatrix}h_1 &amp; h_2 &amp; h_3 \\ h_4 &amp; h_5 &amp; h_6 \\ h_7 &amp; h_8 &amp; h_9\end{pmatrix} \begin{pmatrix}u_1 \\ v_1 \\ 1\end{pmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≃</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>因为等号依然是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≃</mo></mrow><annotation encoding="application/x-tex">\simeq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mrel">≃</span></span></span></span>而不是普通的等号，所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span>矩阵也可以乘以任意非零常数。</p><p>实际处理当中可以令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mn>9</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h_9=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>（在其为非零值时）</p><p>根据第3行去掉这个因子</p><p>其中</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mn>7</mn></msub><msub><mi>u</mi><mn>1</mn></msub><mo>+</mo><msub><mi>h</mi><mn>8</mn></msub><msub><mi>v</mi><mn>1</mn></msub><mo>+</mo><msub><mi>h</mi><mn>9</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">h_7u_1 + h_8v_1 + h_9 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p>所以可以有如下式子</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>u</mi><mn>2</mn></msub><mo>=</mo><mfrac><mrow><msub><mi>h</mi><mn>1</mn></msub><msub><mi>u</mi><mn>1</mn></msub><mo>+</mo><msub><mi>h</mi><mn>2</mn></msub><msub><mi>v</mi><mn>1</mn></msub><mo>+</mo><msub><mi>h</mi><mn>3</mn></msub></mrow><mrow><msub><mi>h</mi><mn>7</mn></msub><msub><mi>u</mi><mn>1</mn></msub><mo>+</mo><msub><mi>h</mi><mn>8</mn></msub><msub><mi>v</mi><mn>1</mn></msub><mo>+</mo><msub><mi>h</mi><mn>9</mn></msub></mrow></mfrac><mspace linebreak="newline"></mspace><msub><mi>v</mi><mn>2</mn></msub><mo>=</mo><mfrac><mrow><msub><mi>h</mi><mn>4</mn></msub><msub><mi>u</mi><mn>1</mn></msub><mo>+</mo><msub><mi>h</mi><mn>5</mn></msub><msub><mi>v</mi><mn>1</mn></msub><mo>+</mo><msub><mi>h</mi><mn>6</mn></msub></mrow><mrow><msub><mi>h</mi><mn>7</mn></msub><msub><mi>u</mi><mn>1</mn></msub><mo>+</mo><msub><mi>h</mi><mn>8</mn></msub><msub><mi>v</mi><mn>1</mn></msub><mo>+</mo><msub><mi>h</mi><mn>9</mn></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">u_2 = \frac{h_1u_1 + h_2v_1 + h_3}{h_7u_1 + h_8v_1 + h_9} \\v_2 = \frac{h_4u_1 + h_5v_1 + h_6}{h_7u_1 + h_8v_1 + h_9}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.20744em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.20744em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>整理可以得到</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mn>1</mn></msub><msub><mi>u</mi><mn>1</mn></msub><mo>+</mo><msub><mi>h</mi><mn>2</mn></msub><msub><mi>v</mi><mn>1</mn></msub><mo>+</mo><msub><mi>h</mi><mn>3</mn></msub><mo>−</mo><msub><mi>h</mi><mn>7</mn></msub><msub><mi>u</mi><mn>1</mn></msub><msub><mi>u</mi><mn>2</mn></msub><mo>−</mo><msub><mi>h</mi><mn>8</mn></msub><msub><mi>v</mi><mn>1</mn></msub><msub><mi>u</mi><mn>2</mn></msub><mo>=</mo><msub><mi>u</mi><mn>2</mn></msub><mspace linebreak="newline"></mspace><msub><mi>h</mi><mn>4</mn></msub><msub><mi>u</mi><mn>1</mn></msub><mo>+</mo><msub><mi>h</mi><mn>5</mn></msub><msub><mi>v</mi><mn>1</mn></msub><mo>+</mo><msub><mi>h</mi><mn>6</mn></msub><mo>−</mo><msub><mi>h</mi><mn>7</mn></msub><msub><mi>u</mi><mn>1</mn></msub><msub><mi>v</mi><mn>2</mn></msub><mo>−</mo><msub><mi>h</mi><mn>8</mn></msub><msub><mi>v</mi><mn>1</mn></msub><msub><mi>v</mi><mn>2</mn></msub><mo>=</mo><msub><mi>u</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">h_1u_1 + h_2v_1 + h_3 - h_7u_1u_2 - h_8v_1u_2 = u_2 \\h_4u_1 + h_5v_1 + h_6 - h_7u_1v_2 - h_8v_1v_2 = u_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>  这样就可以由一对匹配点构造出两项约束（事实上是有三个约束，但是因为线性相关，只取前两个）于是自由度为8的单应矩阵可通过4对匹配特征点算出（在非退化的情况下，即这些特征点不能有三代点共线的情况），即求解一下的线性方程组（当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mn>9</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">h_9=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，右侧为零）：</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111221618343.jpg" style="zoom:50%;" /><p>  这种做法把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span>矩阵看成向量，通过解该向量的线性方程来恢复<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span>，又称直接线性变换法（Direct Linear Transform，DLT）。与本质矩阵相似，求出单应矩阵以后需要对其进行分解，才可以得到相应的旋转矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>和平移向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>。</p><p><em>总结</em>：单应性在SLAM中具有重要意义。当特征点共面或者相机发生纯旋转时，基础矩阵的自由度下降，出现<strong>退化</strong>。现实中的数据总要包含一些噪声，这时如果继续使用八点法求解基础矩阵，基础矩阵多余出来的自由度将会<em>主要由噪声决定</em>。为了能够避免退化现象造成的影响，同时估计基础矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>和单应矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span>，找到最小的那个使用。</p>]]></content>
    
    
    <categories>
      
      <category>SLAM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Structured-Light_Binocular_Vision_System_for_Dynamic_Measurement_of_Rail_Wear</title>
    <link href="/2021/11/18/Structured-Light_Binocular_Vision_System_for_Dynamic_Measurement_of_Rail_Wear/"/>
    <url>/2021/11/18/Structured-Light_Binocular_Vision_System_for_Dynamic_Measurement_of_Rail_Wear/</url>
    
    <content type="html"><![CDATA[<h1 id="论文题目基于结构光双目视觉系统动态测量钢轨磨损"><a class="markdownIt-Anchor" href="#论文题目基于结构光双目视觉系统动态测量钢轨磨损"></a> 论文题目：基于结构光双目视觉系统动态测量钢轨磨损</h1><h2 id="一-摘要"><a class="markdownIt-Anchor" href="#一-摘要"></a> 一、摘要</h2><p>  在测量现场结构光双目视觉系统，可以更有效更准确的获取钢轨轮廓以及测量钢轨磨损。首先相机结合<strong>自动曝光</strong>以及<strong>海瑟矩阵</strong>去估计周围光线的影响，通过钢轨轮廓光带中心的亚像素坐标可以准确提取。其次，自由平面目标常用于实现双目测量系统的标定，这样可以快速获取全部钢轨轮廓。最后<strong>PCA</strong>和<strong>ICP</strong>两种匹配方法用于对比标准钢轨轮廓测量其磨损的准确率。</p><h2 id="二-测量原理"><a class="markdownIt-Anchor" href="#二-测量原理"></a> 二、测量原理</h2><h3 id="1-工具"><a class="markdownIt-Anchor" href="#1-工具"></a> 1、工具</h3><p>1）测量推车 2）电脑 3）数据转换器 4）两个线结构光测量单元（工业CCD相机和一个激光投影仪）</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111190910959.png" alt="" /></p><h2 id="2-rwms工作"><a class="markdownIt-Anchor" href="#2-rwms工作"></a> 2、RWMS工作</h2><h4 id="1提取钢轨轮廓光带中心"><a class="markdownIt-Anchor" href="#1提取钢轨轮廓光带中心"></a> 1）提取钢轨轮廓光带中心</h4><p>  先对于光带坐标中心进行粗定位，然后用海瑟矩阵计算光带中心亚像素坐标找到相符合的像素位置。</p><p>PS：其实目标就是提取激光散点的中心</p><h4 id="2双目标定"><a class="markdownIt-Anchor" href="#2双目标定"></a> 2）双目标定</h4><p>  利用光平面和相机成像平面可以通过计算获取轨道的侧面。</p><h4 id="3钢轨磨损的比较测量"><a class="markdownIt-Anchor" href="#3钢轨磨损的比较测量"></a> 3）钢轨磨损的比较测量</h4><p>  主要是与标准轨的轮廓进行比较测量得到钢轨磨损。然而<strong>测量刨面的初始位置是随机生成</strong>的，会产生较大误差。解决方法：1）对于全部的测量轮廓使用PCA算法完成初始化匹配 2）ICP用于对于钢轨进行精准再匹配</p><h2 id="三-实现"><a class="markdownIt-Anchor" href="#三-实现"></a> 三、实现</h2><h2 id="1-轨道轮廓提取"><a class="markdownIt-Anchor" href="#1-轨道轮廓提取"></a> 1、轨道轮廓提取</h2><p>  由于相机在测量单元的视野范围是固定的，所以激光带的宽度也是固定的。因此，光带在图像中占用的像素个数大约是N个，使用相机的自动曝光功能去高亮光带。发现过曝的光带像素点是线性相关相机曝光时间（在背景没有过曝的情况下）</p><p>相机曝光时间公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mrow><mi>a</mi><mi>u</mi><mi>t</mi><mi>o</mi></mrow></msub><mo>=</mo><msub><mi>E</mi><mi>j</mi></msub><mo>+</mo><mfrac><mi>e</mi><mrow><msub><mi>N</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>N</mi><mi>j</mi></msub></mrow></mfrac><mo stretchy="false">(</mo><msub><mi>N</mi><mn>0</mn></msub><mo>−</mo><msub><mi>N</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E_{auto} = E_j + \frac{e}{N_{j + 1} - N_j}(N_0 - N_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.079668em;vertical-align:-0.972108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.972108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>e是曝光间隔，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">E_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">N_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>（j=1···n）是相机曝光时间和过曝的在相应位置的像素点属性。</p><p>  激光带的法线方向服从高斯分布，亮度高于背景。用平均亮度作为阈值可以分割出激光线，在用高斯平滑以保留激光线特征。加工结果如下图。</p><p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111191053756.png" alt="" /></p><p><em>后续的测量也是分这两部分测量的1）钢轨上面 2）钢轨侧面和底面</em></p><h2 id="2-rwms-双目标定"><a class="markdownIt-Anchor" href="#2-rwms-双目标定"></a> 2、RWMS 双目标定</h2><p>根据针孔相机模型，存在公式（就是SLAM14讲第五章的那个变换公式）</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ρ</mi><mover accent="true"><mi>P</mi><mo stretchy="true">~</mo></mover><mo>=</mo><mi>A</mi><mo stretchy="false">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>R</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>t</mi></mstyle></mtd></mtr></mtable><mo stretchy="false">]</mo><msub><mover accent="true"><mi>P</mi><mo stretchy="true">~</mo></mover><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">\rho \widetilde{P} = A [\begin{matrix} R &amp; t \end{matrix}] \widetilde{P}_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.13777em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ρ</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94333em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span><span class="svg-align" style="width:calc(100% - 0.16668em);margin-left:0.16668em;top:-3.6833299999999998em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg width='100%' height='0.26em' viewBox='0 0 600 260' preserveAspectRatio='none'><path d='M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z'/></svg></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.29333em;vertical-align:-0.35000000000000003em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94333em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span><span class="svg-align" style="width:calc(100% - 0.16668em);margin-left:0.16668em;top:-3.6833299999999998em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg width='100%' height='0.26em' viewBox='0 0 600 260' preserveAspectRatio='none'><path d='M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z'/></svg></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ρ</span></span></span></span>是比例因子，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>是旋转矩阵和平移向量（世界坐标系转向机坐标系）<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>P</mi><mo stretchy="true">~</mo></mover></mrow><annotation encoding="application/x-tex">\widetilde{P}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.94333em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94333em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span><span class="svg-align" style="width:calc(100% - 0.16668em);margin-left:0.16668em;top:-3.6833299999999998em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg width='100%' height='0.26em' viewBox='0 0 600 260' preserveAspectRatio='none'><path d='M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z'/></svg></span></span></span></span></span></span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mover accent="true"><mi>P</mi><mo stretchy="true">~</mo></mover><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">\widetilde{P}_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.09333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94333em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span><span class="svg-align" style="width:calc(100% - 0.16668em);margin-left:0.16668em;top:-3.6833299999999998em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg width='100%' height='0.26em' viewBox='0 0 600 260' preserveAspectRatio='none'><path d='M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z'/></svg></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是其次坐标形式的像素坐标系和世界坐标系，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>为相机内参矩阵。</p><p>标定模型如图</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111191106619.png" alt="" style="zoom:50%;" /><p>相机内参<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>使用张氏标定法解决，而相机的外参则利用如下方法。</p><p>1）将线结构光平面定义为世界坐标系的XY平面。</p><p>2）多次移动标定板，生成特征点</p><p>3）多次使用可以将其线结构光平面拟合出来（相机坐标系）</p><p><em>个人理解：动板子光平面不动，就会有很多的点生成，随便找三个点就可以确认一个平面</em></p><p>4）最后用<strong>Rodriguez transform principle</strong>将外参确定。</p><p>齐次矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span>在世界坐标系下的线结构光平面和相机坐标系下的坐标变换满足：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>=</mo><mi>λ</mi><mi>A</mi><mo stretchy="false">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>R</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>t</mi></mstyle></mtd></mtr></mtable><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>h</mi><mn>1</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>h</mi><mn>2</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>h</mi><mn>3</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>h</mi><mn>4</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>h</mi><mn>5</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>h</mi><mn>6</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>h</mi><mn>7</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>h</mi><mn>8</mn></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">H = \lambda A[\begin{matrix}R &amp; t\end{matrix}] = \begin{bmatrix} h_1 &amp; h_2 &amp; h_3\\ h_4 &amp; h_5 &amp; h_6 \\ h_7 &amp; h_8 &amp; 1\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2000000000000002em;vertical-align:-0.35000000000000003em;"></span><span class="mord mathdefault">λ</span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\lambda = 1/\rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault">ρ</span></span></span></span> 是比例因子， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">h_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span>的元素。</p><p>由上述本段上述两个公式可以得到轨道轮廓在世界坐标系下的结果<img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111191128643.png" alt="" /></p><h2 id="3-钢轨磨损测量"><a class="markdownIt-Anchor" href="#3-钢轨磨损测量"></a> 3、钢轨磨损测量</h2><p>将钢轨分成两部分测量1）上面 2）侧面和下面</p><p>  用钢轨的侧面部分来与标准轨对比进行对齐，其中标准轨道和轮廓图均采用间隔0.2mm米的一系列点进行实验。</p><p><em>这里会出现一个误差：这个点间距会造成与标准轨匹配不准确产生的误差（文章说a large error但没有说多少）</em></p><p>以下为论文中的解决方案</p><p>  在初始化匹配标准轨<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span>和测得曲线<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>的数据，他们分别取其重心<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mi>p</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>p</mi></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>q</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>q</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_p, y_p),(x_q, y_q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>以及钢轨侧面轮廓的特征向量。用旋转矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">R_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和平移向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>完成初始化对其</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>sin</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>cos</mi><mo>⁡</mo><mi>θ</mi></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo separator="true">,</mo><mi>θ</mi><mo>=</mo><mi>a</mi><mi>cos</mi><mo>⁡</mo><mfrac><mrow><mi>p</mi><mo>⋅</mo><mi>q</mi></mrow><mrow><mi mathvariant="normal">∥</mi><mi>p</mi><mi mathvariant="normal">∥</mi><mi mathvariant="normal">∥</mi><mi>q</mi><mi mathvariant="normal">∥</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">R_1 = \begin{bmatrix} \cos{\theta} &amp; -\sin{\theta}\\\sin{\theta} &amp; \cos{\theta}\end{bmatrix},\theta = a \cos{\frac{p\cdot q}{\|p\|\|q\|}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.05745em;vertical-align:-0.936em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1214499999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∥</span><span class="mord mathdefault">p</span><span class="mord">∥</span><span class="mord">∥</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord">∥</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mi>q</mi></msub><mo>−</mo><msub><mi>x</mi><mi>p</mi></msub><mo separator="true">,</mo><msub><mi>y</mi><mi>q</mi></msub><mo>−</mo><msub><mi>y</mi><mi>p</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t_1 = (x_q - x_p, y_q - y_p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p><em>以上就是我们所需要的旋转和平移的公式化</em></p><p>  最后用ICP进行点匹配就可以得到最终的结果。</p><p>  <em>由此我得到的启发是我们将点云的点进行等间距的采样，这样好进行匹配，而我们的实验中的点并没有按照标准轨与激光测量出的线进行等间距的比对，可能误差还可以减小，而且匹配的方式用的是重心，这里我们可以进一步讨论一下。</em></p><h2 id="四-实验结果"><a class="markdownIt-Anchor" href="#四-实验结果"></a> 四、实验结果</h2><h2 id="img-srchttpscdnjsdelivrnetgh18612849621picture_bedmainpicture202111191157421png-alt-stylezoom50"><a class="markdownIt-Anchor" href="#img-srchttpscdnjsdelivrnetgh18612849621picture_bedmainpicture202111191157421png-alt-stylezoom50"></a> <img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111191157421.png" alt="" style="zoom:50%;" /></h2><p>  这是他们论文匹配的结果，确实只用一个重心的话可以很好的得出结果，然后匹配速度也很快。</p><img src="https://cdn.jsdelivr.net/gh/18612849621/picture_bed@main//picture/202111191154637.png" alt="" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>潘潘阅读论文笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>钢轨测量</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
